import { mkPackage } from "../../../package.ts";
import { nixRaw } from "../../../nix.ts";

/**
 * An alternating list of two types
 */
export const ABList = mkPackage(
  nixRaw`pkgs.haskellPackages.ABList`,
  "An alternating list of two types",
);

/**
 * Angles in degrees and radians
 */
export const AC_Angle = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-Angle`,
  "Angles in degrees and radians",
);

/**
 * Handle Boolean values generatically
 */
export const AC_Boolean = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-Boolean`,
  "Handle Boolean values generatically",
);

/**
 * Efficient RGB colour types
 */
export const AC_Colour = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-Colour`,
  "Efficient RGB colour types",
);

/**
 * Trivial package for writing PPM images
 */
export const AC_PPM = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-PPM`,
  "Trivial package for writing PPM images",
);

/**
 * A pure Haskell PRNG
 */
export const AC_Random = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-Random`,
  "A pure Haskell PRNG",
);

/**
 * Fancy type-system stuff for AC-Vector
 */
export const AC_Vector_Fancy = mkPackage(
  nixRaw`pkgs.haskellPackages.AC-Vector-Fancy`,
  "Fancy type-system stuff for AC-Vector",
);

/**
 * Efficient, high-level dynamic programming
 */
export const ADPfusion = mkPackage(
  nixRaw`pkgs.haskellPackages.ADPfusion`,
  "Efficient, high-level dynamic programming",
);

/**
 * Dynamic programming on tree and forest structures
 */
export const ADPfusionForest = mkPackage(
  nixRaw`pkgs.haskellPackages.ADPfusionForest`,
  "Dynamic programming on tree and forest structures",
);

/**
 * Dynamic programming for Set data structures
 */
export const ADPfusionSet = mkPackage(
  nixRaw`pkgs.haskellPackages.ADPfusionSet`,
  "Dynamic programming for Set data structures",
);

/**
 * Compositional lazy dataflow networks for exact real number computation
 */
export const AERN_Net = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-Net`,
  "Compositional lazy dataflow networks for exact real number computation",
);

/**
 * arbitrary precision real interval arithmetic
 */
export const AERN_Real = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-Real`,
  "arbitrary precision real interval arithmetic",
);

/**
 * arbitrary precision real interval arithmetic
 */
export const AERN_Real_Double = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-Real-Double`,
  "arbitrary precision real interval arithmetic",
);

/**
 * arbitrary precision real interval arithmetic
 */
export const AERN_Real_Interval = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-Real-Interval`,
  "arbitrary precision real interval arithmetic",
);

/**
 * polynomial function enclosures (PFEs) approximating exact real functions
 */
export const AERN_RnToRm = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-RnToRm`,
  "polynomial function enclosures (PFEs) approximating exact real functions",
);

/**
 * GL plotting of polynomial function enclosures (PFEs)
 */
export const AERN_RnToRm_Plot = mkPackage(
  nixRaw`pkgs.haskellPackages.AERN-RnToRm-Plot`,
  "GL plotting of polynomial function enclosures (PFEs)",
);

/**
 * Fast AES encryption/decryption for bytestrings
 */
export const AES = mkPackage(
  nixRaw`pkgs.haskellPackages.AES`,
  "Fast AES encryption/decryption for bytestrings",
);

/**
 * Arrowized functional state machines
 */
export const AFSM = mkPackage(
  nixRaw`pkgs.haskellPackages.AFSM`,
  "Arrowized functional state machines",
);

/**
 * A binding for the OpenAL Utility Toolkit
 */
export const ALUT = mkPackage(
  nixRaw`pkgs.haskellPackages.ALUT`,
  "A binding for the OpenAL Utility Toolkit",
);

/**
 * Num instance for Applicatives provided via the ANum newtype
 */
export const ANum = mkPackage(
  nixRaw`pkgs.haskellPackages.ANum`,
  "Num instance for Applicatives provided via the ANum newtype",
);

/**
 * ASN.1 support for Haskell
 */
export const ASN1 = mkPackage(
  nixRaw`pkgs.haskellPackages.ASN1`,
  "ASN.1 support for Haskell",
);

/**
 * Mutable variables with Exception handling and concurrency support
 */
export const AVar = mkPackage(
  nixRaw`pkgs.haskellPackages.AVar`,
  "Mutable variables with Exception handling and concurrency support",
);

/**
 * A binding to a part of the ANSI escape code for the console
 */
export const AWin32Console = mkPackage(
  nixRaw`pkgs.haskellPackages.AWin32Console`,
  "A binding to a part of the ANSI escape code for the console",
);

/**
 * Monads-tf instances for the AbortT monad transformer
 */
export const AbortT_monadstf = mkPackage(
  nixRaw`pkgs.haskellPackages.AbortT-monadstf`,
  "Monads-tf instances for the AbortT monad transformer",
);

/**
 * mtl instances for the AbortT monad transformer
 */
export const AbortT_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.AbortT-mtl`,
  "mtl instances for the AbortT monad transformer",
);

/**
 * Lisperati's adventure game in Lisp translated to Haskell
 */
export const Advgame = mkPackage(
  nixRaw`pkgs.haskellPackages.Advgame`,
  "Lisperati's adventure game in Lisp translated to Haskell",
);

/**
 * Assessment services for the Advise-Me project
 */
export const Advise_me = mkPackage(
  nixRaw`pkgs.haskellPackages.Advise-me`,
  "Assessment services for the Advise-Me project",
);

/**
 * Mapping between Aeson's JSON and Bson objects
 */
export const AesonBson = mkPackage(
  nixRaw`pkgs.haskellPackages.AesonBson`,
  "Mapping between Aeson's JSON and Bson objects",
);

/**
 * A dependently typed functional programming language and proof assistant
 */
export const Agda = mkPackage(
  nixRaw`pkgs.haskellPackages.Agda`,
  "A dependently typed functional programming language and proof assistant",
);

/**
 * Algorithmic music composition
 */
export const AlgoRhythm = mkPackage(
  nixRaw`pkgs.haskellPackages.AlgoRhythm`,
  "Algorithmic music composition",
);

/**
 * Collection of alignment algorithms
 */
export const AlignmentAlgorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.AlignmentAlgorithms`,
  "Collection of alignment algorithms",
);

/**
 * Near-future Sci-Fi roguelike and tactical squad combat game
 */
export const Allure = mkPackage(
  nixRaw`pkgs.haskellPackages.Allure`,
  "Near-future Sci-Fi roguelike and tactical squad combat game",
);

/**
 * Android view hierarchy importer
 */
export const AndroidViewHierarchyImporter = mkPackage(
  nixRaw`pkgs.haskellPackages.AndroidViewHierarchyImporter`,
  "Android view hierarchy importer",
);

/**
 * Constructing, analyzing and destructing annotated trees
 */
export const Annotations = mkPackage(
  nixRaw`pkgs.haskellPackages.Annotations`,
  "Constructing, analyzing and destructing annotated trees",
);

/**
 * Convert ANSI Terminal Sequences to nice HTML markup
 */
export const Ansi2Html = mkPackage(
  nixRaw`pkgs.haskellPackages.Ansi2Html`,
  "Convert ANSI Terminal Sequences to nice HTML markup",
);

/**
 * Library for Apple Push Notification Service
 */
export const ApplePush = mkPackage(
  nixRaw`pkgs.haskellPackages.ApplePush`,
  "Library for Apple Push Notification Service",
);

/**
 * An asynchronous modal FRP language
 */
export const AsyncRattus = mkPackage(
  nixRaw`pkgs.haskellPackages.AsyncRattus`,
  "An asynchronous modal FRP language",
);

/**
 * Simple lightweight JSON parser, generator & manipulator based on ByteString
 */
export const AttoJson = mkPackage(
  nixRaw`pkgs.haskellPackages.AttoJson`,
  "Simple lightweight JSON parser, generator & manipulator based on ByteString",
);

/**
 * GUI library based upon generic programming (SYB3)
 */
export const AutoForms = mkPackage(
  nixRaw`pkgs.haskellPackages.AutoForms`,
  "GUI library based upon generic programming (SYB3)",
);

/**
 * Balanced binary trees using the AVL algorithm
 */
export const AvlTree = mkPackage(
  nixRaw`pkgs.haskellPackages.AvlTree`,
  "Balanced binary trees using the AVL algorithm",
);

/**
 * Embedded BASIC
 */
export const BASIC = mkPackage(
  nixRaw`pkgs.haskellPackages.BASIC`,
  "Embedded BASIC",
);

/**
 * A compiler front-end generator
 */
export const BNFC = mkPackage(
  nixRaw`pkgs.haskellPackages.BNFC`,
  "A compiler front-end generator",
);

/**
 * Deriving Parsers and Quasi-Quoters from BNF Grammars
 */
export const BNFC_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.BNFC-meta`,
  "Deriving Parsers and Quasi-Quoters from BNF Grammars",
);

/**
 * Translations of classic Truth Maintenance Systems
 */
export const BPS = mkPackage(
  nixRaw`pkgs.haskellPackages.BPS`,
  "Translations of classic Truth Maintenance Systems",
);

/**
 * An ad-hoc P2P chat program
 */
export const Barracuda = mkPackage(
  nixRaw`pkgs.haskellPackages.Barracuda`,
  "An ad-hoc P2P chat program",
);

/**
 * Berkeley DB binding
 */
export const BerkeleyDB = mkPackage(
  nixRaw`pkgs.haskellPackages.BerkeleyDB`,
  "Berkeley DB binding",
);

/**
 * Factorization of polynomials over finite field
 */
export const BerlekampAlgorithm = mkPackage(
  nixRaw`pkgs.haskellPackages.BerlekampAlgorithm`,
  "Factorization of polynomials over finite field",
);

/**
 * Bessel J-function, Anger J-function, Weber E-function, and Anger-Weber function
 */
export const BesselJ = mkPackage(
  nixRaw`pkgs.haskellPackages.BesselJ`,
  "Bessel J-function, Anger J-function, Weber E-function, and Anger-Weber function",
);

/**
 * Image editor for pixel art
 */
export const BigPixel = mkPackage(
  nixRaw`pkgs.haskellPackages.BigPixel`,
  "Image editor for pixel art",
);

/**
 * Common bin-packing heuristics
 */
export const Binpack = mkPackage(
  nixRaw`pkgs.haskellPackages.Binpack`,
  "Common bin-packing heuristics",
);

/**
 * Libary for Hidden Markov Models in HMMER3 format
 */
export const BioHMM = mkPackage(
  nixRaw`pkgs.haskellPackages.BioHMM`,
  "Libary for Hidden Markov Models in HMMER3 format",
);

/**
 * Base library for bioinformatics
 */
export const Biobase = mkPackage(
  nixRaw`pkgs.haskellPackages.Biobase`,
  "Base library for bioinformatics",
);

/**
 * BLAST-related tools
 */
export const BiobaseBlast = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseBlast`,
  "BLAST-related tools",
);

/**
 * Vienna / DotBracket / ExtSS parsers
 */
export const BiobaseDotP = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseDotP`,
  "Vienna / DotBracket / ExtSS parsers",
);

/**
 * European Nucleotide Archive data
 */
export const BiobaseENA = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseENA`,
  "European Nucleotide Archive data",
);

/**
 * Ensembl related datastructures and functions
 */
export const BiobaseEnsembl = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseEnsembl`,
  "Ensembl related datastructures and functions",
);

/**
 * Importer for FR3D resources
 */
export const BiobaseFR3D = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseFR3D`,
  "Importer for FR3D resources",
);

/**
 * streaming FASTA parser
 */
export const BiobaseFasta = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseFasta`,
  "streaming FASTA parser",
);

/**
 * Libary to interface with the Bioinformatics HTTP services - Entrez Ensembl
 */
export const BiobaseHTTP = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseHTTP`,
  "Libary to interface with the Bioinformatics HTTP services - Entrez Ensembl",
);

/**
 * Tools to query Bioinformatics HTTP services e.g. Entrez, Ensembl.
 */
export const BiobaseHTTPTools = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseHTTPTools`,
  "Tools to query Bioinformatics HTTP services e.g. Entrez, Ensembl.",
);

/**
 * Infernal data structures and tools
 */
export const BiobaseInfernal = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseInfernal`,
  "Infernal data structures and tools",
);

/**
 * Multiple Alignment Format
 */
export const BiobaseMAF = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseMAF`,
  "Multiple Alignment Format",
);

/**
 * Newick file format parser
 */
export const BiobaseNewick = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseNewick`,
  "Newick file format parser",
);

/**
 * RNA folding training data
 */
export const BiobaseTrainingData = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseTrainingData`,
  "RNA folding training data",
);

/**
 * Import Turner RNA parameters
 */
export const BiobaseTurner = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseTurner`,
  "Import Turner RNA parameters",
);

/**
 * Collection of types for bioinformatics
 */
export const BiobaseTypes = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseTypes`,
  "Collection of types for bioinformatics",
);

/**
 * Import Vienna energy parameters
 */
export const BiobaseVienna = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseVienna`,
  "Import Vienna energy parameters",
);

/**
 * Efficient RNA/DNA/Protein Primary/Secondary Structure
 */
export const BiobaseXNA = mkPackage(
  nixRaw`pkgs.haskellPackages.BiobaseXNA`,
  "Efficient RNA/DNA/Protein Primary/Secondary Structure",
);

/**
 * A preprocessor for Bird-style Literate Haskell comments with Haddock markup
 */
export const BirdPP = mkPackage(
  nixRaw`pkgs.haskellPackages.BirdPP`,
  "A preprocessor for Bird-style Literate Haskell comments with Haddock markup",
);

/**
 * A library to access bit.ly URL shortener.
 */
export const Bitly = mkPackage(
  nixRaw`pkgs.haskellPackages.Bitly`,
  "A library to access bit.ly URL shortener.",
);

/**
 * Batteries-included Structured Logging library
 */
export const Blammo = mkPackage(
  nixRaw`pkgs.haskellPackages.Blammo`,
  "Batteries-included Structured Logging library",
);

/**
 * Libary to interface with the NCBI blast REST interface
 */
export const BlastHTTP = mkPackage(
  nixRaw`pkgs.haskellPackages.BlastHTTP`,
  "Libary to interface with the NCBI blast REST interface",
);

/**
 * Diagram editor
 */
export const Blobs = mkPackage(
  nixRaw`pkgs.haskellPackages.Blobs`,
  "Diagram editor",
);

/**
 * Include images in blog posts with inline diagrams code
 */
export const BlogLiterately_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.BlogLiterately-diagrams`,
  "Include images in blog posts with inline diagrams code",
);

/**
 * Html document layout library
 */
export const BluePrintCSS = mkPackage(
  nixRaw`pkgs.haskellPackages.BluePrintCSS`,
  "Html document layout library",
);

/**
 * A simple document organizer with some wiki functionality
 */
export const Bookshelf = mkPackage(
  nixRaw`pkgs.haskellPackages.Bookshelf`,
  "A simple document organizer with some wiki functionality",
);

/**
 * Generalized booleans and numbers
 */
export const Boolean = mkPackage(
  nixRaw`pkgs.haskellPackages.Boolean`,
  "Generalized booleans and numbers",
);

/**
 * Implementation of bounded channels
 */
export const BoundedChan = mkPackage(
  nixRaw`pkgs.haskellPackages.BoundedChan`,
  "Implementation of bounded channels",
);

/**
 * Encode/Decode values to/from CBOR
 */
export const CBOR = mkPackage(
  nixRaw`pkgs.haskellPackages.CBOR`,
  "Encode/Decode values to/from CBOR",
);

/**
 * Delimited continuations and dynamically scoped variables
 */
export const CC_delcont = mkPackage(
  nixRaw`pkgs.haskellPackages.CC-delcont`,
  "Delimited continuations and dynamically scoped variables",
);

/**
 * Three new monad transformers for multi-prompt delimited control
 */
export const CC_delcont_alt = mkPackage(
  nixRaw`pkgs.haskellPackages.CC-delcont-alt`,
  "Three new monad transformers for multi-prompt delimited control",
);

/**
 * A W3C compliant (X)HTML generating library
 */
export const CHXHtml = mkPackage(
  nixRaw`pkgs.haskellPackages.CHXHtml`,
  "A W3C compliant (X)HTML generating library",
);

/**
 * Infernal covariance model comparison
 */
export const CMCompare = mkPackage(
  nixRaw`pkgs.haskellPackages.CMCompare`,
  "Infernal covariance model comparison",
);

/**
 * A simple Brainfuck interpretter
 */
export const CPBrainfuck = mkPackage(
  nixRaw`pkgs.haskellPackages.CPBrainfuck`,
  "A simple Brainfuck interpretter",
);

/**
 * An interpreter of Hagino's Categorical Programming Language (CPL)
 */
export const CPL = mkPackage(
  nixRaw`pkgs.haskellPackages.CPL`,
  "An interpreter of Hagino's Categorical Programming Language (CPL)",
);

/**
 * Definition of a CSP core-language
 */
export const CSPM_CoreLanguage = mkPackage(
  nixRaw`pkgs.haskellPackages.CSPM-CoreLanguage`,
  "Definition of a CSP core-language",
);

/**
 * Firing rules semantic of CSPM
 */
export const CSPM_FiringRules = mkPackage(
  nixRaw`pkgs.haskellPackages.CSPM-FiringRules`,
  "Firing rules semantic of CSPM",
);

/**
 * An interpreter for CSPM
 */
export const CSPM_Interpreter = mkPackage(
  nixRaw`pkgs.haskellPackages.CSPM-Interpreter`,
  "An interpreter for CSPM",
);

/**
 * some modules specific for the ProB tool
 */
export const CSPM_ToProlog = mkPackage(
  nixRaw`pkgs.haskellPackages.CSPM-ToProlog`,
  "some modules specific for the ProB tool",
);

/**
 * cspm command line tool for analyzing CSPM specifications
 */
export const CSPM_cspm = mkPackage(
  nixRaw`pkgs.haskellPackages.CSPM-cspm`,
  "cspm command line tool for analyzing CSPM specifications",
);

/**
 * Open records using closed type families
 */
export const CTRex = mkPackage(
  nixRaw`pkgs.haskellPackages.CTRex`,
  "Open records using closed type families",
);

/**
 * A framework for packaging Haskell software
 */
export const Cabal_3_10_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal_3_10_1_0`,
  "A framework for packaging Haskell software",
);

/**
 * A framework for packaging Haskell software
 */
export const Cabal_3_2_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal_3_2_1_0`,
  "A framework for packaging Haskell software",
);

/**
 * A framework for packaging Haskell software
 */
export const Cabal_3_6_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal_3_6_3_0`,
  "A framework for packaging Haskell software",
);

/**
 * A library for working with .cabal files
 */
export const Cabal_syntax_3_10_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal-syntax_3_10_1_0`,
  "A library for working with .cabal files",
);

/**
 * A library for working with .cabal files
 */
export const Cabal_syntax_3_6_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal-syntax_3_6_0_0`,
  "A library for working with .cabal files",
);

/**
 * A library for working with .cabal files
 */
export const Cabal_syntax_3_8_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.Cabal-syntax_3_8_1_0`,
  "A library for working with .cabal files",
);

/**
 * Measure container capacity. Use it to safely change container.
 */
export const Cardinality = mkPackage(
  nixRaw`pkgs.haskellPackages.Cardinality`,
  "Measure container capacity. Use it to safely change container.",
);

/**
 * A translation from the Carneades argumentation model into Dung's AFs
 */
export const CarneadesIntoDung = mkPackage(
  nixRaw`pkgs.haskellPackages.CarneadesIntoDung`,
  "A translation from the Carneades argumentation model into Dung's AFs",
);

/**
 * Generalized stream processors
 */
export const ChannelT = mkPackage(
  nixRaw`pkgs.haskellPackages.ChannelT`,
  "Generalized stream processors",
);

/**
 * A library for generating 2D Charts and Plots
 */
export const Chart = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart`,
  "A library for generating 2D Charts and Plots",
);

/**
 * Cairo backend for Charts
 */
export const Chart_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-cairo`,
  "Cairo backend for Charts",
);

/**
 * Diagrams backend for Charts
 */
export const Chart_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-diagrams`,
  "Diagrams backend for Charts",
);

/**
 * A backend for the Chart library for FLTKHS
 */
export const Chart_fltkhs = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-fltkhs`,
  "A backend for the Chart library for FLTKHS",
);

/**
 * Utility functions for using the chart library with GTK
 */
export const Chart_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-gtk`,
  "Utility functions for using the chart library with GTK",
);

/**
 * Utility functions for using the chart library with GTK
 */
export const Chart_gtk3 = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-gtk3`,
  "Utility functions for using the chart library with GTK",
);

/**
 * Tests of the Charts library
 */
export const Chart_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.Chart-tests`,
  "Tests of the Charts library",
);

/**
 * For testing partial and infinite values
 */
export const ChasingBottoms = mkPackage(
  nixRaw`pkgs.haskellPackages.ChasingBottoms`,
  "For testing partial and infinite values",
);

/**
 * A Haskell cheat sheet in PDF and literate formats
 */
export const CheatSheet = mkPackage(
  nixRaw`pkgs.haskellPackages.CheatSheet`,
  "A Haskell cheat sheet in PDF and literate formats",
);

/**
 * Cirru Parser in Haskell
 */
export const CirruParser = mkPackage(
  nixRaw`pkgs.haskellPackages.CirruParser`,
  "Cirru Parser in Haskell",
);

/**
 * System clipboard interface
 */
export const Clipboard = mkPackage(
  nixRaw`pkgs.haskellPackages.Clipboard`,
  "System clipboard interface",
);

/**
 * Libary for parsing Clustal tools output
 */
export const ClustalParser = mkPackage(
  nixRaw`pkgs.haskellPackages.ClustalParser`,
  "Libary for parsing Clustal tools output",
);

/**
 * A generic build tool
 */
export const Coadjute = mkPackage(
  nixRaw`pkgs.haskellPackages.Coadjute`,
  "A generic build tool",
);

/**
 * LZF compression bindings
 */
export const Codec_Compression_LZF = mkPackage(
  nixRaw`pkgs.haskellPackages.Codec-Compression-LZF`,
  "LZF compression bindings",
);

/**
 * An FFI interface to the DevIL library
 */
export const Codec_Image_DevIL = mkPackage(
  nixRaw`pkgs.haskellPackages.Codec-Image-DevIL`,
  "An FFI interface to the DevIL library",
);

/**
 * Color spaces and conversions between them
 */
export const Color = mkPackage(
  nixRaw`pkgs.haskellPackages.Color`,
  "Color spaces and conversions between them",
);

/**
 * A concurrent bittorrent client
 */
export const Combinatorrent = mkPackage(
  nixRaw`pkgs.haskellPackages.Combinatorrent`,
  "A concurrent bittorrent client",
);

/**
 * A library for expressing spreadsheet-like computations as the fixed-points of comonads
 */
export const ComonadSheet = mkPackage(
  nixRaw`pkgs.haskellPackages.ComonadSheet`,
  "A library for expressing spreadsheet-like computations as the fixed-points of comonads",
);

/**
 * Information retrieval library
 */
export const Condor = mkPackage(
  nixRaw`pkgs.haskellPackages.Condor`,
  "Information retrieval library",
);

/**
 * Configuration file reading & writing
 */
export const ConfigFile = mkPackage(
  nixRaw`pkgs.haskellPackages.ConfigFile`,
  "Configuration file reading & writing",
);

/**
 * Parse config files
 */
export const Configger = mkPackage(
  nixRaw`pkgs.haskellPackages.Configger`,
  "Parse config files",
);

/**
 * Trivial re-export of Wouter Swierstra's Stream package, avoiding module name clash
 */
export const ConsStream = mkPackage(
  nixRaw`pkgs.haskellPackages.ConsStream`,
  "Trivial re-export of Wouter Swierstra's Stream package, avoiding module name clash",
);

/**
 * A parallel producer/consumer engine (thread pool)
 */
export const Control_Engine = mkPackage(
  nixRaw`pkgs.haskellPackages.Control-Engine`,
  "A parallel producer/consumer engine (thread pool)",
);

/**
 * A Library for Writing Multi-Pass Algorithms
 */
export const Control_Monad_MultiPass = mkPackage(
  nixRaw`pkgs.haskellPackages.Control-Monad-MultiPass`,
  "A Library for Writing Multi-Pass Algorithms",
);

/**
 * Bindings to Mac OSX's CoreFoundation framework
 */
export const CoreFoundation = mkPackage(
  nixRaw`pkgs.haskellPackages.CoreFoundation`,
  "Bindings to Mac OSX's CoreFoundation framework",
);

/**
 * Common Cryptographic Algorithms in Pure Haskell
 */
export const Crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.Crypto`,
  "Common Cryptographic Algorithms in Pure Haskell",
);

/**
 * RFC 4918 WebDAV support
 */
export const DAV = mkPackage(
  nixRaw`pkgs.haskellPackages.DAV`,
  "RFC 4918 WebDAV support",
);

/**
 * DBFunctor - Functional Data Management => ETL/ELT Data Processing in Haskell
 */
export const DBFunctor = mkPackage(
  nixRaw`pkgs.haskellPackages.DBFunctor`,
  "DBFunctor - Functional Data Management => ETL/ELT Data Processing in Haskell",
);

/**
 * Communication Free Learning-based constraint solver
 */
export const DCFL = mkPackage(
  nixRaw`pkgs.haskellPackages.DCFL`,
  "Communication Free Learning-based constraint solver",
);

/**
 * Distributed Mutation Analysis framework for MuCheck
 */
export const DMuCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.DMuCheck`,
  "Distributed Mutation Analysis framework for MuCheck",
);

/**
 * DOM Level 2 bindings for the WebBits package
 */
export const DOM = mkPackage(
  nixRaw`pkgs.haskellPackages.DOM`,
  "DOM Level 2 bindings for the WebBits package",
);

/**
 * Pragmatic framework for dynamic programming
 */
export const DP = mkPackage(
  nixRaw`pkgs.haskellPackages.DP`,
  "Pragmatic framework for dynamic programming",
);

/**
 * utilities for DP
 */
export const DPutils = mkPackage(
  nixRaw`pkgs.haskellPackages.DPutils`,
  "utilities for DP",
);

/**
 * Deterministic random bit generator (aka RNG, PRNG) based HMACs, Hashes, and Ciphers
 */
export const DRBG = mkPackage(
  nixRaw`pkgs.haskellPackages.DRBG`,
  "Deterministic random bit generator (aka RNG, PRNG) based HMACs, Hashes, and Ciphers",
);

/**
 * Implementation of DSA, based on the description of FIPS 186-4
 */
export const DSA = mkPackage(
  nixRaw`pkgs.haskellPackages.DSA`,
  "Implementation of DSA, based on the description of FIPS 186-4",
);

/**
 * Database Supported Haskell
 */
export const DSH = mkPackage(
  nixRaw`pkgs.haskellPackages.DSH`,
  "Database Supported Haskell",
);

/**
 * A framework for using STM within distributed systems
 */
export const DSTM = mkPackage(
  nixRaw`pkgs.haskellPackages.DSTM`,
  "A framework for using STM within distributed systems",
);

/**
 * Monads for operations that can exit early and produce warnings
 */
export const Dangerous = mkPackage(
  nixRaw`pkgs.haskellPackages.Dangerous`,
  "Monads for operations that can exit early and produce warnings",
);

/**
 * Code used by Patch-Shack that seemed sensible to open for reusability
 */
export const DarcsHelpers = mkPackage(
  nixRaw`pkgs.haskellPackages.DarcsHelpers`,
  "Code used by Patch-Shack that seemed sensible to open for reusability",
);

/**
 * Type safe data migrations
 */
export const DataVersion = mkPackage(
  nixRaw`pkgs.haskellPackages.DataVersion`,
  "Type safe data migrations",
);

/**
 * Geometric angles
 */
export const Data_Angle = mkPackage(
  nixRaw`pkgs.haskellPackages.Data-Angle`,
  "Geometric angles",
);

/**
 * Provide a simple consistent hashing mechanism
 */
export const Data_Hash_Consistent = mkPackage(
  nixRaw`pkgs.haskellPackages.Data-Hash-Consistent`,
  "Provide a simple consistent hashing mechanism",
);

/**
 * Convenience functions and instances for Debug.Trace
 */
export const DebugTraceHelpers = mkPackage(
  nixRaw`pkgs.haskellPackages.DebugTraceHelpers`,
  "Convenience functions and instances for Debug.Trace",
);

/**
 * Decimal numbers with variable precision
 */
export const Decimal = mkPackage(
  nixRaw`pkgs.haskellPackages.Decimal`,
  "Decimal numbers with variable precision",
);

/**
 * Arrows for "deep application"
 */
export const DeepArrow = mkPackage(
  nixRaw`pkgs.haskellPackages.DeepArrow`,
  "Arrows for \"deep application\"",
);

/**
 * A simple RTS game
 */
export const DefendTheKing = mkPackage(
  nixRaw`pkgs.haskellPackages.DefendTheKing`,
  "A simple RTS game",
);

/**
 * A library for specifying xmonad key bindings with functionality
 */
export const DescriptiveKeys = mkPackage(
  nixRaw`pkgs.haskellPackages.DescriptiveKeys`,
  "A library for specifying xmonad key bindings with functionality",
);

/**
 * O(ND) diff algorithm in haskell
 */
export const Diff = mkPackage(
  nixRaw`pkgs.haskellPackages.Diff`,
  "O(ND) diff algorithm in haskell",
);

/**
 * O(ND) diff algorithm in haskell
 */
export const Diff_0_3_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.Diff_0_3_4`,
  "O(ND) diff algorithm in haskell",
);

/**
 * A theory solver for conjunctions of literals in difference logic
 */
export const DifferenceLogic = mkPackage(
  nixRaw`pkgs.haskellPackages.DifferenceLogic`,
  "A theory solver for conjunctions of literals in difference logic",
);

/**
 * A data-type representing digits 0-9
 */
export const Digit = mkPackage(
  nixRaw`pkgs.haskellPackages.Digit`,
  "A data-type representing digits 0-9",
);

/**
 * Group the digits of numbers by lots
 */
export const DigitGroup = mkPackage(
  nixRaw`pkgs.haskellPackages.DigitGroup`,
  "Group the digits of numbers by lots",
);

/**
 * Partial binding to the Microsoft DirectSound API
 */
export const DirectSound = mkPackage(
  nixRaw`pkgs.haskellPackages.DirectSound`,
  "Partial binding to the Microsoft DirectSound API",
);

/**
 * Distributed Bug Tracking System
 */
export const DisTract = mkPackage(
  nixRaw`pkgs.haskellPackages.DisTract`,
  "Distributed Bug Tracking System",
);

/**
 * Distance transform function
 */
export const DistanceTransform = mkPackage(
  nixRaw`pkgs.haskellPackages.DistanceTransform`,
  "Distance transform function",
);

/**
 * A comprehensive distance library
 */
export const DistanceUnits = mkPackage(
  nixRaw`pkgs.haskellPackages.DistanceUnits`,
  "A comprehensive distance library",
);

/**
 * Frameshift-aware alignment of protein sequences with DNA sequences
 */
export const DnaProteinAlignment = mkPackage(
  nixRaw`pkgs.haskellPackages.DnaProteinAlignment`,
  "Frameshift-aware alignment of protein sequences with DNA sequences",
);

/**
 * Test interactive Haskell examples
 */
export const DocTest = mkPackage(
  nixRaw`pkgs.haskellPackages.DocTest`,
  "Test interactive Haskell examples",
);

/**
 * Documentation types library
 */
export const Docs = mkPackage(
  nixRaw`pkgs.haskellPackages.Docs`,
  "Documentation types library",
);

/**
 * A tool for deriving hylomorphisms
 */
export const DrHylo = mkPackage(
  nixRaw`pkgs.haskellPackages.DrHylo`,
  "A tool for deriving hylomorphisms",
);

/**
 * Polymorphic protocol engine
 */
export const Dust = mkPackage(
  nixRaw`pkgs.haskellPackages.Dust`,
  "Polymorphic protocol engine",
);

/**
 * Cryptographic operations
 */
export const Dust_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.Dust-crypto`,
  "Cryptographic operations",
);

/**
 * Network filtering exploration tools
 */
export const Dust_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.Dust-tools`,
  "Network filtering exploration tools",
);

/**
 * Network filtering exploration tools that rely on pcap
 */
export const Dust_tools_pcap = mkPackage(
  nixRaw`pkgs.haskellPackages.Dust-tools-pcap`,
  "Network filtering exploration tools that rely on pcap",
);

/**
 * dysFunctional Reactive Programming on Cairo
 */
export const DysFRP_Cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.DysFRP-Cairo`,
  "dysFunctional Reactive Programming on Cairo",
);

/**
 * dysFunctional Reactive Programming on Craftwerk
 */
export const DysFRP_Craftwerk = mkPackage(
  nixRaw`pkgs.haskellPackages.DysFRP-Craftwerk`,
  "dysFunctional Reactive Programming on Craftwerk",
);

/**
 * ExtremlyEasyConfig - Extremly Simple parser for config files
 */
export const EEConfig = mkPackage(
  nixRaw`pkgs.haskellPackages.EEConfig`,
  "ExtremlyEasyConfig - Extremly Simple parser for config files",
);

/**
 * Auto Korean conjugator/adjustor/adopter/converter
 */
export const ENIG = mkPackage(
  nixRaw`pkgs.haskellPackages.ENIG`,
  "Auto Korean conjugator/adjustor/adopter/converter",
);

/**
 * Parsing all context-free grammars using Earley's algorithm
 */
export const Earley = mkPackage(
  nixRaw`pkgs.haskellPackages.Earley`,
  "Parsing all context-free grammars using Earley's algorithm",
);

/**
 * Peter's Syntax Diagram Drawing Tool
 */
export const Ebnf2ps = mkPackage(
  nixRaw`pkgs.haskellPackages.Ebnf2ps`,
  "Peter's Syntax Diagram Drawing Tool",
);

/**
 * A library of efficient, purely-functional data structures (API)
 */
export const EdisonAPI = mkPackage(
  nixRaw`pkgs.haskellPackages.EdisonAPI`,
  "A library of efficient, purely-functional data structures (API)",
);

/**
 * A library of efficient, purely-functional data structures (Core Implementations)
 */
export const EdisonCore = mkPackage(
  nixRaw`pkgs.haskellPackages.EdisonCore`,
  "A library of efficient, purely-functional data structures (Core Implementations)",
);

/**
 * Query language and report generator for edit logs
 */
export const EditTimeReport = mkPackage(
  nixRaw`pkgs.haskellPackages.EditTimeReport`,
  "Query language and report generator for edit logs",
);

/**
 * Encoding character data
 */
export const Encode = mkPackage(
  nixRaw`pkgs.haskellPackages.Encode`,
  "Encoding character data",
);

/**
 * Libary to interface with the NCBI Entrez REST service
 */
export const EntrezHTTP = mkPackage(
  nixRaw`pkgs.haskellPackages.EntrezHTTP`,
  "Libary to interface with the NCBI Entrez REST service",
);

/**
 * Non-crashing `Enum` operations
 */
export const Enum = mkPackage(
  nixRaw`pkgs.haskellPackages.Enum`,
  "Non-crashing `Enum` operations",
);

/**
 * Type-safe bindings to EsounD (ESD; Enlightened Sound Daemon)
 */
export const EsounD = mkPackage(
  nixRaw`pkgs.haskellPackages.EsounD`,
  "Type-safe bindings to EsounD (ESD; Enlightened Sound Daemon)",
);

/**
 * A new implementation of the LambdaMOO server
 */
export const EtaMOO = mkPackage(
  nixRaw`pkgs.haskellPackages.EtaMOO`,
  "A new implementation of the LambdaMOO server",
);

/**
 * Data-flow based graph algorithms
 */
export const Etage_Graph = mkPackage(
  nixRaw`pkgs.haskellPackages.Etage-Graph`,
  "Data-flow based graph algorithms",
);

/**
 * A 2-D shooting game
 */
export const Eternal10Seconds = mkPackage(
  nixRaw`pkgs.haskellPackages.Eternal10Seconds`,
  "A 2-D shooting game",
);

/**
 * A network analysis toolkit for Haskell
 */
export const Etherbunny = mkPackage(
  nixRaw`pkgs.haskellPackages.Etherbunny`,
  "A network analysis toolkit for Haskell",
);

/**
 * Library for using euro currency, italian language
 */
export const EuroIT = mkPackage(
  nixRaw`pkgs.haskellPackages.EuroIT`,
  "Library for using euro currency, italian language",
);

/**
 * Library for computer music research and education
 */
export const Euterpea = mkPackage(
  nixRaw`pkgs.haskellPackages.Euterpea`,
  "Library for computer music research and education",
);

/**
 * Interfaces with FreeSwitch Event Socket
 */
export const EventSocket = mkPackage(
  nixRaw`pkgs.haskellPackages.EventSocket`,
  "Interfaces with FreeSwitch Event Socket",
);

/**
 * Haskell Foreign Accelerate Interface
 */
export const FAI = mkPackage(
  nixRaw`pkgs.haskellPackages.FAI`,
  "Haskell Foreign Accelerate Interface",
);

/**
 * Compose music
 */
export const FComp = mkPackage(
  nixRaw`pkgs.haskellPackages.FComp`,
  "Compose music",
);

/**
 * A set of computational morphology tools for Swedish diachronic lexicons
 */
export const FM_SBLEX = mkPackage(
  nixRaw`pkgs.haskellPackages.FM-SBLEX`,
  "A set of computational morphology tools for Swedish diachronic lexicons",
);

/**
 * Portable TrueType font rendering for OpenGL using the Freetype2 library
 */
export const FTGL = mkPackage(
  nixRaw`pkgs.haskellPackages.FTGL`,
  "Portable TrueType font rendering for OpenGL using the Freetype2 library",
);

/**
 * A command-line FTP client
 */
export const FTPLine = mkPackage(
  nixRaw`pkgs.haskellPackages.FTPLine`,
  "A command-line FTP client",
);

/**
 * A 'FailT' monad transformer that plays well with 'MonadFail'
 */
export const FailT = mkPackage(
  nixRaw`pkgs.haskellPackages.FailT`,
  "A 'FailT' monad transformer that plays well with 'MonadFail'",
);

/**
 * Failure Monad Transformer
 */
export const FailureT = mkPackage(
  nixRaw`pkgs.haskellPackages.FailureT`,
  "Failure Monad Transformer",
);

/**
 * Data structure for fast query and update of cumulative sums
 */
export const FenwickTree = mkPackage(
  nixRaw`pkgs.haskellPackages.FenwickTree`,
  "Data structure for fast query and update of cumulative sums",
);

/**
 * Annotate ps and pdf documents
 */
export const FermatsLastMargin = mkPackage(
  nixRaw`pkgs.haskellPackages.FermatsLastMargin`,
  "Annotate ps and pdf documents",
);

/**
 * Functional 3D
 */
export const FieldTrip = mkPackage(
  nixRaw`pkgs.haskellPackages.FieldTrip`,
  "Functional 3D",
);

/**
 * Functions on System.FilePath
 */
export const FilePather = mkPackage(
  nixRaw`pkgs.haskellPackages.FilePather`,
  "Functions on System.FilePath",
);

/**
 * Finite totally-ordered sets
 */
export const Fin = mkPackage(
  nixRaw`pkgs.haskellPackages.Fin`,
  "Finite totally-ordered sets",
);

/**
 * Obtain Treasury yield curve data
 */
export const Finance_Treasury = mkPackage(
  nixRaw`pkgs.haskellPackages.Finance-Treasury`,
  "Obtain Treasury yield curve data",
);

/**
 * Locate directory of original program
 */
export const FindBin = mkPackage(
  nixRaw`pkgs.haskellPackages.FindBin`,
  "Locate directory of original program",
);

/**
 * Finite categories and usual categorical constructions on them
 */
export const FiniteCategories = mkPackage(
  nixRaw`pkgs.haskellPackages.FiniteCategories`,
  "Finite categories and usual categorical constructions on them",
);

/**
 * Transform objects of the package FiniteCategories into graphs using GraphViz
 */
export const FiniteCategoriesGraphViz = mkPackage(
  nixRaw`pkgs.haskellPackages.FiniteCategoriesGraphViz`,
  "Transform objects of the package FiniteCategories into graphs using GraphViz",
);

/**
 * A finite map implementation, derived from the paper: Efficient sets: a balancing act, S. Adams, Journal of functional programming 3(4) Oct 1993, pp553-562
 */
export const FiniteMap = mkPackage(
  nixRaw`pkgs.haskellPackages.FiniteMap`,
  "A finite map implementation, derived from the paper: Efficient sets: a balancing act, S. Adams, Journal of functional programming 3(4) Oct 1993, pp553-562",
);

/**
 * Grammar and typeclass for first order theories
 */
export const FirstOrderTheory = mkPackage(
  nixRaw`pkgs.haskellPackages.FirstOrderTheory`,
  "Grammar and typeclass for first order theories",
);

/**
 * Fixed point, large word, and large int numerical representations (types and common class instances)
 */
export const FixedPoint_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.FixedPoint-simple`,
  "Fixed point, large word, and large int numerical representations (types and common class instances)",
);

/**
 * Wiki
 */
export const Flippi = mkPackage(
  nixRaw`pkgs.haskellPackages.Flippi`,
  "Wiki",
);

/**
 * Read and write hexadecimal floating point numbers
 */
export const FloatingHex = mkPackage(
  nixRaw`pkgs.haskellPackages.FloatingHex`,
  "Read and write hexadecimal floating point numbers",
);

/**
 * Tools for focusing in on locations within numbers
 */
export const Focus = mkPackage(
  nixRaw`pkgs.haskellPackages.Focus`,
  "Tools for focusing in on locations within numbers",
);

/**
 * A first order logic library in Haskell
 */
export const Folly = mkPackage(
  nixRaw`pkgs.haskellPackages.Folly`,
  "A first order logic library in Haskell",
);

/**
 * A true type file format loader
 */
export const FontyFruity = mkPackage(
  nixRaw`pkgs.haskellPackages.FontyFruity`,
  "A true type file format loader",
);

/**
 * ForSyDe's Haskell-embedded Domain Specific Language
 */
export const ForSyDe = mkPackage(
  nixRaw`pkgs.haskellPackages.ForSyDe`,
  "ForSyDe's Haskell-embedded Domain Specific Language",
);

/**
 * Tree- and forest structures
 */
export const ForestStructures = mkPackage(
  nixRaw`pkgs.haskellPackages.ForestStructures`,
  "Tree- and forest structures",
);

/**
 * Comparison of trees and forests
 */
export const Forestry = mkPackage(
  nixRaw`pkgs.haskellPackages.Forestry`,
  "Comparison of trees and forests",
);

/**
 * (Context-free) grammars in formal language theory
 */
export const FormalGrammars = mkPackage(
  nixRaw`pkgs.haskellPackages.FormalGrammars`,
  "(Context-free) grammars in formal language theory",
);

/**
 * Utilities to generate and solve puzzles
 */
export const Foster = mkPackage(
  nixRaw`pkgs.haskellPackages.Foster`,
  "Utilities to generate and solve puzzles",
);

/**
 * A binding for the Financial Products Markup Language (v5.3)
 */
export const FpMLv53 = mkPackage(
  nixRaw`pkgs.haskellPackages.FpMLv53`,
  "A binding for the Financial Products Markup Language (v5.3)",
);

/**
 * Generates colorful wallpapers
 */
export const FractalArt = mkPackage(
  nixRaw`pkgs.haskellPackages.FractalArt`,
  "Generates colorful wallpapers",
);

/**
 * Data frames For working with tabular data files
 */
export const Frames = mkPackage(
  nixRaw`pkgs.haskellPackages.Frames`,
  "Data frames For working with tabular data files",
);

/**
 * A library for accessing Postgres tables as in-memory data structures
 */
export const Frames_beam = mkPackage(
  nixRaw`pkgs.haskellPackages.Frames-beam`,
  "A library for accessing Postgres tables as in-memory data structures",
);

/**
 * Alternative CSV parser for the Frames package
 */
export const Frames_dsv = mkPackage(
  nixRaw`pkgs.haskellPackages.Frames-dsv`,
  "Alternative CSV parser for the Frames package",
);

/**
 * Frames wrapper for map-reduce-folds and some extra folds helpers
 */
export const Frames_map_reduce = mkPackage(
  nixRaw`pkgs.haskellPackages.Frames-map-reduce`,
  "Frames wrapper for map-reduce-folds and some extra folds helpers",
);

/**
 * A streamly layer for Frames I/O
 */
export const Frames_streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.Frames-streamly`,
  "A streamly layer for Frames I/O",
);

/**
 * An experimental programming language with typed algebraic effects
 */
export const Frank = mkPackage(
  nixRaw`pkgs.haskellPackages.Frank`,
  "An experimental programming language with typed algebraic effects",
);

/**
 * A lightweight, cross-platform, OpenGL-based game engine
 */
export const FunGEn = mkPackage(
  nixRaw`pkgs.haskellPackages.FunGEn`,
  "A lightweight, cross-platform, OpenGL-based game engine",
);

/**
 * Genetic algorithm library
 */
export const GA = mkPackage(
  nixRaw`pkgs.haskellPackages.GA`,
  "Genetic algorithm library",
);

/**
 * A graphical viewer for Hood
 */
export const GHood = mkPackage(
  nixRaw`pkgs.haskellPackages.GHood`,
  "A graphical viewer for Hood",
);

/**
 * A binding for GLFW (OGL)
 */
export const GLFW_OGL = mkPackage(
  nixRaw`pkgs.haskellPackages.GLFW-OGL`,
  "A binding for GLFW (OGL)",
);

/**
 * Bindings to GLFW OpenGL library
 */
export const GLFW_b = mkPackage(
  nixRaw`pkgs.haskellPackages.GLFW-b`,
  "Bindings to GLFW OpenGL library",
);

/**
 * GLFW utility functions to use together with monad-task
 */
export const GLFW_task = mkPackage(
  nixRaw`pkgs.haskellPackages.GLFW-task`,
  "GLFW utility functions to use together with monad-task",
);

/**
 * Open OpenGL context windows in X11 with libX11
 */
export const GLHUI = mkPackage(
  nixRaw`pkgs.haskellPackages.GLHUI`,
  "Open OpenGL context windows in X11 with libX11",
);

/**
 * Simple Gridlab-D GLM parser and utilities
 */
export const GLM = mkPackage(
  nixRaw`pkgs.haskellPackages.GLM`,
  "Simple Gridlab-D GLM parser and utilities",
);

/**
 * A raw binding for the OpenGL graphics system
 */
export const GLURaw = mkPackage(
  nixRaw`pkgs.haskellPackages.GLURaw`,
  "A raw binding for the OpenGL graphics system",
);

/**
 * A binding for the OpenGL Utility Toolkit
 */
export const GLUT = mkPackage(
  nixRaw`pkgs.haskellPackages.GLUT`,
  "A binding for the OpenGL Utility Toolkit",
);

/**
 * Miscellaneous OpenGL utilities
 */
export const GLUtil = mkPackage(
  nixRaw`pkgs.haskellPackages.GLUtil`,
  "Miscellaneous OpenGL utilities",
);

/**
 * Parse GPX files
 */
export const GPX = mkPackage(
  nixRaw`pkgs.haskellPackages.GPX`,
  "Parse GPX files",
);

/**
 * Load GPipe meshes from Collada files
 */
export const GPipe_Collada = mkPackage(
  nixRaw`pkgs.haskellPackages.GPipe-Collada`,
  "Load GPipe meshes from Collada files",
);

/**
 * Examples for the GPipes package
 */
export const GPipe_Examples = mkPackage(
  nixRaw`pkgs.haskellPackages.GPipe-Examples`,
  "Examples for the GPipes package",
);

/**
 * GLFW OpenGL context creation for GPipe
 */
export const GPipe_GLFW = mkPackage(
  nixRaw`pkgs.haskellPackages.GPipe-GLFW`,
  "GLFW OpenGL context creation for GPipe",
);

/**
 * GLFW OpenGL context creation for GPipe
 */
export const GPipe_GLFW4 = mkPackage(
  nixRaw`pkgs.haskellPackages.GPipe-GLFW4`,
  "GLFW OpenGL context creation for GPipe",
);

/**
 * Load GPipe textures from filesystem
 */
export const GPipe_TextureLoad = mkPackage(
  nixRaw`pkgs.haskellPackages.GPipe-TextureLoad`,
  "Load GPipe textures from filesystem",
);

/**
 * Non-adaptive Gaussian quadrature for numeric integraton
 */
export const GaussQuadIntegration = mkPackage(
  nixRaw`pkgs.haskellPackages.GaussQuadIntegration`,
  "Non-adaptive Gaussian quadrature for numeric integraton",
);

/**
 * Several games
 */
export const GeBoP = mkPackage(
  nixRaw`pkgs.haskellPackages.GeBoP`,
  "Several games",
);

/**
 * A natural language generator (specifically, an FB-LTAG surface realiser)
 */
export const GenI = mkPackage(
  nixRaw`pkgs.haskellPackages.GenI`,
  "A natural language generator (specifically, an FB-LTAG surface realiser)",
);

/**
 * Automatic SMS message generator
 */
export const GenSmsPdu = mkPackage(
  nixRaw`pkgs.haskellPackages.GenSmsPdu`,
  "Automatic SMS message generator",
);

/**
 * Libary for processing the NCBI genbank format
 */
export const Genbank = mkPackage(
  nixRaw`pkgs.haskellPackages.Genbank`,
  "Libary for processing the NCBI genbank format",
);

/**
 * Hox gene clustering
 */
export const Gene_CluEDO = mkPackage(
  nixRaw`pkgs.haskellPackages.Gene-CluEDO`,
  "Hox gene clustering",
);

/**
 * A generic, derivable, haskell pretty printer
 */
export const GenericPretty = mkPackage(
  nixRaw`pkgs.haskellPackages.GenericPretty`,
  "A generic, derivable, haskell pretty printer",
);

/**
 * MCFGs for Genus-1 RNA Pseudoknots
 */
export const GenussFold = mkPackage(
  nixRaw`pkgs.haskellPackages.GenussFold`,
  "MCFGs for Genus-1 RNA Pseudoknots",
);

/**
 * Geodetic calculations
 */
export const Geodetic = mkPackage(
  nixRaw`pkgs.haskellPackages.Geodetic`,
  "Geodetic calculations",
);

/**
 * Geometric predicates
 */
export const GeomPredicates = mkPackage(
  nixRaw`pkgs.haskellPackages.GeomPredicates`,
  "Geometric predicates",
);

/**
 * to auto-do somethings
 */
export const GiveYouAHead = mkPackage(
  nixRaw`pkgs.haskellPackages.GiveYouAHead`,
  "to auto-do somethings",
);

/**
 * Globbing library
 */
export const Glob = mkPackage(
  nixRaw`pkgs.haskellPackages.Glob`,
  "Globbing library",
);

/**
 * Simple 3D vector library
 */
export const GlomeVec = mkPackage(
  nixRaw`pkgs.haskellPackages.GlomeVec`,
  "Simple 3D vector library",
);

/**
 * SDL Frontend for Glome ray tracer
 */
export const GlomeView = mkPackage(
  nixRaw`pkgs.haskellPackages.GlomeView`,
  "SDL Frontend for Glome ray tracer",
);

/**
 * Generate web-based charts using the Google Chart API
 */
export const GoogleChart = mkPackage(
  nixRaw`pkgs.haskellPackages.GoogleChart`,
  "Generate web-based charts using the Google Chart API",
);

/**
 * Haskell Interface to Google Directions API
 */
export const GoogleDirections = mkPackage(
  nixRaw`pkgs.haskellPackages.GoogleDirections`,
  "Haskell Interface to Google Directions API",
);

/**
 * Interface to Google Safe Browsing API
 */
export const GoogleSB = mkPackage(
  nixRaw`pkgs.haskellPackages.GoogleSB`,
  "Interface to Google Safe Browsing API",
);

/**
 * Interface to Google Suggest API
 */
export const GoogleSuggest = mkPackage(
  nixRaw`pkgs.haskellPackages.GoogleSuggest`,
  "Interface to Google Suggest API",
);

/**
 * Interface to Google Translate API
 */
export const GoogleTranslate = mkPackage(
  nixRaw`pkgs.haskellPackages.GoogleTranslate`,
  "Interface to Google Translate API",
);

/**
 * Grammar products and higher-dimensional grammars
 */
export const GrammarProducts = mkPackage(
  nixRaw`pkgs.haskellPackages.GrammarProducts`,
  "Grammar products and higher-dimensional grammars",
);

/**
 * GraphHammer Haskell graph analyses framework inspired by STINGER
 */
export const GraphHammer = mkPackage(
  nixRaw`pkgs.haskellPackages.GraphHammer`,
  "GraphHammer Haskell graph analyses framework inspired by STINGER",
);

/**
 * Test harness for TriangleCount analysis
 */
export const GraphHammer_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.GraphHammer-examples`,
  "Test harness for TriangleCount analysis",
);

/**
 * Tarjan's algorithm for computing the strongly connected components of a graph
 */
export const GraphSCC = mkPackage(
  nixRaw`pkgs.haskellPackages.GraphSCC`,
  "Tarjan's algorithm for computing the strongly connected components of a graph",
);

/**
 * A declarative make-like interpreter
 */
export const Grow = mkPackage(
  nixRaw`pkgs.haskellPackages.Grow`,
  "A declarative make-like interpreter",
);

/**
 * Notification utility for Growl
 */
export const GrowlNotify = mkPackage(
  nixRaw`pkgs.haskellPackages.GrowlNotify`,
  "Notification utility for Growl",
);

/**
 * Convenience functions to extend Gtk2hs
 */
export const Gtk2hsGenerics = mkPackage(
  nixRaw`pkgs.haskellPackages.Gtk2hsGenerics`,
  "Convenience functions to extend Gtk2hs",
);

/**
 * OpenGL support for Gtk-based GUIs for Tangible Values
 */
export const GtkGLTV = mkPackage(
  nixRaw`pkgs.haskellPackages.GtkGLTV`,
  "OpenGL support for Gtk-based GUIs for Tangible Values",
);

/**
 * Gtk-based GUIs for Tangible Values
 */
export const GtkTV = mkPackage(
  nixRaw`pkgs.haskellPackages.GtkTV`,
  "Gtk-based GUIs for Tangible Values",
);

/**
 * A graphical REPL and development environment for Haskell
 */
export const GuiHaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.GuiHaskell`,
  "A graphical REPL and development environment for Haskell",
);

/**
 * GUIs for Tangible Values
 */
export const GuiTV = mkPackage(
  nixRaw`pkgs.haskellPackages.GuiTV`,
  "GUIs for Tangible Values",
);

/**
 * The Haskell/R mixed programming environment
 */
export const H = mkPackage(
  nixRaw`pkgs.haskellPackages.H`,
  "The Haskell/R mixed programming environment",
);

/**
 * OBSOLETE. Please use happstack-helpers
 */
export const HAppSHelpers = mkPackage(
  nixRaw`pkgs.haskellPackages.HAppSHelpers`,
  "OBSOLETE. Please use happstack-helpers",
);

/**
 * HAppS data manipulation libraries
 */
export const HAppS_Data = mkPackage(
  nixRaw`pkgs.haskellPackages.HAppS-Data`,
  "HAppS data manipulation libraries",
);

export const HAppS_IxSet = mkPackage(
  nixRaw`pkgs.haskellPackages.HAppS-IxSet`,
  "",
);

/**
 * Web related tools and services
 */
export const HAppS_Server = mkPackage(
  nixRaw`pkgs.haskellPackages.HAppS-Server`,
  "Web related tools and services",
);

/**
 * Event-based distributed state
 */
export const HAppS_State = mkPackage(
  nixRaw`pkgs.haskellPackages.HAppS-State`,
  "Event-based distributed state",
);

/**
 * High-level library for building command line interfaces
 */
export const HCL = mkPackage(
  nixRaw`pkgs.haskellPackages.HCL`,
  "High-level library for building command line interfaces",
);

/**
 * A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files
 */
export const HCodecs = mkPackage(
  nixRaw`pkgs.haskellPackages.HCodecs`,
  "A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files",
);

/**
 * Haskell Database Connectivity
 */
export const HDBC = mkPackage(
  nixRaw`pkgs.haskellPackages.HDBC`,
  "Haskell Database Connectivity",
);

/**
 * ODBC driver for HDBC
 */
export const HDBC_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.HDBC-odbc`,
  "ODBC driver for HDBC",
);

/**
 * PostgreSQL driver for HDBC
 */
export const HDBC_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.HDBC-postgresql`,
  "PostgreSQL driver for HDBC",
);

/**
 * Bracketed connection for HDBC
 */
export const HDBC_session = mkPackage(
  nixRaw`pkgs.haskellPackages.HDBC-session`,
  "Bracketed connection for HDBC",
);

/**
 * Sqlite v3 driver for HDBC
 */
export const HDBC_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.HDBC-sqlite3`,
  "Sqlite v3 driver for HDBC",
);

/**
 * Utilities for reading, manipulating, and writing HDR images
 */
export const HDRUtils = mkPackage(
  nixRaw`pkgs.haskellPackages.HDRUtils`,
  "Utilities for reading, manipulating, and writing HDR images",
);

/**
 * HFuse is a binding for the Linux FUSE library
 */
export const HFuse = mkPackage(
  nixRaw`pkgs.haskellPackages.HFuse`,
  "HFuse is a binding for the Linux FUSE library",
);

/**
 * A simple graphics library based on X11 or Win32
 */
export const HGL = mkPackage(
  nixRaw`pkgs.haskellPackages.HGL`,
  "A simple graphics library based on X11 or Win32",
);

/**
 * Library to enable 3D game development for Haskell - API
 */
export const HGamer3D_API = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-API`,
  "Library to enable 3D game development for Haskell - API",
);

/**
 * Toolset for the Haskell Game Programmer - Audio Functionality
 */
export const HGamer3D_Audio = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Audio`,
  "Toolset for the Haskell Game Programmer - Audio Functionality",
);

/**
 * Windows Game Engine for the Haskell Programmer - Bullet Bindings
 */
export const HGamer3D_Bullet_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Bullet-Binding`,
  "Windows Game Engine for the Haskell Programmer - Bullet Bindings",
);

/**
 * Library to enable 3D game development for Haskell - cAudio Bindings
 */
export const HGamer3D_CAudio_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-CAudio-Binding`,
  "Library to enable 3D game development for Haskell - cAudio Bindings",
);

/**
 * A Toolset for the Haskell Game Programmer - CEGUI Bindings
 */
export const HGamer3D_CEGUI_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-CEGUI-Binding`,
  "A Toolset for the Haskell Game Programmer - CEGUI Bindings",
);

/**
 * Toolset for the Haskell Game Programmer - Game Engine and Utilities
 */
export const HGamer3D_Common = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Common`,
  "Toolset for the Haskell Game Programmer - Game Engine and Utilities",
);

/**
 * Enet Binding for HGamer3D
 */
export const HGamer3D_Enet_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Enet-Binding`,
  "Enet Binding for HGamer3D",
);

/**
 * GUI Functionality for HGamer3D
 */
export const HGamer3D_GUI = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-GUI`,
  "GUI Functionality for HGamer3D",
);

/**
 * Toolset for the Haskell Game Programmer - 3D Graphics Functionality
 */
export const HGamer3D_Graphics3D = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Graphics3D`,
  "Toolset for the Haskell Game Programmer - 3D Graphics Functionality",
);

/**
 * Joystick, Mouse and Keyboard Functionality for HGamer3D
 */
export const HGamer3D_InputSystem = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-InputSystem`,
  "Joystick, Mouse and Keyboard Functionality for HGamer3D",
);

/**
 * Networking Functionality for HGamer3D
 */
export const HGamer3D_Network = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Network`,
  "Networking Functionality for HGamer3D",
);

/**
 * Library to enable 3D game development for Haskell - OIS Bindings
 */
export const HGamer3D_OIS_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-OIS-Binding`,
  "Library to enable 3D game development for Haskell - OIS Bindings",
);

/**
 * Ogre Binding for HGamer3D
 */
export const HGamer3D_Ogre_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Ogre-Binding`,
  "Ogre Binding for HGamer3D",
);

/**
 * SDL2 Binding for HGamer3D
 */
export const HGamer3D_SDL2_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-SDL2-Binding`,
  "SDL2 Binding for HGamer3D",
);

/**
 * SFML Binding for HGamer3D
 */
export const HGamer3D_SFML_Binding = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-SFML-Binding`,
  "SFML Binding for HGamer3D",
);

/**
 * Windowing and Event Functionality for HGamer3D
 */
export const HGamer3D_WinEvent = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-WinEvent`,
  "Windowing and Event Functionality for HGamer3D",
);

/**
 * Wire Functionality for HGamer3D
 */
export const HGamer3D_Wire = mkPackage(
  nixRaw`pkgs.haskellPackages.HGamer3D-Wire`,
  "Wire Functionality for HGamer3D",
);

/**
 * HJScript is a Haskell EDSL for writing JavaScript programs
 */
export const HJScript = mkPackage(
  nixRaw`pkgs.haskellPackages.HJScript`,
  "HJScript is a Haskell EDSL for writing JavaScript programs",
);

/**
 * Algebraic foundation for homomorphic learning
 */
export const HLearn_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.HLearn-algebra`,
  "Algebraic foundation for homomorphic learning",
);

export const HLearn_approximation = mkPackage(
  nixRaw`pkgs.haskellPackages.HLearn-approximation`,
  "",
);

export const HLearn_classification = mkPackage(
  nixRaw`pkgs.haskellPackages.HLearn-classification`,
  "",
);

export const HLearn_datastructures = mkPackage(
  nixRaw`pkgs.haskellPackages.HLearn-datastructures`,
  "",
);

/**
 * Distributions for use with the HLearn library
 */
export const HLearn_distributions = mkPackage(
  nixRaw`pkgs.haskellPackages.HLearn-distributions`,
  "Distributions for use with the HLearn library",
);

/**
 * A preprocessor for HList labelable labels
 */
export const HListPP = mkPackage(
  nixRaw`pkgs.haskellPackages.HListPP`,
  "A preprocessor for HList labelable labels",
);

/**
 * Fast heterogeneous maps and unconstrained typeable-like functionality
 */
export const HMap = mkPackage(
  nixRaw`pkgs.haskellPackages.HMap`,
  "Fast heterogeneous maps and unconstrained typeable-like functionality",
);

/**
 * Markov-generated sequences
 */
export const HMarkov = mkPackage(
  nixRaw`pkgs.haskellPackages.HMarkov`,
  "Markov-generated sequences",
);

/**
 * A flexible mock framework for testing effectful code
 */
export const HMock = mkPackage(
  nixRaw`pkgs.haskellPackages.HMock`,
  "A flexible mock framework for testing effectful code",
);

/**
 * Happy Network Manager
 */
export const HNM = mkPackage(
  nixRaw`pkgs.haskellPackages.HNM`,
  "Happy Network Manager",
);

/**
 * Haskell Numeric Library with pure functionality, R & MATLAB Syntax
 */
export const HNumeric = mkPackage(
  nixRaw`pkgs.haskellPackages.HNumeric`,
  "Haskell Numeric Library with pure functionality, R & MATLAB Syntax",
);

/**
 * Generation of PDF documents
 */
export const HPDF = mkPackage(
  nixRaw`pkgs.haskellPackages.HPDF`,
  "Generation of PDF documents",
);

/**
 * Phone number parser and validator - This is now DEPRECATED!
 */
export const HPhone = mkPackage(
  nixRaw`pkgs.haskellPackages.HPhone`,
  "Phone number parser and validator - This is now DEPRECATED!",
);

/**
 * A minimal monadic PLplot interface for Haskell
 */
export const HPlot = mkPackage(
  nixRaw`pkgs.haskellPackages.HPlot`,
  "A minimal monadic PLplot interface for Haskell",
);

/**
 * A simple OpenGL Pong game based on GLFW
 */
export const HPong = mkPackage(
  nixRaw`pkgs.haskellPackages.HPong`,
  "A simple OpenGL Pong game based on GLFW",
);

/**
 * quantitative finance library
 */
export const HQu = mkPackage(
  nixRaw`pkgs.haskellPackages.HQu`,
  "quantitative finance library",
);

/**
 * Haskell binding to the ROOT data analysis framework
 */
export const HROOT = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT`,
  "Haskell binding to the ROOT data analysis framework",
);

/**
 * Haskell binding to ROOT Graf modules
 */
export const HROOT_graf = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-graf`,
  "Haskell binding to ROOT Graf modules",
);

/**
 * Haskell binding to ROOT Hist modules
 */
export const HROOT_hist = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-hist`,
  "Haskell binding to ROOT Hist modules",
);

/**
 * Haskell binding to ROOT IO modules
 */
export const HROOT_io = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-io`,
  "Haskell binding to ROOT IO modules",
);

/**
 * Haskell binding to ROOT Math modules
 */
export const HROOT_math = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-math`,
  "Haskell binding to ROOT Math modules",
);

/**
 * Haskell binding to ROOT Net modules
 */
export const HROOT_net = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-net`,
  "Haskell binding to ROOT Net modules",
);

/**
 * Haskell binding to ROOT Tree modules
 */
export const HROOT_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.HROOT-tree`,
  "Haskell binding to ROOT Tree modules",
);

/**
 * Haskell raytracer
 */
export const HRay = mkPackage(
  nixRaw`pkgs.haskellPackages.HRay`,
  "Haskell raytracer",
);

/**
 * Gene Expression Programming evolutionary algorithm in Haskell
 */
export const HSGEP = mkPackage(
  nixRaw`pkgs.haskellPackages.HSGEP`,
  "Gene Expression Programming evolutionary algorithm in Haskell",
);

/**
 * Library to mix shell scripting with Haskell programs
 */
export const HSH = mkPackage(
  nixRaw`pkgs.haskellPackages.HSH`,
  "Library to mix shell scripting with Haskell programs",
);

/**
 * Convenience functions that use HSH, instances for HSH
 */
export const HSHHelpers = mkPackage(
  nixRaw`pkgs.haskellPackages.HSHHelpers`,
  "Convenience functions that use HSH, instances for HSH",
);

/**
 * OpenStreetMap Slippy Map
 */
export const HSlippyMap = mkPackage(
  nixRaw`pkgs.haskellPackages.HSlippyMap`,
  "OpenStreetMap Slippy Map",
);

/**
 * Small template engine
 */
export const HSmarty = mkPackage(
  nixRaw`pkgs.haskellPackages.HSmarty`,
  "Small template engine",
);

/**
 * Library for computer music education
 */
export const HSoM = mkPackage(
  nixRaw`pkgs.haskellPackages.HSoM`,
  "Library for computer music education",
);

/**
 * Audio file reading/writing
 */
export const HSoundFile = mkPackage(
  nixRaw`pkgs.haskellPackages.HSoundFile`,
  "Audio file reading/writing",
);

/**
 * StringTemplate implementation in Haskell
 */
export const HStringTemplate = mkPackage(
  nixRaw`pkgs.haskellPackages.HStringTemplate`,
  "StringTemplate implementation in Haskell",
);

/**
 * Convenience functions and instances for HStringTemplate
 */
export const HStringTemplateHelpers = mkPackage(
  nixRaw`pkgs.haskellPackages.HStringTemplateHelpers`,
  "Convenience functions and instances for HStringTemplate",
);

/**
 * Haskell Bindings for libsvm
 */
export const HSvm = mkPackage(
  nixRaw`pkgs.haskellPackages.HSvm`,
  "Haskell Bindings for libsvm",
);

/**
 * The Haskell Test Framework
 */
export const HTF = mkPackage(
  nixRaw`pkgs.haskellPackages.HTF`,
  "The Haskell Test Framework",
);

/**
 * A library for client-side HTTP
 */
export const HTTP = mkPackage(
  nixRaw`pkgs.haskellPackages.HTTP`,
  "A library for client-side HTTP",
);

/**
 * DEPRECATED Enable simple wrappers to Network.HTTP
 */
export const HTTP_Simple = mkPackage(
  nixRaw`pkgs.haskellPackages.HTTP-Simple`,
  "DEPRECATED Enable simple wrappers to Network.HTTP",
);

/**
 * Tableau based theorem prover for hybrid logics
 */
export const HTab = mkPackage(
  nixRaw`pkgs.haskellPackages.HTab`,
  "Tableau based theorem prover for hybrid logics",
);

/**
 * A unit testing framework for Haskell
 */
export const HUnit = mkPackage(
  nixRaw`pkgs.haskellPackages.HUnit`,
  "A unit testing framework for Haskell",
);

/**
 * Approximate equality for floating point numbers with HUnit
 */
export const HUnit_approx = mkPackage(
  nixRaw`pkgs.haskellPackages.HUnit-approx`,
  "Approximate equality for floating point numbers with HUnit",
);

/**
 * A (prototyped) easy to use XMPP library
 */
export const HXMPP = mkPackage(
  nixRaw`pkgs.haskellPackages.HXMPP`,
  "A (prototyped) easy to use XMPP library",
);

/**
 * An Haskell library to drive the french Minitel through a serial port
 */
export const HaMinitel = mkPackage(
  nixRaw`pkgs.haskellPackages.HaMinitel`,
  "An Haskell library to drive the french Minitel through a serial port",
);

/**
 * the Haskell Refactorer
 */
export const HaRe = mkPackage(
  nixRaw`pkgs.haskellPackages.HaRe`,
  "the Haskell Refactorer",
);

/**
 * The Haskell LaTeX library
 */
export const HaTeX = mkPackage(
  nixRaw`pkgs.haskellPackages.HaTeX`,
  "The Haskell LaTeX library",
);

/**
 * This package is deprecated. From version 3, HaTeX does not need this anymore.
 */
export const HaTeX_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.HaTeX-meta`,
  "This package is deprecated. From version 3, HaTeX does not need this anymore.",
);

/**
 * Quasiquoters for HaTeX
 */
export const HaTeX_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.HaTeX-qq`,
  "Quasiquoters for HaTeX",
);

/**
 * An implementation of the Version Space Algebra learning framework
 */
export const HaVSA = mkPackage(
  nixRaw`pkgs.haskellPackages.HaVSA`,
  "An implementation of the Version Space Algebra learning framework",
);

/**
 * An XPath-generating embedded domain specific language
 */
export const HaXPath = mkPackage(
  nixRaw`pkgs.haskellPackages.HaXPath`,
  "An XPath-generating embedded domain specific language",
);

/**
 * Utilities for manipulating XML documents
 */
export const HaXml = mkPackage(
  nixRaw`pkgs.haskellPackages.HaXml`,
  "Utilities for manipulating XML documents",
);

/**
 * Simple chat
 */
export const Hach = mkPackage(
  nixRaw`pkgs.haskellPackages.Hach`,
  "Simple chat",
);

/**
 * Work with HTML more easily in HXT
 */
export const HandsomeSoup = mkPackage(
  nixRaw`pkgs.haskellPackages.HandsomeSoup`,
  "Work with HTML more easily in HXT",
);

/**
 * Harmony Analysis and Retrieval of Music
 */
export const HarmTrace = mkPackage(
  nixRaw`pkgs.haskellPackages.HarmTrace`,
  "Harmony Analysis and Retrieval of Music",
);

/**
 * A library for arbitrary precision decimal numbers
 */
export const HasBigDecimal = mkPackage(
  nixRaw`pkgs.haskellPackages.HasBigDecimal`,
  "A library for arbitrary precision decimal numbers",
);

/**
 * A Haskell library for inference using Gaussian processes
 */
export const HasGP = mkPackage(
  nixRaw`pkgs.haskellPackages.HasGP`,
  "A Haskell library for inference using Gaussian processes",
);

/**
 * Minimalist R5RS Scheme interpreter
 */
export const Haschoo = mkPackage(
  nixRaw`pkgs.haskellPackages.Haschoo`,
  "Minimalist R5RS Scheme interpreter",
);

/**
 * Simple shell written in Haskell
 */
export const Hashell = mkPackage(
  nixRaw`pkgs.haskellPackages.Hashell`,
  "Simple shell written in Haskell",
);

/**
 * HaskRel, Haskell as a DBMS with support for the relational algebra
 */
export const HaskRel = mkPackage(
  nixRaw`pkgs.haskellPackages.HaskRel`,
  "HaskRel, Haskell as a DBMS with support for the relational algebra",
);

/**
 * Client support for POP3, SMTP, and IMAP
 */
export const HaskellNet = mkPackage(
  nixRaw`pkgs.haskellPackages.HaskellNet`,
  "Client support for POP3, SMTP, and IMAP",
);

/**
 * Helpers to connect to SSL/TLS mail servers with HaskellNet
 */
export const HaskellNet_SSL = mkPackage(
  nixRaw`pkgs.haskellPackages.HaskellNet-SSL`,
  "Helpers to connect to SSL/TLS mail servers with HaskellNet",
);

/**
 * mastodon client module for Haskell
 */
export const Hastodon = mkPackage(
  nixRaw`pkgs.haskellPackages.Hastodon`,
  "mastodon client module for Haskell",
);

/**
 * A small 2D game framework
 */
export const Hate = mkPackage(
  nixRaw`pkgs.haskellPackages.Hate`,
  "A small 2D game framework",
);

/**
 * Haskell Web Application Kit
 */
export const Hawk = mkPackage(
  nixRaw`pkgs.haskellPackages.Hawk`,
  "Haskell Web Application Kit",
);

/**
 * The Hayoo! search engine for Haskell API search on hackage
 */
export const Hayoo = mkPackage(
  nixRaw`pkgs.haskellPackages.Hayoo`,
  "The Hayoo! search engine for Haskell API search on hackage",
);

/**
 * A small cross-platform library for reading and modifying the system clipboard
 */
export const Hclip = mkPackage(
  nixRaw`pkgs.haskellPackages.Hclip`,
  "A small cross-platform library for reading and modifying the system clipboard",
);

/**
 * Line oriented editor
 */
export const Hedi = mkPackage(
  nixRaw`pkgs.haskellPackages.Hedi`,
  "Line oriented editor",
);

/**
 * Purely functional 2D graphics for visualization
 */
export const Hieroglyph = mkPackage(
  nixRaw`pkgs.haskellPackages.Hieroglyph`,
  "Purely functional 2D graphics for visualization",
);

/**
 * A multi-index set with advanced query capabilites
 */
export const HiggsSet = mkPackage(
  nixRaw`pkgs.haskellPackages.HiggsSet`,
  "A multi-index set with advanced query capabilites",
);

/**
 * A playground for testing Hipmunk
 */
export const HipmunkPlayground = mkPackage(
  nixRaw`pkgs.haskellPackages.HipmunkPlayground`,
  "A playground for testing Hipmunk",
);

/**
 * Useful functions for Hipmunk
 */
export const Hipmunk_Utils = mkPackage(
  nixRaw`pkgs.haskellPackages.Hipmunk-Utils`,
  "Useful functions for Hipmunk",
);

export const Histogram = mkPackage(
  nixRaw`pkgs.haskellPackages.Histogram`,
  "",
);

/**
 * Lightweight algorithmic debugging
 */
export const Hoed = mkPackage(
  nixRaw`pkgs.haskellPackages.Hoed`,
  "Lightweight algorithmic debugging",
);

/**
 * Monoids with holes
 */
export const HoleyMonoid = mkPackage(
  nixRaw`pkgs.haskellPackages.HoleyMonoid`,
  "Monoids with holes",
);

/**
 * intra- and inter-program communication
 */
export const Holumbus_Distribution = mkPackage(
  nixRaw`pkgs.haskellPackages.Holumbus-Distribution`,
  "intra- and inter-program communication",
);

/**
 * a distributed MapReduce framework
 */
export const Holumbus_MapReduce = mkPackage(
  nixRaw`pkgs.haskellPackages.Holumbus-MapReduce`,
  "a distributed MapReduce framework",
);

/**
 * a distributed storage system
 */
export const Holumbus_Storage = mkPackage(
  nixRaw`pkgs.haskellPackages.Holumbus-Storage`,
  "a distributed storage system",
);

/**
 * Compute the homology of a chain complex
 */
export const Homology = mkPackage(
  nixRaw`pkgs.haskellPackages.Homology`,
  "Compute the homology of a chain complex",
);

/**
 * A Simple Key Value Store
 */
export const HongoDB = mkPackage(
  nixRaw`pkgs.haskellPackages.HongoDB`,
  "A Simple Key Value Store",
);

/**
 * Parser for host and port pairs like localhost:22
 */
export const HostAndPort = mkPackage(
  nixRaw`pkgs.haskellPackages.HostAndPort`,
  "Parser for host and port pairs like localhost:22",
);

/**
 * A Library and Preprocessor that makes it easier to create shared libs from Haskell programs
 */
export const Hs2lib = mkPackage(
  nixRaw`pkgs.haskellPackages.Hs2lib`,
  "A Library and Preprocessor that makes it easier to create shared libs from Haskell programs",
);

/**
 * A haskell interface to Lester Ingber's adaptive simulating annealing code
 */
export const HsASA = mkPackage(
  nixRaw`pkgs.haskellPackages.HsASA`,
  "A haskell interface to Lester Ingber's adaptive simulating annealing code",
);

/**
 * Bindings to htslib
 */
export const HsHTSLib = mkPackage(
  nixRaw`pkgs.haskellPackages.HsHTSLib`,
  "Bindings to htslib",
);

/**
 * Partial OpenSSL binding for Haskell
 */
export const HsOpenSSL = mkPackage(
  nixRaw`pkgs.haskellPackages.HsOpenSSL`,
  "Partial OpenSSL binding for Haskell",
);

/**
 * Use the system's native CA certificate store with HsOpenSSL
 */
export const HsOpenSSL_x509_system = mkPackage(
  nixRaw`pkgs.haskellPackages.HsOpenSSL-x509-system`,
  "Use the system's native CA certificate store with HsOpenSSL",
);

/**
 * Haskell integration with Parrot virtual machine
 */
export const HsParrot = mkPackage(
  nixRaw`pkgs.haskellPackages.HsParrot`,
  "Haskell integration with Parrot virtual machine",
);

/**
 * Fast, lightweight YAML loader and dumper
 */
export const HsSyck = mkPackage(
  nixRaw`pkgs.haskellPackages.HsSyck`,
  "Fast, lightweight YAML loader and dumper",
);

/**
 * Webots bindings for Haskell
 */
export const HsWebots = mkPackage(
  nixRaw`pkgs.haskellPackages.HsWebots`,
  "Webots bindings for Haskell",
);

/**
 * Pure Haskell YAML 1.2 processor
 */
export const HsYAML = mkPackage(
  nixRaw`pkgs.haskellPackages.HsYAML`,
  "Pure Haskell YAML 1.2 processor",
);

/**
 * JSON to YAML Adapter
 */
export const HsYAML_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.HsYAML-aeson`,
  "JSON to YAML Adapter",
);

/**
 * Stream Editor in Haskell
 */
export const Hsed = mkPackage(
  nixRaw`pkgs.haskellPackages.Hsed`,
  "Stream Editor in Haskell",
);

/**
 * A Linear Sum Assignment Problem (LSAP) solver
 */
export const Hungarian_Munkres = mkPackage(
  nixRaw`pkgs.haskellPackages.Hungarian-Munkres`,
  "A Linear Sum Assignment Problem (LSAP) solver",
);

/**
 * The library for generating a WebGL scene for the web
 */
export const Hydrogen = mkPackage(
  nixRaw`pkgs.haskellPackages.Hydrogen`,
  "The library for generating a WebGL scene for the web",
);

/**
 * Editor and interpreter for Interaction Nets
 */
export const INblobs = mkPackage(
  nixRaw`pkgs.haskellPackages.INblobs`,
  "Editor and interpreter for Interaction Nets",
);

/**
 * Atomic compare and swap for IORefs and STRefs
 */
export const IORefCAS = mkPackage(
  nixRaw`pkgs.haskellPackages.IORefCAS`,
  "Atomic compare and swap for IORefs and STRefs",
);

/**
 * A pure specification of the IO monad
 */
export const IOSpec = mkPackage(
  nixRaw`pkgs.haskellPackages.IOSpec`,
  "A pure specification of the IO monad",
);

/**
 * Library to deal with IPv6 address text representations
 */
export const IPv6Addr = mkPackage(
  nixRaw`pkgs.haskellPackages.IPv6Addr`,
  "Library to deal with IPv6 address text representations",
);

/**
 * Anaphoric and miscellaneous useful control-flow
 */
export const IfElse = mkPackage(
  nixRaw`pkgs.haskellPackages.IfElse`,
  "Anaphoric and miscellaneous useful control-flow",
);

export const Imlib = mkPackage(
  nixRaw`pkgs.haskellPackages.Imlib`,
  "",
);

/**
 * Combinators for parsing indentation based syntatic structures
 */
export const IndentParser = mkPackage(
  nixRaw`pkgs.haskellPackages.IndentParser`,
  "Combinators for parsing indentation based syntatic structures",
);

/**
 * Length- and element-indexed lists sitting somewhere between homogeneous and fully heterogeneous
 */
export const IndexedList = mkPackage(
  nixRaw`pkgs.haskellPackages.IndexedList`,
  "Length- and element-indexed lists sitting somewhere between homogeneous and fully heterogeneous",
);

/**
 * liftA2 for infix operators
 */
export const InfixApplicative = mkPackage(
  nixRaw`pkgs.haskellPackages.InfixApplicative`,
  "liftA2 for infix operators",
);

/**
 * Dynamically sized graph library
 */
export const IntGraph = mkPackage(
  nixRaw`pkgs.haskellPackages.IntGraph`,
  "Dynamically sized graph library",
);

/**
 * Data interning (with compact regions where possible)
 */
export const InternedData = mkPackage(
  nixRaw`pkgs.haskellPackages.InternedData`,
  "Data interning (with compact regions where possible)",
);

/**
 * Multiline strings, interpolation and templating
 */
export const Interpolation = mkPackage(
  nixRaw`pkgs.haskellPackages.Interpolation`,
  "Multiline strings, interpolation and templating",
);

/**
 * Multiline strings, interpolation and templating
 */
export const Interpolation_maxs = mkPackage(
  nixRaw`pkgs.haskellPackages.Interpolation-maxs`,
  "Multiline strings, interpolation and templating",
);

/**
 * Containers for intervals, with efficient search
 */
export const IntervalMap = mkPackage(
  nixRaw`pkgs.haskellPackages.IntervalMap`,
  "Containers for intervals, with efficient search",
);

/**
 * Haskell FRP binding to the Irrlicht game engine
 */
export const IrrHaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.IrrHaskell`,
  "Haskell FRP binding to the Irrlicht game engine",
);

/**
 * Parse JSON
 */
export const JSONParser = mkPackage(
  nixRaw`pkgs.haskellPackages.JSONParser`,
  "Parse JSON",
);

/**
 * A combinator library on top of a generalised JSON type
 */
export const JSON_Combinator = mkPackage(
  nixRaw`pkgs.haskellPackages.JSON-Combinator`,
  "A combinator library on top of a generalised JSON type",
);

/**
 * Example uses of the JSON-Combinator library
 */
export const JSON_Combinator_Examples = mkPackage(
  nixRaw`pkgs.haskellPackages.JSON-Combinator-Examples`,
  "Example uses of the JSON-Combinator library",
);

/**
 * A utility to print the SourceFile attribute of one or more Java class files
 */
export const Javasf = mkPackage(
  nixRaw`pkgs.haskellPackages.Javasf`,
  "A utility to print the SourceFile attribute of one or more Java class files",
);

/**
 * Library for modeling jazz improvisation
 */
export const Jazzkell = mkPackage(
  nixRaw`pkgs.haskellPackages.Jazzkell`,
  "Library for modeling jazz improvisation",
);

/**
 * Design-by-contract for JavaScript
 */
export const JsContracts = mkPackage(
  nixRaw`pkgs.haskellPackages.JsContracts`,
  "Design-by-contract for JavaScript",
);

/**
 * Combinators for bidirectional JSON parsing
 */
export const JsonGrammar = mkPackage(
  nixRaw`pkgs.haskellPackages.JsonGrammar`,
  "Combinators for bidirectional JSON parsing",
);

/**
 * JuPyTer notebook parser
 */
export const JuPyTer_notebook = mkPackage(
  nixRaw`pkgs.haskellPackages.JuPyTer-notebook`,
  "JuPyTer notebook parser",
);

/**
 * Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)
 */
export const JuicyPixels = mkPackage(
  nixRaw`pkgs.haskellPackages.JuicyPixels`,
  "Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)",
);

/**
 * Efficiently scale, crop, flip images with JuicyPixels
 */
export const JuicyPixels_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.JuicyPixels-extra`,
  "Efficiently scale, crop, flip images with JuicyPixels",
);

/**
 * Convenience functions to obtain array representations of images
 */
export const JuicyPixels_repa = mkPackage(
  nixRaw`pkgs.haskellPackages.JuicyPixels-repa`,
  "Convenience functions to obtain array representations of images",
);

/**
 * Scale JuicyPixels images with DCT
 */
export const JuicyPixels_scale_dct = mkPackage(
  nixRaw`pkgs.haskellPackages.JuicyPixels-scale-dct`,
  "Scale JuicyPixels images with DCT",
);

/**
 * Scale JuicyPixels images with stb_image_resize
 */
export const JuicyPixels_stbir = mkPackage(
  nixRaw`pkgs.haskellPackages.JuicyPixels-stbir`,
  "Scale JuicyPixels images with stb_image_resize",
);

export const JunkDB_driver_gdbm = mkPackage(
  nixRaw`pkgs.haskellPackages.JunkDB-driver-gdbm`,
  "",
);

export const JunkDB_driver_hashtables = mkPackage(
  nixRaw`pkgs.haskellPackages.JunkDB-driver-hashtables`,
  "",
);

/**
 * KnuthMorrisPratt string searching algorithm
 */
export const KMP = mkPackage(
  nixRaw`pkgs.haskellPackages.KMP`,
  "KnuthMorrisPratt string searching algorithm",
);

/**
 * KdTree, for efficient search in K-dimensional point clouds
 */
export const KdTree = mkPackage(
  nixRaw`pkgs.haskellPackages.KdTree`,
  "KdTree, for efficient search in K-dimensional point clouds",
);

/**
 * A compiler from Curry to Haskell
 */
export const KiCS = mkPackage(
  nixRaw`pkgs.haskellPackages.KiCS`,
  "A compiler from Curry to Haskell",
);

/**
 * debug features for kics
 */
export const KiCS_debugger = mkPackage(
  nixRaw`pkgs.haskellPackages.KiCS-debugger`,
  "debug features for kics",
);

/**
 * a transformation used by the kics debugger
 */
export const KiCS_prophecy = mkPackage(
  nixRaw`pkgs.haskellPackages.KiCS-prophecy`,
  "a transformation used by the kics debugger",
);

/**
 * Variants of Control.Arrow functions, specialised to kleislis.
 */
export const Kleislify = mkPackage(
  nixRaw`pkgs.haskellPackages.Kleislify`,
  "Variants of Control.Arrow functions, specialised to kleislis.",
);

/**
 * Library for automated composition and musical learning
 */
export const Kulitta = mkPackage(
  nixRaw`pkgs.haskellPackages.Kulitta`,
  "Library for automated composition and musical learning",
);

/**
 * Haskell binding for C LDAP API
 */
export const LDAP = mkPackage(
  nixRaw`pkgs.haskellPackages.LDAP`,
  "Haskell binding for C LDAP API",
);

/**
 * Lightweight Directory Access Protocol (LDAP) version 3
 */
export const LDAPv3 = mkPackage(
  nixRaw`pkgs.haskellPackages.LDAPv3`,
  "Lightweight Directory Access Protocol (LDAP) version 3",
);

/**
 * Code for the book Learn Physics with Functional Programming
 */
export const LPFP = mkPackage(
  nixRaw`pkgs.haskellPackages.LPFP`,
  "Code for the book Learn Physics with Functional Programming",
);

/**
 * Code for the book Learn Physics with Functional Programming
 */
export const LPFP_core = mkPackage(
  nixRaw`pkgs.haskellPackages.LPFP-core`,
  "Code for the book Learn Physics with Functional Programming",
);

/**
 * An automated prover targeting problems that involve nonlinear real arithmetic
 */
export const LPPaver = mkPackage(
  nixRaw`pkgs.haskellPackages.LPPaver`,
  "An automated prover targeting problems that involve nonlinear real arithmetic",
);

/**
 * A continuation-based parser library
 */
export const LParse = mkPackage(
  nixRaw`pkgs.haskellPackages.LParse`,
  "A continuation-based parser library",
);

/**
 * Tree with only leaves carrying the data
 */
export const LTree = mkPackage(
  nixRaw`pkgs.haskellPackages.LTree`,
  "Tree with only leaves carrying the data",
);

/**
 * A basic lambda calculator with beta reduction and a REPL
 */
export const LambdaCalculator = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaCalculator`,
  "A basic lambda calculator with beta reduction and a REPL",
);

/**
 * On-memory Database using Lambda Function environment
 */
export const LambdaDB = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaDB`,
  "On-memory Database using Lambda Function environment",
);

/**
 * A game engine library for tactical squad ASCII roguelike dungeon crawlers
 */
export const LambdaHack = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaHack`,
  "A game engine library for tactical squad ASCII roguelike dungeon crawlers",
);

/**
 * Graphical Interaction Net Evaluator for Optimal Evaluation
 */
export const LambdaINet = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaINet`,
  "Graphical Interaction Net Evaluator for Optimal Evaluation",
);

/**
 * Quasiquoter, and Arbitrary helpers for the lambda calculus
 */
export const LambdaPrettyQuote = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaPrettyQuote`,
  "Quasiquoter, and Arbitrary helpers for the lambda calculus",
);

/**
 * Simple shell for evaluating lambda expressions
 */
export const LambdaShell = mkPackage(
  nixRaw`pkgs.haskellPackages.LambdaShell`,
  "Simple shell for evaluating lambda expressions",
);

/**
 * A library for lattices
 */
export const Lattices = mkPackage(
  nixRaw`pkgs.haskellPackages.Lattices`,
  "A library for lattices",
);

/**
 * Lazy PBKDF2 generator
 */
export const Lazy_Pbkdf2 = mkPackage(
  nixRaw`pkgs.haskellPackages.Lazy-Pbkdf2`,
  "Lazy PBKDF2 generator",
);

/**
 * European option implied vol calculation
 */
export const LetsBeRational = mkPackage(
  nixRaw`pkgs.haskellPackages.LetsBeRational`,
  "European option implied vol calculation",
);

/**
 * Bindings to libzip, a library for manipulating zip archives
 */
export const LibZip = mkPackage(
  nixRaw`pkgs.haskellPackages.LibZip`,
  "Bindings to libzip, a library for manipulating zip archives",
);

/**
 * Partition the sequence of items to the subsequences in the order given
 */
export const LinearSplit = mkPackage(
  nixRaw`pkgs.haskellPackages.LinearSplit`,
  "Partition the sequence of items to the subsequences in the order given",
);

/**
 * Collection of types for natural language
 */
export const LinguisticsTypes = mkPackage(
  nixRaw`pkgs.haskellPackages.LinguisticsTypes`,
  "Collection of types for natural language",
);

/**
 * Check a bunch of local html files for broken links
 */
export const LinkChecker = mkPackage(
  nixRaw`pkgs.haskellPackages.LinkChecker`,
  "Check a bunch of local html files for broken links",
);

/**
 * List monad transformer and class
 */
export const List = mkPackage(
  nixRaw`pkgs.haskellPackages.List`,
  "List monad transformer and class",
);

/**
 * Generalized support for list-like structures
 */
export const ListLike = mkPackage(
  nixRaw`pkgs.haskellPackages.ListLike`,
  "Generalized support for list-like structures",
);

/**
 * List transformer
 */
export const ListT = mkPackage(
  nixRaw`pkgs.haskellPackages.ListT`,
  "List transformer",
);

/**
 * Trees and monadic trees expressed as monadic lists where the underlying monad is a list
 */
export const ListTree = mkPackage(
  nixRaw`pkgs.haskellPackages.ListTree`,
  "Trees and monadic trees expressed as monadic lists where the underlying monad is a list",
);

/**
 * define a list constant using Monadic syntax other than overhead [,]
 */
export const ListWriter = mkPackage(
  nixRaw`pkgs.haskellPackages.ListWriter`,
  "define a list constant using Monadic syntax other than overhead [,]",
);

/**
 * Simple zipper for lists
 */
export const ListZipper = mkPackage(
  nixRaw`pkgs.haskellPackages.ListZipper`,
  "Simple zipper for lists",
);

/**
 * a parallel implementation of logic programming using distributed tree exploration
 */
export const LogicGrowsOnTrees = mkPackage(
  nixRaw`pkgs.haskellPackages.LogicGrowsOnTrees`,
  "a parallel implementation of logic programming using distributed tree exploration",
);

/**
 * an adapter for LogicGrowsOnTrees that uses MPI
 */
export const LogicGrowsOnTrees_MPI = mkPackage(
  nixRaw`pkgs.haskellPackages.LogicGrowsOnTrees-MPI`,
  "an adapter for LogicGrowsOnTrees that uses MPI",
);

/**
 * an adapter for LogicGrowsOnTrees that uses multiple processes running in a network
 */
export const LogicGrowsOnTrees_network = mkPackage(
  nixRaw`pkgs.haskellPackages.LogicGrowsOnTrees-network`,
  "an adapter for LogicGrowsOnTrees that uses multiple processes running in a network",
);

/**
 * an adapter for LogicGrowsOnTrees that uses multiple processes for parallelism
 */
export const LogicGrowsOnTrees_processes = mkPackage(
  nixRaw`pkgs.haskellPackages.LogicGrowsOnTrees-processes`,
  "an adapter for LogicGrowsOnTrees that uses multiple processes for parallelism",
);

/**
 * An execution and testing framework for the Linden Scripting Language (LSL)
 */
export const LslPlus = mkPackage(
  nixRaw`pkgs.haskellPackages.LslPlus`,
  "An execution and testing framework for the Linden Scripting Language (LSL)",
);

/**
 * HTTP Daemonic Library
 */
export const Lucu = mkPackage(
  nixRaw`pkgs.haskellPackages.Lucu`,
  "HTTP Daemonic Library",
);

/**
 * A static website and blog generator
 */
export const Lykah = mkPackage(
  nixRaw`pkgs.haskellPackages.Lykah`,
  "A static website and blog generator",
);

/**
 * Folding algorithm based on nucleotide cyclic motifs
 */
export const MC_Fold_DP = mkPackage(
  nixRaw`pkgs.haskellPackages.MC-Fold-DP`,
  "Folding algorithm based on nucleotide cyclic motifs",
);

/**
 * stateful, RESTful web framework
 */
export const MFlow = mkPackage(
  nixRaw`pkgs.haskellPackages.MFlow`,
  "stateful, RESTful web framework",
);

/**
 * A GLPK backend to the MIP library
 */
export const MIP_glpk = mkPackage(
  nixRaw`pkgs.haskellPackages.MIP-glpk`,
  "A GLPK backend to the MIP library",
);

/**
 * Michael-Scott queue
 */
export const MSQueue = mkPackage(
  nixRaw`pkgs.haskellPackages.MSQueue`,
  "Michael-Scott queue",
);

/**
 * Haskell library to interact with Mailchimp JSON API Version 3.0
 */
export const MailchimpSimple = mkPackage(
  nixRaw`pkgs.haskellPackages.MailchimpSimple`,
  "Haskell library to interact with Mailchimp JSON API Version 3.0",
);

/**
 * Class of key-value maps
 */
export const Map = mkPackage(
  nixRaw`pkgs.haskellPackages.Map`,
  "Class of key-value maps",
);

/**
 * Trie-based memo functions
 */
export const MemoTrie = mkPackage(
  nixRaw`pkgs.haskellPackages.MemoTrie`,
  "Trie-based memo functions",
);

/**
 * A meta-object system for Haskell based on Perl 6
 */
export const MetaObject = mkPackage(
  nixRaw`pkgs.haskellPackages.MetaObject`,
  "A meta-object system for Haskell based on Perl 6",
);

/**
 * Evaluation metrics commonly used in supervised machine learning
 */
export const Metrics = mkPackage(
  nixRaw`pkgs.haskellPackages.Metrics`,
  "Evaluation metrics commonly used in supervised machine learning",
);

/**
 * Haskell mailing list manager
 */
export const Mhailist = mkPackage(
  nixRaw`pkgs.haskellPackages.Mhailist`,
  "Haskell mailing list manager",
);

/**
 * OpenGL for dummies
 */
export const Michelangelo = mkPackage(
  nixRaw`pkgs.haskellPackages.Michelangelo`,
  "OpenGL for dummies",
);

/**
 * Interface for Microsoft Translator
 */
export const MicrosoftTranslator = mkPackage(
  nixRaw`pkgs.haskellPackages.MicrosoftTranslator`,
  "Interface for Microsoft Translator",
);

/**
 * Large utility library
 */
export const MissingH = mkPackage(
  nixRaw`pkgs.haskellPackages.MissingH`,
  "Large utility library",
);

/**
 * Useful types and definitions missing from other libraries
 */
export const MissingK = mkPackage(
  nixRaw`pkgs.haskellPackages.MissingK`,
  "Useful types and definitions missing from other libraries",
);

/**
 * findM and other missing 'M's
 */
export const MissingM = mkPackage(
  nixRaw`pkgs.haskellPackages.MissingM`,
  "findM and other missing 'M's",
);

/**
 * Haskell interface to Python
 */
export const MissingPy = mkPackage(
  nixRaw`pkgs.haskellPackages.MissingPy`,
  "Haskell interface to Python",
);

/**
 * Modular arithmetic via Numeric-Prelude
 */
export const Modulo = mkPackage(
  nixRaw`pkgs.haskellPackages.Modulo`,
  "Modular arithmetic via Numeric-Prelude",
);

/**
 * Polymorphic combinators for working with foreign functions
 */
export const MonadCatchIO_mtl_foreign = mkPackage(
  nixRaw`pkgs.haskellPackages.MonadCatchIO-mtl-foreign`,
  "Polymorphic combinators for working with foreign functions",
);

/**
 * Monad-transformer compatible version of the Control.Exception module
 */
export const MonadCatchIO_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.MonadCatchIO-transformers`,
  "Monad-transformer compatible version of the Control.Exception module",
);

/**
 * Automatically generate layered monads
 */
export const MonadLab = mkPackage(
  nixRaw`pkgs.haskellPackages.MonadLab`,
  "Automatically generate layered monads",
);

/**
 * MonadPrompt, implementation & examples
 */
export const MonadPrompt = mkPackage(
  nixRaw`pkgs.haskellPackages.MonadPrompt`,
  "MonadPrompt, implementation & examples",
);

/**
 * Random-number generation monad
 */
export const MonadRandom = mkPackage(
  nixRaw`pkgs.haskellPackages.MonadRandom`,
  "Random-number generation monad",
);

/**
 * A minimalistic CLI Pomodoro timer
 */
export const Monadoro = mkPackage(
  nixRaw`pkgs.haskellPackages.Monadoro`,
  "A minimalistic CLI Pomodoro timer",
);

/**
 * A simple tetris clone
 */
export const Monaris = mkPackage(
  nixRaw`pkgs.haskellPackages.Monaris`,
  "A simple tetris clone",
);

/**
 * MonadIO instances for the Monatron transformers
 */
export const Monatron_IO = mkPackage(
  nixRaw`pkgs.haskellPackages.Monatron-IO`,
  "MonadIO instances for the Monatron transformers",
);

/**
 * Renders backgrounds & borders
 */
export const Mondrian = mkPackage(
  nixRaw`pkgs.haskellPackages.Mondrian`,
  "Renders backgrounds & borders",
);

/**
 * Symbolic computations in strict monoidal categories with LaTeX output
 */
export const Monocle = mkPackage(
  nixRaw`pkgs.haskellPackages.Monocle`,
  "Symbolic computations in strict monoidal categories with LaTeX output",
);

/**
 * Morse code
 */
export const MorseCode = mkPackage(
  nixRaw`pkgs.haskellPackages.MorseCode`,
  "Morse code",
);

/**
 * Automated Mutation Testing for HUnit tests
 */
export const MuCheck_HUnit = mkPackage(
  nixRaw`pkgs.haskellPackages.MuCheck-HUnit`,
  "Automated Mutation Testing for HUnit tests",
);

/**
 * Automated Mutation Testing for Hspec tests
 */
export const MuCheck_Hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.MuCheck-Hspec`,
  "Automated Mutation Testing for Hspec tests",
);

/**
 * Automated Mutation Testing for QuickCheck tests
 */
export const MuCheck_QuickCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.MuCheck-QuickCheck`,
  "Automated Mutation Testing for QuickCheck tests",
);

/**
 * Automated Mutation Testing for SmallCheck tests
 */
export const MuCheck_SmallCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.MuCheck-SmallCheck`,
  "Automated Mutation Testing for SmallCheck tests",
);

/**
 * A Haskell implementation for combining SU(n) multiplets
 */
export const MultipletCombiner = mkPackage(
  nixRaw`pkgs.haskellPackages.MultipletCombiner`,
  "A Haskell implementation for combining SU(n) multiplets",
);

/**
 * Simple and typesafe layer over the Munkres package
 */
export const Munkres_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.Munkres-simple`,
  "Simple and typesafe layer over the Munkres package",
);

/**
 * interface to MusicBrainz XML2 and JSON web services
 */
export const MusicBrainz = mkPackage(
  nixRaw`pkgs.haskellPackages.MusicBrainz`,
  "interface to MusicBrainz XML2 and JSON web services",
);

/**
 * Binding to libdiscid by MusicBrainz
 */
export const MusicBrainz_libdiscid = mkPackage(
  nixRaw`pkgs.haskellPackages.MusicBrainz-libdiscid`,
  "Binding to libdiscid by MusicBrainz",
);

/**
 * Most likely order of mutation events in RNA
 */
export const MutationOrder = mkPackage(
  nixRaw`pkgs.haskellPackages.MutationOrder`,
  "Most likely order of mutation events in RNA",
);

/**
 * NGLess implements ngless, a DSL for processing sequencing data
 */
export const NGLess = mkPackage(
  nixRaw`pkgs.haskellPackages.NGLess`,
  "NGLess implements ngless, a DSL for processing sequencing data",
);

/**
 * NTRU Cryptography
 */
export const NTRU = mkPackage(
  nixRaw`pkgs.haskellPackages.NTRU`,
  "NTRU Cryptography",
);

/**
 * A Haskell interface to Lego Mindstorms NXT
 */
export const NXT = mkPackage(
  nixRaw`pkgs.haskellPackages.NXT`,
  "A Haskell interface to Lego Mindstorms NXT",
);

/**
 * Easy-and-safe-to-use high-level Haskell bindings to NaCl
 */
export const NaCl = mkPackage(
  nixRaw`pkgs.haskellPackages.NaCl`,
  "Easy-and-safe-to-use high-level Haskell bindings to NaCl",
);

/**
 * A name generator written in Haskell
 */
export const NameGenerator = mkPackage(
  nixRaw`pkgs.haskellPackages.NameGenerator`,
  "A name generator written in Haskell",
);

/**
 * Instances of NcStore for hypercuboids
 */
export const NaperianNetCDF = mkPackage(
  nixRaw`pkgs.haskellPackages.NaperianNetCDF`,
  "Instances of NcStore for hypercuboids",
);

/**
 * Simple scoring schemes for word alignments
 */
export const NaturalLanguageAlphabets = mkPackage(
  nixRaw`pkgs.haskellPackages.NaturalLanguageAlphabets`,
  "Simple scoring schemes for word alignments",
);

/**
 * Context Algebra of near
 */
export const NearContextAlgebra = mkPackage(
  nixRaw`pkgs.haskellPackages.NearContextAlgebra`,
  "Context Algebra of near",
);

/**
 * A port of John Skilling's nested sampling C code to Haskell
 */
export const NestedSampling = mkPackage(
  nixRaw`pkgs.haskellPackages.NestedSampling`,
  "A port of John Skilling's nested sampling C code to Haskell",
);

/**
 * High-level abstraction over 9P protocol
 */
export const Network_NineP = mkPackage(
  nixRaw`pkgs.haskellPackages.Network-NineP`,
  "High-level abstraction over 9P protocol",
);

/**
 * 9P2000 in pure Haskell
 */
export const NineP = mkPackage(
  nixRaw`pkgs.haskellPackages.NineP`,
  "9P2000 in pure Haskell",
);

/**
 * Ninja game
 */
export const Ninjas = mkPackage(
  nixRaw`pkgs.haskellPackages.Ninjas`,
  "Ninja game",
);

/**
 * Placeholder package to preserve debug ability via conditional builds
 */
export const NoHoed = mkPackage(
  nixRaw`pkgs.haskellPackages.NoHoed`,
  "Placeholder package to preserve debug ability via conditional builds",
);

/**
 * Microbenchmarks for various array libraries
 */
export const NoSlow = mkPackage(
  nixRaw`pkgs.haskellPackages.NoSlow`,
  "Microbenchmarks for various array libraries",
);

/**
 * A Haskell coherent noise generator based on libnoise
 */
export const Noise = mkPackage(
  nixRaw`pkgs.haskellPackages.Noise`,
  "A Haskell coherent noise generator based on libnoise",
);

/**
 * A Nomic game in haskell
 */
export const Nomyx = mkPackage(
  nixRaw`pkgs.haskellPackages.Nomyx`,
  "A Nomic game in haskell",
);

/**
 * A Nomic game in haskell
 */
export const Nomyx_Core = mkPackage(
  nixRaw`pkgs.haskellPackages.Nomyx-Core`,
  "A Nomic game in haskell",
);

/**
 * Language to express rules for Nomic
 */
export const Nomyx_Language = mkPackage(
  nixRaw`pkgs.haskellPackages.Nomyx-Language`,
  "Language to express rules for Nomic",
);

/**
 * Language to express rules for Nomic
 */
export const Nomyx_Rules = mkPackage(
  nixRaw`pkgs.haskellPackages.Nomyx-Rules`,
  "Language to express rules for Nomic",
);

/**
 * Web gui for Nomyx
 */
export const Nomyx_Web = mkPackage(
  nixRaw`pkgs.haskellPackages.Nomyx-Web`,
  "Web gui for Nomyx",
);

/**
 * A list with a length of at least one
 */
export const NonEmptyList = mkPackage(
  nixRaw`pkgs.haskellPackages.NonEmptyList`,
  "A list with a length of at least one",
);

/**
 * Instances of numeric classes for functions and tuples
 */
export const NumInstances = mkPackage(
  nixRaw`pkgs.haskellPackages.NumInstances`,
  "Instances of numeric classes for functions and tuples",
);

/**
 * Num, Enum, Eq, Integral, Ord, Real, and Show instances for Lazy ByteStrings
 */
export const NumLazyByteString = mkPackage(
  nixRaw`pkgs.haskellPackages.NumLazyByteString`,
  "Num, Enum, Eq, Integral, Ord, Real, and Show instances for Lazy ByteStrings",
);

/**
 * An assortment of number theoretic functions
 */
export const Numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.Numbers`,
  "An assortment of number theoretic functions",
);

/**
 * Nussinov78 using the ADPfusion library
 */
export const Nussinov78 = mkPackage(
  nixRaw`pkgs.haskellPackages.Nussinov78`,
  "Nussinov78 using the ADPfusion library",
);

/**
 * Explicitly handled object names
 */
export const ObjectName = mkPackage(
  nixRaw`pkgs.haskellPackages.ObjectName`,
  "Explicitly handled object names",
);

/**
 * Embedded language for GPU Programming
 */
export const Obsidian = mkPackage(
  nixRaw`pkgs.haskellPackages.Obsidian`,
  "Embedded language for GPU Programming",
);

/**
 * Text UI library for performing parallel remote SSH operations
 */
export const OnRmt = mkPackage(
  nixRaw`pkgs.haskellPackages.OnRmt`,
  "Text UI library for performing parallel remote SSH operations",
);

/**
 * Singleton Tuple
 */
export const OneTuple = mkPackage(
  nixRaw`pkgs.haskellPackages.OneTuple`,
  "Singleton Tuple",
);

/**
 * The 1-tuple type or single-value "collection"
 */
export const Only = mkPackage(
  nixRaw`pkgs.haskellPackages.Only`,
  "The 1-tuple type or single-value \"collection\"",
);

/**
 * Assorted utilities to work with AFP data streams
 */
export const OpenAFP_Utils = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenAFP-Utils`,
  "Assorted utilities to work with AFP data streams",
);

/**
 * A binding to the OpenAL cross-platform 3D audio API
 */
export const OpenAL = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenAL`,
  "A binding to the OpenAL cross-platform 3D audio API",
);

/**
 * A binding for the OpenGL graphics system
 */
export const OpenGL = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenGL`,
  "A binding for the OpenGL graphics system",
);

/**
 * Quickcheck instances for various data structures
 */
export const OpenGLCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenGLCheck`,
  "Quickcheck instances for various data structures",
);

/**
 * A raw binding for the OpenGL graphics system
 */
export const OpenGLRaw = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenGLRaw`,
  "A raw binding for the OpenGL graphics system",
);

/**
 * ADT wrapper and renderer for OpenSCAD models
 */
export const OpenSCAD = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenSCAD`,
  "ADT wrapper and renderer for OpenSCAD models",
);

/**
 * OpenVG (ShivaVG-0.2.1) binding
 */
export const OpenVG = mkPackage(
  nixRaw`pkgs.haskellPackages.OpenVG`,
  "OpenVG (ShivaVG-0.2.1) binding",
);

/**
 * The OptDir type for representing optimization directions
 */
export const OptDir = mkPackage(
  nixRaw`pkgs.haskellPackages.OptDir`,
  "The OptDir type for representing optimization directions",
);

/**
 * Efficient ordered (by popcount) enumeration of bits
 */
export const OrderedBits = mkPackage(
  nixRaw`pkgs.haskellPackages.OrderedBits`,
  "Efficient ordered (by popcount) enumeration of bits",
);

/**
 * Ordinal arithmetic
 */
export const Ordinals = mkPackage(
  nixRaw`pkgs.haskellPackages.Ordinals`,
  "Ordinal arithmetic",
);

/**
 * An addon to PCLT package: enchance PCLT catalog with PostgreSQL powers
 */
export const PCLT_DB = mkPackage(
  nixRaw`pkgs.haskellPackages.PCLT-DB`,
  "An addon to PCLT package: enchance PCLT catalog with PostgreSQL powers",
);

/**
 * A library for analysis of 3-D protein coordinates
 */
export const PDBtools = mkPackage(
  nixRaw`pkgs.haskellPackages.PDBtools`,
  "A library for analysis of 3-D protein coordinates",
);

/**
 * Priority Search Queue
 */
export const PSQueue = mkPackage(
  nixRaw`pkgs.haskellPackages.PSQueue`,
  "Priority Search Queue",
);

/**
 * Page-oriented extraction and composition library
 */
export const PageIO = mkPackage(
  nixRaw`pkgs.haskellPackages.PageIO`,
  "Page-oriented extraction and composition library",
);

/**
 * a simple Paillier cryptosystem
 */
export const Paillier = mkPackage(
  nixRaw`pkgs.haskellPackages.Paillier`,
  "a simple Paillier cryptosystem",
);

/**
 * a code generator for partial differential equations solvers
 */
export const Paraiso = mkPackage(
  nixRaw`pkgs.haskellPackages.Paraiso`,
  "a code generator for partial differential equations solvers",
);

/**
 * BaseSpecs used for @Parallel-Arrows-Definition@ and Co
 */
export const Parallel_Arrows_BaseSpec = mkPackage(
  nixRaw`pkgs.haskellPackages.Parallel-Arrows-BaseSpec`,
  "BaseSpecs used for @Parallel-Arrows-Definition@ and Co",
);

/**
 * Eden based backend for @Parallel-Arrows-Definition@
 */
export const Parallel_Arrows_Eden = mkPackage(
  nixRaw`pkgs.haskellPackages.Parallel-Arrows-Eden`,
  "Eden based backend for @Parallel-Arrows-Definition@",
);

/**
 * GpH based backend for @Parallel-Arrows-Definition@ in a multicore variant
 */
export const Parallel_Arrows_Multicore = mkPackage(
  nixRaw`pkgs.haskellPackages.Parallel-Arrows-Multicore`,
  "GpH based backend for @Parallel-Arrows-Definition@ in a multicore variant",
);

/**
 * Par Monad (@monad-par@) based backend for @Parallel-Arrows-Definition@
 */
export const Parallel_Arrows_ParMonad = mkPackage(
  nixRaw`pkgs.haskellPackages.Parallel-Arrows-ParMonad`,
  "Par Monad (@monad-par@) based backend for @Parallel-Arrows-Definition@",
);

/**
 * Parsec combinators for more complex objects
 */
export const ParsecTools = mkPackage(
  nixRaw`pkgs.haskellPackages.ParsecTools`,
  "Parsec combinators for more complex objects",
);

/**
 * Parse and evaluate mathematical expressions
 */
export const ParserFunction = mkPackage(
  nixRaw`pkgs.haskellPackages.ParserFunction`,
  "Parse and evaluate mathematical expressions",
);

/**
 * emulate partial type signatures with template haskell
 */
export const PartialTypeSignatures = mkPackage(
  nixRaw`pkgs.haskellPackages.PartialTypeSignatures`,
  "emulate partial type signatures with template haskell",
);

/**
 * CLI for pasting to lpaste.net
 */
export const PastePipe = mkPackage(
  nixRaw`pkgs.haskellPackages.PastePipe`,
  "CLI for pasting to lpaste.net",
);

/**
 * simple Peano numbers
 */
export const Peano = mkPackage(
  nixRaw`pkgs.haskellPackages.Peano`,
  "simple Peano numbers",
);

/**
 * Permutations of effectful computations
 */
export const PermuteEffects = mkPackage(
  nixRaw`pkgs.haskellPackages.PermuteEffects`,
  "Permutations of effectful computations",
);

/**
 * Play Hangman Game
 */
export const PlayHangmanGame = mkPackage(
  nixRaw`pkgs.haskellPackages.PlayHangmanGame`,
  "Play Hangman Game",
);

/**
 * Real-time line plotter for generic data
 */
export const Plot_ho_matic = mkPackage(
  nixRaw`pkgs.haskellPackages.Plot-ho-matic`,
  "Real-time line plotter for generic data",
);

/**
 * So far just a lint like program for PL/SQL. Diff and refactoring tools are planned
 */
export const PlslTools = mkPackage(
  nixRaw`pkgs.haskellPackages.PlslTools`,
  "So far just a lint like program for PL/SQL. Diff and refactoring tools are planned",
);

/**
 * Pluralize English words
 */
export const Plural = mkPackage(
  nixRaw`pkgs.haskellPackages.Plural`,
  "Pluralize English words",
);

/**
 * A binding for PortMedia/PortMidi
 */
export const PortMidi = mkPackage(
  nixRaw`pkgs.haskellPackages.PortMidi`,
  "A binding for PortMedia/PortMidi",
);

/**
 * Simplified PortMidi wrapper
 */
export const PortMidi_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.PortMidi-simple`,
  "Simplified PortMidi wrapper",
);

export const Printf_TH = mkPackage(
  nixRaw`pkgs.haskellPackages.Printf-TH`,
  "",
);

/**
 * Probability distribution monads
 */
export const ProbabilityMonads = mkPackage(
  nixRaw`pkgs.haskellPackages.ProbabilityMonads`,
  "Probability distribution monads",
);

/**
 * Propositional Logic
 */
export const PropLogic = mkPackage(
  nixRaw`pkgs.haskellPackages.PropLogic`,
  "Propositional Logic",
);

/**
 * Proximity sets in N dimensions
 */
export const ProxN = mkPackage(
  nixRaw`pkgs.haskellPackages.ProxN`,
  "Proximity sets in N dimensions",
);

/**
 * A Perl 6 Implementation
 */
export const Pugs = mkPackage(
  nixRaw`pkgs.haskellPackages.Pugs`,
  "A Perl 6 Implementation",
);

/**
 * A networked event handling framework for hooking into other programs
 */
export const Pup_Events = mkPackage(
  nixRaw`pkgs.haskellPackages.Pup-Events`,
  "A networked event handling framework for hooking into other programs",
);

/**
 * A networked event handling framework for hooking into other programs
 */
export const Pup_Events_Client = mkPackage(
  nixRaw`pkgs.haskellPackages.Pup-Events-Client`,
  "A networked event handling framework for hooking into other programs",
);

/**
 * A networked event handling framework for hooking into other programs
 */
export const Pup_Events_Demo = mkPackage(
  nixRaw`pkgs.haskellPackages.Pup-Events-Demo`,
  "A networked event handling framework for hooking into other programs",
);

/**
 * A networked event handling framework for hooking into other programs
 */
export const Pup_Events_PQueue = mkPackage(
  nixRaw`pkgs.haskellPackages.Pup-Events-PQueue`,
  "A networked event handling framework for hooking into other programs",
);

/**
 * Quasiquotations for a python like interpolated string formatter
 */
export const PyF = mkPackage(
  nixRaw`pkgs.haskellPackages.PyF`,
  "Quasiquotations for a python like interpolated string formatter",
);

/**
 * A QuasiQuoter for Text
 */
export const QuasiText = mkPackage(
  nixRaw`pkgs.haskellPackages.QuasiText`,
  "A QuasiQuoter for Text",
);

/**
 * Programming with Eventual Consistency over Cassandra
 */
export const Quelea = mkPackage(
  nixRaw`pkgs.haskellPackages.Quelea`,
  "Programming with Eventual Consistency over Cassandra",
);

/**
 * Automatic testing of Haskell programs
 */
export const QuickCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.QuickCheck`,
  "Automatic testing of Haskell programs",
);

/**
 * A GenT monad transformer for QuickCheck library
 */
export const QuickCheck_GenT = mkPackage(
  nixRaw`pkgs.haskellPackages.QuickCheck-GenT`,
  "A GenT monad transformer for QuickCheck library",
);

/**
 * Safe reimplementation of QuickCheck's core
 */
export const QuickCheck_safe = mkPackage(
  nixRaw`pkgs.haskellPackages.QuickCheck-safe`,
  "Safe reimplementation of QuickCheck's core",
);

/**
 * Quick and easy data visualization with Haskell
 */
export const QuickPlot = mkPackage(
  nixRaw`pkgs.haskellPackages.QuickPlot`,
  "Quick and easy data visualization with Haskell",
);

/**
 * The RANSAC algorithm for parameter estimation
 */
export const RANSAC = mkPackage(
  nixRaw`pkgs.haskellPackages.RANSAC`,
  "The RANSAC algorithm for parameter estimation",
);

/**
 * Pure haskell Red-Black-Tree implemetation
 */
export const RBTree = mkPackage(
  nixRaw`pkgs.haskellPackages.RBTree`,
  "Pure haskell Red-Black-Tree implemetation",
);

/**
 * A framework for writing RESTful applications
 */
export const RESTng = mkPackage(
  nixRaw`pkgs.haskellPackages.RESTng`,
  "A framework for writing RESTful applications",
);

/**
 * RFC-1751 library for Haskell
 */
export const RFC1751 = mkPackage(
  nixRaw`pkgs.haskellPackages.RFC1751`,
  "RFC-1751 library for Haskell",
);

/**
 * A reflective JSON serializer/parser
 */
export const RJson = mkPackage(
  nixRaw`pkgs.haskellPackages.RJson`,
  "A reflective JSON serializer/parser",
);

/**
 * Binding to code that controls a Segway RMP
 */
export const RMP = mkPackage(
  nixRaw`pkgs.haskellPackages.RMP`,
  "Binding to code that controls a Segway RMP",
);

/**
 * RNA secondary structure prediction
 */
export const RNAFold = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAFold`,
  "RNA secondary structure prediction",
);

/**
 * RNA secondary structure folding
 */
export const RNAFoldProgs = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAFoldProgs`,
  "RNA secondary structure folding",
);

/**
 * Multi-target RNA sequence design
 */
export const RNAdesign = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAdesign`,
  "Multi-target RNA sequence design",
);

/**
 * Draw RNA secondary structures
 */
export const RNAdraw = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAdraw`,
  "Draw RNA secondary structures",
);

/**
 * Unsupervized construction of RNA family models
 */
export const RNAlien = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAlien`,
  "Unsupervized construction of RNA family models",
);

/**
 * RNA folding with non-canonical basepairs and base-triplets
 */
export const RNAwolf = mkPackage(
  nixRaw`pkgs.haskellPackages.RNAwolf`,
  "RNA folding with non-canonical basepairs and base-triplets",
);

/**
 * Implementation of RSA, using the padding schemes of PKCS#1 v2.1.
 */
export const RSA = mkPackage(
  nixRaw`pkgs.haskellPackages.RSA`,
  "Implementation of RSA, using the padding schemes of PKCS#1 v2.1.",
);

export const RSolve = mkPackage(
  nixRaw`pkgs.haskellPackages.RSolve`,
  "",
);

/**
 * A puzzle game written in Haskell with a cat in lead role
 */
export const Raincat = mkPackage(
  nixRaw`pkgs.haskellPackages.Raincat`,
  "A puzzle game written in Haskell with a cat in lead role",
);

/**
 * Haskell port of Random123 library
 */
export const Random123 = mkPackage(
  nixRaw`pkgs.haskellPackages.Random123`,
  "Haskell port of Random123 library",
);

/**
 * Ranged sets for Haskell
 */
export const Ranged_sets = mkPackage(
  nixRaw`pkgs.haskellPackages.Ranged-sets`,
  "Ranged sets for Haskell",
);

/**
 * HTTP to XMPP omegle chats gate
 */
export const Ranka = mkPackage(
  nixRaw`pkgs.haskellPackages.Ranka`,
  "HTTP to XMPP omegle chats gate",
);

/**
 * A pure haskell drawing engine
 */
export const Rasterific = mkPackage(
  nixRaw`pkgs.haskellPackages.Rasterific`,
  "A pure haskell drawing engine",
);

/**
 * A modal FRP language
 */
export const Rattus = mkPackage(
  nixRaw`pkgs.haskellPackages.Rattus`,
  "A modal FRP language",
);

/**
 * Simple command line argument parsing
 */
export const ReadArgs = mkPackage(
  nixRaw`pkgs.haskellPackages.ReadArgs`,
  "Simple command line argument parsing",
);

/**
 * Write to and read from ByteStrings maintaining internal memory references
 */
export const RefSerialize = mkPackage(
  nixRaw`pkgs.haskellPackages.RefSerialize`,
  "Write to and read from ByteStrings maintaining internal memory references",
);

/**
 * quasiquoter for inline-R code
 */
export const Rlang_QQ = mkPackage(
  nixRaw`pkgs.haskellPackages.Rlang-QQ`,
  "quasiquoter for inline-R code",
);

/**
 * Limits the size of a directory's contents
 */
export const RollingDirectory = mkPackage(
  nixRaw`pkgs.haskellPackages.RollingDirectory`,
  "Limits the size of a directory's contents",
);

/**
 * All hail the Royal Monad!
 */
export const RoyalMonad = mkPackage(
  nixRaw`pkgs.haskellPackages.RoyalMonad`,
  "All hail the Royal Monad!",
);

/**
 * Library for accessing S3 compatible storage services
 */
export const S3 = mkPackage(
  nixRaw`pkgs.haskellPackages.S3`,
  "Library for accessing S3 compatible storage services",
);

/**
 * A benchmark suite for runtime and heap measurements over a series of inputs
 */
export const SBench = mkPackage(
  nixRaw`pkgs.haskellPackages.SBench`,
  "A benchmark suite for runtime and heap measurements over a series of inputs",
);

/**
 * ESCRIPT: a human friendly language for programming Bitcoin scripts
 */
export const SCRIPTWriter = mkPackage(
  nixRaw`pkgs.haskellPackages.SCRIPTWriter`,
  "ESCRIPT: a human friendly language for programming Bitcoin scripts",
);

/**
 * This is a library for handling calendars and resource availability based on the "top-nodes algorithm" and set operations
 */
export const SCalendar = mkPackage(
  nixRaw`pkgs.haskellPackages.SCalendar`,
  "This is a library for handling calendars and resource availability based on the \"top-nodes algorithm\" and set operations",
);

/**
 * Binding to libSDL
 */
export const SDL = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL`,
  "Binding to libSDL",
);

/**
 * Binding to libSDL_gfx
 */
export const SDL_gfx = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL-gfx`,
  "Binding to libSDL_gfx",
);

/**
 * Binding to libSDL_image
 */
export const SDL_image = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL-image`,
  "Binding to libSDL_image",
);

/**
 * Binding to libSDL_mixer
 */
export const SDL_mixer = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL-mixer`,
  "Binding to libSDL_mixer",
);

/**
 * Binding to the SMPEG library
 */
export const SDL_mpeg = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL-mpeg`,
  "Binding to the SMPEG library",
);

/**
 * Binding to libSDL_ttf
 */
export const SDL_ttf = mkPackage(
  nixRaw`pkgs.haskellPackages.SDL-ttf`,
  "Binding to libSDL_ttf",
);

/**
 * Higher level library on top of SFML
 */
export const SFML_control = mkPackage(
  nixRaw`pkgs.haskellPackages.SFML-control`,
  "Higher level library on top of SFML",
);

/**
 * SFont SDL Bitmap Fonts
 */
export const SFont = mkPackage(
  nixRaw`pkgs.haskellPackages.SFont`,
  "SFont SDL Bitmap Fonts",
);

/**
 * An example of using the SG and OpenGL libraries
 */
export const SGdemo = mkPackage(
  nixRaw`pkgs.haskellPackages.SGdemo`,
  "An example of using the SG and OpenGL libraries",
);

/**
 * Implementations of the SHA suite of message digest functions
 */
export const SHA = mkPackage(
  nixRaw`pkgs.haskellPackages.SHA`,
  "Implementations of the SHA suite of message digest functions",
);

/**
 * Fast, incremental SHA hashing for bytestrings
 */
export const SHA2 = mkPackage(
  nixRaw`pkgs.haskellPackages.SHA2`,
  "Fast, incremental SHA hashing for bytestrings",
);

/**
 * Calculate db-data dependencies of functions
 */
export const SQLDeps = mkPackage(
  nixRaw`pkgs.haskellPackages.SQLDeps`,
  "Calculate db-data dependencies of functions",
);

/**
 * STLink USB interface in Haskell
 */
export const STLinkUSB = mkPackage(
  nixRaw`pkgs.haskellPackages.STLinkUSB`,
  "STLink USB interface in Haskell",
);

/**
 * Definition for Peripherals,Registers and Fields from STM32F103xx.svd
 */
export const STM32F103xx_SVD = mkPackage(
  nixRaw`pkgs.haskellPackages.STM32F103xx-SVD`,
  "Definition for Peripherals,Registers and Fields from STM32F103xx.svd",
);

/**
 * control a STM32F103 microcontroller
 */
export const STM32_Zombie = mkPackage(
  nixRaw`pkgs.haskellPackages.STM32-Zombie`,
  "control a STM32F103 microcontroller",
);

/**
 * A monad transformer version of the ST monad
 */
export const STMonadTrans = mkPackage(
  nixRaw`pkgs.haskellPackages.STMonadTrans`,
  "A monad transformer version of the ST monad",
);

/**
 * Code generation tool for Quartz code from a SVG
 */
export const SVG2Q = mkPackage(
  nixRaw`pkgs.haskellPackages.SVG2Q`,
  "Code generation tool for Quartz code from a SVG",
);

/**
 * Fonts from the SVG-Font format
 */
export const SVGFonts = mkPackage(
  nixRaw`pkgs.haskellPackages.SVGFonts`,
  "Fonts from the SVG-Font format",
);

/**
 * Parsing the path command of SVG
 */
export const SVGPath = mkPackage(
  nixRaw`pkgs.haskellPackages.SVGPath`,
  "Parsing the path command of SVG",
);

/**
 * A parser for SWMM 5 binary .OUT files
 */
export const SWMMoutGetMB = mkPackage(
  nixRaw`pkgs.haskellPackages.SWMMoutGetMB`,
  "A parser for SWMM 5 binary .OUT files",
);

/**
 * Library for safe (pattern match free) functions
 */
export const Safe = mkPackage(
  nixRaw`pkgs.haskellPackages.Safe`,
  "Library for safe (pattern match free) functions",
);

/**
 * Much safer replacement for QSemN, QSem, and SampleVar
 */
export const SafeSemaphore = mkPackage(
  nixRaw`pkgs.haskellPackages.SafeSemaphore`,
  "Much safer replacement for QSemN, QSem, and SampleVar",
);

/**
 * Base types and classes for statistics, sciences and humanities
 */
export const SciBaseTypes = mkPackage(
  nixRaw`pkgs.haskellPackages.SciBaseTypes`,
  "Base types and classes for statistics, sciences and humanities",
);

/**
 * Scientific workflow management system
 */
export const SciFlow = mkPackage(
  nixRaw`pkgs.haskellPackages.SciFlow`,
  "Scientific workflow management system",
);

/**
 * Scientific workflow management system
 */
export const SciFlow_drmaa = mkPackage(
  nixRaw`pkgs.haskellPackages.SciFlow-drmaa`,
  "Scientific workflow management system",
);

/**
 * A cross platform P2P VPN application built using Haskell
 */
export const Scurry = mkPackage(
  nixRaw`pkgs.haskellPackages.Scurry`,
  "A cross platform P2P VPN application built using Haskell",
);

/**
 * Selects a representative subset of sequences from multiple sequence alignment
 */
export const SelectSequencesFromMSA = mkPackage(
  nixRaw`pkgs.haskellPackages.SelectSequencesFromMSA`,
  "Selects a representative subset of sequences from multiple sequence alignment",
);

/**
 * See README for more info
 */
export const Set = mkPackage(
  nixRaw`pkgs.haskellPackages.Set`,
  "See README for more info",
);

/**
 * Shell script analysis tool
 */
export const ShellCheck = mkPackage(
  nixRaw`pkgs.haskellPackages.ShellCheck`,
  "Shell script analysis tool",
);

/**
 * "compatline" backend module for Shellac
 */
export const Shellac_compatline = mkPackage(
  nixRaw`pkgs.haskellPackages.Shellac-compatline`,
  "\"compatline\" backend module for Shellac",
);

/**
 * Editline backend module for Shellac
 */
export const Shellac_editline = mkPackage(
  nixRaw`pkgs.haskellPackages.Shellac-editline`,
  "Editline backend module for Shellac",
);

/**
 * Haskeline backend module for Shellac
 */
export const Shellac_haskeline = mkPackage(
  nixRaw`pkgs.haskellPackages.Shellac-haskeline`,
  "Haskeline backend module for Shellac",
);

/**
 * Readline backend module for Shellac
 */
export const Shellac_readline = mkPackage(
  nixRaw`pkgs.haskellPackages.Shellac-readline`,
  "Readline backend module for Shellac",
);

/**
 * grammars for TSP and SHP
 */
export const ShortestPathProblems = mkPackage(
  nixRaw`pkgs.haskellPackages.ShortestPathProblems`,
  "grammars for TSP and SHP",
);

/**
 * Show for * -> *
 */
export const ShowF = mkPackage(
  nixRaw`pkgs.haskellPackages.ShowF`,
  "Show for * -> *",
);

/**
 * A programming model for declarative, high performance user interface
 */
export const Shpadoinkle = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle`,
  "A programming model for declarative, high performance user interface",
);

/**
 * A Virtual Dom in pure Haskell, based on Html as an Alignable Functor
 */
export const Shpadoinkle_backend_pardiff = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-backend-pardiff`,
  "A Virtual Dom in pure Haskell, based on Html as an Alignable Functor",
);

/**
 * Use the high-performance Snabbdom virtual dom library written in JavaScript
 */
export const Shpadoinkle_backend_snabbdom = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-backend-snabbdom`,
  "Use the high-performance Snabbdom virtual dom library written in JavaScript",
);

/**
 * A backend for rendering Shpadoinkle as Text
 */
export const Shpadoinkle_backend_static = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-backend-static`,
  "A backend for rendering Shpadoinkle as Text",
);

/**
 * Chrome extension to aide in development
 */
export const Shpadoinkle_developer_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-developer-tools`,
  "Chrome extension to aide in development",
);

/**
 * Shpadoinkle as a static site
 */
export const Shpadoinkle_disembodied = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-disembodied`,
  "Shpadoinkle as a static site",
);

/**
 * Example usages of Shpadoinkle
 */
export const Shpadoinkle_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-examples`,
  "Example usages of Shpadoinkle",
);

/**
 * A typed, template generated Html DSL, and helpers
 */
export const Shpadoinkle_html = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-html`,
  "A typed, template generated Html DSL, and helpers",
);

/**
 * Lens combinators for Shpadoinkle applications
 */
export const Shpadoinkle_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-lens`,
  "Lens combinators for Shpadoinkle applications",
);

/**
 * A single page application rounter for Shpadoinkle based on Servant
 */
export const Shpadoinkle_router = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-router`,
  "A single page application rounter for Shpadoinkle based on Servant",
);

/**
 * Integration of the streaming library with Shpadoinkle continuations
 */
export const Shpadoinkle_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-streaming`,
  "Integration of the streaming library with Shpadoinkle continuations",
);

/**
 * Read standard file formats into Shpadoinkle with Template Haskell
 */
export const Shpadoinkle_template = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-template`,
  "Read standard file formats into Shpadoinkle with Template Haskell",
);

/**
 * A collection of common reusable types and components
 */
export const Shpadoinkle_widgets = mkPackage(
  nixRaw`pkgs.haskellPackages.Shpadoinkle-widgets`,
  "A collection of common reusable types and components",
);

/**
 * 4-way trie fuzzy search
 */
export const Shrub = mkPackage(
  nixRaw`pkgs.haskellPackages.Shrub`,
  "4-way trie fuzzy search",
);

/**
 * A vector shooter game
 */
export const Shu_thing = mkPackage(
  nixRaw`pkgs.haskellPackages.Shu-thing`,
  "A vector shooter game",
);

/**
 * Fast AES encryption/decryption for bytestrings
 */
export const SimpleAES = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleAES`,
  "Fast AES encryption/decryption for bytestrings",
);

/**
 * Simple evolutionary algorithm framework
 */
export const SimpleEA = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleEA`,
  "Simple evolutionary algorithm framework",
);

/**
 * A Simple Graphics Library from the SimpleH framework
 */
export const SimpleGL = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleGL`,
  "A Simple Graphics Library from the SimpleH framework",
);

/**
 * Simple, configurable logging
 */
export const SimpleLog = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleLog`,
  "Simple, configurable logging",
);

/**
 * A simple static file server, for when apache is overkill
 */
export const SimpleServer = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleServer`,
  "A simple static file server, for when apache is overkill",
);

/**
 * Simple table generator
 */
export const SimpleTableGenerator = mkPackage(
  nixRaw`pkgs.haskellPackages.SimpleTableGenerator`,
  "Simple table generator",
);

/**
 * Prototypical type checker for Type Theory with Sized Natural Numbers
 */
export const Sit = mkPackage(
  nixRaw`pkgs.haskellPackages.Sit`,
  "Prototypical type checker for Type Theory with Sized Natural Numbers",
);

/**
 * Prototypical type checker for Type Theory with Sized Natural Numbers
 */
export const Sit_0_2023_8_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.Sit_0_2023_8_3`,
  "Prototypical type checker for Type Theory with Sized Natural Numbers",
);

/**
 * Fast size comparison for standard containers
 */
export const SizeCompare = mkPackage(
  nixRaw`pkgs.haskellPackages.SizeCompare`,
  "Fast size comparison for standard containers",
);

/**
 * A tiny, lazy SMT solver
 */
export const Smooth = mkPackage(
  nixRaw`pkgs.haskellPackages.Smooth`,
  "A tiny, lazy SMT solver",
);

/**
 * E-library directory based on FUSE virtual file system
 */
export const Snusmumrik = mkPackage(
  nixRaw`pkgs.haskellPackages.Snusmumrik`,
  "E-library directory based on FUSE virtual file system",
);

/**
 * Football simulation framework for teaching functional programming
 */
export const SoccerFun = mkPackage(
  nixRaw`pkgs.haskellPackages.SoccerFun`,
  "Football simulation framework for teaching functional programming",
);

/**
 * OpenGL UI for the SoccerFun framework
 */
export const SoccerFunGL = mkPackage(
  nixRaw`pkgs.haskellPackages.SoccerFunGL`,
  "OpenGL UI for the SoccerFun framework",
);

/**
 * Static code analysis using graph-theoretic techniques
 */
export const SourceGraph = mkPackage(
  nixRaw`pkgs.haskellPackages.SourceGraph`,
  "Static code analysis using graph-theoretic techniques",
);

/**
 * Assorted utility modules
 */
export const Southpaw = mkPackage(
  nixRaw`pkgs.haskellPackages.Southpaw`,
  "Assorted utility modules",
);

/**
 * Simple space pirate roguelike
 */
export const SpacePrivateers = mkPackage(
  nixRaw`pkgs.haskellPackages.SpacePrivateers`,
  "Simple space pirate roguelike",
);

/**
 * Lock free Spin Counter
 */
export const SpinCounter = mkPackage(
  nixRaw`pkgs.haskellPackages.SpinCounter`,
  "Lock free Spin Counter",
);

/**
 * Another Haskell web framework for rapid development
 */
export const Spock = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock`,
  "Another Haskell web framework for rapid development",
);

/**
 * Another Haskell web framework for rapid development
 */
export const Spock_api = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-api`,
  "Another Haskell web framework for rapid development",
);

/**
 * Another Haskell web framework for rapid development
 */
export const Spock_api_server = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-api-server`,
  "Another Haskell web framework for rapid development",
);

/**
 * Another Haskell web framework for rapid development
 */
export const Spock_core = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-core`,
  "Another Haskell web framework for rapid development",
);

/**
 * Digestive functors support for Spock
 */
export const Spock_digestive = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-digestive`,
  "Digestive functors support for Spock",
);

/**
 * Lucid support for Spock
 */
export const Spock_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-lucid`,
  "Lucid support for Spock",
);

/**
 * Background workers for Spock
 */
export const Spock_worker = mkPackage(
  nixRaw`pkgs.haskellPackages.Spock-worker`,
  "Background workers for Spock",
);

/**
 * Write support for Excel's SpreadsheetML format
 */
export const SpreadsheetML = mkPackage(
  nixRaw`pkgs.haskellPackages.SpreadsheetML`,
  "Write support for Excel's SpreadsheetML format",
);

/**
 * Stack data structure
 */
export const Stack = mkPackage(
  nixRaw`pkgs.haskellPackages.Stack`,
  "Stack data structure",
);

/**
 * State variables
 */
export const StateVar = mkPackage(
  nixRaw`pkgs.haskellPackages.StateVar`,
  "State variables",
);

/**
 * State variables
 */
export const StateVar_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.StateVar-transformer`,
  "State variables",
);

/**
 * Collection of useful statistical methods
 */
export const StatisticalMethods = mkPackage(
  nixRaw`pkgs.haskellPackages.StatisticalMethods`,
  "Collection of useful statistical methods",
);

/**
 * Libary for Stockholm aligmnent format
 */
export const StockholmAlignment = mkPackage(
  nixRaw`pkgs.haskellPackages.StockholmAlignment`,
  "Libary for Stockholm aligmnent format",
);

/**
 * Converts SDF to Haskell
 */
export const Strafunski_Sdf2Haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.Strafunski-Sdf2Haskell`,
  "Converts SDF to Haskell",
);

/**
 * A library for manipulating infinite lists
 */
export const Stream = mkPackage(
  nixRaw`pkgs.haskellPackages.Stream`,
  "A library for manipulating infinite lists",
);

/**
 * String manipulation utilities
 */
export const StringUtils = mkPackage(
  nixRaw`pkgs.haskellPackages.StringUtils`,
  "String manipulation utilities",
);

/**
 * Svg Icons and more
 */
export const SvgIcons = mkPackage(
  nixRaw`pkgs.haskellPackages.SvgIcons`,
  "Svg Icons and more",
);

/**
 * Library which aids constructing generic (SYB3-based) widgets
 */
export const SybWidget = mkPackage(
  nixRaw`pkgs.haskellPackages.SybWidget`,
  "Library which aids constructing generic (SYB3-based) widgets",
);

/**
 * Syntax Macros in the form of an EDSL
 */
export const SyntaxMacros = mkPackage(
  nixRaw`pkgs.haskellPackages.SyntaxMacros`,
  "Syntax Macros in the form of an EDSL",
);

/**
 * A Transactional cache with user-defined persistence
 */
export const TCache = mkPackage(
  nixRaw`pkgs.haskellPackages.TCache`,
  "A Transactional cache with user-defined persistence",
);

/**
 * Typed Transformations of Typed Abstract Syntax
 */
export const TTTAS = mkPackage(
  nixRaw`pkgs.haskellPackages.TTTAS`,
  "Typed Transformations of Typed Abstract Syntax",
);

/**
 * Tangible Values -- composable interfaces
 */
export const TV = mkPackage(
  nixRaw`pkgs.haskellPackages.TV`,
  "Tangible Values -- composable interfaces",
);

/**
 * Ferry Table Algebra
 */
export const TableAlgebra = mkPackage(
  nixRaw`pkgs.haskellPackages.TableAlgebra`,
  "Ferry Table Algebra",
);

/**
 * Tahin Password Generator
 */
export const Tahin = mkPackage(
  nixRaw`pkgs.haskellPackages.Tahin`,
  "Tahin Password Generator",
);

/**
 * Tainted type, and associated operations
 */
export const Tainted = mkPackage(
  nixRaw`pkgs.haskellPackages.Tainted`,
  "Tainted type, and associated operations",
);

/**
 * Run TLT tests from Tasty
 */
export const TastyTLT = mkPackage(
  nixRaw`pkgs.haskellPackages.TastyTLT`,
  "Run TLT tests from Tasty",
);

/**
 * Libary for parsing, processing and vizualization of taxonomy data
 */
export const Taxonomy = mkPackage(
  nixRaw`pkgs.haskellPackages.Taxonomy`,
  "Libary for parsing, processing and vizualization of taxonomy data",
);

/**
 * Tool for parsing, processing, comparing and visualizing taxonomy data
 */
export const TaxonomyTools = mkPackage(
  nixRaw`pkgs.haskellPackages.TaxonomyTools`,
  "Tool for parsing, processing, comparing and visualizing taxonomy data",
);

/**
 * TeaHS Game Creation Library
 */
export const TeaHS = mkPackage(
  nixRaw`pkgs.haskellPackages.TeaHS`,
  "TeaHS Game Creation Library",
);

/**
 * Tensor data types
 */
export const Tensor = mkPackage(
  nixRaw`pkgs.haskellPackages.Tensor`,
  "Tensor data types",
);

/**
 * Efficient pure ternary tree Sets and Maps
 */
export const TernaryTrees = mkPackage(
  nixRaw`pkgs.haskellPackages.TernaryTrees`,
  "Efficient pure ternary tree Sets and Maps",
);

/**
 * Mutable objects that reside in their own threads
 */
export const ThreadObjects = mkPackage(
  nixRaw`pkgs.haskellPackages.ThreadObjects`,
  "Mutable objects that reside in their own threads",
);

/**
 * Tic Tac Toe in your command line!
 */
export const Tic_Tac_Toe = mkPackage(
  nixRaw`pkgs.haskellPackages.Tic-Tac-Toe`,
  "Tic Tac Toe in your command line!",
);

/**
 * Functions that should have been in Debug.Trace
 */
export const TraceUtils = mkPackage(
  nixRaw`pkgs.haskellPackages.TraceUtils`,
  "Functions that should have been in Debug.Trace",
);

/**
 * A library to apply transformation to containers so as to maximize sharing of unchanged subcomponents
 */
export const Transhare = mkPackage(
  nixRaw`pkgs.haskellPackages.Transhare`,
  "A library to apply transformation to containers so as to maximize sharing of unchanged subcomponents",
);

/**
 * Wait-free Tree Counter
 */
export const TreeCounter = mkPackage(
  nixRaw`pkgs.haskellPackages.TreeCounter`,
  "Wait-free Tree Counter",
);

/**
 * Transformer for Data.Tree
 */
export const TreeT = mkPackage(
  nixRaw`pkgs.haskellPackages.TreeT`,
  "Transformer for Data.Tree",
);

/**
 * Lock free Treiber stack
 */
export const Treiber = mkPackage(
  nixRaw`pkgs.haskellPackages.Treiber`,
  "Lock free Treiber stack",
);

/**
 * Automatic type inference of generalized tries with Template Haskell
 */
export const TrieMap = mkPackage(
  nixRaw`pkgs.haskellPackages.TrieMap`,
  "Automatic type inference of generalized tries with Template Haskell",
);

/**
 * An implementation of the Twofish Symmetric-key cipher
 */
export const Twofish = mkPackage(
  nixRaw`pkgs.haskellPackages.Twofish`,
  "An implementation of the Twofish Symmetric-key cipher",
);

/**
 * Typing speed game
 */
export const TypeClass = mkPackage(
  nixRaw`pkgs.haskellPackages.TypeClass`,
  "Typing speed game",
);

/**
 * TypeIlluminator is a prototype tool exploring debugging of type errors/
 */
export const TypeIlluminator = mkPackage(
  nixRaw`pkgs.haskellPackages.TypeIlluminator`,
  "TypeIlluminator is a prototype tool exploring debugging of type errors/",
);

/**
 * Some Nat-indexed types for GHC
 */
export const TypeNat = mkPackage(
  nixRaw`pkgs.haskellPackages.TypeNat`,
  "Some Nat-indexed types for GHC",
);

/**
 * Command Line Typing speed tester
 */
export const TypingTester = mkPackage(
  nixRaw`pkgs.haskellPackages.TypingTester`,
  "Command Line Typing speed tester",
);

/**
 * Library for Arrowized Graphical User Interfaces
 */
export const UISF = mkPackage(
  nixRaw`pkgs.haskellPackages.UISF`,
  "Library for Arrowized Graphical User Interfaces",
);

/**
 * A small command-line accounting tool
 */
export const UMM = mkPackage(
  nixRaw`pkgs.haskellPackages.UMM`,
  "A small command-line accounting tool",
);

/**
 * Library for maintaining correctness of URLs within an application
 */
export const URLT = mkPackage(
  nixRaw`pkgs.haskellPackages.URLT`,
  "Library for maintaining correctness of URLs within an application",
);

/**
 * Processing popular picture formats into .c or .raw format in RGB565
 */
export const UTFTConverter = mkPackage(
  nixRaw`pkgs.haskellPackages.UTFTConverter`,
  "Processing popular picture formats into .c or .raw format in RGB565",
);

/**
 * It provides the functionality like unix "uniq" utility
 */
export const Unique = mkPackage(
  nixRaw`pkgs.haskellPackages.Unique`,
  "It provides the functionality like unix \"uniq\" utility",
);

/**
 * A crude interface between Haskell and Unix-like operating systems
 */
export const Unixutils = mkPackage(
  nixRaw`pkgs.haskellPackages.Unixutils`,
  "A crude interface between Haskell and Unix-like operating systems",
);

/**
 * A simple interface to shadow passwords (aka, shadow.h)
 */
export const Unixutils_shadow = mkPackage(
  nixRaw`pkgs.haskellPackages.Unixutils-shadow`,
  "A simple interface to shadow passwords (aka, shadow.h)",
);

/**
 * Url dispatcher. Helps to retain friendly URLs in web applications.
 */
export const UrlDisp = mkPackage(
  nixRaw`pkgs.haskellPackages.UrlDisp`,
  "Url dispatcher. Helps to retain friendly URLs in web applications.",
);

/**
 * Some useful functions and shorthands
 */
export const Useful = mkPackage(
  nixRaw`pkgs.haskellPackages.Useful`,
  "Some useful functions and shorthands",
);

/**
 * Utility functions that are missing from the standard library
 */
export const UtilityTM = mkPackage(
  nixRaw`pkgs.haskellPackages.UtilityTM`,
  "Utility functions that are missing from the standard library",
);

/**
 * A Valve Value-keyvalue parser for Haskell made with Parsec
 */
export const ValveValueKeyvalue = mkPackage(
  nixRaw`pkgs.haskellPackages.ValveValueKeyvalue`,
  "A Valve Value-keyvalue parser for Haskell made with Parsec",
);

/**
 * Fixed-length lists and low-dimensional linear algebra
 */
export const Vec = mkPackage(
  nixRaw`pkgs.haskellPackages.Vec`,
  "Fixed-length lists and low-dimensional linear algebra",
);

/**
 * a simple peano-indexed vector type
 */
export const VecN = mkPackage(
  nixRaw`pkgs.haskellPackages.VecN`,
  "a simple peano-indexed vector type",
);

/**
 * This package is obsolete
 */
export const Vec_Transform = mkPackage(
  nixRaw`pkgs.haskellPackages.Vec-Transform`,
  "This package is obsolete",
);

/**
 * Libary for parsing ViennaRNA package output
 */
export const ViennaRNAParser = mkPackage(
  nixRaw`pkgs.haskellPackages.ViennaRNAParser`,
  "Libary for parsing ViennaRNA package output",
);

/**
 * ViennaRNA v2 bindings
 */
export const ViennaRNA_bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.ViennaRNA-bindings`,
  "ViennaRNA v2 bindings",
);

/**
 * ViennaRNA v2 extensions
 */
export const ViennaRNA_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.ViennaRNA-extras`,
  "ViennaRNA v2 extensions",
);

/**
 * Painless 3D graphics, no affiliation with gloss
 */
export const Vis = mkPackage(
  nixRaw`pkgs.haskellPackages.Vis`,
  "Painless 3D graphics, no affiliation with gloss",
);

/**
 * A binding for the Vulkan API
 */
export const Vulkan = mkPackage(
  nixRaw`pkgs.haskellPackages.Vulkan`,
  "A binding for the Vulkan API",
);

/**
 * Bindings to the VulkanMemoryAllocator library
 */
export const VulkanMemoryAllocator = mkPackage(
  nixRaw`pkgs.haskellPackages.VulkanMemoryAllocator`,
  "Bindings to the VulkanMemoryAllocator library",
);

/**
 * WAVE audio file IO library
 */
export const WAVE = mkPackage(
  nixRaw`pkgs.haskellPackages.WAVE`,
  "WAVE audio file IO library",
);

/**
 * Text-editor widget with dynamic line-wrapping for use with Brick
 */
export const WEditorBrick = mkPackage(
  nixRaw`pkgs.haskellPackages.WEditorBrick`,
  "Text-editor widget with dynamic line-wrapping for use with Brick",
);

/**
 * Language-specific hyphenation policies for WEditor
 */
export const WEditorHyphen = mkPackage(
  nixRaw`pkgs.haskellPackages.WEditorHyphen`,
  "Language-specific hyphenation policies for WEditor",
);

/**
 * A simple command line tools to control the Asus WL500gP router
 */
export const WL500gPControl = mkPackage(
  nixRaw`pkgs.haskellPackages.WL500gPControl`,
  "A simple command line tools to control the Asus WL500gP router",
);

/**
 * Convert the WURFL file into a Parsec parser
 */
export const WURFL = mkPackage(
  nixRaw`pkgs.haskellPackages.WURFL`,
  "Convert the WURFL file into a Parsec parser",
);

/**
 * WXDiffCtrl
 */
export const WXDiffCtrl = mkPackage(
  nixRaw`pkgs.haskellPackages.WXDiffCtrl`,
  "WXDiffCtrl",
);

/**
 * WASH is a family of EDSLs for programming Web applications in Haskell
 */
export const WashNGo = mkPackage(
  nixRaw`pkgs.haskellPackages.WashNGo`,
  "WASH is a family of EDSLs for programming Web applications in Haskell",
);

/**
 * Parsers and utilities for the OBJ WaveFront 3D model format
 */
export const WaveFront = mkPackage(
  nixRaw`pkgs.haskellPackages.WaveFront`,
  "Parsers and utilities for the OBJ WaveFront 3D model format",
);

/**
 * JavaScript analysis tools
 */
export const WebBits_Html = mkPackage(
  nixRaw`pkgs.haskellPackages.WebBits-Html`,
  "JavaScript analysis tools",
);

/**
 * A Multiplate instance for JavaScript
 */
export const WebBits_multiplate = mkPackage(
  nixRaw`pkgs.haskellPackages.WebBits-multiplate`,
  "A Multiplate instance for JavaScript",
);

/**
 * Continuation based web programming for Happstack
 */
export const WebCont = mkPackage(
  nixRaw`pkgs.haskellPackages.WebCont`,
  "Continuation based web programming for Happstack",
);

/**
 * Binding to the Win32 console API
 */
export const Win32_console = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-console`,
  "Binding to the Win32 console API",
);

/**
 * Win32 DHCP Server Management API
 */
export const Win32_dhcp_server = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-dhcp-server`,
  "Win32 DHCP Server Management API",
);

/**
 * Alternative error handling for Win32 foreign calls
 */
export const Win32_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-errors`,
  "Alternative error handling for Win32 foreign calls",
);

/**
 * Provides missing Win32 API
 */
export const Win32_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-extras`,
  "Provides missing Win32 API",
);

/**
 * Support for manipulating NTFS junction points
 */
export const Win32_junction_point = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-junction-point`,
  "Support for manipulating NTFS junction points",
);

/**
 * A binding to part of the Win32 library for file notification
 */
export const Win32_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-notify`,
  "A binding to part of the Win32 library for file notification",
);

/**
 * Haskell bindings to a security-related functions of the Windows API
 */
export const Win32_security = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-security`,
  "Haskell bindings to a security-related functions of the Windows API",
);

/**
 * Windows service applications
 */
export const Win32_services = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-services`,
  "Windows service applications",
);

/**
 * Wrapper code for making a Win32 service
 */
export const Win32_services_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-services-wrapper`,
  "Wrapper code for making a Win32 service",
);

/**
 * Support for manipulating shortcuts (.lnk files) on Windows
 */
export const Win32_shortcut = mkPackage(
  nixRaw`pkgs.haskellPackages.Win32-shortcut`,
  "Support for manipulating shortcuts (.lnk files) on Windows",
);

/**
 * Wire-aware hardware description
 */
export const Wired = mkPackage(
  nixRaw`pkgs.haskellPackages.Wired`,
  "Wire-aware hardware description",
);

/**
 * Bigram word pair alignments
 */
export const WordAlignment = mkPackage(
  nixRaw`pkgs.haskellPackages.WordAlignment`,
  "Bigram word pair alignments",
);

/**
 * Generic (SYB3) construction of wxHaskell widgets
 */
export const WxGeneric = mkPackage(
  nixRaw`pkgs.haskellPackages.WxGeneric`,
  "Generic (SYB3) construction of wxHaskell widgets",
);

/**
 * A binding to the X11 graphics library
 */
export const X11 = mkPackage(
  nixRaw`pkgs.haskellPackages.X11`,
  "A binding to the X11 graphics library",
);

/**
 * Bindings to the Xft and some Xrender parts
 */
export const X11_xft = mkPackage(
  nixRaw`pkgs.haskellPackages.X11-xft`,
  "Bindings to the Xft and some Xrender parts",
);

/**
 * A binding to the Xshape X11 extension library
 */
export const X11_xshape = mkPackage(
  nixRaw`pkgs.haskellPackages.X11-xshape`,
  "A binding to the Xshape X11 extension library",
);

/**
 * Read, set, and list extended attributes
 */
export const XAttr = mkPackage(
  nixRaw`pkgs.haskellPackages.XAttr`,
  "Read, set, and list extended attributes",
);

/**
 * Bindings for the DirectX XInput library
 */
export const XInput = mkPackage(
  nixRaw`pkgs.haskellPackages.XInput`,
  "Bindings for the DirectX XInput library",
);

/**
 * Extensible Markup Language
 */
export const XML = mkPackage(
  nixRaw`pkgs.haskellPackages.XML`,
  "Extensible Markup Language",
);

/**
 * A library to parse xml
 */
export const XMLParser = mkPackage(
  nixRaw`pkgs.haskellPackages.XMLParser`,
  "A library to parse xml",
);

/**
 * XMPP library
 */
export const XMPP = mkPackage(
  nixRaw`pkgs.haskellPackages.XMPP`,
  "XMPP library",
);

/**
 * An implementation of a polynomial-time top-down parser suitable for NLP
 */
export const XSaiga = mkPackage(
  nixRaw`pkgs.haskellPackages.XSaiga`,
  "An implementation of a polynomial-time top-down parser suitable for NLP",
);

/**
 * A binding to the X11 authentication library
 */
export const Xauth = mkPackage(
  nixRaw`pkgs.haskellPackages.Xauth`,
  "A binding to the X11 authentication library",
);

/**
 * A simple blog engine powered by Yesod
 */
export const Yablog = mkPackage(
  nixRaw`pkgs.haskellPackages.Yablog`,
  "A simple blog engine powered by Yesod",
);

/**
 * Elegant Functional Reactive Programming Language for Hybrid Systems
 */
export const Yampa = mkPackage(
  nixRaw`pkgs.haskellPackages.Yampa`,
  "Elegant Functional Reactive Programming Language for Hybrid Systems",
);

/**
 * Library for programming hybrid systems
 */
export const Yampa_core = mkPackage(
  nixRaw`pkgs.haskellPackages.Yampa-core`,
  "Library for programming hybrid systems",
);

/**
 * A Minimal JSON Parser & Printer for Haskell
 */
export const Yocto = mkPackage(
  nixRaw`pkgs.haskellPackages.Yocto`,
  "A Minimal JSON Parser & Printer for Haskell",
);

/**
 * A functional MUD client
 */
export const Yogurt_Standalone = mkPackage(
  nixRaw`pkgs.haskellPackages.Yogurt-Standalone`,
  "A functional MUD client",
);

/**
 * Crypto for Haskell
 */
export const Z_Botan = mkPackage(
  nixRaw`pkgs.haskellPackages.Z-Botan`,
  "Crypto for Haskell",
);

/**
 * Simple and high performance IO toolkit for Haskell
 */
export const Z_IO = mkPackage(
  nixRaw`pkgs.haskellPackages.Z-IO`,
  "Simple and high performance IO toolkit for Haskell",
);

/**
 * MessagePack
 */
export const Z_MessagePack = mkPackage(
  nixRaw`pkgs.haskellPackages.Z-MessagePack`,
  "MessagePack",
);

/**
 * YAML tools
 */
export const Z_YAML = mkPackage(
  nixRaw`pkgs.haskellPackages.Z-YAML`,
  "YAML tools",
);

/**
 * Zipping folds
 */
export const ZipFold = mkPackage(
  nixRaw`pkgs.haskellPackages.ZipFold`,
  "Zipping folds",
);

/**
 * An implementationg of Attribute Grammars using Functional Zippers
 */
export const ZipperAG = mkPackage(
  nixRaw`pkgs.haskellPackages.ZipperAG`,
  "An implementationg of Attribute Grammars using Functional Zippers",
);

/**
 * Graphing library wrapper + assorted useful functions
 */
export const Zora = mkPackage(
  nixRaw`pkgs.haskellPackages.Zora`,
  "Graphing library wrapper + assorted useful functions",
);

/**
 * A tetris-like game (works with GHC 6.8.3 and Gtk2hs 0.9.13)
 */
export const _4Blocks = mkPackage(
  nixRaw`pkgs.haskellPackages.4Blocks`,
  "A tetris-like game (works with GHC 6.8.3 and Gtk2hs 0.9.13)",
);

/**
 * Compare genome assemblies
 */
export const a50 = mkPackage(
  nixRaw`pkgs.haskellPackages.a50`,
  "Compare genome assemblies",
);

/**
 * Bindings for ABC, A System for Sequential Synthesis and Verification
 */
export const abcBridge = mkPackage(
  nixRaw`pkgs.haskellPackages.abcBridge`,
  "Bindings for ABC, A System for Sequential Synthesis and Verification",
);

/**
 * Generate instances of the ABC Logic Puzzle
 */
export const abc_puzzle = mkPackage(
  nixRaw`pkgs.haskellPackages.abc-puzzle`,
  "Generate instances of the ABC Logic Puzzle",
);

/**
 * Abstract, parameterized interface to mutable Deques
 */
export const abstract_deque = mkPackage(
  nixRaw`pkgs.haskellPackages.abstract-deque`,
  "Abstract, parameterized interface to mutable Deques",
);

/**
 * A test-suite for any queue or double-ended queue satisfying an interface
 */
export const abstract_deque_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.abstract-deque-tests`,
  "A test-suite for any queue or double-ended queue satisfying an interface",
);

/**
 * Type classes generalizing the functionality of the 'monad-par' library
 */
export const abstract_par = mkPackage(
  nixRaw`pkgs.haskellPackages.abstract-par`,
  "Type classes generalizing the functionality of the 'monad-par' library",
);

/**
 * Provides the class ParAccelerate, nothing more
 */
export const abstract_par_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.abstract-par-accelerate`,
  "Provides the class ParAccelerate, nothing more",
);

/**
 * Drive Aho-Corasick machines in Conduit pipelines
 */
export const ac_machine_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.ac-machine-conduit`,
  "Drive Aho-Corasick machines in Conduit pipelines",
);

/**
 * Sequence optimized for monoidal construction and folding
 */
export const acc = mkPackage(
  nixRaw`pkgs.haskellPackages.acc`,
  "Sequence optimized for monoidal construction and folding",
);

/**
 * Linear algebra and interpolation using the Accelerate framework
 */
export const accelerate_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-arithmetic`,
  "Linear algebra and interpolation using the Accelerate framework",
);

/**
 * Fixed-length large integer arithmetic for Accelerate
 */
export const accelerate_bignum = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-bignum`,
  "Fixed-length large integer arithmetic for Accelerate",
);

/**
 * Numeric Linear Algebra in Accelerate
 */
export const accelerate_blas = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-blas`,
  "Numeric Linear Algebra in Accelerate",
);

/**
 * Basic Linear Algebra using native CUBLAS library
 */
export const accelerate_cublas = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-cublas`,
  "Basic Linear Algebra using native CUBLAS library",
);

/**
 * Accelerate backend for NVIDIA GPUs
 */
export const accelerate_cuda = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-cuda`,
  "Accelerate backend for NVIDIA GPUs",
);

/**
 * Accelerate frontend to the CUFFT library (Fourier transform)
 */
export const accelerate_cufft = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-cufft`,
  "Accelerate frontend to the CUFFT library (Fourier transform)",
);

/**
 * Examples using the Accelerate library
 */
export const accelerate_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-examples`,
  "Examples using the Accelerate library",
);

/**
 * FFT using the Accelerate library
 */
export const accelerate_fft = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-fft`,
  "FFT using the Accelerate library",
);

/**
 * Accelerate frontend to the FFTW library (Fourier transform)
 */
export const accelerate_fftw = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-fftw`,
  "Accelerate frontend to the FFTW library (Fourier transform)",
);

/**
 * Fast Fourier transform and convolution using the Accelerate framework
 */
export const accelerate_fourier = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-fourier`,
  "Fast Fourier transform and convolution using the Accelerate framework",
);

/**
 * Compare different implementations of the Fast Fourier Transform
 */
export const accelerate_fourier_benchmark = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-fourier-benchmark`,
  "Compare different implementations of the Fast Fourier Transform",
);

/**
 * Convert between Accelerate arrays and raw pointers
 */
export const accelerate_io = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io`,
  "Convert between Accelerate arrays and raw pointers",
);

/**
 * Convert between Accelerate arrays and JuicyPixels images
 */
export const accelerate_io_JuicyPixels = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-JuicyPixels`,
  "Convert between Accelerate arrays and JuicyPixels images",
);

/**
 * Convert between Accelerate and array
 */
export const accelerate_io_array = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-array`,
  "Convert between Accelerate and array",
);

/**
 * Convert between Accelerate arrays and BMP images
 */
export const accelerate_io_bmp = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-bmp`,
  "Convert between Accelerate arrays and BMP images",
);

/**
 * Convert between Accelerate and ByteString
 */
export const accelerate_io_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-bytestring`,
  "Convert between Accelerate and ByteString",
);

/**
 * Binary serialisation of Accelerate arrays using cereal
 */
export const accelerate_io_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-cereal`,
  "Binary serialisation of Accelerate arrays using cereal",
);

/**
 * Convert between Accelerate and Repa arrays
 */
export const accelerate_io_repa = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-repa`,
  "Convert between Accelerate and Repa arrays",
);

/**
 * Binary serialisation of Accelerate arrays using serialise
 */
export const accelerate_io_serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-serialise`,
  "Binary serialisation of Accelerate arrays using serialise",
);

/**
 * Convert between Accelerate and vector
 */
export const accelerate_io_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-io-vector`,
  "Convert between Accelerate and vector",
);

/**
 * Kullback-Liebler divergence
 */
export const accelerate_kullback_liebler = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-kullback-liebler`,
  "Kullback-Liebler divergence",
);

/**
 * Accelerate backend component generating LLVM IR
 */
export const accelerate_llvm = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-llvm`,
  "Accelerate backend component generating LLVM IR",
);

/**
 * Accelerate backend for multicore CPUs
 */
export const accelerate_llvm_native = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-llvm-native`,
  "Accelerate backend for multicore CPUs",
);

/**
 * Accelerate backend for NVIDIA GPUs
 */
export const accelerate_llvm_ptx = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-llvm-ptx`,
  "Accelerate backend for NVIDIA GPUs",
);

/**
 * Generate Accelerate arrays filled with high quality pseudorandom numbers
 */
export const accelerate_random = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-random`,
  "Generate Accelerate arrays filled with high quality pseudorandom numbers",
);

/**
 * a typesafe way encode accelerate matrices and vectors
 */
export const accelerate_typelits = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-typelits`,
  "a typesafe way encode accelerate matrices and vectors",
);

/**
 * Utility functions for the Accelerate framework
 */
export const accelerate_utility = mkPackage(
  nixRaw`pkgs.haskellPackages.accelerate-utility`,
  "Utility functions for the Accelerate framework",
);

/**
 * Provides Access Token for Services
 */
export const access_token_provider = mkPackage(
  nixRaw`pkgs.haskellPackages.access-token-provider`,
  "Provides Access Token for Services",
);

/**
 * Add ACID guarantees to any serializable Haskell data structure
 */
export const acid_state = mkPackage(
  nixRaw`pkgs.haskellPackages.acid-state`,
  "Add ACID guarantees to any serializable Haskell data structure",
);

/**
 * Writing and calling ACL2 from Haskell
 */
export const acl2 = mkPackage(
  nixRaw`pkgs.haskellPackages.acl2`,
  "Writing and calling ACL2 from Haskell",
);

/**
 * A full featured empty project
 */
export const acme_box = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-box`,
  "A full featured empty project",
);

/**
 * car, cdr and more
 */
export const acme_cadre = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-cadre`,
  "car, cdr and more",
);

/**
 * Spineless containers which are fast to read but inefficient to update
 */
export const acme_circular_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-circular-containers`,
  "Spineless containers which are fast to read but inefficient to update",
);

/**
 * A Cofunctor is a structure from category theory dual to Functor
 */
export const acme_cofunctor = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-cofunctor`,
  "A Cofunctor is a structure from category theory dual to Functor",
);

/**
 * Determines whether it is numberwang
 */
export const acme_colosson = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-colosson`,
  "Determines whether it is numberwang",
);

/**
 * Maybe gives you a cute boy
 */
export const acme_cuteboy = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-cuteboy`,
  "Maybe gives you a cute boy",
);

/**
 * Maybe gives you a cute girl
 */
export const acme_cutegirl = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-cutegirl`,
  "Maybe gives you a cute girl",
);

/**
 * A class for types with a distinguished aesthetically pleasing value
 */
export const acme_default = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-default`,
  "A class for types with a distinguished aesthetically pleasing value",
);

/**
 * The best applicative functors
 */
export const acme_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-functors`,
  "The best applicative functors",
);

/**
 * More readable names for commonly used symbols
 */
export const acme_grawlix = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-grawlix`,
  "More readable names for commonly used symbols",
);

/**
 * IO monad transformer
 */
export const acme_iot = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-iot`,
  "IO monad transformer",
);

/**
 * LOLSPEAK translator
 */
export const acme_lolcat = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-lolcat`,
  "LOLSPEAK translator",
);

/**
 * Express your disapproval
 */
export const acme_lookofdisapproval = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-lookofdisapproval`,
  "Express your disapproval",
);

/**
 * The eighth wonder of the world, kitchen math!
 */
export const acme_microwave = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-microwave`,
  "The eighth wonder of the world, kitchen math!",
);

/**
 * Cause serious international side effects
 */
export const acme_missiles = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-missiles`,
  "Cause serious international side effects",
);

/**
 * A name for omitted definitions
 */
export const acme_omitted = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-omitted`,
  "A name for omitted definitions",
);

/**
 * The identity element of package dependencies
 */
export const acme_one = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-one`,
  "The identity element of package dependencies",
);

/**
 * The flexibility of Haskell and the safety of PHP
 */
export const acme_php = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-php`,
  "The flexibility of Haskell and the safety of PHP",
);

/**
 * Make more than one point in numeric literals
 */
export const acme_pointful_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-pointful-numbers`,
  "Make more than one point in numeric literals",
);

/**
 * Primitives for manipulating the state of the universe
 */
export const acme_realworld = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-realworld`,
  "Primitives for manipulating the state of the universe",
);

/**
 * Safe versions of some infamous haskell functions such as fromJust
 */
export const acme_safe = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-safe`,
  "Safe versions of some infamous haskell functions such as fromJust",
);

/**
 * Smuggle arbitrary values in arbitrary types
 */
export const acme_smuggler = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-smuggler`,
  "Smuggle arbitrary values in arbitrary types",
);

/**
 * A Haskell port of the C/PHP strtok function
 */
export const acme_strtok = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-strtok`,
  "A Haskell port of the C/PHP strtok function",
);

/**
 * An easy way to perform and unperform IO and other stateful actions
 */
export const acme_timemachine = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-timemachine`,
  "An easy way to perform and unperform IO and other stateful actions",
);

/**
 * Get the current year
 */
export const acme_year = mkPackage(
  nixRaw`pkgs.haskellPackages.acme-year`,
  "Get the current year",
);

/**
 * Abstraction over management of resources
 */
export const acquire = mkPackage(
  nixRaw`pkgs.haskellPackages.acquire`,
  "Abstraction over management of resources",
);

/**
 * Execute a set of actions (e.g. parsers) in each possible order
 */
export const action_permutations = mkPackage(
  nixRaw`pkgs.haskellPackages.action-permutations`,
  "Execute a set of actions (e.g. parsers) in each possible order",
);

/**
 * Abstractions for animation
 */
export const active = mkPackage(
  nixRaw`pkgs.haskellPackages.active`,
  "Abstractions for animation",
);

/**
 * Haskell code presentation tool
 */
export const activehs = mkPackage(
  nixRaw`pkgs.haskellPackages.activehs`,
  "Haskell code presentation tool",
);

/**
 * Actors with multi-headed receive clauses
 */
export const actor = mkPackage(
  nixRaw`pkgs.haskellPackages.actor`,
  "Actors with multi-headed receive clauses",
);

/**
 * Semigroup actions and torsors
 */
export const acts = mkPackage(
  nixRaw`pkgs.haskellPackages.acts`,
  "Semigroup actions and torsors",
);

/**
 * Automatic Differentiation
 */
export const ad = mkPackage(
  nixRaw`pkgs.haskellPackages.ad`,
  "Automatic Differentiation",
);

/**
 * Reverse-mode automatic differentiation with delimited continuations
 */
export const ad_delcont = mkPackage(
  nixRaw`pkgs.haskellPackages.ad-delcont`,
  "Reverse-mode automatic differentiation with delimited continuations",
);

/**
 * Reverse-mode automatic differentiation with delimited continuations
 */
export const ad_delcont_0_5_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ad-delcont_0_5_0_0`,
  "Reverse-mode automatic differentiation with delimited continuations",
);

/**
 * Multidimensional integration
 */
export const adaptive_cubature = mkPackage(
  nixRaw`pkgs.haskellPackages.adaptive-cubature`,
  "Multidimensional integration",
);

/**
 * Convert adblock config files to privoxy format
 */
export const adblock2privoxy = mkPackage(
  nixRaw`pkgs.haskellPackages.adblock2privoxy`,
  "Convert adblock config files to privoxy format",
);

/**
 * Adds license info to the top of a file
 */
export const addLicenseInfo = mkPackage(
  nixRaw`pkgs.haskellPackages.addLicenseInfo`,
  "Adds license info to the top of a file",
);

/**
 * Manage fine grained fixtures
 */
export const adhoc_fixtures = mkPackage(
  nixRaw`pkgs.haskellPackages.adhoc-fixtures`,
  "Manage fine grained fixtures",
);

/**
 * Manage fine grained fixtures
 */
export const adhoc_fixtures_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.adhoc-fixtures-hspec`,
  "Manage fine grained fixtures",
);

/**
 * Ad-hoc P2P network protocol
 */
export const adhoc_network = mkPackage(
  nixRaw`pkgs.haskellPackages.adhoc-network`,
  "Ad-hoc P2P network protocol",
);

/**
 * Approximate dictionary searching
 */
export const adict = mkPackage(
  nixRaw`pkgs.haskellPackages.adict`,
  "Approximate dictionary searching",
);

/**
 * Adjunctions and representable functors
 */
export const adjunctions = mkPackage(
  nixRaw`pkgs.haskellPackages.adjunctions`,
  "Adjunctions and representable functors",
);

/**
 * An implementation of Adler-32, supporting rolling checksum operation
 */
export const adler32 = mkPackage(
  nixRaw`pkgs.haskellPackages.adler32`,
  "An implementation of Adler-32, supporting rolling checksum operation",
);

/**
 * Subword construction in adp-multi using monadiccp
 */
export const adp_multi_monadiccp = mkPackage(
  nixRaw`pkgs.haskellPackages.adp-multi-monadiccp`,
  "Subword construction in adp-multi using monadiccp",
);

/**
 * Advent of Code REST API bindings and servant API
 */
export const advent_of_code_api = mkPackage(
  nixRaw`pkgs.haskellPackages.advent-of-code-api`,
  "Advent of Code REST API bindings and servant API",
);

/**
 * Parse Advent of Code ASCII art letters
 */
export const advent_of_code_ocr = mkPackage(
  nixRaw`pkgs.haskellPackages.advent-of-code-ocr`,
  "Parse Advent of Code ASCII art letters",
);

/**
 * Generic operations for real functions
 */
export const aern2_fun = mkPackage(
  nixRaw`pkgs.haskellPackages.aern2-fun`,
  "Generic operations for real functions",
);

/**
 * Multi-variate real function optimisation and proving
 */
export const aern2_mfun = mkPackage(
  nixRaw`pkgs.haskellPackages.aern2-mfun`,
  "Multi-variate real function optimisation and proving",
);

/**
 * Multi-precision ball (interval) arithmetic
 */
export const aern2_mp = mkPackage(
  nixRaw`pkgs.haskellPackages.aern2-mp`,
  "Multi-precision ball (interval) arithmetic",
);

/**
 * Real numbers as convergent sequences of intervals
 */
export const aern2_real = mkPackage(
  nixRaw`pkgs.haskellPackages.aern2-real`,
  "Real numbers as convergent sequences of intervals",
);

/**
 * Fast JSON parsing and encoding
 */
export const aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson`,
  "Fast JSON parsing and encoding",
);

/**
 * Fast JSON parsing and encoding
 */
export const aeson_1_5_6_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson_1_5_6_0`,
  "Fast JSON parsing and encoding",
);

/**
 * Fast JSON parsing and encoding
 */
export const aeson_2_2_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson_2_2_0_0`,
  "Fast JSON parsing and encoding",
);

/**
 * Embed an Attoparsec text parser into an Aeson parser
 */
export const aeson_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-attoparsec`,
  "Embed an Attoparsec text parser into an Aeson parser",
);

/**
 * Better error messages when decoding JSON values
 */
export const aeson_better_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-better-errors`,
  "Better error messages when decoding JSON values",
);

/**
 * Tools to change the formatting of field names in Aeson instances
 */
export const aeson_casing = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-casing`,
  "Tools to change the formatting of field names in Aeson instances",
);

/**
 * Initial project template from stack
 */
export const aeson_coerce = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-coerce`,
  "Initial project template from stack",
);

/**
 * Aeson combinators for dead simple JSON decoding
 */
export const aeson_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-combinators`,
  "Aeson combinators for dead simple JSON decoding",
);

/**
 * Extract and apply patches to JSON documents
 */
export const aeson_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-diff`,
  "Extract and apply patches to JSON documents",
);

/**
 * Extra goodies for aeson
 */
export const aeson_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-extra`,
  "Extra goodies for aeson",
);

/**
 * Extra goodies for aeson
 */
export const aeson_extra_0_5_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-extra_0_5_1_3`,
  "Extra goodies for aeson",
);

/**
 * Compatible generic class names of Aeson
 */
export const aeson_generic_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-generic-compat`,
  "Compatible generic class names of Aeson",
);

/**
 * Aeson helper func
 */
export const aeson_helper = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-helper`,
  "Aeson helper func",
);

/**
 * Aeson instances for iproute types
 */
export const aeson_iproute = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-iproute`,
  "Aeson instances for iproute types",
);

/**
 * Declarative JSON matchers
 */
export const aeson_match_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-match-qq`,
  "Declarative JSON matchers",
);

/**
 * Fast JSON parsing and encoding (deprecated)
 */
export const aeson_native = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-native`,
  "Fast JSON parsing and encoding (deprecated)",
);

/**
 * Law-abiding optics for aeson
 */
export const aeson_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-optics`,
  "Law-abiding optics for aeson",
);

/**
 * Tiny library to get fields from JSON format
 */
export const aeson_picker = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-picker`,
  "Tiny library to get fields from JSON format",
);

/**
 * JSON pretty-printing library and command-line tool
 */
export const aeson_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-pretty`,
  "JSON pretty-printing library and command-line tool",
);

/**
 * JSON pretty-printing library and command-line tool
 */
export const aeson_pretty_0_8_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-pretty_0_8_10`,
  "JSON pretty-printing library and command-line tool",
);

/**
 * JSON quasiquoter for Haskell
 */
export const aeson_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-qq`,
  "JSON quasiquoter for Haskell",
);

/**
 * Quick JSON extractions with Aeson
 */
export const aeson_quick = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-quick`,
  "Quick JSON extractions with Aeson",
);

/**
 * API Result for aeson
 */
export const aeson_result = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-result`,
  "API Result for aeson",
);

/**
 * Easily consume JSON data on-demand with type-safety
 */
export const aeson_schemas = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-schemas`,
  "Easily consume JSON data on-demand with type-safety",
);

/**
 * Simple serialization functions for aeson types
 */
export const aeson_serialize = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-serialize`,
  "Simple serialization functions for aeson types",
);

/**
 * Aeson instances for the Tiled map editor
 */
export const aeson_tiled = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-tiled`,
  "Aeson instances for the Tiled map editor",
);

/**
 * Generate TypeScript definition files from your ADTs
 */
export const aeson_typescript = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-typescript`,
  "Generate TypeScript definition files from your ADTs",
);

/**
 * API for parsing "aeson" JSON tree into Haskell types
 */
export const aeson_value_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-value-parser`,
  "API for parsing \"aeson\" JSON tree into Haskell types",
);

/**
 * Wrappers to derive-via Aeson ToJSON/FromJSON typeclasses
 */
export const aeson_via = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-via`,
  "Wrappers to derive-via Aeson ToJSON/FromJSON typeclasses",
);

/**
 * Library providing JSON parser that warns about unexpected fields in objects
 */
export const aeson_warning_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-warning-parser`,
  "Library providing JSON parser that warns about unexpected fields in objects",
);

/**
 * Handle JSON that may or may not be a list, or exist
 */
export const aeson_yak = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-yak`,
  "Handle JSON that may or may not be a list, or exist",
);

/**
 * Output any Aeson value as YAML (pure Haskell library)
 */
export const aeson_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.aeson-yaml`,
  "Output any Aeson value as YAML (pure Haskell library)",
);

/**
 * Affine spaces (generalized)
 */
export const affine = mkPackage(
  nixRaw`pkgs.haskellPackages.affine`,
  "Affine spaces (generalized)",
);

export const affinely_extended = mkPackage(
  nixRaw`pkgs.haskellPackages.affinely-extended`,
  "",
);

/**
 * Anti-forensic Information Splitter
 */
export const afis = mkPackage(
  nixRaw`pkgs.haskellPackages.afis`,
  "Anti-forensic Information Splitter",
);

/**
 * Infinite state model checking of iterative C programs
 */
export const afv = mkPackage(
  nixRaw`pkgs.haskellPackages.afv`,
  "Infinite state model checking of iterative C programs",
);

/**
 * Compiling Agda code to readable Haskell
 */
export const agda2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.agda2hs`,
  "Compiling Agda code to readable Haskell",
);

/**
 * Translate .agda files into .lagda.tex files.
 */
export const agda2lagda = mkPackage(
  nixRaw`pkgs.haskellPackages.agda2lagda`,
  "Translate .agda files into .lagda.tex files.",
);

/**
 * Http server for Agda (prototype)
 */
export const agda_server = mkPackage(
  nixRaw`pkgs.haskellPackages.agda-server`,
  "Http server for Agda (prototype)",
);

/**
 * Literate Agda support using agda-snippets, for Hakyll pages
 */
export const agda_snippets_hakyll = mkPackage(
  nixRaw`pkgs.haskellPackages.agda-snippets-hakyll`,
  "Literate Agda support using agda-snippets, for Hakyll pages",
);

/**
 * AgentX protocol for write SNMP subagents
 */
export const agentx = mkPackage(
  nixRaw`pkgs.haskellPackages.agentx`,
  "AgentX protocol for write SNMP subagents",
);

/**
 * Idiomatic data structure for agreement
 */
export const agreeing = mkPackage(
  nixRaw`pkgs.haskellPackages.agreeing`,
  "Idiomatic data structure for agreement",
);

/**
 * Unification and Matching in an Abelian Group
 */
export const agum = mkPackage(
  nixRaw`pkgs.haskellPackages.agum`,
  "Unification and Matching in an Abelian Group",
);

/**
 * Aeronautical Information Package (AIP)
 */
export const aip = mkPackage(
  nixRaw`pkgs.haskellPackages.aip`,
  "Aeronautical Information Package (AIP)",
);

/**
 * air
 */
export const air = mkPackage(
  nixRaw`pkgs.haskellPackages.air`,
  "air",
);

/**
 * air spec helper
 */
export const air_spec = mkPackage(
  nixRaw`pkgs.haskellPackages.air-spec`,
  "air spec helper",
);

/**
 * A multi-method simulation library
 */
export const aivika = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika`,
  "A multi-method simulation library",
);

/**
 * Nested discrete event simulation module for the Aivika library
 */
export const aivika_branches = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-branches`,
  "Nested discrete event simulation module for the Aivika library",
);

/**
 * Parallel distributed discrete event simulation module for the Aivika library
 */
export const aivika_distributed = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-distributed`,
  "Parallel distributed discrete event simulation module for the Aivika library",
);

/**
 * Simulation experiments for the Aivika library
 */
export const aivika_experiment = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-experiment`,
  "Simulation experiments for the Aivika library",
);

/**
 * Cairo-based charting backend for the Aivika simulation library
 */
export const aivika_experiment_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-experiment-cairo`,
  "Cairo-based charting backend for the Aivika simulation library",
);

/**
 * Simulation experiments with charting for the Aivika library
 */
export const aivika_experiment_chart = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-experiment-chart`,
  "Simulation experiments with charting for the Aivika library",
);

/**
 * Diagrams-based charting backend for the Aivika simulation library
 */
export const aivika_experiment_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-experiment-diagrams`,
  "Diagrams-based charting backend for the Aivika simulation library",
);

/**
 * Nested discrete event simulation module for the Aivika library using lattice
 */
export const aivika_lattice = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-lattice`,
  "Nested discrete event simulation module for the Aivika library using lattice",
);

/**
 * Soft real-time simulation module for the Aivika library
 */
export const aivika_realtime = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-realtime`,
  "Soft real-time simulation module for the Aivika library",
);

/**
 * Transformers for the Aivika simulation library
 */
export const aivika_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.aivika-transformers`,
  "Transformers for the Aivika simulation library",
);

/**
 * OpenAL 1.1 raw API.
 */
export const al = mkPackage(
  nixRaw`pkgs.haskellPackages.al`,
  "OpenAL 1.1 raw API.",
);

/**
 * Wake up and perform an action at a certain time
 */
export const alarmclock = mkPackage(
  nixRaw`pkgs.haskellPackages.alarmclock`,
  "Wake up and perform an action at a certain time",
);

/**
 * a diceware passphrase generator
 */
export const alea = mkPackage(
  nixRaw`pkgs.haskellPackages.alea`,
  "a diceware passphrase generator",
);

/**
 * Alex is a tool for generating lexical analysers in Haskell
 */
export const alex = mkPackage(
  nixRaw`pkgs.haskellPackages.alex`,
  "Alex is a tool for generating lexical analysers in Haskell",
);

/**
 * Alex is a tool for generating lexical analysers in Haskell
 */
export const alex_3_4_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.alex_3_4_0_0`,
  "Alex is a tool for generating lexical analysers in Haskell",
);

/**
 * Quasi-quoter for Alex lexers
 */
export const alex_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.alex-meta`,
  "Quasi-quoter for Alex lexers",
);

/**
 * A set of functions for a common use case of Alex
 */
export const alex_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.alex-tools`,
  "A set of functions for a common use case of Alex",
);

/**
 * Algebraic structures
 */
export const alg = mkPackage(
  nixRaw`pkgs.haskellPackages.alg`,
  "Algebraic structures",
);

/**
 * Constructive abstract algebra
 */
export const algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.algebra`,
  "Constructive abstract algebra",
);

/**
 * Model and test API surfaces algebraically
 */
export const algebra_checkers = mkPackage(
  nixRaw`pkgs.haskellPackages.algebra-checkers`,
  "Model and test API surfaces algebraically",
);

/**
 * Companion library for the book Algebra-Driven Design by Sandy Maguire
 */
export const algebra_driven_design = mkPackage(
  nixRaw`pkgs.haskellPackages.algebra-driven-design`,
  "Companion library for the book Algebra-Driven Design by Sandy Maguire",
);

/**
 * Relational Algebra and SQL Code Generation
 */
export const algebra_sql = mkPackage(
  nixRaw`pkgs.haskellPackages.algebra-sql`,
  "Relational Algebra and SQL Code Generation",
);

/**
 * General linear algebra structures
 */
export const algebraic = mkPackage(
  nixRaw`pkgs.haskellPackages.algebraic`,
  "General linear algebra structures",
);

/**
 * A library for algebraic graph construction and transformation
 */
export const algebraic_graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.algebraic-graphs`,
  "A library for algebraic graph construction and transformation",
);

/**
 * A library for algebraic graph construction and transformation
 */
export const algebraic_graphs_0_6_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.algebraic-graphs_0_6_1`,
  "A library for algebraic graph construction and transformation",
);

/**
 * I/O utilities and datasets for algebraic-graphs
 */
export const algebraic_graphs_io = mkPackage(
  nixRaw`pkgs.haskellPackages.algebraic-graphs-io`,
  "I/O utilities and datasets for algebraic-graphs",
);

/**
 * A client implementing the Algolia search API
 */
export const algolia = mkPackage(
  nixRaw`pkgs.haskellPackages.algolia`,
  "A client implementing the Algolia search API",
);

/**
 * Helps to create experimental music from a file (or its part) and a Ukrainian text
 */
export const algorithmic_composition_additional = mkPackage(
  nixRaw`pkgs.haskellPackages.algorithmic-composition-additional`,
  "Helps to create experimental music from a file (or its part) and a Ukrainian text",
);

/**
 * Helps to create experimental music from a file (or its part) and a Ukrainian text
 */
export const algorithmic_composition_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.algorithmic-composition-basic`,
  "Helps to create experimental music from a file (or its part) and a Ukrainian text",
);

/**
 * Helps to create more complex experimental music from a file (especially timbre)
 */
export const algorithmic_composition_complex = mkPackage(
  nixRaw`pkgs.haskellPackages.algorithmic-composition-complex`,
  "Helps to create more complex experimental music from a file (especially timbre)",
);

/**
 * Helps to create experimental music. Uses SoX inside.
 */
export const algorithmic_composition_frequency_shift = mkPackage(
  nixRaw`pkgs.haskellPackages.algorithmic-composition-frequency-shift`,
  "Helps to create experimental music. Uses SoX inside.",
);

/**
 * Some variants of the overtones functions to generate a timbre
 */
export const algorithmic_composition_overtones = mkPackage(
  nixRaw`pkgs.haskellPackages.algorithmic-composition-overtones`,
  "Some variants of the overtones functions to generate a timbre",
);

/**
 * Sequence alignment algorithms
 */
export const align = mkPackage(
  nixRaw`pkgs.haskellPackages.align`,
  "Sequence alignment algorithms",
);

/**
 * Find relative time displacement of two recordings of the same music
 */
export const align_audio = mkPackage(
  nixRaw`pkgs.haskellPackages.align-audio`,
  "Find relative time displacement of two recordings of the same music",
);

/**
 * An aligned ForeignPtr type
 */
export const aligned_foreignptr = mkPackage(
  nixRaw`pkgs.haskellPackages.aligned-foreignptr`,
  "An aligned ForeignPtr type",
);

/**
 * Zip-alignment
 */
export const alignment = mkPackage(
  nixRaw`pkgs.haskellPackages.alignment`,
  "Zip-alignment",
);

/**
 * lists with O(1) append
 */
export const alist = mkPackage(
  nixRaw`pkgs.haskellPackages.alist`,
  "lists with O(1) append",
);

/**
 * A monadic way of calculating relations between intervals of time
 */
export const allen = mkPackage(
  nixRaw`pkgs.haskellPackages.allen`,
  "A monadic way of calculating relations between intervals of time",
);

/**
 * Functional combinators for monadic actions that require allocation and de-allocation
 */
export const allocated_processor = mkPackage(
  nixRaw`pkgs.haskellPackages.allocated-processor`,
  "Functional combinators for monadic actions that require allocation and de-allocation",
);

/**
 * Generic programming library
 */
export const alloy = mkPackage(
  nixRaw`pkgs.haskellPackages.alloy`,
  "Generic programming library",
);

/**
 * Some add-on instances for the Alloy library
 */
export const alloy_proxy_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.alloy-proxy-fd`,
  "Some add-on instances for the Alloy library",
);

/**
 * Recurse while a predicate is satisfied
 */
export const almost_fix = mkPackage(
  nixRaw`pkgs.haskellPackages.almost-fix`,
  "Recurse while a predicate is satisfied",
);

/**
 * a practical affine language
 */
export const alms = mkPackage(
  nixRaw`pkgs.haskellPackages.alms`,
  "a practical affine language",
);

/**
 * A compiler for the Alpha language
 */
export const alpha = mkPackage(
  nixRaw`pkgs.haskellPackages.alpha`,
  "A compiler for the Alpha language",
);

/**
 * A character between a-z
 */
export const alphachar = mkPackage(
  nixRaw`pkgs.haskellPackages.alphachar`,
  "A character between a-z",
);

/**
 * Binding to the ALSA Library API (Exceptions)
 */
export const alsa_core = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-core`,
  "Binding to the ALSA Library API (Exceptions)",
);

/**
 * Some simple interactive programs for sending MIDI control messages via ALSA
 */
export const alsa_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-gui`,
  "Some simple interactive programs for sending MIDI control messages via ALSA",
);

/**
 * Bindings to the ALSA simple mixer API
 */
export const alsa_mixer = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-mixer`,
  "Bindings to the ALSA simple mixer API",
);

/**
 * Binding to the ALSA Library API (PCM audio)
 */
export const alsa_pcm = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-pcm`,
  "Binding to the ALSA Library API (PCM audio)",
);

/**
 * Tests for the ALSA audio signal library
 */
export const alsa_pcm_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-pcm-tests`,
  "Tests for the ALSA audio signal library",
);

/**
 * Binding to the ALSA Library API (MIDI sequencer)
 */
export const alsa_seq = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-seq`,
  "Binding to the ALSA Library API (MIDI sequencer)",
);

/**
 * Tests for the ALSA sequencer library
 */
export const alsa_seq_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.alsa-seq-tests`,
  "Tests for the ALSA sequencer library",
);

/**
 * Use vectors instead of lists for many and some
 */
export const alternative_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.alternative-vector`,
  "Use vectors instead of lists for many and some",
);

/**
 * Handy functions when using transformers
 */
export const alternators = mkPackage(
  nixRaw`pkgs.haskellPackages.alternators`,
  "Handy functions when using transformers",
);

/**
 * Implement a menu experience fit for web users
 */
export const alto = mkPackage(
  nixRaw`pkgs.haskellPackages.alto`,
  "Implement a menu experience fit for web users",
);

/**
 * HTTP Alternative Services
 */
export const altsvc = mkPackage(
  nixRaw`pkgs.haskellPackages.altsvc`,
  "HTTP Alternative Services",
);

/**
 * provides a typeclass that is always satisfied
 */
export const always = mkPackage(
  nixRaw`pkgs.haskellPackages.always`,
  "provides a typeclass that is always satisfied",
);

/**
 * Client library for amazon-emailer daemon
 */
export const amazon_emailer_client_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.amazon-emailer-client-snap`,
  "Client library for amazon-emailer daemon",
);

/**
 * Comprehensive Amazon Web Services SDK
 */
export const amazonka = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka`,
  "Comprehensive Amazon Web Services SDK",
);

/**
 * Amazon Access Analyzer SDK
 */
export const amazonka_accessanalyzer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-accessanalyzer`,
  "Amazon Access Analyzer SDK",
);

/**
 * Amazon Account SDK
 */
export const amazonka_account = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-account`,
  "Amazon Account SDK",
);

/**
 * Amazon Alexa For Business SDK
 */
export const amazonka_alexa_business = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-alexa-business`,
  "Amazon Alexa For Business SDK",
);

/**
 * Amazon Prometheus Service SDK
 */
export const amazonka_amp = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-amp`,
  "Amazon Prometheus Service SDK",
);

/**
 * Amazon Amplify SDK
 */
export const amazonka_amplify = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-amplify`,
  "Amazon Amplify SDK",
);

/**
 * Amazon AmplifyBackend SDK
 */
export const amazonka_amplifybackend = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-amplifybackend`,
  "Amazon AmplifyBackend SDK",
);

/**
 * Amazon Amplify UI Builder SDK
 */
export const amazonka_amplifyuibuilder = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-amplifyuibuilder`,
  "Amazon Amplify UI Builder SDK",
);

/**
 * Amazon API Gateway SDK
 */
export const amazonka_apigateway = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-apigateway`,
  "Amazon API Gateway SDK",
);

/**
 * Amazon ApiGatewayManagementApi SDK
 */
export const amazonka_apigatewaymanagementapi = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-apigatewaymanagementapi`,
  "Amazon ApiGatewayManagementApi SDK",
);

/**
 * Amazon ApiGatewayV2 SDK
 */
export const amazonka_apigatewayv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-apigatewayv2`,
  "Amazon ApiGatewayV2 SDK",
);

/**
 * Amazon AppConfig SDK
 */
export const amazonka_appconfig = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appconfig`,
  "Amazon AppConfig SDK",
);

/**
 * Amazon AppConfig Data SDK
 */
export const amazonka_appconfigdata = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appconfigdata`,
  "Amazon AppConfig Data SDK",
);

/**
 * Amazon Appflow SDK
 */
export const amazonka_appflow = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appflow`,
  "Amazon Appflow SDK",
);

/**
 * Amazon AppIntegrations Service SDK
 */
export const amazonka_appintegrations = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appintegrations`,
  "Amazon AppIntegrations Service SDK",
);

/**
 * Amazon Application Auto Scaling SDK
 */
export const amazonka_application_autoscaling = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-application-autoscaling`,
  "Amazon Application Auto Scaling SDK",
);

/**
 * Amazon CloudWatch Application Insights SDK
 */
export const amazonka_application_insights = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-application-insights`,
  "Amazon CloudWatch Application Insights SDK",
);

/**
 * Amazon Application Cost Profiler SDK
 */
export const amazonka_applicationcostprofiler = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-applicationcostprofiler`,
  "Amazon Application Cost Profiler SDK",
);

/**
 * Amazon App Mesh SDK
 */
export const amazonka_appmesh = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appmesh`,
  "Amazon App Mesh SDK",
);

/**
 * Amazon App Runner SDK
 */
export const amazonka_apprunner = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-apprunner`,
  "Amazon App Runner SDK",
);

/**
 * Amazon AppStream SDK
 */
export const amazonka_appstream = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appstream`,
  "Amazon AppStream SDK",
);

/**
 * Amazon AppSync SDK
 */
export const amazonka_appsync = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-appsync`,
  "Amazon AppSync SDK",
);

/**
 * Amazon ARC - Zonal Shift SDK
 */
export const amazonka_arc_zonal_shift = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-arc-zonal-shift`,
  "Amazon ARC - Zonal Shift SDK",
);

/**
 * Amazon Athena SDK
 */
export const amazonka_athena = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-athena`,
  "Amazon Athena SDK",
);

/**
 * Amazon Audit Manager SDK
 */
export const amazonka_auditmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-auditmanager`,
  "Amazon Audit Manager SDK",
);

/**
 * Amazon Auto Scaling SDK
 */
export const amazonka_autoscaling = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-autoscaling`,
  "Amazon Auto Scaling SDK",
);

/**
 * Amazon Auto Scaling Plans SDK
 */
export const amazonka_autoscaling_plans = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-autoscaling-plans`,
  "Amazon Auto Scaling Plans SDK",
);

/**
 * Amazon Backup SDK
 */
export const amazonka_backup = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-backup`,
  "Amazon Backup SDK",
);

/**
 * Amazon Backup Gateway SDK
 */
export const amazonka_backup_gateway = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-backup-gateway`,
  "Amazon Backup Gateway SDK",
);

/**
 * Amazon Backup Storage SDK
 */
export const amazonka_backupstorage = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-backupstorage`,
  "Amazon Backup Storage SDK",
);

/**
 * Amazon Batch SDK
 */
export const amazonka_batch = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-batch`,
  "Amazon Batch SDK",
);

/**
 * Amazon BillingConductor SDK
 */
export const amazonka_billingconductor = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-billingconductor`,
  "Amazon BillingConductor SDK",
);

/**
 * Amazon Braket SDK
 */
export const amazonka_braket = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-braket`,
  "Amazon Braket SDK",
);

/**
 * Amazon Budgets SDK
 */
export const amazonka_budgets = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-budgets`,
  "Amazon Budgets SDK",
);

/**
 * Amazon Certificate Manager SDK
 */
export const amazonka_certificatemanager = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-certificatemanager`,
  "Amazon Certificate Manager SDK",
);

/**
 * Amazon Certificate Manager Private Certificate Authority SDK
 */
export const amazonka_certificatemanager_pca = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-certificatemanager-pca`,
  "Amazon Certificate Manager Private Certificate Authority SDK",
);

/**
 * Amazon Chime SDK
 */
export const amazonka_chime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime`,
  "Amazon Chime SDK",
);

/**
 * Amazon Chime SDK Identity SDK
 */
export const amazonka_chime_sdk_identity = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime-sdk-identity`,
  "Amazon Chime SDK Identity SDK",
);

/**
 * Amazon Chime SDK Media Pipelines SDK
 */
export const amazonka_chime_sdk_media_pipelines = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime-sdk-media-pipelines`,
  "Amazon Chime SDK Media Pipelines SDK",
);

/**
 * Amazon Chime SDK Meetings SDK
 */
export const amazonka_chime_sdk_meetings = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime-sdk-meetings`,
  "Amazon Chime SDK Meetings SDK",
);

/**
 * Amazon Chime SDK Messaging SDK
 */
export const amazonka_chime_sdk_messaging = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime-sdk-messaging`,
  "Amazon Chime SDK Messaging SDK",
);

/**
 * Amazon Chime SDK Voice SDK
 */
export const amazonka_chime_sdk_voice = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-chime-sdk-voice`,
  "Amazon Chime SDK Voice SDK",
);

/**
 * Amazon Cloud9 SDK
 */
export const amazonka_cloud9 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloud9`,
  "Amazon Cloud9 SDK",
);

/**
 * Amazon Cloud Control API SDK
 */
export const amazonka_cloudcontrol = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudcontrol`,
  "Amazon Cloud Control API SDK",
);

/**
 * Amazon CloudDirectory SDK
 */
export const amazonka_clouddirectory = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-clouddirectory`,
  "Amazon CloudDirectory SDK",
);

/**
 * Amazon CloudFormation SDK
 */
export const amazonka_cloudformation = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudformation`,
  "Amazon CloudFormation SDK",
);

/**
 * Amazon CloudFront SDK
 */
export const amazonka_cloudfront = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudfront`,
  "Amazon CloudFront SDK",
);

/**
 * Amazon CloudHSM SDK
 */
export const amazonka_cloudhsm = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudhsm`,
  "Amazon CloudHSM SDK",
);

/**
 * Amazon CloudHSM V2 SDK
 */
export const amazonka_cloudhsmv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudhsmv2`,
  "Amazon CloudHSM V2 SDK",
);

/**
 * Amazon CloudSearch SDK
 */
export const amazonka_cloudsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudsearch`,
  "Amazon CloudSearch SDK",
);

/**
 * Amazon CloudSearch Domain SDK
 */
export const amazonka_cloudsearch_domains = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudsearch-domains`,
  "Amazon CloudSearch Domain SDK",
);

/**
 * Amazon CloudTrail SDK
 */
export const amazonka_cloudtrail = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudtrail`,
  "Amazon CloudTrail SDK",
);

/**
 * Amazon CloudWatch SDK
 */
export const amazonka_cloudwatch = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudwatch`,
  "Amazon CloudWatch SDK",
);

/**
 * Amazon EventBridge SDK
 */
export const amazonka_cloudwatch_events = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudwatch-events`,
  "Amazon EventBridge SDK",
);

/**
 * Amazon CloudWatch Logs SDK
 */
export const amazonka_cloudwatch_logs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cloudwatch-logs`,
  "Amazon CloudWatch Logs SDK",
);

/**
 * Amazon CodeArtifact SDK
 */
export const amazonka_codeartifact = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codeartifact`,
  "Amazon CodeArtifact SDK",
);

/**
 * Amazon CodeBuild SDK
 */
export const amazonka_codebuild = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codebuild`,
  "Amazon CodeBuild SDK",
);

/**
 * Amazon CodeCommit SDK
 */
export const amazonka_codecommit = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codecommit`,
  "Amazon CodeCommit SDK",
);

/**
 * Amazon CodeDeploy SDK
 */
export const amazonka_codedeploy = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codedeploy`,
  "Amazon CodeDeploy SDK",
);

/**
 * Amazon CodeGuru Reviewer SDK
 */
export const amazonka_codeguru_reviewer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codeguru-reviewer`,
  "Amazon CodeGuru Reviewer SDK",
);

/**
 * Amazon CodeGuru Profiler SDK
 */
export const amazonka_codeguruprofiler = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codeguruprofiler`,
  "Amazon CodeGuru Profiler SDK",
);

/**
 * Amazon CodePipeline SDK
 */
export const amazonka_codepipeline = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codepipeline`,
  "Amazon CodePipeline SDK",
);

/**
 * Amazon CodeStar SDK
 */
export const amazonka_codestar = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codestar`,
  "Amazon CodeStar SDK",
);

/**
 * Amazon CodeStar connections SDK
 */
export const amazonka_codestar_connections = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codestar-connections`,
  "Amazon CodeStar connections SDK",
);

/**
 * Amazon CodeStar Notifications SDK
 */
export const amazonka_codestar_notifications = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-codestar-notifications`,
  "Amazon CodeStar Notifications SDK",
);

/**
 * Amazon Cognito Identity SDK
 */
export const amazonka_cognito_identity = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cognito-identity`,
  "Amazon Cognito Identity SDK",
);

/**
 * Amazon Cognito Identity Provider SDK
 */
export const amazonka_cognito_idp = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cognito-idp`,
  "Amazon Cognito Identity Provider SDK",
);

/**
 * Amazon Cognito Sync SDK
 */
export const amazonka_cognito_sync = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cognito-sync`,
  "Amazon Cognito Sync SDK",
);

/**
 * Amazon Comprehend SDK
 */
export const amazonka_comprehend = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-comprehend`,
  "Amazon Comprehend SDK",
);

/**
 * Amazon Comprehend Medical SDK
 */
export const amazonka_comprehendmedical = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-comprehendmedical`,
  "Amazon Comprehend Medical SDK",
);

/**
 * Amazon Compute Optimizer SDK
 */
export const amazonka_compute_optimizer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-compute-optimizer`,
  "Amazon Compute Optimizer SDK",
);

/**
 * Amazon Config SDK
 */
export const amazonka_config = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-config`,
  "Amazon Config SDK",
);

/**
 * Amazon Connect Service SDK
 */
export const amazonka_connect = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-connect`,
  "Amazon Connect Service SDK",
);

/**
 * Amazon Connect Contact Lens SDK
 */
export const amazonka_connect_contact_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-connect-contact-lens`,
  "Amazon Connect Contact Lens SDK",
);

/**
 * Amazon ConnectCampaignService SDK
 */
export const amazonka_connectcampaigns = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-connectcampaigns`,
  "Amazon ConnectCampaignService SDK",
);

/**
 * Amazon Connect Cases SDK
 */
export const amazonka_connectcases = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-connectcases`,
  "Amazon Connect Cases SDK",
);

/**
 * Amazon Connect Participant Service SDK
 */
export const amazonka_connectparticipant = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-connectparticipant`,
  "Amazon Connect Participant Service SDK",
);

/**
 * Amazon Control Tower SDK
 */
export const amazonka_controltower = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-controltower`,
  "Amazon Control Tower SDK",
);

/**
 * Core data types and functionality for Amazonka libraries
 */
export const amazonka_core = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-core`,
  "Core data types and functionality for Amazonka libraries",
);

/**
 * Amazon Cost Explorer Service SDK
 */
export const amazonka_cost_explorer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cost-explorer`,
  "Amazon Cost Explorer Service SDK",
);

/**
 * Amazon Cost and Usage Report Service SDK
 */
export const amazonka_cur = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-cur`,
  "Amazon Cost and Usage Report Service SDK",
);

/**
 * Amazon Connect Customer Profiles SDK
 */
export const amazonka_customer_profiles = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-customer-profiles`,
  "Amazon Connect Customer Profiles SDK",
);

/**
 * Amazon Glue DataBrew SDK
 */
export const amazonka_databrew = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-databrew`,
  "Amazon Glue DataBrew SDK",
);

/**
 * Amazon Data Exchange SDK
 */
export const amazonka_dataexchange = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dataexchange`,
  "Amazon Data Exchange SDK",
);

/**
 * Amazon Data Pipeline SDK
 */
export const amazonka_datapipeline = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-datapipeline`,
  "Amazon Data Pipeline SDK",
);

/**
 * Amazon DataSync SDK
 */
export const amazonka_datasync = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-datasync`,
  "Amazon DataSync SDK",
);

/**
 * Amazon Detective SDK
 */
export const amazonka_detective = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-detective`,
  "Amazon Detective SDK",
);

/**
 * Amazon Device Farm SDK
 */
export const amazonka_devicefarm = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-devicefarm`,
  "Amazon Device Farm SDK",
);

/**
 * Amazon DevOps Guru SDK
 */
export const amazonka_devops_guru = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-devops-guru`,
  "Amazon DevOps Guru SDK",
);

/**
 * Amazon Direct Connect SDK
 */
export const amazonka_directconnect = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-directconnect`,
  "Amazon Direct Connect SDK",
);

/**
 * Amazon Application Discovery Service SDK
 */
export const amazonka_discovery = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-discovery`,
  "Amazon Application Discovery Service SDK",
);

/**
 * Amazon Data Lifecycle Manager SDK
 */
export const amazonka_dlm = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dlm`,
  "Amazon Data Lifecycle Manager SDK",
);

/**
 * Amazon Database Migration Service SDK
 */
export const amazonka_dms = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dms`,
  "Amazon Database Migration Service SDK",
);

/**
 * Amazon DocumentDB with MongoDB compatibility SDK
 */
export const amazonka_docdb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-docdb`,
  "Amazon DocumentDB with MongoDB compatibility SDK",
);

/**
 * Amazon DocumentDB Elastic Clusters SDK
 */
export const amazonka_docdb_elastic = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-docdb-elastic`,
  "Amazon DocumentDB Elastic Clusters SDK",
);

/**
 * Amazon Elastic Disaster Recovery Service SDK
 */
export const amazonka_drs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-drs`,
  "Amazon Elastic Disaster Recovery Service SDK",
);

/**
 * Amazon Directory Service SDK
 */
export const amazonka_ds = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ds`,
  "Amazon Directory Service SDK",
);

/**
 * Amazon DynamoDB SDK
 */
export const amazonka_dynamodb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dynamodb`,
  "Amazon DynamoDB SDK",
);

/**
 * Amazon DynamoDB Accelerator (DAX) SDK
 */
export const amazonka_dynamodb_dax = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dynamodb-dax`,
  "Amazon DynamoDB Accelerator (DAX) SDK",
);

/**
 * Amazon DynamoDB Streams SDK
 */
export const amazonka_dynamodb_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-dynamodb-streams`,
  "Amazon DynamoDB Streams SDK",
);

/**
 * Amazon Elastic Block Store SDK
 */
export const amazonka_ebs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ebs`,
  "Amazon Elastic Block Store SDK",
);

/**
 * Amazon Elastic Compute Cloud SDK
 */
export const amazonka_ec2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ec2`,
  "Amazon Elastic Compute Cloud SDK",
);

/**
 * Amazon EC2 Instance Connect SDK
 */
export const amazonka_ec2_instance_connect = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ec2-instance-connect`,
  "Amazon EC2 Instance Connect SDK",
);

/**
 * Amazon EC2 Container Registry SDK
 */
export const amazonka_ecr = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ecr`,
  "Amazon EC2 Container Registry SDK",
);

/**
 * Amazon Elastic Container Registry Public SDK
 */
export const amazonka_ecr_public = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ecr-public`,
  "Amazon Elastic Container Registry Public SDK",
);

/**
 * Amazon EC2 Container Service SDK
 */
export const amazonka_ecs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ecs`,
  "Amazon EC2 Container Service SDK",
);

/**
 * Amazon Elastic File System SDK
 */
export const amazonka_efs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-efs`,
  "Amazon Elastic File System SDK",
);

/**
 * Amazon Elastic Kubernetes Service SDK
 */
export const amazonka_eks = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-eks`,
  "Amazon Elastic Kubernetes Service SDK",
);

/**
 * Amazon Elastic Inference SDK
 */
export const amazonka_elastic_inference = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elastic-inference`,
  "Amazon Elastic Inference SDK",
);

/**
 * Amazon ElastiCache SDK
 */
export const amazonka_elasticache = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elasticache`,
  "Amazon ElastiCache SDK",
);

/**
 * Amazon Elastic Beanstalk SDK
 */
export const amazonka_elasticbeanstalk = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elasticbeanstalk`,
  "Amazon Elastic Beanstalk SDK",
);

/**
 * Amazon Elasticsearch Service SDK
 */
export const amazonka_elasticsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elasticsearch`,
  "Amazon Elasticsearch Service SDK",
);

/**
 * Amazon Elastic Transcoder SDK
 */
export const amazonka_elastictranscoder = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elastictranscoder`,
  "Amazon Elastic Transcoder SDK",
);

/**
 * Amazon Elastic Load Balancing SDK
 */
export const amazonka_elb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elb`,
  "Amazon Elastic Load Balancing SDK",
);

/**
 * Amazon Elastic Load Balancing SDK
 */
export const amazonka_elbv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-elbv2`,
  "Amazon Elastic Load Balancing SDK",
);

/**
 * Amazon EMR SDK
 */
export const amazonka_emr = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-emr`,
  "Amazon EMR SDK",
);

/**
 * Amazon EMR Containers SDK
 */
export const amazonka_emr_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-emr-containers`,
  "Amazon EMR Containers SDK",
);

/**
 * Amazon EMR Serverless SDK
 */
export const amazonka_emr_serverless = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-emr-serverless`,
  "Amazon EMR Serverless SDK",
);

/**
 * Amazon CloudWatch Evidently SDK
 */
export const amazonka_evidently = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-evidently`,
  "Amazon CloudWatch Evidently SDK",
);

/**
 * Amazon FinSpace User Environment Management service SDK
 */
export const amazonka_finspace = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-finspace`,
  "Amazon FinSpace User Environment Management service SDK",
);

/**
 * Amazon FinSpace Public API SDK
 */
export const amazonka_finspace_data = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-finspace-data`,
  "Amazon FinSpace Public API SDK",
);

/**
 * Amazon Fault Injection Simulator SDK
 */
export const amazonka_fis = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-fis`,
  "Amazon Fault Injection Simulator SDK",
);

/**
 * Amazon Firewall Management Service SDK
 */
export const amazonka_fms = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-fms`,
  "Amazon Firewall Management Service SDK",
);

/**
 * Amazon Forecast Service SDK
 */
export const amazonka_forecast = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-forecast`,
  "Amazon Forecast Service SDK",
);

/**
 * Amazon Forecast Query Service SDK
 */
export const amazonka_forecastquery = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-forecastquery`,
  "Amazon Forecast Query Service SDK",
);

/**
 * Amazon Fraud Detector SDK
 */
export const amazonka_frauddetector = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-frauddetector`,
  "Amazon Fraud Detector SDK",
);

/**
 * Amazon FSx SDK
 */
export const amazonka_fsx = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-fsx`,
  "Amazon FSx SDK",
);

/**
 * Amazon GameLift SDK
 */
export const amazonka_gamelift = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-gamelift`,
  "Amazon GameLift SDK",
);

/**
 * Amazon GameSparks SDK
 */
export const amazonka_gamesparks = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-gamesparks`,
  "Amazon GameSparks SDK",
);

/**
 * Amazon Glacier SDK
 */
export const amazonka_glacier = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-glacier`,
  "Amazon Glacier SDK",
);

/**
 * Amazon Global Accelerator SDK
 */
export const amazonka_globalaccelerator = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-globalaccelerator`,
  "Amazon Global Accelerator SDK",
);

/**
 * Amazon Glue SDK
 */
export const amazonka_glue = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-glue`,
  "Amazon Glue SDK",
);

/**
 * Amazon Managed Grafana SDK
 */
export const amazonka_grafana = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-grafana`,
  "Amazon Managed Grafana SDK",
);

/**
 * Amazon Greengrass SDK
 */
export const amazonka_greengrass = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-greengrass`,
  "Amazon Greengrass SDK",
);

/**
 * Amazon IoT Greengrass V2 SDK
 */
export const amazonka_greengrassv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-greengrassv2`,
  "Amazon IoT Greengrass V2 SDK",
);

/**
 * Amazon Ground Station SDK
 */
export const amazonka_groundstation = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-groundstation`,
  "Amazon Ground Station SDK",
);

/**
 * Amazon GuardDuty SDK
 */
export const amazonka_guardduty = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-guardduty`,
  "Amazon GuardDuty SDK",
);

/**
 * Amazon Health APIs and Notifications SDK
 */
export const amazonka_health = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-health`,
  "Amazon Health APIs and Notifications SDK",
);

/**
 * Amazon HealthLake SDK
 */
export const amazonka_healthlake = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-healthlake`,
  "Amazon HealthLake SDK",
);

/**
 * Amazon Honeycode SDK
 */
export const amazonka_honeycode = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-honeycode`,
  "Amazon Honeycode SDK",
);

/**
 * Amazon Identity and Access Management SDK
 */
export const amazonka_iam = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iam`,
  "Amazon Identity and Access Management SDK",
);

/**
 * Amazon SSO Identity Store SDK
 */
export const amazonka_identitystore = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-identitystore`,
  "Amazon SSO Identity Store SDK",
);

/**
 * Amazon EC2 Image Builder SDK
 */
export const amazonka_imagebuilder = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-imagebuilder`,
  "Amazon EC2 Image Builder SDK",
);

/**
 * Amazon Import/Export SDK
 */
export const amazonka_importexport = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-importexport`,
  "Amazon Import/Export SDK",
);

/**
 * Amazon Inspector SDK
 */
export const amazonka_inspector = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-inspector`,
  "Amazon Inspector SDK",
);

/**
 * Amazon Inspector2 SDK
 */
export const amazonka_inspector2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-inspector2`,
  "Amazon Inspector2 SDK",
);

/**
 * Amazon IoT SDK
 */
export const amazonka_iot = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot`,
  "Amazon IoT SDK",
);

/**
 * Amazon IoT 1-Click Devices Service SDK
 */
export const amazonka_iot1click_devices = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot1click-devices`,
  "Amazon IoT 1-Click Devices Service SDK",
);

/**
 * Amazon IoT 1-Click Projects Service SDK
 */
export const amazonka_iot1click_projects = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot1click-projects`,
  "Amazon IoT 1-Click Projects Service SDK",
);

/**
 * Amazon IoT Analytics SDK
 */
export const amazonka_iot_analytics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot-analytics`,
  "Amazon IoT Analytics SDK",
);

/**
 * Amazon IoT Data Plane SDK
 */
export const amazonka_iot_dataplane = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot-dataplane`,
  "Amazon IoT Data Plane SDK",
);

/**
 * Amazon IoT Jobs Data Plane SDK
 */
export const amazonka_iot_jobs_dataplane = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot-jobs-dataplane`,
  "Amazon IoT Jobs Data Plane SDK",
);

/**
 * Amazon IoT RoboRunner SDK
 */
export const amazonka_iot_roborunner = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iot-roborunner`,
  "Amazon IoT RoboRunner SDK",
);

/**
 * Amazon IoT Core Device Advisor SDK
 */
export const amazonka_iotdeviceadvisor = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotdeviceadvisor`,
  "Amazon IoT Core Device Advisor SDK",
);

/**
 * Amazon IoT Events SDK
 */
export const amazonka_iotevents = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotevents`,
  "Amazon IoT Events SDK",
);

/**
 * Amazon IoT Events Data SDK
 */
export const amazonka_iotevents_data = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotevents-data`,
  "Amazon IoT Events Data SDK",
);

/**
 * Amazon IoT Fleet Hub SDK
 */
export const amazonka_iotfleethub = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotfleethub`,
  "Amazon IoT Fleet Hub SDK",
);

/**
 * Amazon IoT FleetWise SDK
 */
export const amazonka_iotfleetwise = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotfleetwise`,
  "Amazon IoT FleetWise SDK",
);

/**
 * Amazon IoT Secure Tunneling SDK
 */
export const amazonka_iotsecuretunneling = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotsecuretunneling`,
  "Amazon IoT Secure Tunneling SDK",
);

/**
 * Amazon IoT SiteWise SDK
 */
export const amazonka_iotsitewise = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotsitewise`,
  "Amazon IoT SiteWise SDK",
);

/**
 * Amazon IoT Things Graph SDK
 */
export const amazonka_iotthingsgraph = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotthingsgraph`,
  "Amazon IoT Things Graph SDK",
);

/**
 * Amazon IoT TwinMaker SDK
 */
export const amazonka_iottwinmaker = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iottwinmaker`,
  "Amazon IoT TwinMaker SDK",
);

/**
 * Amazon IoT Wireless SDK
 */
export const amazonka_iotwireless = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-iotwireless`,
  "Amazon IoT Wireless SDK",
);

/**
 * Amazon Interactive Video Service SDK
 */
export const amazonka_ivs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ivs`,
  "Amazon Interactive Video Service SDK",
);

/**
 * Amazon Interactive Video Service Chat SDK
 */
export const amazonka_ivschat = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ivschat`,
  "Amazon Interactive Video Service Chat SDK",
);

/**
 * Amazon Managed Streaming for Kafka SDK
 */
export const amazonka_kafka = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kafka`,
  "Amazon Managed Streaming for Kafka SDK",
);

/**
 * Amazon Managed Streaming for Kafka Connect SDK
 */
export const amazonka_kafkaconnect = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kafkaconnect`,
  "Amazon Managed Streaming for Kafka Connect SDK",
);

/**
 * Amazon KendraFrontendService SDK
 */
export const amazonka_kendra = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kendra`,
  "Amazon KendraFrontendService SDK",
);

/**
 * Amazon Keyspaces SDK
 */
export const amazonka_keyspaces = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-keyspaces`,
  "Amazon Keyspaces SDK",
);

/**
 * Amazon Kinesis SDK
 */
export const amazonka_kinesis = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis`,
  "Amazon Kinesis SDK",
);

/**
 * Amazon Kinesis Analytics SDK
 */
export const amazonka_kinesis_analytics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-analytics`,
  "Amazon Kinesis Analytics SDK",
);

/**
 * Amazon Kinesis Firehose SDK
 */
export const amazonka_kinesis_firehose = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-firehose`,
  "Amazon Kinesis Firehose SDK",
);

/**
 * Amazon Kinesis Video Streams SDK
 */
export const amazonka_kinesis_video = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-video`,
  "Amazon Kinesis Video Streams SDK",
);

/**
 * Amazon Kinesis Video Streams Archived Media SDK
 */
export const amazonka_kinesis_video_archived_media = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-video-archived-media`,
  "Amazon Kinesis Video Streams Archived Media SDK",
);

/**
 * Amazon Kinesis Video Streams Media SDK
 */
export const amazonka_kinesis_video_media = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-video-media`,
  "Amazon Kinesis Video Streams Media SDK",
);

/**
 * Amazon Kinesis Video Signaling Channels SDK
 */
export const amazonka_kinesis_video_signaling = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-video-signaling`,
  "Amazon Kinesis Video Signaling Channels SDK",
);

/**
 * Amazon Kinesis Video WebRTC Storage SDK
 */
export const amazonka_kinesis_video_webrtc_storage = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesis-video-webrtc-storage`,
  "Amazon Kinesis Video WebRTC Storage SDK",
);

/**
 * Amazon Kinesis Analytics SDK
 */
export const amazonka_kinesisanalyticsv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kinesisanalyticsv2`,
  "Amazon Kinesis Analytics SDK",
);

/**
 * Amazon Key Management Service SDK
 */
export const amazonka_kms = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-kms`,
  "Amazon Key Management Service SDK",
);

/**
 * Amazon Lake Formation SDK
 */
export const amazonka_lakeformation = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lakeformation`,
  "Amazon Lake Formation SDK",
);

/**
 * Amazon Lambda SDK
 */
export const amazonka_lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lambda`,
  "Amazon Lambda SDK",
);

/**
 * Amazon Lex Model Building Service SDK
 */
export const amazonka_lex_models = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lex-models`,
  "Amazon Lex Model Building Service SDK",
);

/**
 * Amazon Lex Runtime Service SDK
 */
export const amazonka_lex_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lex-runtime`,
  "Amazon Lex Runtime Service SDK",
);

/**
 * Amazon Lex Model Building V2 SDK
 */
export const amazonka_lexv2_models = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lexv2-models`,
  "Amazon Lex Model Building V2 SDK",
);

/**
 * Amazon License Manager SDK
 */
export const amazonka_license_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-license-manager`,
  "Amazon License Manager SDK",
);

/**
 * Amazon License Manager Linux Subscriptions SDK
 */
export const amazonka_license_manager_linux_subscriptions = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-license-manager-linux-subscriptions`,
  "Amazon License Manager Linux Subscriptions SDK",
);

/**
 * Amazon License Manager User Subscriptions SDK
 */
export const amazonka_license_manager_user_subscriptions = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-license-manager-user-subscriptions`,
  "Amazon License Manager User Subscriptions SDK",
);

/**
 * Amazon Lightsail SDK
 */
export const amazonka_lightsail = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lightsail`,
  "Amazon Lightsail SDK",
);

/**
 * Amazon Location Service SDK
 */
export const amazonka_location = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-location`,
  "Amazon Location Service SDK",
);

/**
 * Amazon Lookout for Equipment SDK
 */
export const amazonka_lookoutequipment = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lookoutequipment`,
  "Amazon Lookout for Equipment SDK",
);

/**
 * Amazon Lookout for Metrics SDK
 */
export const amazonka_lookoutmetrics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lookoutmetrics`,
  "Amazon Lookout for Metrics SDK",
);

/**
 * Amazon Lookout for Vision SDK
 */
export const amazonka_lookoutvision = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-lookoutvision`,
  "Amazon Lookout for Vision SDK",
);

/**
 * Amazon MainframeModernization SDK
 */
export const amazonka_m2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-m2`,
  "Amazon MainframeModernization SDK",
);

/**
 * Amazon Macie SDK
 */
export const amazonka_macie = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-macie`,
  "Amazon Macie SDK",
);

/**
 * Amazon Macie 2 SDK
 */
export const amazonka_maciev2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-maciev2`,
  "Amazon Macie 2 SDK",
);

/**
 * Amazon Managed Blockchain SDK
 */
export const amazonka_managedblockchain = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-managedblockchain`,
  "Amazon Managed Blockchain SDK",
);

/**
 * Amazon Marketplace Commerce Analytics SDK
 */
export const amazonka_marketplace_analytics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-marketplace-analytics`,
  "Amazon Marketplace Commerce Analytics SDK",
);

/**
 * Amazon Marketplace Catalog Service SDK
 */
export const amazonka_marketplace_catalog = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-marketplace-catalog`,
  "Amazon Marketplace Catalog Service SDK",
);

/**
 * Amazon Marketplace Entitlement Service SDK
 */
export const amazonka_marketplace_entitlement = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-marketplace-entitlement`,
  "Amazon Marketplace Entitlement Service SDK",
);

/**
 * Amazon Marketplace Metering SDK
 */
export const amazonka_marketplace_metering = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-marketplace-metering`,
  "Amazon Marketplace Metering SDK",
);

/**
 * Amazon Mechanical Turk SDK
 */
export const amazonka_mechanicalturk = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mechanicalturk`,
  "Amazon Mechanical Turk SDK",
);

/**
 * Amazon MediaConnect SDK
 */
export const amazonka_mediaconnect = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediaconnect`,
  "Amazon MediaConnect SDK",
);

/**
 * Amazon Elemental MediaConvert SDK
 */
export const amazonka_mediaconvert = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediaconvert`,
  "Amazon Elemental MediaConvert SDK",
);

/**
 * Amazon Elemental MediaLive SDK
 */
export const amazonka_medialive = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-medialive`,
  "Amazon Elemental MediaLive SDK",
);

/**
 * Amazon Elemental MediaPackage SDK
 */
export const amazonka_mediapackage = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediapackage`,
  "Amazon Elemental MediaPackage SDK",
);

/**
 * Amazon Elemental MediaPackage VOD SDK
 */
export const amazonka_mediapackage_vod = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediapackage-vod`,
  "Amazon Elemental MediaPackage VOD SDK",
);

/**
 * Amazon Elemental MediaStore SDK
 */
export const amazonka_mediastore = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediastore`,
  "Amazon Elemental MediaStore SDK",
);

/**
 * Amazon Elemental MediaStore Data Plane SDK
 */
export const amazonka_mediastore_dataplane = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediastore-dataplane`,
  "Amazon Elemental MediaStore Data Plane SDK",
);

/**
 * Amazon MediaTailor SDK
 */
export const amazonka_mediatailor = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mediatailor`,
  "Amazon MediaTailor SDK",
);

/**
 * Amazon MemoryDB SDK
 */
export const amazonka_memorydb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-memorydb`,
  "Amazon MemoryDB SDK",
);

/**
 * Amazon Application Migration Service SDK
 */
export const amazonka_mgn = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mgn`,
  "Amazon Application Migration Service SDK",
);

/**
 * Amazon Migration Hub Refactor Spaces SDK
 */
export const amazonka_migration_hub_refactor_spaces = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-migration-hub-refactor-spaces`,
  "Amazon Migration Hub Refactor Spaces SDK",
);

/**
 * Amazon Migration Hub SDK
 */
export const amazonka_migrationhub = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-migrationhub`,
  "Amazon Migration Hub SDK",
);

/**
 * Amazon Migration Hub Config SDK
 */
export const amazonka_migrationhub_config = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-migrationhub-config`,
  "Amazon Migration Hub Config SDK",
);

/**
 * Amazon Migration Hub Orchestrator SDK
 */
export const amazonka_migrationhuborchestrator = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-migrationhuborchestrator`,
  "Amazon Migration Hub Orchestrator SDK",
);

/**
 * Amazon Migration Hub Strategy Recommendations SDK
 */
export const amazonka_migrationhubstrategy = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-migrationhubstrategy`,
  "Amazon Migration Hub Strategy Recommendations SDK",
);

/**
 * Amazon Machine Learning SDK
 */
export const amazonka_ml = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ml`,
  "Amazon Machine Learning SDK",
);

/**
 * Amazon Mobile SDK
 */
export const amazonka_mobile = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mobile`,
  "Amazon Mobile SDK",
);

/**
 * Amazon MQ SDK
 */
export const amazonka_mq = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mq`,
  "Amazon MQ SDK",
);

/**
 * MTL-style type-class and deriving-via newtypes for Amazonka
 */
export const amazonka_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mtl`,
  "MTL-style type-class and deriving-via newtypes for Amazonka",
);

/**
 * Amazon MWAA SDK
 */
export const amazonka_mwaa = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-mwaa`,
  "Amazon MWAA SDK",
);

/**
 * Amazon Neptune SDK
 */
export const amazonka_neptune = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-neptune`,
  "Amazon Neptune SDK",
);

/**
 * Amazon Network Firewall SDK
 */
export const amazonka_network_firewall = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-network-firewall`,
  "Amazon Network Firewall SDK",
);

/**
 * Amazon Network Manager SDK
 */
export const amazonka_networkmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-networkmanager`,
  "Amazon Network Manager SDK",
);

/**
 * Amazon NimbleStudio SDK
 */
export const amazonka_nimble = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-nimble`,
  "Amazon NimbleStudio SDK",
);

/**
 * Amazon CloudWatch Observability Access Manager SDK
 */
export const amazonka_oam = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-oam`,
  "Amazon CloudWatch Observability Access Manager SDK",
);

/**
 * Amazon Omics SDK
 */
export const amazonka_omics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-omics`,
  "Amazon Omics SDK",
);

/**
 * Amazon OpenSearch Service SDK
 */
export const amazonka_opensearch = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-opensearch`,
  "Amazon OpenSearch Service SDK",
);

/**
 * Amazon OpenSearch Service Serverless SDK
 */
export const amazonka_opensearchserverless = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-opensearchserverless`,
  "Amazon OpenSearch Service Serverless SDK",
);

/**
 * Amazon OpsWorks SDK
 */
export const amazonka_opsworks = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-opsworks`,
  "Amazon OpsWorks SDK",
);

/**
 * Amazon OpsWorks CM SDK
 */
export const amazonka_opsworks_cm = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-opsworks-cm`,
  "Amazon OpsWorks CM SDK",
);

/**
 * Amazon Organizations SDK
 */
export const amazonka_organizations = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-organizations`,
  "Amazon Organizations SDK",
);

/**
 * Amazon Outposts SDK
 */
export const amazonka_outposts = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-outposts`,
  "Amazon Outposts SDK",
);

/**
 * Amazon Panorama SDK
 */
export const amazonka_panorama = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-panorama`,
  "Amazon Panorama SDK",
);

/**
 * Amazon Personalize SDK
 */
export const amazonka_personalize = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-personalize`,
  "Amazon Personalize SDK",
);

/**
 * Amazon Personalize Events SDK
 */
export const amazonka_personalize_events = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-personalize-events`,
  "Amazon Personalize Events SDK",
);

/**
 * Amazon Personalize Runtime SDK
 */
export const amazonka_personalize_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-personalize-runtime`,
  "Amazon Personalize Runtime SDK",
);

/**
 * Amazon Performance Insights SDK
 */
export const amazonka_pi = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pi`,
  "Amazon Performance Insights SDK",
);

/**
 * Amazon Pinpoint SDK
 */
export const amazonka_pinpoint = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pinpoint`,
  "Amazon Pinpoint SDK",
);

/**
 * Amazon Pinpoint Email Service SDK
 */
export const amazonka_pinpoint_email = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pinpoint-email`,
  "Amazon Pinpoint Email Service SDK",
);

/**
 * Amazon Pinpoint SMS and Voice Service SDK
 */
export const amazonka_pinpoint_sms_voice = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pinpoint-sms-voice`,
  "Amazon Pinpoint SMS and Voice Service SDK",
);

/**
 * Amazon Pinpoint SMS Voice V2 SDK
 */
export const amazonka_pinpoint_sms_voice_v2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pinpoint-sms-voice-v2`,
  "Amazon Pinpoint SMS Voice V2 SDK",
);

/**
 * Amazon EventBridge Pipes SDK
 */
export const amazonka_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pipes`,
  "Amazon EventBridge Pipes SDK",
);

/**
 * Amazon Polly SDK
 */
export const amazonka_polly = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-polly`,
  "Amazon Polly SDK",
);

/**
 * Amazon Price List Service SDK
 */
export const amazonka_pricing = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-pricing`,
  "Amazon Price List Service SDK",
);

/**
 * Amazon Private 5G SDK
 */
export const amazonka_privatenetworks = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-privatenetworks`,
  "Amazon Private 5G SDK",
);

/**
 * Amazon Proton SDK
 */
export const amazonka_proton = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-proton`,
  "Amazon Proton SDK",
);

/**
 * Amazon QLDB SDK
 */
export const amazonka_qldb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-qldb`,
  "Amazon QLDB SDK",
);

/**
 * Amazon QLDB Session SDK
 */
export const amazonka_qldb_session = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-qldb-session`,
  "Amazon QLDB Session SDK",
);

/**
 * Amazon QuickSight SDK
 */
export const amazonka_quicksight = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-quicksight`,
  "Amazon QuickSight SDK",
);

/**
 * Amazon Resource Access Manager SDK
 */
export const amazonka_ram = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ram`,
  "Amazon Resource Access Manager SDK",
);

/**
 * Amazon Recycle Bin SDK
 */
export const amazonka_rbin = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rbin`,
  "Amazon Recycle Bin SDK",
);

/**
 * Amazon Relational Database Service SDK
 */
export const amazonka_rds = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rds`,
  "Amazon Relational Database Service SDK",
);

/**
 * Amazon RDS DataService SDK
 */
export const amazonka_rds_data = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rds-data`,
  "Amazon RDS DataService SDK",
);

/**
 * Amazon Redshift SDK
 */
export const amazonka_redshift = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-redshift`,
  "Amazon Redshift SDK",
);

/**
 * Amazon Redshift Data API Service SDK
 */
export const amazonka_redshift_data = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-redshift-data`,
  "Amazon Redshift Data API Service SDK",
);

/**
 * Amazon Redshift Serverless SDK
 */
export const amazonka_redshift_serverless = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-redshift-serverless`,
  "Amazon Redshift Serverless SDK",
);

/**
 * Amazon Rekognition SDK
 */
export const amazonka_rekognition = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rekognition`,
  "Amazon Rekognition SDK",
);

/**
 * Amazon Resilience Hub SDK
 */
export const amazonka_resiliencehub = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-resiliencehub`,
  "Amazon Resilience Hub SDK",
);

/**
 * Amazon Resource Explorer SDK
 */
export const amazonka_resource_explorer_v2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-resource-explorer-v2`,
  "Amazon Resource Explorer SDK",
);

/**
 * Amazon Resource Groups SDK
 */
export const amazonka_resourcegroups = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-resourcegroups`,
  "Amazon Resource Groups SDK",
);

/**
 * Amazon Resource Groups Tagging API SDK
 */
export const amazonka_resourcegroupstagging = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-resourcegroupstagging`,
  "Amazon Resource Groups Tagging API SDK",
);

/**
 * Amazon RoboMaker SDK
 */
export const amazonka_robomaker = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-robomaker`,
  "Amazon RoboMaker SDK",
);

/**
 * Amazon IAM Roles Anywhere SDK
 */
export const amazonka_rolesanywhere = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rolesanywhere`,
  "Amazon IAM Roles Anywhere SDK",
);

/**
 * Amazon Route 53 SDK
 */
export const amazonka_route53 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53`,
  "Amazon Route 53 SDK",
);

/**
 * Amazon Cloud Map SDK
 */
export const amazonka_route53_autonaming = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53-autonaming`,
  "Amazon Cloud Map SDK",
);

/**
 * Amazon Route 53 Domains SDK
 */
export const amazonka_route53_domains = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53-domains`,
  "Amazon Route 53 Domains SDK",
);

/**
 * Amazon Route53 Recovery Cluster SDK
 */
export const amazonka_route53_recovery_cluster = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53-recovery-cluster`,
  "Amazon Route53 Recovery Cluster SDK",
);

/**
 * Amazon Route53 Recovery Control Config SDK
 */
export const amazonka_route53_recovery_control_config = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53-recovery-control-config`,
  "Amazon Route53 Recovery Control Config SDK",
);

/**
 * Amazon Route53 Recovery Readiness SDK
 */
export const amazonka_route53_recovery_readiness = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53-recovery-readiness`,
  "Amazon Route53 Recovery Readiness SDK",
);

/**
 * Amazon Route 53 Resolver SDK
 */
export const amazonka_route53resolver = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-route53resolver`,
  "Amazon Route 53 Resolver SDK",
);

/**
 * Amazon CloudWatch RUM SDK
 */
export const amazonka_rum = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-rum`,
  "Amazon CloudWatch RUM SDK",
);

/**
 * Amazon Simple Storage Service SDK
 */
export const amazonka_s3 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-s3`,
  "Amazon Simple Storage Service SDK",
);

/**
 * Amazon Simple Storage Service SDK - Client-Side Encryption
 */
export const amazonka_s3_encryption = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-s3-encryption`,
  "Amazon Simple Storage Service SDK - Client-Side Encryption",
);

/**
 * Provides conduits to upload data to S3 using the Multipart API
 */
export const amazonka_s3_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-s3-streaming`,
  "Provides conduits to upload data to S3 using the Multipart API",
);

/**
 * Amazon S3 on Outposts SDK
 */
export const amazonka_s3outposts = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-s3outposts`,
  "Amazon S3 on Outposts SDK",
);

/**
 * Amazon SageMaker Service SDK
 */
export const amazonka_sagemaker = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker`,
  "Amazon SageMaker Service SDK",
);

/**
 * Amazon Augmented AI Runtime SDK
 */
export const amazonka_sagemaker_a2i_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-a2i-runtime`,
  "Amazon Augmented AI Runtime SDK",
);

/**
 * Amazon Sagemaker Edge Manager SDK
 */
export const amazonka_sagemaker_edge = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-edge`,
  "Amazon Sagemaker Edge Manager SDK",
);

/**
 * Amazon SageMaker Feature Store Runtime SDK
 */
export const amazonka_sagemaker_featurestore_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-featurestore-runtime`,
  "Amazon SageMaker Feature Store Runtime SDK",
);

/**
 * Amazon SageMaker geospatial capabilities SDK
 */
export const amazonka_sagemaker_geospatial = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-geospatial`,
  "Amazon SageMaker geospatial capabilities SDK",
);

/**
 * Amazon SageMaker Metrics Service SDK
 */
export const amazonka_sagemaker_metrics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-metrics`,
  "Amazon SageMaker Metrics Service SDK",
);

/**
 * Amazon SageMaker Runtime SDK
 */
export const amazonka_sagemaker_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sagemaker-runtime`,
  "Amazon SageMaker Runtime SDK",
);

/**
 * Amazon Savings Plans SDK
 */
export const amazonka_savingsplans = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-savingsplans`,
  "Amazon Savings Plans SDK",
);

/**
 * Amazon EventBridge Scheduler SDK
 */
export const amazonka_scheduler = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-scheduler`,
  "Amazon EventBridge Scheduler SDK",
);

/**
 * Amazon Schemas SDK
 */
export const amazonka_schemas = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-schemas`,
  "Amazon Schemas SDK",
);

/**
 * Amazon SimpleDB SDK
 */
export const amazonka_sdb = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sdb`,
  "Amazon SimpleDB SDK",
);

/**
 * Amazon Secrets Manager SDK
 */
export const amazonka_secretsmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-secretsmanager`,
  "Amazon Secrets Manager SDK",
);

/**
 * Amazon SecurityHub SDK
 */
export const amazonka_securityhub = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-securityhub`,
  "Amazon SecurityHub SDK",
);

/**
 * Amazon Security Lake SDK
 */
export const amazonka_securitylake = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-securitylake`,
  "Amazon Security Lake SDK",
);

/**
 * Amazon ServerlessApplicationRepository SDK
 */
export const amazonka_serverlessrepo = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-serverlessrepo`,
  "Amazon ServerlessApplicationRepository SDK",
);

/**
 * Amazon Quotas SDK
 */
export const amazonka_service_quotas = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-service-quotas`,
  "Amazon Quotas SDK",
);

/**
 * Amazon Service Catalog SDK
 */
export const amazonka_servicecatalog = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-servicecatalog`,
  "Amazon Service Catalog SDK",
);

/**
 * Amazon Service Catalog App Registry SDK
 */
export const amazonka_servicecatalog_appregistry = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-servicecatalog-appregistry`,
  "Amazon Service Catalog App Registry SDK",
);

/**
 * Amazon Simple Email Service SDK
 */
export const amazonka_ses = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ses`,
  "Amazon Simple Email Service SDK",
);

/**
 * Amazon Simple Email Service SDK
 */
export const amazonka_sesv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sesv2`,
  "Amazon Simple Email Service SDK",
);

/**
 * Amazon Shield SDK
 */
export const amazonka_shield = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-shield`,
  "Amazon Shield SDK",
);

/**
 * Amazon Signer SDK
 */
export const amazonka_signer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-signer`,
  "Amazon Signer SDK",
);

/**
 * Amazon SimSpace Weaver SDK
 */
export const amazonka_simspaceweaver = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-simspaceweaver`,
  "Amazon SimSpace Weaver SDK",
);

/**
 * Amazon Server Migration Service SDK
 */
export const amazonka_sms = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sms`,
  "Amazon Server Migration Service SDK",
);

/**
 * Amazon Pinpoint SMS and Voice Service SDK
 */
export const amazonka_sms_voice = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sms-voice`,
  "Amazon Pinpoint SMS and Voice Service SDK",
);

/**
 * Amazon Snow Device Management SDK
 */
export const amazonka_snow_device_management = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-snow-device-management`,
  "Amazon Snow Device Management SDK",
);

/**
 * Amazon Import/Export Snowball SDK
 */
export const amazonka_snowball = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-snowball`,
  "Amazon Import/Export Snowball SDK",
);

/**
 * Amazon Simple Notification Service SDK
 */
export const amazonka_sns = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sns`,
  "Amazon Simple Notification Service SDK",
);

/**
 * Amazon Simple Queue Service SDK
 */
export const amazonka_sqs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sqs`,
  "Amazon Simple Queue Service SDK",
);

/**
 * Amazon Simple Systems Manager (SSM) SDK
 */
export const amazonka_ssm = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ssm`,
  "Amazon Simple Systems Manager (SSM) SDK",
);

/**
 * Amazon Systems Manager Incident Manager Contacts SDK
 */
export const amazonka_ssm_contacts = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ssm-contacts`,
  "Amazon Systems Manager Incident Manager Contacts SDK",
);

/**
 * Amazon Systems Manager Incident Manager SDK
 */
export const amazonka_ssm_incidents = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ssm-incidents`,
  "Amazon Systems Manager Incident Manager SDK",
);

/**
 * Amazon Systems Manager for SAP SDK
 */
export const amazonka_ssm_sap = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-ssm-sap`,
  "Amazon Systems Manager for SAP SDK",
);

/**
 * Amazon Single Sign-On SDK
 */
export const amazonka_sso = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sso`,
  "Amazon Single Sign-On SDK",
);

/**
 * Amazon Single Sign-On Admin SDK
 */
export const amazonka_sso_admin = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sso-admin`,
  "Amazon Single Sign-On Admin SDK",
);

/**
 * Amazon SSO OIDC SDK
 */
export const amazonka_sso_oidc = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sso-oidc`,
  "Amazon SSO OIDC SDK",
);

/**
 * Amazon Step Functions SDK
 */
export const amazonka_stepfunctions = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-stepfunctions`,
  "Amazon Step Functions SDK",
);

/**
 * Amazon Storage Gateway SDK
 */
export const amazonka_storagegateway = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-storagegateway`,
  "Amazon Storage Gateway SDK",
);

/**
 * Amazon Security Token Service SDK
 */
export const amazonka_sts = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-sts`,
  "Amazon Security Token Service SDK",
);

/**
 * Amazon Support SDK
 */
export const amazonka_support = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-support`,
  "Amazon Support SDK",
);

/**
 * Amazon Support App SDK
 */
export const amazonka_support_app = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-support-app`,
  "Amazon Support App SDK",
);

/**
 * Amazon Simple Workflow Service SDK
 */
export const amazonka_swf = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-swf`,
  "Amazon Simple Workflow Service SDK",
);

/**
 * Amazon Synthetics SDK
 */
export const amazonka_synthetics = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-synthetics`,
  "Amazon Synthetics SDK",
);

/**
 * Common functionality for Amazonka library test-suites
 */
export const amazonka_test = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-test`,
  "Common functionality for Amazonka library test-suites",
);

/**
 * Amazon Textract SDK
 */
export const amazonka_textract = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-textract`,
  "Amazon Textract SDK",
);

/**
 * Amazon Timestream Query SDK
 */
export const amazonka_timestream_query = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-timestream-query`,
  "Amazon Timestream Query SDK",
);

/**
 * Amazon Timestream Write SDK
 */
export const amazonka_timestream_write = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-timestream-write`,
  "Amazon Timestream Write SDK",
);

/**
 * Amazon Transcribe Service SDK
 */
export const amazonka_transcribe = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-transcribe`,
  "Amazon Transcribe Service SDK",
);

/**
 * Amazon Transfer Family SDK
 */
export const amazonka_transfer = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-transfer`,
  "Amazon Transfer Family SDK",
);

/**
 * Amazon Translate SDK
 */
export const amazonka_translate = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-translate`,
  "Amazon Translate SDK",
);

/**
 * Amazon Voice ID SDK
 */
export const amazonka_voice_id = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-voice-id`,
  "Amazon Voice ID SDK",
);

/**
 * Amazon WAF SDK
 */
export const amazonka_waf = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-waf`,
  "Amazon WAF SDK",
);

/**
 * Amazon WAF Regional SDK
 */
export const amazonka_waf_regional = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-waf-regional`,
  "Amazon WAF Regional SDK",
);

/**
 * Amazon WAFV2 SDK
 */
export const amazonka_wafv2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-wafv2`,
  "Amazon WAFV2 SDK",
);

/**
 * Amazon Well-Architected Tool SDK
 */
export const amazonka_wellarchitected = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-wellarchitected`,
  "Amazon Well-Architected Tool SDK",
);

/**
 * Amazon Connect Wisdom Service SDK
 */
export const amazonka_wisdom = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-wisdom`,
  "Amazon Connect Wisdom Service SDK",
);

/**
 * Amazon WorkDocs SDK
 */
export const amazonka_workdocs = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-workdocs`,
  "Amazon WorkDocs SDK",
);

/**
 * Amazon WorkLink SDK
 */
export const amazonka_worklink = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-worklink`,
  "Amazon WorkLink SDK",
);

/**
 * Amazon WorkMail SDK
 */
export const amazonka_workmail = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-workmail`,
  "Amazon WorkMail SDK",
);

/**
 * Amazon WorkMail Message Flow SDK
 */
export const amazonka_workmailmessageflow = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-workmailmessageflow`,
  "Amazon WorkMail Message Flow SDK",
);

/**
 * Amazon WorkSpaces SDK
 */
export const amazonka_workspaces = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-workspaces`,
  "Amazon WorkSpaces SDK",
);

/**
 * Amazon WorkSpaces Web SDK
 */
export const amazonka_workspaces_web = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-workspaces-web`,
  "Amazon WorkSpaces Web SDK",
);

/**
 * Amazon X-Ray SDK
 */
export const amazonka_xray = mkPackage(
  nixRaw`pkgs.haskellPackages.amazonka-xray`,
  "Amazon X-Ray SDK",
);

/**
 * Statistical data visualization
 */
export const amby = mkPackage(
  nixRaw`pkgs.haskellPackages.amby`,
  "Statistical data visualization",
);

/**
 * Toolsuite for automated design of business processes
 */
export const ampersand = mkPackage(
  nixRaw`pkgs.haskellPackages.ampersand`,
  "Toolsuite for automated design of business processes",
);

/**
 * Client library for AMQP servers (currently only RabbitMQ)
 */
export const amqp = mkPackage(
  nixRaw`pkgs.haskellPackages.amqp`,
  "Client library for AMQP servers (currently only RabbitMQ)",
);

/**
 * Client library for AMQP servers (currently only RabbitMQ)
 */
export const amqp_0_22_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.amqp_0_22_2`,
  "Client library for AMQP servers (currently only RabbitMQ)",
);

/**
 * A simple streamly wrapper for amqp
 */
export const amqp_streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.amqp-streamly`,
  "A simple streamly wrapper for amqp",
);

/**
 * AMQP toolset for the command line
 */
export const amqp_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.amqp-utils`,
  "AMQP toolset for the command line",
);

/**
 * AMQP toolset for the command line
 */
export const amqp_utils_0_6_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.amqp-utils_0_6_4_0`,
  "AMQP toolset for the command line",
);

/**
 * Interpreter for AM
 */
export const amrun = mkPackage(
  nixRaw`pkgs.haskellPackages.amrun`,
  "Interpreter for AM",
);

/**
 * Find strings with permutations (anagrams) that match a regular expression
 */
export const anagrep = mkPackage(
  nixRaw`pkgs.haskellPackages.anagrep`,
  "Find strings with permutations (anagrams) that match a regular expression",
);

/**
 * Client for analyze service
 */
export const analyze_client = mkPackage(
  nixRaw`pkgs.haskellPackages.analyze-client`,
  "Client for analyze service",
);

/**
 * Simple literate programming preprocessor
 */
export const anansi = mkPackage(
  nixRaw`pkgs.haskellPackages.anansi`,
  "Simple literate programming preprocessor",
);

/**
 * Colorized looms for Anansi
 */
export const anansi_hscolour = mkPackage(
  nixRaw`pkgs.haskellPackages.anansi-hscolour`,
  "Colorized looms for Anansi",
);

/**
 * Anatomy: Atomo documentation system
 */
export const anatomy = mkPackage(
  nixRaw`pkgs.haskellPackages.anatomy`,
  "Anatomy: Atomo documentation system",
);

/**
 * Animation for sprites
 */
export const animate_example = mkPackage(
  nixRaw`pkgs.haskellPackages.animate-example`,
  "Animation for sprites",
);

/**
 * Convert sprite frames to animate files
 */
export const animate_frames = mkPackage(
  nixRaw`pkgs.haskellPackages.animate-frames`,
  "Convert sprite frames to animate files",
);

/**
 * Preview tool for sprite animation
 */
export const animate_preview = mkPackage(
  nixRaw`pkgs.haskellPackages.animate-preview`,
  "Preview tool for sprite animation",
);

/**
 * sdl2 + animate auxiliary library
 */
export const animate_sdl2 = mkPackage(
  nixRaw`pkgs.haskellPackages.animate-sdl2`,
  "sdl2 + animate auxiliary library",
);

/**
 * Informative annotations which don't change equality
 */
export const ann = mkPackage(
  nixRaw`pkgs.haskellPackages.ann`,
  "Informative annotations which don't change equality",
);

/**
 * Medium-level language that desugars to Morte
 */
export const annah = mkPackage(
  nixRaw`pkgs.haskellPackages.annah`,
  "Medium-level language that desugars to Morte",
);

/**
 * Semigroups with annihilators and utility functions
 */
export const annihilator = mkPackage(
  nixRaw`pkgs.haskellPackages.annihilator`,
  "Semigroups with annihilators and utility functions",
);

/**
 * Exceptions, with checkpoints and context
 */
export const annotated_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.annotated-exception`,
  "Exceptions, with checkpoints and context",
);

/**
 * The Wadler/Leijen Pretty Printer, with annotation support
 */
export const annotated_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.annotated-wl-pprint`,
  "The Wadler/Leijen Pretty Printer, with annotation support",
);

/**
 * QuickCheck functions to accompany the anonymous-sums package
 */
export const anonymous_sums_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.anonymous-sums-tests`,
  "QuickCheck functions to accompany the anonymous-sums package",
);

/**
 * Haskell package to generate ANSI escape codes for styling strings in the terminal
 */
export const ansi_escape_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-escape-codes`,
  "Haskell package to generate ANSI escape codes for styling strings in the terminal",
);

/**
 * Simple ANSI terminal support, with Windows compatibility
 */
export const ansi_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-terminal`,
  "Simple ANSI terminal support, with Windows compatibility",
);

/**
 * Simple ANSI terminal support
 */
export const ansi_terminal_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-terminal_1_0`,
  "Simple ANSI terminal support",
);

/**
 * cross-platform library for terminal games
 */
export const ansi_terminal_game = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-terminal-game`,
  "cross-platform library for terminal games",
);

/**
 * Types and functions used to represent SGR aspects
 */
export const ansi_terminal_types = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-terminal-types`,
  "Types and functions used to represent SGR aspects",
);

/**
 * The Wadler/Leijen Pretty Printer for colored ANSI terminal output
 */
export const ansi_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-wl-pprint`,
  "The Wadler/Leijen Pretty Printer for colored ANSI terminal output",
);

/**
 * The Wadler/Leijen Pretty Printer for colored ANSI terminal output
 */
export const ansi_wl_pprint_1_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.ansi-wl-pprint_1_0_2`,
  "The Wadler/Leijen Pretty Printer for colored ANSI terminal output",
);

/**
 * A web interface to Antisplice dungeons
 */
export const antagonist = mkPackage(
  nixRaw`pkgs.haskellPackages.antagonist`,
  "A web interface to Antisplice dungeons",
);

/**
 * This is an IRC bot for Mafia and Resistance
 */
export const anticiv = mkPackage(
  nixRaw`pkgs.haskellPackages.anticiv`,
  "This is an IRC bot for Mafia and Resistance",
);

/**
 * Please see the README on Github at <https://github.com/arbor/antiope#readme>
 */
export const antiope_contract = mkPackage(
  nixRaw`pkgs.haskellPackages.antiope-contract`,
  "Please see the README on Github at <https://github.com/arbor/antiope#readme>",
);

/**
 * Please see the README on Github at <https://github.com/arbor/antiope#readme>
 */
export const antiope_core = mkPackage(
  nixRaw`pkgs.haskellPackages.antiope-core`,
  "Please see the README on Github at <https://github.com/arbor/antiope#readme>",
);

/**
 * Please see the README on Github at <https://github.com/arbor/antiope#readme>
 */
export const antiope_dynamodb = mkPackage(
  nixRaw`pkgs.haskellPackages.antiope-dynamodb`,
  "Please see the README on Github at <https://github.com/arbor/antiope#readme>",
);

/**
 * Please see the README on Github at <https://github.com/arbor/antiope#readme>
 */
export const antiope_s3 = mkPackage(
  nixRaw`pkgs.haskellPackages.antiope-s3`,
  "Please see the README on Github at <https://github.com/arbor/antiope#readme>",
);

/**
 * Please see the README on Github at <https://github.com/arbor/antiope#readme>
 */
export const antiope_shell = mkPackage(
  nixRaw`pkgs.haskellPackages.antiope-shell`,
  "Please see the README on Github at <https://github.com/arbor/antiope#readme>",
);

/**
 * Initial project template from stack
 */
export const antiprimes = mkPackage(
  nixRaw`pkgs.haskellPackages.antiprimes`,
  "Initial project template from stack",
);

/**
 * Haskell binding to the ANTLR parser generator C runtime library
 */
export const antlrc = mkPackage(
  nixRaw`pkgs.haskellPackages.antlrc`,
  "Haskell binding to the ANTLR parser generator C runtime library",
);

/**
 * Quasiquoters that act on a sequence of patterns and compiles these view into patterns and expressions
 */
export const any_pat = mkPackage(
  nixRaw`pkgs.haskellPackages.any-pat`,
  "Quasiquoters that act on a sequence of patterns and compiles these view into patterns and expressions",
);

/**
 * prelude for Algebra of Programming
 */
export const aop_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.aop-prelude`,
  "prelude for Algebra of Programming",
);

/**
 * An implementation of the AOS signatures
 */
export const aos_signature = mkPackage(
  nixRaw`pkgs.haskellPackages.aos-signature`,
  "An implementation of the AOS signatures",
);

/**
 * Self-normalizing applicative expressions
 */
export const ap_normalize = mkPackage(
  nixRaw`pkgs.haskellPackages.ap-normalize`,
  "Self-normalizing applicative expressions",
);

/**
 * Partial evaluation reflection a la simple-reflect
 */
export const ap_reflect = mkPackage(
  nixRaw`pkgs.haskellPackages.ap-reflect`,
  "Partial evaluation reflection a la simple-reflect",
);

/**
 * Fast Entity-Component-System library for game programming
 */
export const apecs = mkPackage(
  nixRaw`pkgs.haskellPackages.apecs`,
  "Fast Entity-Component-System library for game programming",
);

/**
 * Adaptation of the apecs library for the effectful ecosystem
 */
export const apecs_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.apecs-effectful`,
  "Adaptation of the apecs library for the effectful ecosystem",
);

/**
 * Simple gloss renderer for apecs
 */
export const apecs_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.apecs-gloss`,
  "Simple gloss renderer for apecs",
);

/**
 * Gloss rendering for apecs-physics
 */
export const apecs_physics_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.apecs-physics-gloss`,
  "Gloss rendering for apecs-physics",
);

/**
 * STM stores for apecs
 */
export const apecs_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.apecs-stm`,
  "STM stores for apecs",
);

/**
 * Server and community browser for the game Tremulous
 */
export const apelsin = mkPackage(
  nixRaw`pkgs.haskellPackages.apelsin`,
  "Server and community browser for the game Tremulous",
);

/**
 * option of aeson's deriveJSON
 */
export const api_field_json_th = mkPackage(
  nixRaw`pkgs.haskellPackages.api-field-json-th`,
  "option of aeson's deriveJSON",
);

/**
 * Package to make APIs
 */
export const api_maker = mkPackage(
  nixRaw`pkgs.haskellPackages.api-maker`,
  "Package to make APIs",
);

/**
 * OpenTheory unicode character API
 */
export const api_opentheory_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.api-opentheory-unicode`,
  "OpenTheory unicode character API",
);

/**
 * JSON-RPC API client for Accumulate blockchain
 */
export const api_rpc_accumulate = mkPackage(
  nixRaw`pkgs.haskellPackages.api-rpc-accumulate`,
  "JSON-RPC API client for Accumulate blockchain",
);

/**
 * simple json-rpc client for PegNet
 */
export const api_rpc_pegnet = mkPackage(
  nixRaw`pkgs.haskellPackages.api-rpc-pegnet`,
  "simple json-rpc client for PegNet",
);

/**
 * DSL for generating API boilerplate and docs
 */
export const api_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.api-tools`,
  "DSL for generating API boilerplate and docs",
);

/**
 * Api bindings for Yoti services
 */
export const api_yoti = mkPackage(
  nixRaw`pkgs.haskellPackages.api-yoti`,
  "Api bindings for Yoti services",
);

/**
 * Simple and type safe web framework that generate web API documentation
 */
export const apiary = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary`,
  "Simple and type safe web framework that generate web API documentation",
);

/**
 * authenticate support for apiary web framework
 */
export const apiary_authenticate = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-authenticate`,
  "authenticate support for apiary web framework",
);

/**
 * clientsession support for apiary web framework
 */
export const apiary_clientsession = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-clientsession`,
  "clientsession support for apiary web framework",
);

/**
 * Cookie support for apiary web framework
 */
export const apiary_cookie = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-cookie`,
  "Cookie support for apiary web framework",
);

/**
 * eventsource support for apiary web framework
 */
export const apiary_eventsource = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-eventsource`,
  "eventsource support for apiary web framework",
);

/**
 * helics support for apiary web framework
 */
export const apiary_helics = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-helics`,
  "helics support for apiary web framework",
);

/**
 * A http client for Apiary
 */
export const apiary_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-http-client`,
  "A http client for Apiary",
);

/**
 * fast-logger support for apiary web framework
 */
export const apiary_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-logger`,
  "fast-logger support for apiary web framework",
);

/**
 * memcached client for apiary web framework
 */
export const apiary_memcached = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-memcached`,
  "memcached client for apiary web framework",
);

/**
 * mongoDB support for apiary web framework
 */
export const apiary_mongoDB = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-mongoDB`,
  "mongoDB support for apiary web framework",
);

/**
 * persistent support for apiary web framework
 */
export const apiary_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-persistent`,
  "persistent support for apiary web framework",
);

/**
 * purescript compiler for apiary web framework
 */
export const apiary_purescript = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-purescript`,
  "purescript compiler for apiary web framework",
);

/**
 * redis support for apiary web framework
 */
export const apiary_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-redis`,
  "redis support for apiary web framework",
);

/**
 * session support for apiary web framework
 */
export const apiary_session = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-session`,
  "session support for apiary web framework",
);

/**
 * websockets support for apiary web framework
 */
export const apiary_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.apiary-websockets`,
  "websockets support for apiary web framework",
);

/**
 * Consumer library for anapioficeandfire.com
 */
export const apioiaf_client = mkPackage(
  nixRaw`pkgs.haskellPackages.apioiaf-client`,
  "Consumer library for anapioficeandfire.com",
);

/**
 * A Template Haskell library for generating type safe API calls
 */
export const apis = mkPackage(
  nixRaw`pkgs.haskellPackages.apis`,
  "A Template Haskell library for generating type safe API calls",
);

/**
 * a faster debian repository
 */
export const apotiki = mkPackage(
  nixRaw`pkgs.haskellPackages.apotiki`,
  "a faster debian repository",
);

/**
 * A library to manage application settings (INI file-like)
 */
export const app_settings = mkPackage(
  nixRaw`pkgs.haskellPackages.app-settings`,
  "A library to manage application settings (INI file-like)",
);

/**
 * A simple applicative parser
 */
export const appar = mkPackage(
  nixRaw`pkgs.haskellPackages.appar`,
  "A simple applicative parser",
);

export const appendful = mkPackage(
  nixRaw`pkgs.haskellPackages.appendful`,
  "",
);

/**
 * Map with a Semigroup and Monoid instances delegating to Semigroup of the elements
 */
export const appendmap = mkPackage(
  nixRaw`pkgs.haskellPackages.appendmap`,
  "Map with a Semigroup and Monoid instances delegating to Semigroup of the elements",
);

/**
 * A class for things that can be applied
 */
export const applicable = mkPackage(
  nixRaw`pkgs.haskellPackages.applicable`,
  "A class for things that can be applied",
);

/**
 * Instances for Applicative
 */
export const applicative_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.applicative-extras`,
  "Instances for Applicative",
);

/**
 * Applicative-based numeric instances
 */
export const applicative_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.applicative-numbers`,
  "Applicative-based numeric instances",
);

/**
 * Perform refactorings specified by the refact library
 */
export const apply_refact = mkPackage(
  nixRaw`pkgs.haskellPackages.apply-refact`,
  "Perform refactorings specified by the refact library",
);

/**
 * Perform refactorings specified by the refact library
 */
export const apply_refact_0_11_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.apply-refact_0_11_0_0`,
  "Perform refactorings specified by the refact library",
);

/**
 * Perform refactorings specified by the refact library
 */
export const apply_refact_0_9_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.apply-refact_0_9_3_0`,
  "Perform refactorings specified by the refact library",
);

/**
 * Apply functions to arguments in an unordered type-directed fashion
 */
export const apply_unordered_mono = mkPackage(
  nixRaw`pkgs.haskellPackages.apply-unordered-mono`,
  "Apply functions to arguments in an unordered type-directed fashion",
);

/**
 * Round a set of numbers while maintaining its sum
 */
export const apportionment = mkPackage(
  nixRaw`pkgs.haskellPackages.apportionment`,
  "Round a set of numbers while maintaining its sum",
);

/**
 * Approximate randomization test
 */
export const approx_rand_test = mkPackage(
  nixRaw`pkgs.haskellPackages.approx-rand-test`,
  "Approximate randomization test",
);

/**
 * Approximate discrete values and numbers
 */
export const approximate = mkPackage(
  nixRaw`pkgs.haskellPackages.approximate`,
  "Approximate discrete values and numbers",
);

/**
 * Newtype wrappers for approximate equality
 */
export const approximate_equality = mkPackage(
  nixRaw`pkgs.haskellPackages.approximate-equality`,
  "Newtype wrappers for approximate equality",
);

/**
 * Wipes time stamps from .a files (like ar -D)
 */
export const ar_timestamp_wiper = mkPackage(
  nixRaw`pkgs.haskellPackages.ar-timestamp-wiper`,
  "Wipes time stamps from .a files (like ar -D)",
);

/**
 * Datadog client for Haskell
 */
export const arbor_datadog = mkPackage(
  nixRaw`pkgs.haskellPackages.arbor-datadog`,
  "Datadog client for Haskell",
);

/**
 * Metric library backend for datadog
 */
export const arbor_monad_metric_datadog = mkPackage(
  nixRaw`pkgs.haskellPackages.arbor-monad-metric-datadog`,
  "Metric library backend for datadog",
);

/**
 * Automatic Rule-Based Time Tracker
 */
export const arbtt = mkPackage(
  nixRaw`pkgs.haskellPackages.arbtt`,
  "Automatic Rule-Based Time Tracker",
);

/**
 * Parse ESRI/ArcInfo (ArcGrid) raster GIS files
 */
export const arcgrid = mkPackage(
  nixRaw`pkgs.haskellPackages.arcgrid`,
  "Parse ESRI/ArcInfo (ArcGrid) raster GIS files",
);

/**
 * Simple viewer for ESRI/ArcInfo (ArcGrid) geospatial data
 */
export const arcgrid_viewer = mkPackage(
  nixRaw`pkgs.haskellPackages.arcgrid-viewer`,
  "Simple viewer for ESRI/ArcInfo (ArcGrid) geospatial data",
);

/**
 * Arch Linux official and AUR web interface binding
 */
export const arch_web = mkPackage(
  nixRaw`pkgs.haskellPackages.arch-web`,
  "Arch Linux official and AUR web interface binding",
);

/**
 * Common interface using libarchive
 */
export const archive_libarchive = mkPackage(
  nixRaw`pkgs.haskellPackages.archive-libarchive`,
  "Common interface using libarchive",
);

/**
 * Backpack signature for archive libraries
 */
export const archive_sig = mkPackage(
  nixRaw`pkgs.haskellPackages.archive-sig`,
  "Backpack signature for archive libraries",
);

/**
 * Common interface using the tar package
 */
export const archive_tar = mkPackage(
  nixRaw`pkgs.haskellPackages.archive-tar`,
  "Common interface using the tar package",
);

/**
 * Common interface using the tar-bytestring package
 */
export const archive_tar_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.archive-tar-bytestring`,
  "Common interface using the tar-bytestring package",
);

/**
 * Website maintenance for Arch Linux packages
 */
export const archlinux_web = mkPackage(
  nixRaw`pkgs.haskellPackages.archlinux-web`,
  "Website maintenance for Arch Linux packages",
);

/**
 * Arduino programming in haskell using the Copilot stream DSL
 */
export const arduino_copilot = mkPackage(
  nixRaw`pkgs.haskellPackages.arduino-copilot`,
  "Arduino programming in haskell using the Copilot stream DSL",
);

/**
 * Generate Attribute-Relation File Format (ARFF) files
 */
export const arff = mkPackage(
  nixRaw`pkgs.haskellPackages.arff`,
  "Generate Attribute-Relation File Format (ARFF) files",
);

/**
 * An interpreter for the Argh! programming language in wxHaskell
 */
export const arghwxhaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.arghwxhaskell`,
  "An interpreter for the Argh! programming language in wxHaskell",
);

/**
 * Measure your code's complexity
 */
export const argon = mkPackage(
  nixRaw`pkgs.haskellPackages.argon`,
  "Measure your code's complexity",
);

/**
 * Go-to-definition for Haskell
 */
export const ariadne = mkPackage(
  nixRaw`pkgs.haskellPackages.ariadne`,
  "Go-to-definition for Haskell",
);

/**
 * Run docker-compose with help from Nix/NixOS
 */
export const arion_compose = mkPackage(
  nixRaw`pkgs.haskellPackages.arion-compose`,
  "Run docker-compose with help from Nix/NixOS",
);

/**
 * A practical arithmetic encoding (aka Godel numbering) library
 */
export const arith_encode = mkPackage(
  nixRaw`pkgs.haskellPackages.arith-encode`,
  "A practical arithmetic encoding (aka Godel numbering) library",
);

/**
 * do things with numbers
 */
export const arithmatic = mkPackage(
  nixRaw`pkgs.haskellPackages.arithmatic`,
  "do things with numbers",
);

/**
 * Natural number arithmetic
 */
export const arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.arithmetic`,
  "Natural number arithmetic",
);

/**
 * Arithmetic circuits for zkSNARKs
 */
export const arithmetic_circuits = mkPackage(
  nixRaw`pkgs.haskellPackages.arithmetic-circuits`,
  "Arithmetic circuits for zkSNARKs",
);

/**
 * Efficient basic number-theoretic functions
 */
export const arithmoi = mkPackage(
  nixRaw`pkgs.haskellPackages.arithmoi`,
  "Efficient basic number-theoretic functions",
);

/**
 * Efficient basic number-theoretic functions
 */
export const arithmoi_0_13_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.arithmoi_0_13_0_0`,
  "Efficient basic number-theoretic functions",
);

/**
 * Provides an arity-generic version of the liftA2, liftA3... liftAn functions.
 */
export const arity_generic_liftA = mkPackage(
  nixRaw`pkgs.haskellPackages.arity-generic-liftA`,
  "Provides an arity-generic version of the liftA2, liftA3... liftAn functions.",
);

/**
 * Mutable and immutable arrays
 */
export const array_0_5_6_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.array_0_5_6_0`,
  "Mutable and immutable arrays",
);

/**
 * Builders for arrays
 */
export const array_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.array-builder`,
  "Builders for arrays",
);

/**
 * Lists of chunks
 */
export const array_chunks = mkPackage(
  nixRaw`pkgs.haskellPackages.array-chunks`,
  "Lists of chunks",
);

/**
 * A simple interpreter for arrayForth, the language used on GreenArrays chips
 */
export const array_forth = mkPackage(
  nixRaw`pkgs.haskellPackages.array-forth`,
  "A simple interpreter for arrayForth, the language used on GreenArrays chips",
);

/**
 * Memoization combinators using arrays for finite sub-domains of functions
 */
export const array_memoize = mkPackage(
  nixRaw`pkgs.haskellPackages.array-memoize`,
  "Memoization combinators using arrays for finite sub-domains of functions",
);

/**
 * Primitive functions for updating many elements in mutable arrays at once
 */
export const array_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.array-utils`,
  "Primitive functions for updating many elements in mutable arrays at once",
);

/**
 * Memory-efficient ArrayList implementation
 */
export const arraylist = mkPackage(
  nixRaw`pkgs.haskellPackages.arraylist`,
  "Memory-efficient ArrayList implementation",
);

/**
 * Extra functions for Control.Arrow
 */
export const arrow_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.arrow-extras`,
  "Extra functions for Control.Arrow",
);

/**
 * functions for working with arrows
 */
export const arrow_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.arrow-utils`,
  "functions for working with arrows",
);

/**
 * Arrow classes and transformers
 */
export const arrows = mkPackage(
  nixRaw`pkgs.haskellPackages.arrows`,
  "Arrow classes and transformers",
);

/**
 * Archive execution tool
 */
export const arx = mkPackage(
  nixRaw`pkgs.haskellPackages.arx`,
  "Archive execution tool",
);

/**
 * A client for the Arxiv API
 */
export const arxiv = mkPackage(
  nixRaw`pkgs.haskellPackages.arxiv`,
  "A client for the Arxiv API",
);

/**
 * Asana API Client
 */
export const asana = mkPackage(
  nixRaw`pkgs.haskellPackages.asana`,
  "Asana API Client",
);

/**
 * Generic markup builder
 */
export const ascetic = mkPackage(
  nixRaw`pkgs.haskellPackages.ascetic`,
  "Generic markup builder",
);

/**
 * The ASCII character set and encoding
 */
export const ascii = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii`,
  "The ASCII character set and encoding",
);

/**
 * ASCII Art to Unicode Box Drawing converter
 */
export const ascii_art_to_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-art-to-unicode`,
  "ASCII Art to Unicode Box Drawing converter",
);

/**
 * ASCII letter case
 */
export const ascii_case = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-case`,
  "ASCII letter case",
);

/**
 * ASCII character without an upper/lower case distinction
 */
export const ascii_caseless = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-caseless`,
  "ASCII character without an upper/lower case distinction",
);

/**
 * A Char type representing an ASCII character
 */
export const ascii_char = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-char`,
  "A Char type representing an ASCII character",
);

/**
 * A collection of ASCII cows. Moo.
 */
export const ascii_cows = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-cows`,
  "A collection of ASCII cows. Moo.",
);

/**
 * ASCII character groups
 */
export const ascii_group = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-group`,
  "ASCII character groups",
);

/**
 * ASCII animations for the holidays!
 */
export const ascii_holidays = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-holidays`,
  "ASCII animations for the holidays!",
);

/**
 * ASCII representations of numbers
 */
export const ascii_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-numbers`,
  "ASCII representations of numbers",
);

/**
 * Various categorizations of ASCII characters
 */
export const ascii_predicates = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-predicates`,
  "Various categorizations of ASCII characters",
);

/**
 * A simple progress bar for the console
 */
export const ascii_progress = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-progress`,
  "A simple progress bar for the console",
);

/**
 * Representing ASCII with refined supersets
 */
export const ascii_superset = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-superset`,
  "Representing ASCII with refined supersets",
);

/**
 * ASCII table
 */
export const ascii_table = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-table`,
  "ASCII table",
);

/**
 * Template Haskell support for ASCII
 */
export const ascii_th = mkPackage(
  nixRaw`pkgs.haskellPackages.ascii-th`,
  "Template Haskell support for ASCII",
);

/**
 * Line charts in terminal
 */
export const asciichart = mkPackage(
  nixRaw`pkgs.haskellPackages.asciichart`,
  "Line charts in terminal",
);

/**
 * Action Script Instrumentation Compiler
 */
export const asic = mkPackage(
  nixRaw`pkgs.haskellPackages.asic`,
  "Action Script Instrumentation Compiler",
);

/**
 * asn type and encoding/decoding
 */
export const asn = mkPackage(
  nixRaw`pkgs.haskellPackages.asn`,
  "asn type and encoding/decoding",
);

/**
 * ASN1 data reader and writer in RAW, BER and DER forms
 */
export const asn1_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.asn1-encoding`,
  "ASN1 data reader and writer in RAW, BER and DER forms",
);

/**
 * Simple monadic parser for ASN1 stream types
 */
export const asn1_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.asn1-parse`,
  "Simple monadic parser for ASN1 stream types",
);

/**
 * ASN.1 types
 */
export const asn1_types = mkPackage(
  nixRaw`pkgs.haskellPackages.asn1-types`,
  "ASN.1 types",
);

/**
 * Dump ASN1 structure
 */
export const asn1dump = mkPackage(
  nixRaw`pkgs.haskellPackages.asn1dump`,
  "Dump ASN1 structure",
);

/**
 * Pipe-based interface to the Aspell program
 */
export const aspell_pipe = mkPackage(
  nixRaw`pkgs.haskellPackages.aspell-pipe`,
  "Pipe-based interface to the Aspell program",
);

/**
 * A set of assertion for writing more readable tests cases
 */
export const assert4hs = mkPackage(
  nixRaw`pkgs.haskellPackages.assert4hs`,
  "A set of assertion for writing more readable tests cases",
);

/**
 * A set of assertion for writing more readable tests cases
 */
export const assert4hs_core = mkPackage(
  nixRaw`pkgs.haskellPackages.assert4hs-core`,
  "A set of assertion for writing more readable tests cases",
);

/**
 * integration point of assert4hs and hspec
 */
export const assert4hs_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.assert4hs-hspec`,
  "integration point of assert4hs and hspec",
);

/**
 * Provider for tasty runner to run assert4hs tests
 */
export const assert4hs_tasty = mkPackage(
  nixRaw`pkgs.haskellPackages.assert4hs-tasty`,
  "Provider for tasty runner to run assert4hs tests",
);

/**
 * Syntactic sugar improving 'assert' and 'error'
 */
export const assert_failure = mkPackage(
  nixRaw`pkgs.haskellPackages.assert-failure`,
  "Syntactic sugar improving 'assert' and 'error'",
);

/**
 * A build-time Cabal library that bundles executables with assets
 */
export const asset_bundle = mkPackage(
  nixRaw`pkgs.haskellPackages.asset-bundle`,
  "A build-time Cabal library that bundles executables with assets",
);

/**
 * The Assimp asset import library
 */
export const assimp = mkPackage(
  nixRaw`pkgs.haskellPackages.assimp`,
  "The Assimp asset import library",
);

/**
 * swap and assoc: Symmetric and Semigroupy Bifunctors
 */
export const assoc = mkPackage(
  nixRaw`pkgs.haskellPackages.assoc`,
  "swap and assoc: Symmetric and Semigroupy Bifunctors",
);

/**
 * Core functionality for an SMTP client
 */
export const assumpta_core = mkPackage(
  nixRaw`pkgs.haskellPackages.assumpta-core`,
  "Core functionality for an SMTP client",
);

/**
 * A library for writing JSON
 */
export const ast_monad_json = mkPackage(
  nixRaw`pkgs.haskellPackages.ast-monad-json`,
  "A library for writing JSON",
);

/**
 * vocabulary representation for predicting program properties
 */
export const ast_path = mkPackage(
  nixRaw`pkgs.haskellPackages.ast-path`,
  "vocabulary representation for predicting program properties",
);

/**
 * General A* search algorithm
 */
export const astar = mkPackage(
  nixRaw`pkgs.haskellPackages.astar`,
  "General A* search algorithm",
);

export const astar_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.astar-monad`,
  "",
);

/**
 * A GTK-based abstract syntax tree viewer for custom languages and parsers
 */
export const astview = mkPackage(
  nixRaw`pkgs.haskellPackages.astview`,
  "A GTK-based abstract syntax tree viewer for custom languages and parsers",
);

/**
 * Interfacing between hint and astview
 */
export const astview_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.astview-utils`,
  "Interfacing between hint and astview",
);

/**
 * Run IO operations asynchronously and wait for their results
 */
export const async = mkPackage(
  nixRaw`pkgs.haskellPackages.async`,
  "Run IO operations asynchronously and wait for their results",
);

/**
 * Crossbrowser async AJAX Bindings for GHCJS
 */
export const async_ajax = mkPackage(
  nixRaw`pkgs.haskellPackages.async-ajax`,
  "Crossbrowser async AJAX Bindings for GHCJS",
);

/**
 * Useful concurrent combinators
 */
export const async_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.async-extra`,
  "Useful concurrent combinators",
);

/**
 * Extra Utilities for the Async Library
 */
export const async_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.async-extras`,
  "Extra Utilities for the Async Library",
);

/**
 * Could be useful
 */
export const async_io_either = mkPackage(
  nixRaw`pkgs.haskellPackages.async-io-either`,
  "Could be useful",
);

/**
 * A modified version of async that supports worker groups and many-to-many task dependencies
 */
export const async_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.async-pool`,
  "A modified version of async that supports worker groups and many-to-many task dependencies",
);

/**
 * Package implementing core logic for refreshing of expiring data
 */
export const async_refresh = mkPackage(
  nixRaw`pkgs.haskellPackages.async-refresh`,
  "Package implementing core logic for refreshing of expiring data",
);

/**
 * Package implementing core logic for refreshing of expiring access tokens
 */
export const async_refresh_tokens = mkPackage(
  nixRaw`pkgs.haskellPackages.async-refresh-tokens`,
  "Package implementing core logic for refreshing of expiring access tokens",
);

/**
 * Utility functions for working with aterms as generated by Minitermite
 */
export const aterm_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.aterm-utils`,
  "Utility functions for working with aterms as generated by Minitermite",
);

/**
 * Arrow Transformer Library
 */
export const atl = mkPackage(
  nixRaw`pkgs.haskellPackages.atl`,
  "Arrow Transformer Library",
);

/**
 * Skyline rectangle packing
 */
export const atlas = mkPackage(
  nixRaw`pkgs.haskellPackages.atlas`,
  "Skyline rectangle packing",
);

/**
 * Atlassian Connect snaplet for the Snap Framework and helper code
 */
export const atlassian_connect_core = mkPackage(
  nixRaw`pkgs.haskellPackages.atlassian-connect-core`,
  "Atlassian Connect snaplet for the Snap Framework and helper code",
);

/**
 * 1976 US Standard Atmosphere Model
 */
export const atmos = mkPackage(
  nixRaw`pkgs.haskellPackages.atmos`,
  "1976 US Standard Atmosphere Model",
);

/**
 * dimensional wrapper on atmos package
 */
export const atmos_dimensional = mkPackage(
  nixRaw`pkgs.haskellPackages.atmos-dimensional`,
  "dimensional wrapper on atmos package",
);

/**
 * dimensional-tf wrapper on atmos package
 */
export const atmos_dimensional_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.atmos-dimensional-tf`,
  "dimensional-tf wrapper on atmos package",
);

/**
 * Basic Atom feed construction
 */
export const atom_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.atom-basic`,
  "Basic Atom feed construction",
);

/**
 * Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).
 */
export const atom_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.atom-conduit`,
  "Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).",
);

/**
 * Convenience functions for using Atom with the MSP430 microcontroller family
 */
export const atom_msp430 = mkPackage(
  nixRaw`pkgs.haskellPackages.atom-msp430`,
  "Convenience functions for using Atom with the MSP430 microcontroller family",
);

/**
 * Mutable counters that can be modified with atomic operatinos
 */
export const atomic_counter = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-counter`,
  "Mutable counters that can be modified with atomic operatinos",
);

/**
 * Functions to atomically write to files
 */
export const atomic_file_ops = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-file-ops`,
  "Functions to atomically write to files",
);

/**
 * Generalizations of atomicModifyIORef
 */
export const atomic_modify_general = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-modify-general`,
  "Generalizations of atomicModifyIORef",
);

/**
 * A safe approach to CAS and other atomic ops in Haskell
 */
export const atomic_primops = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-primops`,
  "A safe approach to CAS and other atomic ops in Haskell",
);

/**
 * An atomic counter implemented using the FFI
 */
export const atomic_primops_foreign = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-primops-foreign`,
  "An atomic counter implemented using the FFI",
);

/**
 * Atomically write to a file
 */
export const atomic_write = mkPackage(
  nixRaw`pkgs.haskellPackages.atomic-write`,
  "Atomically write to a file",
);

/**
 * Interface to automated theorem provers
 */
export const atp = mkPackage(
  nixRaw`pkgs.haskellPackages.atp`,
  "Interface to automated theorem provers",
);

/**
 * A small collection of monad (transformer) instances
 */
export const atrans = mkPackage(
  nixRaw`pkgs.haskellPackages.atrans`,
  "A small collection of monad (transformer) instances",
);

/**
 * Faster integer division and modulus operations
 */
export const atrophy = mkPackage(
  nixRaw`pkgs.haskellPackages.atrophy`,
  "Faster integer division and modulus operations",
);

/**
 * Subtyping relations and variance roles
 */
export const attenuation = mkPackage(
  nixRaw`pkgs.haskellPackages.attenuation`,
  "Subtyping relations and variance roles",
);

/**
 * Attenuation support for Profunctors
 */
export const attenuation_profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.attenuation-profunctors`,
  "Attenuation support for Profunctors",
);

/**
 * Fast combinator parsing for bytestrings and text
 */
export const attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec`,
  "Fast combinator parsing for bytestrings and text",
);

/**
 * Fast combinator parsing for bytestrings and text
 */
export const attoparsec_0_13_2_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec_0_13_2_5`,
  "Fast combinator parsing for bytestrings and text",
);

/**
 * Parsing of aeson's Value with attoparsec
 */
export const attoparsec_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-aeson`,
  "Parsing of aeson's Value with attoparsec",
);

/**
 * Parsing of aeson's Value with attoparsec
 */
export const attoparsec_aeson_2_2_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-aeson_2_2_0_0`,
  "Parsing of aeson's Value with attoparsec",
);

/**
 * An ARFF file parser using Attoparsec
 */
export const attoparsec_arff = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-arff`,
  "An ARFF file parser using Attoparsec",
);

/**
 * Fetch only base64 characters, erroring in the attoparsec monad on failure
 */
export const attoparsec_base64 = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-base64`,
  "Fetch only base64 characters, erroring in the attoparsec monad on failure",
);

/**
 * Binary processing extensions to Attoparsec
 */
export const attoparsec_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-binary`,
  "Binary processing extensions to Attoparsec",
);

/**
 * Consume attoparsec parsers via conduit. (deprecated)
 */
export const attoparsec_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-conduit`,
  "Consume attoparsec parsers via conduit. (deprecated)",
);

/**
 * Parsers for the standard Haskell data types
 */
export const attoparsec_data = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-data`,
  "Parsers for the standard Haskell data types",
);

/**
 * Pass input from an enumerator to an Attoparsec parser
 */
export const attoparsec_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-enumerator`,
  "Pass input from an enumerator to an Attoparsec parser",
);

/**
 * Port of parsec's expression parser to attoparsec
 */
export const attoparsec_expr = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-expr`,
  "Port of parsec's expression parser to attoparsec",
);

/**
 * Use Attoparsec to parse framed protocol byte streams
 */
export const attoparsec_framer = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-framer`,
  "Use Attoparsec to parse framed protocol byte streams",
);

/**
 * Parse IP data types with attoparsec
 */
export const attoparsec_ip = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-ip`,
  "Parse IP data types with attoparsec",
);

/**
 * Parsing of ISO 8601 dates, originally from aeson
 */
export const attoparsec_iso8601 = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-iso8601`,
  "Parsing of ISO 8601 dates, originally from aeson",
);

/**
 * An adapter to convert attoparsec Parsers into blazing-fast Iteratees
 */
export const attoparsec_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-iteratee`,
  "An adapter to convert attoparsec Parsers into blazing-fast Iteratees",
);

/**
 * An Attoparsec compatibility layer for Parsec
 */
export const attoparsec_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-parsec`,
  "An Attoparsec compatibility layer for Parsec",
);

/**
 * Convenience bindings between path and attoparsec
 */
export const attoparsec_path = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-path`,
  "Convenience bindings between path and attoparsec",
);

/**
 * Conveniently run Attoparsec parsers
 */
export const attoparsec_run = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-run`,
  "Conveniently run Attoparsec parsers",
);

/**
 * (deprecated)
 */
export const attoparsec_text_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-text-enumerator`,
  "(deprecated)",
);

/**
 * Attoparsec parsers of time
 */
export const attoparsec_time = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-time`,
  "Attoparsec parsers of time",
);

/**
 * URI parser / printer using attoparsec
 */
export const attoparsec_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.attoparsec-uri`,
  "URI parser / printer using attoparsec",
);

/**
 * Embedded Turtle language compiler in Haskell, with Epic output
 */
export const atuin = mkPackage(
  nixRaw`pkgs.haskellPackages.atuin`,
  "Embedded Turtle language compiler in Haskell, with Epic output",
);

/**
 * Interchange with the Audacity sound signal editor
 */
export const audacity = mkPackage(
  nixRaw`pkgs.haskellPackages.audacity`,
  "Interchange with the Audacity sound signal editor",
);

/**
 * A battery-included audiovisual framework
 */
export const audiovisual = mkPackage(
  nixRaw`pkgs.haskellPackages.audiovisual`,
  "A battery-included audiovisual framework",
);

/**
 * A secure package manager for Arch Linux and the AUR
 */
export const aura = mkPackage(
  nixRaw`pkgs.haskellPackages.aura`,
  "A secure package manager for Arch Linux and the AUR",
);

/**
 * Authentication methods for Haskell web applications
 */
export const authenticate = mkPackage(
  nixRaw`pkgs.haskellPackages.authenticate`,
  "Authentication methods for Haskell web applications",
);

/**
 * Authentication methods for Haskell web applications
 */
export const authenticate_kerberos = mkPackage(
  nixRaw`pkgs.haskellPackages.authenticate-kerberos`,
  "Authentication methods for Haskell web applications",
);

/**
 * Library to authenticate with OAuth for Haskell web applications
 */
export const authenticate_oauth = mkPackage(
  nixRaw`pkgs.haskellPackages.authenticate-oauth`,
  "Library to authenticate with OAuth for Haskell web applications",
);

/**
 * A library for writing papers
 */
export const authoring = mkPackage(
  nixRaw`pkgs.haskellPackages.authoring`,
  "A library for writing papers",
);

/**
 * Deriving (Show|Read)(1|2)
 */
export const auto_lift_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.auto-lift-classes`,
  "Deriving (Show|Read)(1|2)",
);

/**
 * Efficiently run periodic, on-demand actions
 */
export const auto_update = mkPackage(
  nixRaw`pkgs.haskellPackages.auto-update`,
  "Efficiently run periodic, on-demand actions",
);

/**
 * Template Haskell to automatically pass values to functions
 */
export const autoapply = mkPackage(
  nixRaw`pkgs.haskellPackages.autoapply`,
  "Template Haskell to automatically pass values to functions",
);

/**
 * Self-documenting encoder and decoder
 */
export const autodocodec = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec`,
  "Self-documenting encoder and decoder",
);

/**
 * Autodocodec interpreters for openapi3
 */
export const autodocodec_openapi3 = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec-openapi3`,
  "Autodocodec interpreters for openapi3",
);

/**
 * Autodocodec interpreters for JSON Schema
 */
export const autodocodec_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec-schema`,
  "Autodocodec interpreters for JSON Schema",
);

/**
 * Autodocodec interpreters for Servant Multipart
 */
export const autodocodec_servant_multipart = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec-servant-multipart`,
  "Autodocodec interpreters for Servant Multipart",
);

/**
 * Autodocodec interpreters for swagger2
 */
export const autodocodec_swagger2 = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec-swagger2`,
  "Autodocodec interpreters for swagger2",
);

/**
 * Autodocodec interpreters for yaml
 */
export const autodocodec_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.autodocodec-yaml`,
  "Autodocodec interpreters for yaml",
);

/**
 * Automatically re-export modules
 */
export const autoexporter = mkPackage(
  nixRaw`pkgs.haskellPackages.autoexporter`,
  "Automatically re-export modules",
);

/**
 * automata
 */
export const automata = mkPackage(
  nixRaw`pkgs.haskellPackages.automata`,
  "automata",
);

/**
 * Automotive CSE emulation
 */
export const automitive_cse = mkPackage(
  nixRaw`pkgs.haskellPackages.automitive-cse`,
  "Automotive CSE emulation",
);

/**
 * Automotive CSE emulation
 */
export const automotive_cse = mkPackage(
  nixRaw`pkgs.haskellPackages.automotive-cse`,
  "Automotive CSE emulation",
);

/**
 * Generate dependencies for KDE 5 Nix expressions
 */
export const autonix_deps_kf5 = mkPackage(
  nixRaw`pkgs.haskellPackages.autonix-deps-kf5`,
  "Generate dependencies for KDE 5 Nix expressions",
);

/**
 * EDSL for Procmail scripts
 */
export const autoproc = mkPackage(
  nixRaw`pkgs.haskellPackages.autoproc`,
  "EDSL for Procmail scripts",
);

/**
 * Minimal DBus bindings for Avahi daemon (http://avahi.org)
 */
export const avahi = mkPackage(
  nixRaw`pkgs.haskellPackages.avahi`,
  "Minimal DBus bindings for Avahi daemon (http://avahi.org)",
);

/**
 * An average (arithmetic mean) monoid
 */
export const average = mkPackage(
  nixRaw`pkgs.haskellPackages.average`,
  "An average (arithmetic mean) monoid",
);

/**
 * Server-side implementation of the Avers storage model
 */
export const avers = mkPackage(
  nixRaw`pkgs.haskellPackages.avers`,
  "Server-side implementation of the Avers storage model",
);

/**
 * Types describing the core and extended Avers APIs
 */
export const avers_api = mkPackage(
  nixRaw`pkgs.haskellPackages.avers-api`,
  "Types describing the core and extended Avers APIs",
);

/**
 * Swagger documentation for the Avers API
 */
export const avers_api_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.avers-api-docs`,
  "Swagger documentation for the Avers API",
);

/**
 * Server implementation of the Avers API
 */
export const avers_server = mkPackage(
  nixRaw`pkgs.haskellPackages.avers-server`,
  "Server implementation of the Avers API",
);

/**
 * Diagrams for the Cessna 172 aircraft in aviation
 */
export const aviation_cessna172_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.aviation-cessna172-diagrams`,
  "Diagrams for the Cessna 172 aircraft in aviation",
);

/**
 * Weight and Balance for the Cessna 172 aircraft in aviation
 */
export const aviation_cessna172_weight_balance = mkPackage(
  nixRaw`pkgs.haskellPackages.aviation-cessna172-weight-balance`,
  "Weight and Balance for the Cessna 172 aircraft in aviation",
);

/**
 * Aviation Navigation functions
 */
export const aviation_navigation = mkPackage(
  nixRaw`pkgs.haskellPackages.aviation-navigation`,
  "Aviation Navigation functions",
);

/**
 * Weight and Balance structures used in aviation
 */
export const aviation_weight_balance = mkPackage(
  nixRaw`pkgs.haskellPackages.aviation-weight-balance`,
  "Weight and Balance structures used in aviation",
);

/**
 * High-level bindings to libavif
 */
export const avif = mkPackage(
  nixRaw`pkgs.haskellPackages.avif`,
  "High-level bindings to libavif",
);

/**
 * Avro serialization support for Haskell
 */
export const avro = mkPackage(
  nixRaw`pkgs.haskellPackages.avro`,
  "Avro serialization support for Haskell",
);

/**
 * High-level Awesomium bindings
 */
export const awesomium = mkPackage(
  nixRaw`pkgs.haskellPackages.awesomium`,
  "High-level Awesomium bindings",
);

/**
 * Utilities for using Awesomium with GLUT
 */
export const awesomium_glut = mkPackage(
  nixRaw`pkgs.haskellPackages.awesomium-glut`,
  "Utilities for using Awesomium with GLUT",
);

/**
 * Amazon Web Services (AWS) for Haskell
 */
export const aws = mkPackage(
  nixRaw`pkgs.haskellPackages.aws`,
  "Amazon Web Services (AWS) for Haskell",
);

/**
 * Types and optics for manipulating Amazon Resource Names (ARNs)
 */
export const aws_arn = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-arn`,
  "Types and optics for manipulating Amazon Resource Names (ARNs)",
);

/**
 * Generate signed cookies for AWS CloudFront
 */
export const aws_cloudfront_signed_cookies = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-cloudfront-signed-cookies`,
  "Generate signed cookies for AWS CloudFront",
);

/**
 * Configuration types, parsers & renderers for AWS services
 */
export const aws_configuration_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-configuration-tools`,
  "Configuration types, parsers & renderers for AWS services",
);

/**
 * Conduit-based interface for AWS DynamoDB
 */
export const aws_dynamodb_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-dynamodb-conduit`,
  "Conduit-based interface for AWS DynamoDB",
);

/**
 * Haskell bindings for Amazon DynamoDB Streams
 */
export const aws_dynamodb_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-dynamodb-streams`,
  "Haskell bindings for Amazon DynamoDB Streams",
);

/**
 * Haskell suite for the Elastic Transcoder service
 */
export const aws_elastic_transcoder = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-elastic-transcoder`,
  "Haskell suite for the Elastic Transcoder service",
);

/**
 * Bindings for Amazon Kinesis
 */
export const aws_kinesis = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-kinesis`,
  "Bindings for Amazon Kinesis",
);

/**
 * A producer & consumer client library for AWS Kinesis
 */
export const aws_kinesis_client = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-kinesis-client`,
  "A producer & consumer client library for AWS Kinesis",
);

/**
 * Reshard AWS Kinesis streams in response to Cloud Watch metrics
 */
export const aws_kinesis_reshard = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-kinesis-reshard`,
  "Reshard AWS Kinesis streams in response to Cloud Watch metrics",
);

/**
 * Haskell bindings for AWS Lambda
 */
export const aws_lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-lambda`,
  "Haskell bindings for AWS Lambda",
);

/**
 * Haskell runtime for AWS Lambda
 */
export const aws_lambda_haskell_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-lambda-haskell-runtime`,
  "Haskell runtime for AWS Lambda",
);

/**
 * Run wai applications on AWS Lambda
 */
export const aws_lambda_haskell_runtime_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-lambda-haskell-runtime-wai`,
  "Run wai applications on AWS Lambda",
);

/**
 * Keep your AWS credentials file up to date with MFA-carrying credentials
 */
export const aws_mfa_credentials = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-mfa-credentials`,
  "Keep your AWS credentials file up to date with MFA-carrying credentials",
);

/**
 * AWS SDK for Haskell
 */
export const aws_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sdk`,
  "AWS SDK for Haskell",
);

/**
 * The xml parser for aws-sdk package
 */
export const aws_sdk_xml_unordered = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sdk-xml-unordered`,
  "The xml parser for aws-sdk package",
);

/**
 * Fetch data from AWS Secrets Manager
 */
export const aws_secrets = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-secrets`,
  "Fetch data from AWS Secrets Manager",
);

/**
 * Amazon Web Services (AWS) Signature v4 HTTP request signer
 */
export const aws_sign4 = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sign4`,
  "Amazon Web Services (AWS) Signature v4 HTTP request signer",
);

/**
 * Bindings for AWS SNS Version 2013-03-31
 */
export const aws_sns = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sns`,
  "Bindings for AWS SNS Version 2013-03-31",
);

/**
 * Parse and verify AWS SNS messages
 */
export const aws_sns_verify = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sns-verify`,
  "Parse and verify AWS SNS messages",
);

/**
 * Parse and verify AWS SNS messages
 */
export const aws_sns_verify_0_0_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-sns-verify_0_0_0_3`,
  "Parse and verify AWS SNS messages",
);

/**
 * A client for AWS X-Ray
 */
export const aws_xray_client = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-xray-client`,
  "A client for AWS X-Ray",
);

/**
 * A client for AWS X-Ray integration with Persistent
 */
export const aws_xray_client_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-xray-client-persistent`,
  "A client for AWS X-Ray integration with Persistent",
);

/**
 * A client for AWS X-Ray integration with WAI
 */
export const aws_xray_client_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.aws-xray-client-wai`,
  "A client for AWS X-Ray integration with WAI",
);

/**
 * The Axel programming language
 */
export const axel = mkPackage(
  nixRaw`pkgs.haskellPackages.axel`,
  "The Axel programming language",
);

/**
 * Web EDSL for running in browsers and server nodes using transient
 */
export const axiom = mkPackage(
  nixRaw`pkgs.haskellPackages.axiom`,
  "Web EDSL for running in browsers and server nodes using transient",
);

/**
 * Interact with Azimuth from Haskell
 */
export const azimuth_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.azimuth-hs`,
  "Interact with Azimuth from Haskell",
);

/**
 * Azure Functions Worker
 */
export const azure_functions_worker = mkPackage(
  nixRaw`pkgs.haskellPackages.azure-functions-worker`,
  "Azure Functions Worker",
);

/**
 * Haskell bindings for the Microsoft Azure Service Management API
 */
export const azure_service_api = mkPackage(
  nixRaw`pkgs.haskellPackages.azure-service-api`,
  "Haskell bindings for the Microsoft Azure Service Management API",
);

/**
 * Haskell wrapper over Microsoft Azure ServiceBus REST API
 */
export const azure_servicebus = mkPackage(
  nixRaw`pkgs.haskellPackages.azure-servicebus`,
  "Haskell wrapper over Microsoft Azure ServiceBus REST API",
);

/**
 * A tool and library for building virtual machine images
 */
export const b9 = mkPackage(
  nixRaw`pkgs.haskellPackages.b9`,
  "A tool and library for building virtual machine images",
);

/**
 * Immutable disk-based B* trees
 */
export const b_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.b-tree`,
  "Immutable disk-based B* trees",
);

/**
 * An implementation of a simple 2-player board game
 */
export const babylon = mkPackage(
  nixRaw`pkgs.haskellPackages.babylon`,
  "An implementation of a simple 2-player board game",
);

/**
 * A client library to access Backblaze B2 cloud storage in Haskell
 */
export const backblaze_b2_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.backblaze-b2-hs`,
  "A client library to access Backblaze B2 cloud storage in Haskell",
);

/**
 * Rotates backdrops for X11 displays using Imagemagic
 */
export const backdropper = mkPackage(
  nixRaw`pkgs.haskellPackages.backdropper`,
  "Rotates backdrops for X11 displays using Imagemagic",
);

/**
 * Heterogeneous automatic differentation
 */
export const backprop = mkPackage(
  nixRaw`pkgs.haskellPackages.backprop`,
  "Heterogeneous automatic differentation",
);

/**
 * A backtracking monad
 */
export const backtracking = mkPackage(
  nixRaw`pkgs.haskellPackages.backtracking`,
  "A backtracking monad",
);

/**
 * braindead utility to compose Xinerama backgrounds
 */
export const bacteria = mkPackage(
  nixRaw`pkgs.haskellPackages.bacteria`,
  "braindead utility to compose Xinerama backgrounds",
);

/**
 * Text layout engine built on top of HarfBuzz
 */
export const balkon = mkPackage(
  nixRaw`pkgs.haskellPackages.balkon`,
  "Text layout engine built on top of HarfBuzz",
);

/**
 * Shipwire API client
 */
export const ballast = mkPackage(
  nixRaw`pkgs.haskellPackages.ballast`,
  "Shipwire API client",
);

/**
 * A blog engine on Hack
 */
export const bamboo = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo`,
  "A blog engine on Hack",
);

/**
 * bamboo-launcher
 */
export const bamboo_launcher = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo-launcher`,
  "bamboo-launcher",
);

/**
 * A highlight middleware
 */
export const bamboo_plugin_highlight = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo-plugin-highlight`,
  "A highlight middleware",
);

/**
 * A photo album middleware
 */
export const bamboo_plugin_photo = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo-plugin-photo`,
  "A photo album middleware",
);

/**
 * bamboo blueprint theme
 */
export const bamboo_theme_blueprint = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo-theme-blueprint`,
  "bamboo blueprint theme",
);

/**
 * bamboo mini html5 theme
 */
export const bamboo_theme_mini_html5 = mkPackage(
  nixRaw`pkgs.haskellPackages.bamboo-theme-mini-html5`,
  "bamboo mini html5 theme",
);

/**
 * A Windows Installer (MSI) generator framework
 */
export const bamse = mkPackage(
  nixRaw`pkgs.haskellPackages.bamse`,
  "A Windows Installer (MSI) generator framework",
);

/**
 * A program to extract various information from BAM alignmnet files
 */
export const bamstats = mkPackage(
  nixRaw`pkgs.haskellPackages.bamstats`,
  "A program to extract various information from BAM alignmnet files",
);

/**
 * For when a type should never be an instance of a class
 */
export const ban_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.ban-instance`,
  "For when a type should never be an instance of a class",
);

/**
 * US bank holidays
 */
export const bank_holiday_usa = mkPackage(
  nixRaw`pkgs.haskellPackages.bank-holiday-usa`,
  "US bank holidays",
);

/**
 * Calculation of bank holidays in England and Wales
 */
export const bank_holidays_england = mkPackage(
  nixRaw`pkgs.haskellPackages.bank-holidays-england`,
  "Calculation of bank holidays in England and Wales",
);

/**
 * Classes for working with types that can change clothes
 */
export const barbies = mkPackage(
  nixRaw`pkgs.haskellPackages.barbies`,
  "Classes for working with types that can change clothes",
);

/**
 * Barbies with layered clothes
 */
export const barbies_layered = mkPackage(
  nixRaw`pkgs.haskellPackages.barbies-layered`,
  "Barbies with layered clothes",
);

/**
 * Create status bar menus for macOS from executables
 */
export const barbly = mkPackage(
  nixRaw`pkgs.haskellPackages.barbly`,
  "Create status bar menus for macOS from executables",
);

/**
 * A web based environment for learning and tinkering with Haskell
 */
export const barley = mkPackage(
  nixRaw`pkgs.haskellPackages.barley`,
  "A web based environment for learning and tinkering with Haskell",
);

/**
 * lens via string literals
 */
export const barlow_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.barlow-lens`,
  "lens via string literals",
);

/**
 * Fast RFC 4648-compliant Base16 encoding
 */
export const base16 = mkPackage(
  nixRaw`pkgs.haskellPackages.base16`,
  "Fast RFC 4648-compliant Base16 encoding",
);

/**
 * Fast RFC 4648-compliant Base16 encoding
 */
export const base16_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.base16_1_0`,
  "Fast RFC 4648-compliant Base16 encoding",
);

/**
 * RFC 4648-compliant Base16 encodings for ByteStrings
 */
export const base16_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.base16-bytestring`,
  "RFC 4648-compliant Base16 encodings for ByteStrings",
);

/**
 * Fast base16 (hex) encoding and decoding for ByteStrings
 */
export const base16_bytestring_0_1_1_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.base16-bytestring_0_1_1_7`,
  "Fast base16 (hex) encoding and decoding for ByteStrings",
);

/**
 * Fast RFC 4648-compliant Base32 encoding
 */
export const base32 = mkPackage(
  nixRaw`pkgs.haskellPackages.base32`,
  "Fast RFC 4648-compliant Base32 encoding",
);

/**
 * Fast base32 and base32hex codec for ByteStrings
 */
export const base32_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.base32-bytestring`,
  "Fast base32 and base32hex codec for ByteStrings",
);

/**
 * Fast and safe representation of a Base-32 string
 */
export const base32string = mkPackage(
  nixRaw`pkgs.haskellPackages.base32string`,
  "Fast and safe representation of a Base-32 string",
);

/**
 * Implementation of BASE58 transcoding for ByteStrings
 */
export const base58_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.base58-bytestring`,
  "Implementation of BASE58 transcoding for ByteStrings",
);

/**
 * Fast and safe representation of a Base-58 string
 */
export const base58string = mkPackage(
  nixRaw`pkgs.haskellPackages.base58string`,
  "Fast and safe representation of a Base-58 string",
);

/**
 * A modern RFC 4648-compliant Base64 library
 */
export const base64 = mkPackage(
  nixRaw`pkgs.haskellPackages.base64`,
  "A modern RFC 4648-compliant Base64 library",
);

/**
 * Base64 encoding of byte sequences
 */
export const base64_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.base64-bytes`,
  "Base64 encoding of byte sequences",
);

/**
 * Fast base64 encoding and decoding for ByteStrings
 */
export const base64_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.base64-bytestring`,
  "Fast base64 encoding and decoding for ByteStrings",
);

/**
 * A newtype around ByteString, for base64 encoding
 */
export const base64_bytestring_type = mkPackage(
  nixRaw`pkgs.haskellPackages.base64-bytestring-type`,
  "A newtype around ByteString, for base64 encoding",
);

/**
 * Base64 implementation for String's
 */
export const base64_string = mkPackage(
  nixRaw`pkgs.haskellPackages.base64-string`,
  "Base64 implementation for String's",
);

/**
 * A Generic Base91 Encoder & Decoder
 */
export const base91 = mkPackage(
  nixRaw`pkgs.haskellPackages.base91`,
  "A Generic Base91 Encoder & Decoder",
);

/**
 * Basic libraries
 */
export const base_4_18_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.base_4_18_1_0`,
  "Basic libraries",
);

/**
 * A compatibility layer for base
 */
export const base_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.base-compat`,
  "A compatibility layer for base",
);

/**
 * A compatibility layer for base
 */
export const base_compat_0_13_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.base-compat_0_13_0`,
  "A compatibility layer for base",
);

/**
 * base-compat with extra batteries
 */
export const base_compat_batteries = mkPackage(
  nixRaw`pkgs.haskellPackages.base-compat-batteries`,
  "base-compat with extra batteries",
);

/**
 * base-compat with extra batteries
 */
export const base_compat_batteries_0_13_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.base-compat-batteries_0_13_0`,
  "base-compat with extra batteries",
);

/**
 * "base" package sans "Prelude" module
 */
export const base_noprelude = mkPackage(
  nixRaw`pkgs.haskellPackages.base-noprelude`,
  "\"base\" package sans \"Prelude\" module",
);

/**
 * Backwards-compatible orphan instances for base
 */
export const base_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.base-orphans`,
  "Backwards-compatible orphan instances for base",
);

/**
 * Featureful preludes formed solely from the "base" package
 */
export const base_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.base-prelude`,
  "Featureful preludes formed solely from the \"base\" package",
);

/**
 * Unicode alternatives for common functions and operators
 */
export const base_unicode_symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.base-unicode-symbols`,
  "Unicode alternatives for common functions and operators",
);

/**
 * Foundation scrap box of array & string
 */
export const basement = mkPackage(
  nixRaw`pkgs.haskellPackages.basement`,
  "Foundation scrap box of array & string",
);

/**
 * Foundation scrap box of array & string
 */
export const basement_0_0_14 = mkPackage(
  nixRaw`pkgs.haskellPackages.basement_0_0_14`,
  "Foundation scrap box of array & string",
);

export const basen_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.basen-bytestring`,
  "",
);

/**
 * Baserock Definitions Schema
 */
export const baserock_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.baserock-schema`,
  "Baserock Definitions Schema",
);

/**
 * Bash generation library
 */
export const bash = mkPackage(
  nixRaw`pkgs.haskellPackages.bash`,
  "Bash generation library",
);

/**
 * Lifting values from base types
 */
export const basic = mkPackage(
  nixRaw`pkgs.haskellPackages.basic`,
  "Lifting values from base types",
);

/**
 * A small package to access the cpuid instruction directly
 */
export const basic_cpuid = mkPackage(
  nixRaw`pkgs.haskellPackages.basic-cpuid`,
  "A small package to access the cpuid instruction directly",
);

/**
 * Basic lens type and functions
 */
export const basic_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.basic-lens`,
  "Basic lens type and functions",
);

/**
 * An enhanced core prelude; a common foundation for alternate preludes
 */
export const basic_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.basic-prelude`,
  "An enhanced core prelude; a common foundation for alternate preludes",
);

/**
 * Simplify queuing up data and processing it in batch
 */
export const batch = mkPackage(
  nixRaw`pkgs.haskellPackages.batch`,
  "Simplify queuing up data and processing it in batch",
);

/**
 * Make Linux or MacOS do things like "rename *.mp3 *.mp4"
 */
export const batch_rename = mkPackage(
  nixRaw`pkgs.haskellPackages.batch-rename`,
  "Make Linux or MacOS do things like \"rename *.mp3 *.mp4\"",
);

/**
 * Batch processing toolset for Linux / Unix
 */
export const batchd = mkPackage(
  nixRaw`pkgs.haskellPackages.batchd`,
  "Batch processing toolset for Linux / Unix",
);

/**
 * Core modules of batchd, to use in batchd extensions
 */
export const batchd_core = mkPackage(
  nixRaw`pkgs.haskellPackages.batchd-core`,
  "Core modules of batchd, to use in batchd extensions",
);

/**
 * docker containers host controller for batchd
 */
export const batchd_docker = mkPackage(
  nixRaw`pkgs.haskellPackages.batchd-docker`,
  "docker containers host controller for batchd",
);

/**
 * host controller for batchd, which controls virtual machines via libvirt library
 */
export const batchd_libvirt = mkPackage(
  nixRaw`pkgs.haskellPackages.batchd-libvirt`,
  "host controller for batchd, which controls virtual machines via libvirt library",
);

/**
 * An Applicative Functor deferring actions to run in a batch later
 */
export const batching = mkPackage(
  nixRaw`pkgs.haskellPackages.batching`,
  "An Applicative Functor deferring actions to run in a batch later",
);

/**
 * Yesod integration for the battlenet package
 */
export const battlenet_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.battlenet-yesod`,
  "Yesod integration for the battlenet package",
);

/**
 * Public API definitions of BattlePlace.io service
 */
export const battleplace_api = mkPackage(
  nixRaw`pkgs.haskellPackages.battleplace-api`,
  "Public API definitions of BattlePlace.io service",
);

/**
 * Compute number of possible arrangements in the battleship game
 */
export const battleship_combinatorics = mkPackage(
  nixRaw`pkgs.haskellPackages.battleship-combinatorics`,
  "Compute number of possible arrangements in the battleship game",
);

/**
 * A web-based implementation of battleships including an AI opponent
 */
export const battleships = mkPackage(
  nixRaw`pkgs.haskellPackages.battleships`,
  "A web-based implementation of battleships including an AI opponent",
);

/**
 * Framework for inferring generative probabilistic models with Gibbs sampling
 */
export const bayes_stack = mkPackage(
  nixRaw`pkgs.haskellPackages.bayes-stack`,
  "Framework for inferring generative probabilistic models with Gibbs sampling",
);

/**
 * Locate Bazel runfiles location
 */
export const bazel_runfiles = mkPackage(
  nixRaw`pkgs.haskellPackages.bazel-runfiles`,
  "Locate Bazel runfiles location",
);

/**
 * Ability to read, write, and modify BBDB files
 */
export const bbdb = mkPackage(
  nixRaw`pkgs.haskellPackages.bbdb`,
  "Ability to read, write, and modify BBDB files",
);

/**
 * Tools for reading Big Binary Indexed files, e.g., bigBed, bigWig
 */
export const bbi = mkPackage(
  nixRaw`pkgs.haskellPackages.bbi`,
  "Tools for reading Big Binary Indexed files, e.g., bigBed, bigWig",
);

/**
 * Language tags as specified by BCP 47
 */
export const bcp47 = mkPackage(
  nixRaw`pkgs.haskellPackages.bcp47`,
  "Language tags as specified by BCP 47",
);

/**
 * BCP47 orphan instances
 */
export const bcp47_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.bcp47-orphans`,
  "BCP47 orphan instances",
);

/**
 * Haskell bindings to the bcrypt password hash
 */
export const bcrypt = mkPackage(
  nixRaw`pkgs.haskellPackages.bcrypt`,
  "Haskell bindings to the bcrypt password hash",
);

/**
 * Tools for managing a content store of software packages
 */
export const bdcs = mkPackage(
  nixRaw`pkgs.haskellPackages.bdcs`,
  "Tools for managing a content store of software packages",
);

/**
 * BDCS API Server
 */
export const bdcs_api = mkPackage(
  nixRaw`pkgs.haskellPackages.bdcs-api`,
  "BDCS API Server",
);

/**
 * DB migration library for beam, targeting Postgres
 */
export const beam_automigrate = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-automigrate`,
  "DB migration library for beam, targeting Postgres",
);

/**
 * Type-safe, feature-complete SQL query and manipulation interface for Haskell
 */
export const beam_core = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-core`,
  "Type-safe, feature-complete SQL query and manipulation interface for Haskell",
);

/**
 * SQL DDL support and migrations support library for Beam
 */
export const beam_migrate = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-migrate`,
  "SQL DDL support and migrations support library for Beam",
);

/**
 * Connection layer between beam and postgres
 */
export const beam_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-postgres`,
  "Connection layer between beam and postgres",
);

/**
 * Beam driver for SQLite
 */
export const beam_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-sqlite`,
  "Beam driver for SQLite",
);

/**
 * Template Haskell utilities for beam
 */
export const beam_th = mkPackage(
  nixRaw`pkgs.haskellPackages.beam-th`,
  "Template Haskell utilities for beam",
);

/**
 * FRP Yampa replacement implemented with Monadic Stream Functions
 */
export const bearriver = mkPackage(
  nixRaw`pkgs.haskellPackages.bearriver`,
  "FRP Yampa replacement implemented with Monadic Stream Functions",
);

/**
 * A pretty-printer for higher-order logic
 */
export const beautifHOL = mkPackage(
  nixRaw`pkgs.haskellPackages.beautifHOL`,
  "A pretty-printer for higher-order logic",
);

/**
 * Template Haskell extensions to the Bech32 library
 */
export const bech32_th = mkPackage(
  nixRaw`pkgs.haskellPackages.bech32-th`,
  "Template Haskell extensions to the Bech32 library",
);

/**
 * Bindings to the beeminder.com JSON API
 */
export const beeminder_api = mkPackage(
  nixRaw`pkgs.haskellPackages.beeminder-api`,
  "Bindings to the beeminder.com JSON API",
);

/**
 * Bein is a provenance and workflow management system for bioinformatics
 */
export const bein = mkPackage(
  nixRaw`pkgs.haskellPackages.bein`,
  "Bein is a provenance and workflow management system for bioinformatics",
);

/**
 * parsing, rendering and manipulating the structured communication of Belgian financial transactions
 */
export const belgian_structured_communication = mkPackage(
  nixRaw`pkgs.haskellPackages.belgian-structured-communication`,
  "parsing, rendering and manipulating the structured communication of Belgian financial transactions",
);

/**
 * HTTP client DSL
 */
export const belka = mkPackage(
  nixRaw`pkgs.haskellPackages.belka`,
  "HTTP client DSL",
);

/**
 * Command-line benchmark tool
 */
export const bench = mkPackage(
  nixRaw`pkgs.haskellPackages.bench`,
  "Command-line benchmark tool",
);

/**
 * Test the time it takes to run a haskell function
 */
export const benchmark_function = mkPackage(
  nixRaw`pkgs.haskellPackages.benchmark-function`,
  "Test the time it takes to run a haskell function",
);

/**
 * Micro-benchmarking with detailed statistics
 */
export const benchpress = mkPackage(
  nixRaw`pkgs.haskellPackages.benchpress`,
  "Micro-benchmarking with detailed statistics",
);

/**
 * Parsers and printers for bencoded data
 */
export const bencode = mkPackage(
  nixRaw`pkgs.haskellPackages.bencode`,
  "Parsers and printers for bencoded data",
);

/**
 * A library for encoding and decoding of BEncode data
 */
export const bencoding = mkPackage(
  nixRaw`pkgs.haskellPackages.bencoding`,
  "A library for encoding and decoding of BEncode data",
);

/**
 * Simplify tests where Either or Maybe types are returned from monadic code
 */
export const benri_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.benri-hspec`,
  "Simplify tests where Either or Maybe types are returned from monadic code",
);

/**
 *  Manage stateful components
 */
export const bento = mkPackage(
  nixRaw`pkgs.haskellPackages.bento`,
  " Manage stateful components",
);

/**
 * Function combinator "between" and derived combinators
 */
export const between = mkPackage(
  nixRaw`pkgs.haskellPackages.between`,
  "Function combinator \"between\" and derived combinators",
);

export const bf_cata = mkPackage(
  nixRaw`pkgs.haskellPackages.bf-cata`,
  "",
);

/**
 * Bidirectionalization for Free! (POPL'09)
 */
export const bff = mkPackage(
  nixRaw`pkgs.haskellPackages.bff`,
  "Bidirectionalization for Free! (POPL'09)",
);

/**
 * "Bidirectionalization for Free" for Monomorphic Transformations
 */
export const bff_mono = mkPackage(
  nixRaw`pkgs.haskellPackages.bff-mono`,
  "\"Bidirectionalization for Free\" for Monomorphic Transformations",
);

/**
 * Implementation of the BGAPI serial protocol
 */
export const bglib = mkPackage(
  nixRaw`pkgs.haskellPackages.bglib`,
  "Implementation of the BGAPI serial protocol",
);

/**
 * Simple terminal GUI for local hoogle
 */
export const bhoogle = mkPackage(
  nixRaw`pkgs.haskellPackages.bhoogle`,
  "Simple terminal GUI for local hoogle",
);

/**
 * Parse, format and processing BibTeX files
 */
export const bibtex = mkPackage(
  nixRaw`pkgs.haskellPackages.bibtex`,
  "Parse, format and processing BibTeX files",
);

/**
 * Bifunctors
 */
export const bifunctor = mkPackage(
  nixRaw`pkgs.haskellPackages.bifunctor`,
  "Bifunctors",
);

/**
 * Compatibility package for the Bifunctor, Bifoldable, and Bitraversable classes
 */
export const bifunctor_classes_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.bifunctor-classes-compat`,
  "Compatibility package for the Bifunctor, Bifoldable, and Bitraversable classes",
);

/**
 * Bifunctors
 */
export const bifunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.bifunctors`,
  "Bifunctors",
);

/**
 * Bifunctors
 */
export const bifunctors_5_6_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.bifunctors_5_6_1`,
  "Bifunctors",
);

/**
 * API wrapper for Big Huge Thesaurus
 */
export const bighugethesaurus = mkPackage(
  nixRaw`pkgs.haskellPackages.bighugethesaurus`,
  "API wrapper for Big Huge Thesaurus",
);

/**
 * A parser for the Billboard chord dataset
 */
export const billboard_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.billboard-parser`,
  "A parser for the Billboard chord dataset",
);

/**
 * Leksah library
 */
export const billeksah_forms = mkPackage(
  nixRaw`pkgs.haskellPackages.billeksah-forms`,
  "Leksah library",
);

/**
 * Leksah plugin base
 */
export const billeksah_main = mkPackage(
  nixRaw`pkgs.haskellPackages.billeksah-main`,
  "Leksah plugin base",
);

/**
 * Leksah library
 */
export const billeksah_pane = mkPackage(
  nixRaw`pkgs.haskellPackages.billeksah-pane`,
  "Leksah library",
);

/**
 * Bidirectional mapping between two key types
 */
export const bimap = mkPackage(
  nixRaw`pkgs.haskellPackages.bimap`,
  "Bidirectional mapping between two key types",
);

/**
 * Two-column database server
 */
export const bimap_server = mkPackage(
  nixRaw`pkgs.haskellPackages.bimap-server`,
  "Two-column database server",
);

/**
 * bijections with multiple implementations
 */
export const bimaps = mkPackage(
  nixRaw`pkgs.haskellPackages.bimaps`,
  "bijections with multiple implementations",
);

/**
 * Bin: binary natural numbers
 */
export const bin = mkPackage(
  nixRaw`pkgs.haskellPackages.bin`,
  "Bin: binary natural numbers",
);

/**
 * Generate CSV Exports of your Binance Trade History
 */
export const binance_exports = mkPackage(
  nixRaw`pkgs.haskellPackages.binance-exports`,
  "Generate CSV Exports of your Binance Trade History",
);

/**
 * Binary serialisation for Haskell values using lazy ByteStrings
 */
export const binary_0_8_9_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.binary_0_8_9_1`,
  "Binary serialisation for Haskell values using lazy ByteStrings",
);

/**
 * data serialization/deserialization conduit library
 */
export const binary_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-conduit`,
  "data serialization/deserialization conduit library",
);

/**
 * Simple wrappers around enum types
 */
export const binary_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-enum`,
  "Simple wrappers around enum types",
);

/**
 * read/write binary file
 */
export const binary_file = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-file`,
  "read/write binary file",
);

/**
 * Generic binary serialisation using binary and syb
 */
export const binary_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-generic`,
  "Generic binary serialisation using binary and syb",
);

/**
 * Combinators and utilities to make Generic-based deriving of Binary easier and more expressive
 */
export const binary_generic_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-generic-combinators`,
  "Combinators and utilities to make Generic-based deriving of Binary easier and more expressive",
);

/**
 * Backport ieee754 float double combinators to older binary
 */
export const binary_ieee754 = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-ieee754`,
  "Backport ieee754 float double combinators to older binary",
);

/**
 * Orphan instances for binary
 */
export const binary_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-instances`,
  "Orphan instances for binary",
);

/**
 * Read and write values of types that implement Binary
 */
export const binary_io = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-io`,
  "Read and write values of types that implement Binary",
);

/**
 * Lists of length a power of two
 */
export const binary_list = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-list`,
  "Lists of length a power of two",
);

/**
 * Extends Haskell with binary literals
 */
export const binary_literal_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-literal-qq`,
  "Extends Haskell with binary literals",
);

/**
 * Compatibility package for binary; provides instances
 */
export const binary_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-orphans`,
  "Compatibility package for binary; provides instances",
);

/**
 * An efficient but limited parser API specialised to bytestrings
 */
export const binary_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-parser`,
  "An efficient but limited parser API specialised to bytestrings",
);

/**
 * Monad to ease implementing a binary network protocol over ZeroMQ
 */
export const binary_protocol_zmq = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-protocol-zmq`,
  "Monad to ease implementing a binary network protocol over ZeroMQ",
);

/**
 * Binary and exponential searches
 */
export const binary_search = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-search`,
  "Binary and exponential searches",
);

/**
 * Yet Another Binary Serialisation Library (compatibility shim)
 */
export const binary_serialise_cbor = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-serialise-cbor`,
  "Yet Another Binary Serialisation Library (compatibility shim)",
);

/**
 * Sharing for the binary package
 */
export const binary_shared = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-shared`,
  "Sharing for the binary package",
);

/**
 * Simple wrapper around Data.Binary, which adds StateT to Get/Put monads.
 */
export const binary_state = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-state`,
  "Simple wrapper around Data.Binary, which adds StateT to Get/Put monads.",
);

/**
 * data serialization/deserialization io-streams library
 */
export const binary_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-streams`,
  "data serialization/deserialization io-streams library",
);

/**
 * Tagged binary serialisation
 */
export const binary_tagged = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-tagged`,
  "Tagged binary serialisation",
);

/**
 * VarInt encoding/decoding via Data.Binary
 */
export const binary_varint = mkPackage(
  nixRaw`pkgs.haskellPackages.binary-varint`,
  "VarInt encoding/decoding via Data.Binary",
);

/**
 * Binary serialization with deferred loading
 */
export const binarydefer = mkPackage(
  nixRaw`pkgs.haskellPackages.binarydefer`,
  "Binary serialization with deferred loading",
);

/**
 * Haskell bindings to binaryen
 */
export const binaryen = mkPackage(
  nixRaw`pkgs.haskellPackages.binaryen`,
  "Haskell bindings to binaryen",
);

/**
 * Variable binding for abstract syntax tree
 */
export const binder = mkPackage(
  nixRaw`pkgs.haskellPackages.binder`,
  "Variable binding for abstract syntax tree",
);

/**
 * Data Binding in Gtk2Hs
 */
export const binding_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.binding-gtk`,
  "Data Binding in Gtk2Hs",
);

/**
 * Data Binding in WxHaskell
 */
export const binding_wx = mkPackage(
  nixRaw`pkgs.haskellPackages.binding-wx`,
  "Data Binding in WxHaskell",
);

/**
 * Deprecated package
 */
export const bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings`,
  "Deprecated package",
);

/**
 * FFI domain specific language, on top of hsc2hs
 */
export const bindings_DSL = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-DSL`,
  "FFI domain specific language, on top of hsc2hs",
);

/**
 * Low-level bindings to GLFW OpenGL library
 */
export const bindings_GLFW = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-GLFW`,
  "Low-level bindings to GLFW OpenGL library",
);

/**
 * Low level bindings to Apache Portable Runtime Utility (APR Utility)
 */
export const bindings_apr_util = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-apr-util`,
  "Low level bindings to Apache Portable Runtime Utility (APR Utility)",
);

/**
 * Low level bindings to audiofile
 */
export const bindings_audiofile = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-audiofile`,
  "Low level bindings to audiofile",
);

/**
 * Very low-level FFI bindings for Codec2
 */
export const bindings_codec2 = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-codec2`,
  "Very low-level FFI bindings for Codec2",
);

/**
 * Low level bindings to DirectFB
 */
export const bindings_directfb = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-directfb`,
  "Low level bindings to DirectFB",
);

/**
 * Low level bindings to GLib
 */
export const bindings_glib = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-glib`,
  "Low level bindings to GLib",
);

/**
 * Low level bindings supporting GObject and derived libraries
 */
export const bindings_gobject = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-gobject`,
  "Low level bindings supporting GObject and derived libraries",
);

/**
 * Project bindings-* raw interface to gpgme
 */
export const bindings_gpgme = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-gpgme`,
  "Project bindings-* raw interface to gpgme",
);

/**
 * Low level bindings supporting GTS, the GNU Triangulated Surface Library
 */
export const bindings_gts = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-gts`,
  "Low level bindings supporting GTS, the GNU Triangulated Surface Library",
);

/**
 * Low level bindings to the C levmar (Levenberg-Marquardt) library
 */
export const bindings_levmar = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-levmar`,
  "Low level bindings to the C levmar (Levenberg-Marquardt) library",
);

/**
 * Low level binding to libcddb
 */
export const bindings_libcddb = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-libcddb`,
  "Low level binding to libcddb",
);

/**
 * Low level bindings to libffi
 */
export const bindings_libffi = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-libffi`,
  "Low level bindings to libffi",
);

/**
 * Low level bindings to libzip
 */
export const bindings_libzip = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-libzip`,
  "Low level bindings to libzip",
);

/**
 * bindings to Video For Linux Two (v4l2) kernel interfaces
 */
export const bindings_linux_videodev2 = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-linux-videodev2`,
  "bindings to Video For Linux Two (v4l2) kernel interfaces",
);

/**
 * Direct Haskell bindings to LXC (Linux containers) C API
 */
export const bindings_lxc = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-lxc`,
  "Direct Haskell bindings to LXC (Linux containers) C API",
);

/**
 * (deprecated) see bindings-posix instead
 */
export const bindings_mmap = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-mmap`,
  "(deprecated) see bindings-posix instead",
);

/**
 * bindings to nettle crypto library
 */
export const bindings_nettle = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-nettle`,
  "bindings to nettle crypto library",
);

/**
 * parport bindings
 */
export const bindings_parport = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-parport`,
  "parport bindings",
);

/**
 * Low-level bindings to portaudio library
 */
export const bindings_portaudio = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-portaudio`,
  "Low-level bindings to portaudio library",
);

/**
 * Project bindings-* raw interface to Posix
 */
export const bindings_posix = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-posix`,
  "Project bindings-* raw interface to Posix",
);

/**
 * Low-level bindings to the potrace bitmap tracing library
 */
export const bindings_potrace = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-potrace`,
  "Low-level bindings to the potrace bitmap tracing library",
);

/**
 * PPDev bindings
 */
export const bindings_ppdev = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-ppdev`,
  "PPDev bindings",
);

/**
 * Wrapping saga_cmd
 */
export const bindings_saga_cmd = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-saga-cmd`,
  "Wrapping saga_cmd",
);

/**
 * FFI bindings to libsane
 */
export const bindings_sane = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-sane`,
  "FFI bindings to libsane",
);

/**
 * Low-level bindings to sophia library
 */
export const bindings_sophia = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-sophia`,
  "Low-level bindings to sophia library",
);

/**
 * Low level bindings to sqlite3
 */
export const bindings_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-sqlite3`,
  "Low level bindings to sqlite3",
);

/**
 * Low level bindings to libsvm
 */
export const bindings_svm = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-svm`,
  "Low level bindings to libsvm",
);

/**
 * Low-level binding to POSIX uname(3)
 */
export const bindings_uname = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-uname`,
  "Low-level binding to POSIX uname(3)",
);

/**
 * Bindings to the Yices theorem prover
 */
export const bindings_yices = mkPackage(
  nixRaw`pkgs.haskellPackages.bindings-yices`,
  "Bindings to the Yices theorem prover",
);

/**
 * A variation of Data.Dynamic.Dynamic with a Binary instance
 */
export const bindynamic = mkPackage(
  nixRaw`pkgs.haskellPackages.bindynamic`,
  "A variation of Data.Dynamic.Dynamic with a Binary instance",
);

/**
 * Example project using binembed to embed data in object files
 */
export const binembed_example = mkPackage(
  nixRaw`pkgs.haskellPackages.binembed-example`,
  "Example project using binembed to embed data in object files",
);

/**
 * A collection of various methods for reading and writing bini files
 */
export const bini = mkPackage(
  nixRaw`pkgs.haskellPackages.bini`,
  "A collection of various methods for reading and writing bini files",
);

/**
 * Encode precise binary representations directly in types
 */
export const binrep = mkPackage(
  nixRaw`pkgs.haskellPackages.binrep`,
  "Encode precise binary representations directly in types",
);

/**
 * Aggregate continuous values into discrete bins
 */
export const bins = mkPackage(
  nixRaw`pkgs.haskellPackages.bins`,
  "Aggregate continuous values into discrete bins",
);

/**
 * Library for reading ace assembly files
 */
export const bioace = mkPackage(
  nixRaw`pkgs.haskellPackages.bioace`,
  "Library for reading ace assembly files",
);

/**
 * Data structures and helper functions for calculating alignments
 */
export const bioalign = mkPackage(
  nixRaw`pkgs.haskellPackages.bioalign`,
  "Data structures and helper functions for calculating alignments",
);

/**
 * Library for reading fasta sequence files
 */
export const biofasta = mkPackage(
  nixRaw`pkgs.haskellPackages.biofasta`,
  "Library for reading fasta sequence files",
);

/**
 * A library for reading FASTQ files
 */
export const biofastq = mkPackage(
  nixRaw`pkgs.haskellPackages.biofastq`,
  "A library for reading FASTQ files",
);

/**
 * A collection of bioinformatics tools
 */
export const bioinformatics_toolkit = mkPackage(
  nixRaw`pkgs.haskellPackages.bioinformatics-toolkit`,
  "A collection of bioinformatics tools",
);

/**
 * Library for reading phd sequence files
 */
export const biophd = mkPackage(
  nixRaw`pkgs.haskellPackages.biophd`,
  "Library for reading phd sequence files",
);

/**
 * Library and executables for working with PSL files
 */
export const biopsl = mkPackage(
  nixRaw`pkgs.haskellPackages.biopsl`,
  "Library and executables for working with PSL files",
);

/**
 * Library and executables for working with SFF files
 */
export const biosff = mkPackage(
  nixRaw`pkgs.haskellPackages.biosff`,
  "Library and executables for working with SFF files",
);

/**
 * Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal)
 */
export const biostockholm = mkPackage(
  nixRaw`pkgs.haskellPackages.biostockholm`,
  "Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal)",
);

/**
 * BIP-0032: Hierarchical Deterministic Wallets for Bitcoin and other cryptocurrencies
 */
export const bip32 = mkPackage(
  nixRaw`pkgs.haskellPackages.bip32`,
  "BIP-0032: Hierarchical Deterministic Wallets for Bitcoin and other cryptocurrencies",
);

/**
 * Plot a colorful tree
 */
export const birch_beer = mkPackage(
  nixRaw`pkgs.haskellPackages.birch-beer`,
  "Plot a colorful tree",
);

/**
 * A simple, sinatra-inspired web framework
 */
export const bird = mkPackage(
  nixRaw`pkgs.haskellPackages.bird`,
  "A simple, sinatra-inspired web framework",
);

/**
 * Birds of Paradise
 */
export const birds_of_paradise = mkPackage(
  nixRaw`pkgs.haskellPackages.birds-of-paradise`,
  "Birds of Paradise",
);

/**
 * A small tool that clears cookies (and more)
 */
export const bisc = mkPackage(
  nixRaw`pkgs.haskellPackages.bisc`,
  "A small tool that clears cookies (and more)",
);

/**
 * Servant support for the Biscuit security token
 */
export const biscuit_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.biscuit-servant`,
  "Servant support for the Biscuit security token",
);

/**
 * Plays chess
 */
export const bishbosh = mkPackage(
  nixRaw`pkgs.haskellPackages.bishbosh`,
  "Plays chess",
);

/**
 * A bit array (aka bitset, bitmap, bit vector) API for numeric types
 */
export const bit_array = mkPackage(
  nixRaw`pkgs.haskellPackages.bit-array`,
  "A bit array (aka bitset, bitmap, bit vector) API for numeric types",
);

/**
 * Encode binary protocols with some odd bit numbers into a bytestring
 */
export const bit_protocol = mkPackage(
  nixRaw`pkgs.haskellPackages.bit-protocol`,
  "Encode binary protocols with some odd bit numbers into a bytestring",
);

/**
 * Simple bit vectors for Haskell
 */
export const bit_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.bit-vector`,
  "Simple bit vectors for Haskell",
);

/**
 * Mutable and immutable bit arrays
 */
export const bitarray = mkPackage(
  nixRaw`pkgs.haskellPackages.bitarray`,
  "Mutable and immutable bit arrays",
);

/**
 * Bitcoin address generation and rendering. Parsing coming soon.
 */
export const bitcoin_address = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-address`,
  "Bitcoin address generation and rendering. Parsing coming soon.",
);

/**
 * Provides access to the RPC API of Bitcoin Core
 */
export const bitcoin_api = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-api`,
  "Provides access to the RPC API of Bitcoin Core",
);

/**
 * Higher level constructs on top of the bitcoin-api package
 */
export const bitcoin_api_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-api-extra`,
  "Higher level constructs on top of the bitcoin-api package",
);

/**
 * Utility functions for manipulating bitcoin blocks
 */
export const bitcoin_block = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-block`,
  "Utility functions for manipulating bitcoin blocks",
);

/**
 * BIP 158 compact block filters
 */
export const bitcoin_compact_filters = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-compact-filters`,
  "BIP 158 compact block filters",
);

/**
 * Bitcoin hash primitives
 */
export const bitcoin_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-hash`,
  "Bitcoin hash primitives",
);

/**
 * Resources for working with miniscript, and script descriptors
 */
export const bitcoin_scripting = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-scripting`,
  "Resources for working with miniscript, and script descriptors",
);

/**
 * Utility functions for manipulating bitcoin transactions
 */
export const bitcoin_tx = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-tx`,
  "Utility functions for manipulating bitcoin transactions",
);

/**
 * Provides consistent low-level types used commonly among Bitcoin implementations
 */
export const bitcoin_types = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoin-types`,
  "Provides consistent low-level types used commonly among Bitcoin implementations",
);

/**
 * A library for working with bitcoin-core regtest networks
 */
export const bitcoind_regtest = mkPackage(
  nixRaw`pkgs.haskellPackages.bitcoind-regtest`,
  "A library for working with bitcoin-core regtest networks",
);

/**
 * A command line tool to access bit.ly URL shortener.
 */
export const bitly_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.bitly-cli`,
  "A command line tool to access bit.ly URL shortener.",
);

/**
 * A library for handling and manipulating bitmaps (rectangular pixel arrays)
 */
export const bitmap = mkPackage(
  nixRaw`pkgs.haskellPackages.bitmap`,
  "A library for handling and manipulating bitmaps (rectangular pixel arrays)",
);

/**
 * OpenGL support for Data.Bitmap.
 */
export const bitmap_opengl = mkPackage(
  nixRaw`pkgs.haskellPackages.bitmap-opengl`,
  "OpenGL support for Data.Bitmap.",
);

/**
 * Bitmap library
 */
export const bitmaps = mkPackage(
  nixRaw`pkgs.haskellPackages.bitmaps`,
  "Bitmap library",
);

/**
 * Various bit twiddling and bitwise serialization primitives
 */
export const bits = mkPackage(
  nixRaw`pkgs.haskellPackages.bits`,
  "Various bit twiddling and bitwise serialization primitives",
);

/**
 * Bits instance for bytestrings
 */
export const bits_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.bits-bytestring`,
  "Bits instance for bytestrings",
);

/**
 * Bits instance for lazy bytestrings
 */
export const bits_bytestring_lazy = mkPackage(
  nixRaw`pkgs.haskellPackages.bits-bytestring-lazy`,
  "Bits instance for lazy bytestrings",
);

/**
 * Useful bitwise operations
 */
export const bits_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.bits-extra`,
  "Useful bitwise operations",
);

/**
 * Showing data as strings of 0 and 1
 */
export const bits_show = mkPackage(
  nixRaw`pkgs.haskellPackages.bits-show`,
  "Showing data as strings of 0 and 1",
);

/**
 * Space efficient set of Word8 and some pre-canned sets useful for parsing HTTP
 */
export const bitset_word8 = mkPackage(
  nixRaw`pkgs.haskellPackages.bitset-word8`,
  "Space efficient set of Word8 and some pre-canned sets useful for parsing HTTP",
);

/**
 * Lazy bit strings
 */
export const bitstring = mkPackage(
  nixRaw`pkgs.haskellPackages.bitstring`,
  "Lazy bit strings",
);

/**
 * Bittorrent protocol implementation
 */
export const bittorrent = mkPackage(
  nixRaw`pkgs.haskellPackages.bittorrent`,
  "Bittorrent protocol implementation",
);

/**
 * Bindings for the Bittrex API
 */
export const bittrex = mkPackage(
  nixRaw`pkgs.haskellPackages.bittrex`,
  "Bindings for the Bittrex API",
);

/**
 * Space-efficient bit vectors
 */
export const bitvec = mkPackage(
  nixRaw`pkgs.haskellPackages.bitvec`,
  "Space-efficient bit vectors",
);

/**
 * fast multi-dimensional unboxed bit packed Bool arrays
 */
export const bitwise = mkPackage(
  nixRaw`pkgs.haskellPackages.bitwise`,
  "fast multi-dimensional unboxed bit packed Bool arrays",
);

/**
 * Bitwise operations on bounded enumerations
 */
export const bitwise_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.bitwise-enum`,
  "Bitwise operations on bounded enumerations",
);

/**
 * BK-tree implementation
 */
export const bk_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.bk-tree`,
  "BK-tree implementation",
);

/**
 * A set data structure with approximate searching
 */
export const bktrees = mkPackage(
  nixRaw`pkgs.haskellPackages.bktrees`,
  "A set data structure with approximate searching",
);

/**
 * a stupid cron
 */
export const bla = mkPackage(
  nixRaw`pkgs.haskellPackages.bla`,
  "a stupid cron",
);

/**
 * The pirate bay client
 */
export const black_jewel = mkPackage(
  nixRaw`pkgs.haskellPackages.black-jewel`,
  "The pirate bay client",
);

/**
 * Decentralized, k-ordered unique ID generator
 */
export const blacktip = mkPackage(
  nixRaw`pkgs.haskellPackages.blacktip`,
  "Decentralized, k-ordered unique ID generator",
);

/**
 * A library providing BLAKE2
 */
export const blake2 = mkPackage(
  nixRaw`pkgs.haskellPackages.blake2`,
  "A library providing BLAKE2",
);

/**
 * A library providing BLAKE2
 */
export const blake2_0_3_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.blake2_0_3_0_1`,
  "A library providing BLAKE2",
);

/**
 * BLAKE3 hashing algorithm
 */
export const blake3 = mkPackage(
  nixRaw`pkgs.haskellPackages.blake3`,
  "BLAKE3 hashing algorithm",
);

/**
 * The BLAKE SHA-3 candidate hashes, in Haskell
 */
export const blakesum_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.blakesum-demo`,
  "The BLAKE SHA-3 candidate hashes, in Haskell",
);

/**
 * HTML5 Canvas Graphics Library
 */
export const blank_canvas = mkPackage(
  nixRaw`pkgs.haskellPackages.blank-canvas`,
  "HTML5 Canvas Graphics Library",
);

/**
 * Fill-in-the-blanks - A library factoring out substitution from ASTs
 */
export const blanks = mkPackage(
  nixRaw`pkgs.haskellPackages.blanks`,
  "Fill-in-the-blanks - A library factoring out substitution from ASTs",
);

/**
 * Auto-generated interface to Fortran BLAS via CArrays
 */
export const blas_carray = mkPackage(
  nixRaw`pkgs.haskellPackages.blas-carray`,
  "Auto-generated interface to Fortran BLAS via CArrays",
);

/**
 * Auto-generated interface to Fortran BLAS via comfort-array
 */
export const blas_comfort_array = mkPackage(
  nixRaw`pkgs.haskellPackages.blas-comfort-array`,
  "Auto-generated interface to Fortran BLAS via comfort-array",
);

/**
 * Auto-generated interface to Fortran BLAS
 */
export const blas_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.blas-ffi`,
  "Auto-generated interface to Fortran BLAS",
);

/**
 * Low-level Haskell bindings to Blas
 */
export const blas_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.blas-hs`,
  "Low-level Haskell bindings to Blas",
);

/**
 * Library for reading Blast XML output
 */
export const blastxml = mkPackage(
  nixRaw`pkgs.haskellPackages.blastxml`,
  "Library for reading Blast XML output",
);

/**
 * Blog in LaTeX
 */
export const blatex = mkPackage(
  nixRaw`pkgs.haskellPackages.blatex`,
  "Blog in LaTeX",
);

/**
 * None
 */
export const blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze`,
  "None",
);

/**
 * ...
 */
export const blazeMarker = mkPackage(
  nixRaw`pkgs.haskellPackages.blazeMarker`,
  "...",
);

/**
 * Blaze helper functions for bootstrap pages
 */
export const blaze_bootstrap = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-bootstrap`,
  "Blaze helper functions for bootstrap pages",
);

/**
 * Efficient buffered output
 */
export const blaze_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-builder`,
  "Efficient buffered output",
);

/**
 * Convert streams of builders to streams of bytestrings. (deprecated)
 */
export const blaze_builder_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-builder-conduit`,
  "Convert streams of builders to streams of bytestrings. (deprecated)",
);

/**
 * Enumeratees for the incremental conversion of builders to bytestrings
 */
export const blaze_builder_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-builder-enumerator`,
  "Enumeratees for the incremental conversion of builders to bytestrings",
);

/**
 * blaze-html backend for colonnade
 */
export const blaze_colonnade = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-colonnade`,
  "blaze-html backend for colonnade",
);

/**
 * Tool to convert HTML to BlazeHtml code
 */
export const blaze_from_html = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-from-html`,
  "Tool to convert HTML to BlazeHtml code",
);

/**
 * A blazingly fast HTML combinator library for Haskell
 */
export const blaze_html = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-html`,
  "A blazingly fast HTML combinator library for Haskell",
);

/**
 * Blaze integration of the htmx library
 */
export const blaze_htmx = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-htmx`,
  "Blaze integration of the htmx library",
);

/**
 * A blazingly fast markup combinator library for Haskell
 */
export const blaze_markup = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-markup`,
  "A blazingly fast markup combinator library for Haskell",
);

/**
 * SVG combinator library
 */
export const blaze_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-svg`,
  "SVG combinator library",
);

/**
 * Fast rendering of common datatypes
 */
export const blaze_textual = mkPackage(
  nixRaw`pkgs.haskellPackages.blaze-textual`,
  "Fast rendering of common datatypes",
);

/**
 * Bluetooth Low Energy (BLE) peripherals
 */
export const ble = mkPackage(
  nixRaw`pkgs.haskellPackages.ble`,
  "Bluetooth Low Energy (BLE) peripherals",
);

/**
 * Control library for blink(1) LED from ThingM
 */
export const blink1 = mkPackage(
  nixRaw`pkgs.haskellPackages.blink1`,
  "Control library for blink(1) LED from ThingM",
);

/**
 * Python to bytecode compiler
 */
export const blip = mkPackage(
  nixRaw`pkgs.haskellPackages.blip`,
  "Python to bytecode compiler",
);

/**
 * An HTML generator for Haskell
 */
export const blizzard_html = mkPackage(
  nixRaw`pkgs.haskellPackages.blizzard-html`,
  "An HTML generator for Haskell",
);

/**
 * API definitions for blockfrost.io
 */
export const blockfrost_api = mkPackage(
  nixRaw`pkgs.haskellPackages.blockfrost-api`,
  "API definitions for blockfrost.io",
);

/**
 * blockfrost.io basic client
 */
export const blockfrost_client = mkPackage(
  nixRaw`pkgs.haskellPackages.blockfrost-client`,
  "blockfrost.io basic client",
);

/**
 * blockfrost.io common client definitions / instances
 */
export const blockfrost_client_core = mkPackage(
  nixRaw`pkgs.haskellPackages.blockfrost-client-core`,
  "blockfrost.io common client definitions / instances",
);

/**
 * blockfrost.io pretty-printing utilities
 */
export const blockfrost_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.blockfrost-pretty`,
  "blockfrost.io pretty-printing utilities",
);

/**
 * Composable, blocking transactions
 */
export const blocking_transactions = mkPackage(
  nixRaw`pkgs.haskellPackages.blocking-transactions`,
  "Composable, blocking transactions",
);

/**
 * Very simple static blog software
 */
export const blogination = mkPackage(
  nixRaw`pkgs.haskellPackages.blogination`,
  "Very simple static blog software",
);

/**
 * Elasticsearch client library for Haskell
 */
export const bloodhound = mkPackage(
  nixRaw`pkgs.haskellPackages.bloodhound`,
  "Elasticsearch client library for Haskell",
);

/**
 * Pure and impure Bloom Filter implementations
 */
export const bloomfilter = mkPackage(
  nixRaw`pkgs.haskellPackages.bloomfilter`,
  "Pure and impure Bloom Filter implementations",
);

/**
 * OpenGL Logic Game
 */
export const bloxorz = mkPackage(
  nixRaw`pkgs.haskellPackages.bloxorz`,
  "OpenGL Logic Game",
);

/**
 * The blubber client; connects to the blubber server
 */
export const blubber = mkPackage(
  nixRaw`pkgs.haskellPackages.blubber`,
  "The blubber client; connects to the blubber server",
);

/**
 * Configurable blue light filter
 */
export const blucontrol = mkPackage(
  nixRaw`pkgs.haskellPackages.blucontrol`,
  "Configurable blue light filter",
);

/**
 * Bindings to Bluemix APIs
 */
export const bluemix_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.bluemix-sdk`,
  "Bindings to Bluemix APIs",
);

/**
 * full-featured tiling for the GNOME desktop environment
 */
export const bluetile = mkPackage(
  nixRaw`pkgs.haskellPackages.bluetile`,
  "full-featured tiling for the GNOME desktop environment",
);

/**
 * Convert between pointfree and pointful expressions
 */
export const blunt = mkPackage(
  nixRaw`pkgs.haskellPackages.blunt`,
  "Convert between pointfree and pointful expressions",
);

/**
 * open bookmarks and queries from the command line
 */
export const bm = mkPackage(
  nixRaw`pkgs.haskellPackages.bm`,
  "open bookmarks and queries from the command line",
);

/**
 * Read and write uncompressed BMP image files
 */
export const bmp = mkPackage(
  nixRaw`pkgs.haskellPackages.bmp`,
  "Read and write uncompressed BMP image files",
);

/**
 * Generate CSV Exports of Your BNB Staking Rewards
 */
export const bnb_staking_csvs = mkPackage(
  nixRaw`pkgs.haskellPackages.bnb-staking-csvs`,
  "Generate CSV Exports of Your BNB Staking Rewards",
);

/**
 * Library for communication with the Bosch BNO055 orientation sensor
 */
export const bno055_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.bno055-haskell`,
  "Library for communication with the Bosch BNO055 orientation sensor",
);

/**
 * Three games for inclusion in a web server
 */
export const board_games = mkPackage(
  nixRaw`pkgs.haskellPackages.board-games`,
  "Three games for inclusion in a web server",
);

/**
 * Modeling boardgames
 */
export const boardgame = mkPackage(
  nixRaw`pkgs.haskellPackages.boardgame`,
  "Modeling boardgames",
);

/**
 * Fedora Bodhi REST client library
 */
export const bodhi = mkPackage(
  nixRaw`pkgs.haskellPackages.bodhi`,
  "Fedora Bodhi REST client library",
);

export const bogre_banana = mkPackage(
  nixRaw`pkgs.haskellPackages.bogre-banana`,
  "",
);

/**
 * Uniform random generators
 */
export const boltzmann_samplers = mkPackage(
  nixRaw`pkgs.haskellPackages.boltzmann-samplers`,
  "Uniform random generators",
);

/**
 * Bond schema compiler and code generator
 */
export const bond = mkPackage(
  nixRaw`pkgs.haskellPackages.bond`,
  "Bond schema compiler and code generator",
);

/**
 * Runtime support for BOND serialization
 */
export const bond_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.bond-haskell`,
  "Runtime support for BOND serialization",
);

/**
 * Bond code generator for Haskell
 */
export const bond_haskell_compiler = mkPackage(
  nixRaw`pkgs.haskellPackages.bond-haskell-compiler`,
  "Bond code generator for Haskell",
);

/**
 * Simple Parser Combinators
 */
export const bookhound = mkPackage(
  nixRaw`pkgs.haskellPackages.bookhound`,
  "Simple Parser Combinators",
);

/**
 * Anonymous records and overloaded labels
 */
export const bookkeeper = mkPackage(
  nixRaw`pkgs.haskellPackages.bookkeeper`,
  "Anonymous records and overloaded labels",
);

/**
 * Permissions for bookkeeper records
 */
export const bookkeeper_permissions = mkPackage(
  nixRaw`pkgs.haskellPackages.bookkeeper-permissions`,
  "Permissions for bookkeeper records",
);

/**
 * Helper functions for Japanese bookkeeping
 */
export const bookkeeping_jp = mkPackage(
  nixRaw`pkgs.haskellPackages.bookkeeping-jp`,
  "Helper functions for Japanese bookkeeping",
);

/**
 * Alternative Bool type stored as byte
 */
export const bool8 = mkPackage(
  nixRaw`pkgs.haskellPackages.bool8`,
  "Alternative Bool type stored as byte",
);

/**
 * A fold function for Bool
 */
export const bool_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.bool-extras`,
  "A fold function for Bool",
);

/**
 * convert numbers to binary coded lists
 */
export const boolean_list = mkPackage(
  nixRaw`pkgs.haskellPackages.boolean-list`,
  "convert numbers to binary coded lists",
);

/**
 * Haskell bindings for the Boolector SMT solver
 */
export const boolector = mkPackage(
  nixRaw`pkgs.haskellPackages.boolector`,
  "Haskell bindings for the Boolector SMT solver",
);

/**
 * Boolean expressions with various representations and search queries
 */
export const boolexpr = mkPackage(
  nixRaw`pkgs.haskellPackages.boolexpr`,
  "Boolean expressions with various representations and search queries",
);

/**
 * None
 */
export const bools = mkPackage(
  nixRaw`pkgs.haskellPackages.bools`,
  "None",
);

/**
 * Simplification tools for simple propositional formulas
 */
export const boolsimplifier = mkPackage(
  nixRaw`pkgs.haskellPackages.boolsimplifier`,
  "Simplification tools for simple propositional formulas",
);

/**
 * A bookmarks manager with an HTML generator
 */
export const boomange = mkPackage(
  nixRaw`pkgs.haskellPackages.boomange`,
  "A bookmarks manager with an HTML generator",
);

/**
 * Library for invertible parsing and printing
 */
export const boomerang = mkPackage(
  nixRaw`pkgs.haskellPackages.boomerang`,
  "Library for invertible parsing and printing",
);

/**
 * Boomshine clone
 */
export const boomslang = mkPackage(
  nixRaw`pkgs.haskellPackages.boomslang`,
  "Boomshine clone",
);

/**
 * Convert MIDI file to play-along boomwhacker animation
 */
export const boomwhacker = mkPackage(
  nixRaw`pkgs.haskellPackages.boomwhacker`,
  "Convert MIDI file to play-along boomwhacker animation",
);

/**
 * OOP primitives for Haskell
 */
export const boop = mkPackage(
  nixRaw`pkgs.haskellPackages.boop`,
  "OOP primitives for Haskell",
);

/**
 * Mathematically sound sound synthesis
 */
export const boopadoop = mkPackage(
  nixRaw`pkgs.haskellPackages.boopadoop`,
  "Mathematically sound sound synthesis",
);

/**
 * IoC Monad in Haskell
 */
export const boots = mkPackage(
  nixRaw`pkgs.haskellPackages.boots`,
  "IoC Monad in Haskell",
);

/**
 * Factory for quickly building an application
 */
export const boots_app = mkPackage(
  nixRaw`pkgs.haskellPackages.boots-app`,
  "Factory for quickly building an application",
);

/**
 * Factory for quickly building a microservice
 */
export const boots_cloud = mkPackage(
  nixRaw`pkgs.haskellPackages.boots-cloud`,
  "Factory for quickly building a microservice",
);

/**
 * Factory for quickly building a web application
 */
export const boots_web = mkPackage(
  nixRaw`pkgs.haskellPackages.boots-web`,
  "Factory for quickly building a web application",
);

/**
 * Bootstrap CSS Framework type-safe interface
 */
export const bootstrap_types = mkPackage(
  nixRaw`pkgs.haskellPackages.bootstrap-types`,
  "Bootstrap CSS Framework type-safe interface",
);

/**
 * Implementation of the Borda count election method
 */
export const bordacount = mkPackage(
  nixRaw`pkgs.haskellPackages.bordacount`,
  "Implementation of the Borda count election method",
);

/**
 * Metering System for OpenStack metrics provided by Vaultaire
 */
export const borel = mkPackage(
  nixRaw`pkgs.haskellPackages.borel`,
  "Metering System for OpenStack metrics provided by Vaultaire",
);

/**
 * Boring and Absurd types
 */
export const boring = mkPackage(
  nixRaw`pkgs.haskellPackages.boring`,
  "Boring and Absurd types",
);

/**
 * An educational game
 */
export const boring_game = mkPackage(
  nixRaw`pkgs.haskellPackages.boring-game`,
  "An educational game",
);

/**
 * Implementation of BORSH serialisation
 */
export const borsh = mkPackage(
  nixRaw`pkgs.haskellPackages.borsh`,
  "Implementation of BORSH serialisation",
);

/**
 * Like Maybe, but with a different Monoid instance
 */
export const both = mkPackage(
  nixRaw`pkgs.haskellPackages.both`,
  "Like Maybe, but with a different Monoid instance",
);

/**
 * Making de Bruijn Succ Less
 */
export const bound = mkPackage(
  nixRaw`pkgs.haskellPackages.bound`,
  "Making de Bruijn Succ Less",
);

/**
 * ScopeH and ScopeT extras for bound
 */
export const bound_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.bound-extras`,
  "ScopeH and ScopeT extras for bound",
);

/**
 * Unwrap Scope's with globally fresh values
 */
export const bound_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.bound-gen`,
  "Unwrap Scope's with globally fresh values",
);

/**
 * Bounded quantity semaphores
 */
export const bounded_qsem = mkPackage(
  nixRaw`pkgs.haskellPackages.bounded-qsem`,
  "Bounded quantity semaphores",
);

/**
 * A strict, immutable, thread-safe, single-ended, bounded queue
 */
export const bounded_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.bounded-queue`,
  "A strict, immutable, thread-safe, single-ended, bounded queue",
);

/**
 * Bounded Transactional channels (queues)
 */
export const bounded_tchan = mkPackage(
  nixRaw`pkgs.haskellPackages.bounded-tchan`,
  "Bounded Transactional channels (queues)",
);

/**
 * A generic boundingbox for an arbitrary vector
 */
export const boundingboxes = mkPackage(
  nixRaw`pkgs.haskellPackages.boundingboxes`,
  "A generic boundingbox for an arbitrary vector",
);

/**
 * Read bower.json from Haskell
 */
export const bower_json = mkPackage(
  nixRaw`pkgs.haskellPackages.bower-json`,
  "Read bower.json from Haskell",
);

/**
 * Read bower.json from Haskell
 */
export const bower_json_1_0_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.bower-json_1_0_0_1`,
  "Read bower.json from Haskell",
);

/**
 * A profunctor effect system
 */
export const box = mkPackage(
  nixRaw`pkgs.haskellPackages.box`,
  "A profunctor effect system",
);

/**
 * Box websockets
 */
export const box_socket = mkPackage(
  nixRaw`pkgs.haskellPackages.box-socket`,
  "Box websockets",
);

/**
 * 2D text pretty-printing library
 */
export const boxes = mkPackage(
  nixRaw`pkgs.haskellPackages.boxes`,
  "2D text pretty-printing library",
);

/**
 * backpropagation neuronal network
 */
export const bpann = mkPackage(
  nixRaw`pkgs.haskellPackages.bpann`,
  "backpropagation neuronal network",
);

/**
 * Brainfuck interpreter
 */
export const brainfuck = mkPackage(
  nixRaw`pkgs.haskellPackages.brainfuck`,
  "Brainfuck interpreter",
);

/**
 * BrainFuck monad
 */
export const brainfuck_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.brainfuck-monad`,
  "BrainFuck monad",
);

/**
 * A simple BF interpreter
 */
export const brainfuck_tut = mkPackage(
  nixRaw`pkgs.haskellPackages.brainfuck-tut`,
  "A simple BF interpreter",
);

/**
 * Brainh*ck interpreter in haskell
 */
export const brainheck = mkPackage(
  nixRaw`pkgs.haskellPackages.brainheck`,
  "Brainh*ck interpreter in haskell",
);

/**
 * Break from a loop
 */
export const break_ = mkPackage(
  nixRaw`pkgs.haskellPackages.break`,
  "Break from a loop",
);

/**
 * A simple Breakout game implementation
 */
export const breakout = mkPackage(
  nixRaw`pkgs.haskellPackages.breakout`,
  "A simple Breakout game implementation",
);

/**
 * Set breakpoints using a GHC plugin
 */
export const breakpoint = mkPackage(
  nixRaw`pkgs.haskellPackages.breakpoint`,
  "Set breakpoints using a GHC plugin",
);

/**
 * a url shortener
 */
export const breve = mkPackage(
  nixRaw`pkgs.haskellPackages.breve`,
  "a url shortener",
);

/**
 * A declarative terminal user interface library
 */
export const brick = mkPackage(
  nixRaw`pkgs.haskellPackages.brick`,
  "A declarative terminal user interface library",
);

/**
 * A declarative terminal user interface library
 */
export const brick_0_70_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.brick_0_70_1`,
  "A declarative terminal user interface library",
);

/**
 * A declarative terminal user interface library
 */
export const brick_1_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.brick_1_10`,
  "A declarative terminal user interface library",
);

/**
 * Skip a certain kind of items when moving in brick list
 */
export const brick_list_skip = mkPackage(
  nixRaw`pkgs.haskellPackages.brick-list-skip`,
  "Skip a certain kind of items when moving in brick list",
);

/**
 * Show syntax-highlighted text in your Brick UI
 */
export const brick_skylighting = mkPackage(
  nixRaw`pkgs.haskellPackages.brick-skylighting`,
  "Show syntax-highlighted text in your Brick UI",
);

/**
 * Show syntax-highlighted text in your Brick UI
 */
export const brick_skylighting_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.brick-skylighting_0_3`,
  "Show syntax-highlighted text in your Brick UI",
);

/**
 * Tabular list widgets for brick
 */
export const brick_tabular_list = mkPackage(
  nixRaw`pkgs.haskellPackages.brick-tabular-list`,
  "Tabular list widgets for brick",
);

/**
 * Bricks is a lazy functional language based on Nix
 */
export const bricks = mkPackage(
  nixRaw`pkgs.haskellPackages.bricks`,
  "Bricks is a lazy functional language based on Nix",
);

/**
 * ...
 */
export const bricks_internal_test = mkPackage(
  nixRaw`pkgs.haskellPackages.bricks-internal-test`,
  "...",
);

/**
 * ...
 */
export const bricks_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.bricks-parsec`,
  "...",
);

/**
 * ...
 */
export const bricks_rendering = mkPackage(
  nixRaw`pkgs.haskellPackages.bricks-rendering`,
  "...",
);

/**
 * ...
 */
export const bricks_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.bricks-syntax`,
  "...",
);

/**
 * Closable, fair, single-wakeup channel type that avoids 0 reader space leaks
 */
export const broadcast_chan = mkPackage(
  nixRaw`pkgs.haskellPackages.broadcast-chan`,
  "Closable, fair, single-wakeup channel type that avoids 0 reader space leaks",
);

/**
 * Conduit-based parallel streaming code for broadcast-chan
 */
export const broadcast_chan_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.broadcast-chan-conduit`,
  "Conduit-based parallel streaming code for broadcast-chan",
);

/**
 * Pipes-based parallel streaming code for broadcast-chan
 */
export const broadcast_chan_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.broadcast-chan-pipes`,
  "Pipes-based parallel streaming code for broadcast-chan",
);

/**
 * Streaming interface for the BronyRadioGermany API
 */
export const bronyradiogermany_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.bronyradiogermany-streaming`,
  "Streaming interface for the BronyRadioGermany API",
);

/**
 * Brotli (RFC7932) compression and decompression
 */
export const brotli = mkPackage(
  nixRaw`pkgs.haskellPackages.brotli`,
  "Brotli (RFC7932) compression and decompression",
);

/**
 * IO-Streams interface for Brotli (RFC7932) compression
 */
export const brotli_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.brotli-streams`,
  "IO-Streams interface for Brotli (RFC7932) compression",
);

/**
 * Chunked HTTP transfer encoding for bytestring builders
 */
export const bsb_http_chunked = mkPackage(
  nixRaw`pkgs.haskellPackages.bsb-http-chunked`,
  "Chunked HTTP transfer encoding for bytestring builders",
);

/**
 * BSON documents are JSON-like objects with a standard binary encoding
 */
export const bson = mkPackage(
  nixRaw`pkgs.haskellPackages.bson`,
  "BSON documents are JSON-like objects with a standard binary encoding",
);

/**
 * BSON lenses
 */
export const bson_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.bson-lens`,
  "BSON lenses",
);

/**
 * A simple and fast bytestring packer
 */
export const bspack = mkPackage(
  nixRaw`pkgs.haskellPackages.bspack`,
  "A simple and fast bytestring packer",
);

/**
 * Lightning service provider
 */
export const btc_lsp = mkPackage(
  nixRaw`pkgs.haskellPackages.btc-lsp`,
  "Lightning service provider",
);

/**
 * B-Tree on Unmanaged Heap
 */
export const btree = mkPackage(
  nixRaw`pkgs.haskellPackages.btree`,
  "B-Tree on Unmanaged Heap",
);

/**
 * Automates most of your plain text accounting data entry in ledger format
 */
export const buchhaltung = mkPackage(
  nixRaw`pkgs.haskellPackages.buchhaltung`,
  "Automates most of your plain text accounting data entry in ledger format",
);

/**
 * Library for efficiently building up buffers, one piece at a time
 */
export const buffer_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.buffer-builder`,
  "Library for efficiently building up buffers, one piece at a time",
);

/**
 * Read from stdin and write to stdout in large blocks
 */
export const buffer_pipe = mkPackage(
  nixRaw`pkgs.haskellPackages.buffer-pipe`,
  "Read from stdin and write to stdout in large blocks",
);

/**
 * Better alternatives to the "error" function
 */
export const bug = mkPackage(
  nixRaw`pkgs.haskellPackages.bug`,
  "Better alternatives to the \"error\" function",
);

/**
 * Bugsnag error reporter for Haskell
 */
export const bugsnag = mkPackage(
  nixRaw`pkgs.haskellPackages.bugsnag`,
  "Bugsnag error reporter for Haskell",
);

/**
 * Bugsnag error reporter for Haskell
 */
export const bugsnag_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.bugsnag-haskell`,
  "Bugsnag error reporter for Haskell",
);

/**
 * A Bugsnag client for Haskell
 */
export const bugsnag_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.bugsnag-hs`,
  "A Bugsnag client for Haskell",
);

/**
 * WAI integration for Bugsnag error reporting for Haskell
 */
export const bugsnag_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.bugsnag-wai`,
  "WAI integration for Bugsnag error reporting for Haskell",
);

/**
 * Yesod integration for Bugsnag error reporting for Haskell
 */
export const bugsnag_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.bugsnag-yesod`,
  "Yesod integration for Bugsnag error reporting for Haskell",
);

/**
 * A Haskell interface to the Bugzilla native REST API
 */
export const bugzilla_redhat = mkPackage(
  nixRaw`pkgs.haskellPackages.bugzilla-redhat`,
  "A Haskell interface to the Bugzilla native REST API",
);

/**
 * A Haskell interface to the Bugzilla native REST API
 */
export const bugzilla_redhat_1_0_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.bugzilla-redhat_1_0_1_1`,
  "A Haskell interface to the Bugzilla native REST API",
);

/**
 * Compute, fetch and install Cabal build plans into a local environment
 */
export const build_env = mkPackage(
  nixRaw`pkgs.haskellPackages.build-env`,
  "Compute, fetch and install Cabal build plans into a local environment",
);

/**
 * Tools for working with buildbox benchmark result files
 */
export const buildbox_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.buildbox-tools`,
  "Tools for working with buildbox benchmark result files",
);

/**
 * A library and an executable that provide an easy API for a Haskell IDE
 */
export const buildwrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.buildwrapper`,
  "A library and an executable that provide an easy API for a Haskell IDE",
);

/**
 * A wrapper for the Bullet physics engine
 */
export const bullet = mkPackage(
  nixRaw`pkgs.haskellPackages.bullet`,
  "A wrapper for the Bullet physics engine",
);

/**
 * Bulletproofs are short zero-knowledge proofs without a trusted setup
 */
export const bulletproofs = mkPackage(
  nixRaw`pkgs.haskellPackages.bulletproofs`,
  "Bulletproofs are short zero-knowledge proofs without a trusted setup",
);

/**
 * Reflex infused with bulma (css)
 */
export const bulmex = mkPackage(
  nixRaw`pkgs.haskellPackages.bulmex`,
  "Reflex infused with bulma (css)",
);

/**
 * List OP_RETURN cryptocurrency transaction outputs
 */
export const burnt_explorer = mkPackage(
  nixRaw`pkgs.haskellPackages.burnt-explorer`,
  "List OP_RETURN cryptocurrency transaction outputs",
);

/**
 * Parse and render URI templates
 */
export const burrito = mkPackage(
  nixRaw`pkgs.haskellPackages.burrito`,
  "Parse and render URI templates",
);

/**
 * Haskell interface to the Bus Pirate binary interface
 */
export const bus_pirate = mkPackage(
  nixRaw`pkgs.haskellPackages.bus-pirate`,
  "Haskell interface to the Bus Pirate binary interface",
);

/**
 * Almost but not quite entirely unlike FRP
 */
export const buster_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.buster-gtk`,
  "Almost but not quite entirely unlike FRP",
);

/**
 * Almost but not quite entirely unlike FRP
 */
export const buster_network = mkPackage(
  nixRaw`pkgs.haskellPackages.buster-network`,
  "Almost but not quite entirely unlike FRP",
);

/**
 * Draw sequence diagrams of D-Bus traffic
 */
export const bustle = mkPackage(
  nixRaw`pkgs.haskellPackages.bustle`,
  "Draw sequence diagrams of D-Bus traffic",
);

/**
 * Chops a command or program invocation into digestable pieces
 */
export const butcher = mkPackage(
  nixRaw`pkgs.haskellPackages.butcher`,
  "Chops a command or program invocation into digestable pieces",
);

/**
 * butterfly tilings
 */
export const butterflies = mkPackage(
  nixRaw`pkgs.haskellPackages.butterflies`,
  "butterfly tilings",
);

/**
 * Bit-vector arithmetic library
 */
export const bv = mkPackage(
  nixRaw`pkgs.haskellPackages.bv`,
  "Bit-vector arithmetic library",
);

/**
 * Define embeddings of small bit vectors into larger ones
 */
export const bv_embed = mkPackage(
  nixRaw`pkgs.haskellPackages.bv-embed`,
  "Define embeddings of small bit vectors into larger ones",
);

/**
 * a bitvector datatype that is parameterized by the vector width
 */
export const bv_sized = mkPackage(
  nixRaw`pkgs.haskellPackages.bv-sized`,
  "a bitvector datatype that is parameterized by the vector width",
);

/**
 * Give aliases to record fields
 */
export const by_other_names = mkPackage(
  nixRaw`pkgs.haskellPackages.by-other-names`,
  "Give aliases to record fields",
);

/**
 * data from/to ByteString
 */
export const bytable = mkPackage(
  nixRaw`pkgs.haskellPackages.bytable`,
  "data from/to ByteString",
);

/**
 * Read strings describing a number of bytes like 2Kb and 0.5 MiB
 */
export const byte_count_reader = mkPackage(
  nixRaw`pkgs.haskellPackages.byte-count-reader`,
  "Read strings describing a number of bytes like 2Kb and 0.5 MiB",
);

/**
 * Portable big-endian and little-endian conversions
 */
export const byte_order = mkPackage(
  nixRaw`pkgs.haskellPackages.byte-order`,
  "Portable big-endian and little-endian conversions",
);

/**
 * Type class for sequence of bytes
 */
export const byteable = mkPackage(
  nixRaw`pkgs.haskellPackages.byteable`,
  "Type class for sequence of bytes",
);

/**
 * Build byte arrays
 */
export const bytebuild = mkPackage(
  nixRaw`pkgs.haskellPackages.bytebuild`,
  "Build byte arrays",
);

/**
 * Flexible byte dump helpers for human readers
 */
export const bytedump = mkPackage(
  nixRaw`pkgs.haskellPackages.bytedump`,
  "Flexible byte dump helpers for human readers",
);

/**
 * Universal hashing of bytes
 */
export const bytehash = mkPackage(
  nixRaw`pkgs.haskellPackages.bytehash`,
  "Universal hashing of bytes",
);

/**
 * Universal hashing of bytes
 */
export const bytehash_0_1_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.bytehash_0_1_1_0`,
  "Universal hashing of bytes",
);

/**
 * Fast logging
 */
export const bytelog = mkPackage(
  nixRaw`pkgs.haskellPackages.bytelog`,
  "Fast logging",
);

/**
 * Exposes the native endianness or byte ordering of the system
 */
export const byteorder = mkPackage(
  nixRaw`pkgs.haskellPackages.byteorder`,
  "Exposes the native endianness or byte ordering of the system",
);

/**
 * Sharing code for serialization between binary and cereal
 */
export const bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.bytes`,
  "Sharing code for serialization between binary and cereal",
);

/**
 * Set of bytes
 */
export const byteset = mkPackage(
  nixRaw`pkgs.haskellPackages.byteset`,
  "Set of bytes",
);

/**
 * Slicing managed and unmanaged memory
 */
export const byteslice = mkPackage(
  nixRaw`pkgs.haskellPackages.byteslice`,
  "Slicing managed and unmanaged memory",
);

/**
 * Nonresumable byte parser
 */
export const bytesmith = mkPackage(
  nixRaw`pkgs.haskellPackages.bytesmith`,
  "Nonresumable byte parser",
);

/**
 * Fast, compact, strict and lazy byte strings with a list interface
 */
export const bytestring_0_12_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring_0_12_0_2`,
  "Fast, compact, strict and lazy byte strings with a list interface",
);

/**
 * Aeson instances for ByteString, using base 64 encoding
 */
export const bytestring_aeson_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-aeson-orphans`,
  "Aeson instances for ByteString, using base 64 encoding",
);

/**
 * The new bytestring builder, packaged outside of GHC
 */
export const bytestring_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-builder`,
  "The new bytestring builder, packaged outside of GHC",
);

/**
 * Variable-length integer encoding
 */
export const bytestring_builder_varword = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-builder-varword`,
  "Variable-length integer encoding",
);

/**
 * ByteString  Text converter based on GHC.IO.Encoding
 */
export const bytestring_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-encoding`,
  "ByteString  Text converter based on GHC.IO.Encoding",
);

/**
 * checks to see if a given bytestring adheres to a certain encoding
 */
export const bytestring_encodings = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-encodings`,
  "checks to see if a given bytestring adheres to a certain encoding",
);

/**
 * A type-class to convert values from ByteString
 */
export const bytestring_from = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-from`,
  "A type-class to convert values from ByteString",
);

/**
 * Efficiently parse and produce common integral and fractional numbers
 */
export const bytestring_lexing = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-lexing`,
  "Efficiently parse and produce common integral and fractional numbers",
);

/**
 * mmap support for strict ByteStrings
 */
export const bytestring_mmap = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-mmap`,
  "mmap support for strict ByteStrings",
);

/**
 * Parse numeric literals from ByteStrings
 */
export const bytestring_nums = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-nums`,
  "Parse numeric literals from ByteStrings",
);

/**
 * A library for tracking the consumption of a lazy ByteString
 */
export const bytestring_progress = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-progress`,
  "A library for tracking the consumption of a lazy ByteString",
);

/**
 * fast ByteString to number converting library
 */
export const bytestring_read = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-read`,
  "fast ByteString to number converting library",
);

/**
 * Backport copy of ShortByteString
 */
export const bytestring_short = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-short`,
  "Backport copy of ShortByteString",
);

/**
 * An efficient strict bytestring builder
 */
export const bytestring_strict_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-strict-builder`,
  "An efficient strict bytestring builder",
);

/**
 * Convert between ByteString and Vector.Storable without copying
 */
export const bytestring_to_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-to-vector`,
  "Convert between ByteString and Vector.Storable without copying",
);

/**
 * A very efficient ByteString builder implementation based on the binary tree
 */
export const bytestring_tree_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-tree-builder`,
  "A very efficient ByteString builder implementation based on the binary tree",
);

/**
 * An efficient finite map from bytestrings to values
 */
export const bytestring_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.bytestring-trie`,
  "An efficient finite map from bytestrings to values",
);

/**
 * Human friendly conversion between byte units (KB, MB, GB...)
 */
export const byteunits = mkPackage(
  nixRaw`pkgs.haskellPackages.byteunits`,
  "Human friendly conversion between byte units (KB, MB, GB...)",
);

/**
 * Bindings to libbz2
 */
export const bz2 = mkPackage(
  nixRaw`pkgs.haskellPackages.bz2`,
  "Bindings to libbz2",
);

/**
 * Backpack signature for BZip compression
 */
export const bzip_signature = mkPackage(
  nixRaw`pkgs.haskellPackages.bzip-signature`,
  "Backpack signature for BZip compression",
);

/**
 * Compression and decompression in the bzip2 format
 */
export const bzlib = mkPackage(
  nixRaw`pkgs.haskellPackages.bzlib`,
  "Compression and decompression in the bzip2 format",
);

/**
 * Streaming compression/decompression via conduits
 */
export const bzlib_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.bzlib-conduit`,
  "Streaming compression/decompression via conduits",
);

/**
 * Simple C0 Syntax Check
 */
export const c0check = mkPackage(
  nixRaw`pkgs.haskellPackages.c0check`,
  "Simple C0 Syntax Check",
);

/**
 * Simple C0 Parser
 */
export const c0parser = mkPackage(
  nixRaw`pkgs.haskellPackages.c0parser`,
  "Simple C0 Parser",
);

/**
 * Bindings to the c14n implementation in libxml
 */
export const c14n = mkPackage(
  nixRaw`pkgs.haskellPackages.c14n`,
  "Bindings to the c14n implementation in libxml",
);

/**
 * C->Haskell FFI tool that gives some cross-language type safety
 */
export const c2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.c2hs`,
  "C->Haskell FFI tool that gives some cross-language type safety",
);

/**
 * Convenient marshallers for complicate C types
 */
export const c2hs_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.c2hs-extra`,
  "Convenient marshallers for complicate C types",
);

/**
 * Convert C API header files to .hsc and .hsc.helper.c files
 */
export const c2hsc = mkPackage(
  nixRaw`pkgs.haskellPackages.c2hsc`,
  "Convert C API header files to .hsc and .hsc.helper.c files",
);

/**
 * To make a type corresponding to an enum of C language
 */
export const c_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.c-enum`,
  "To make a type corresponding to an enum of C language",
);

/**
 * CStorable class
 */
export const c_storable = mkPackage(
  nixRaw`pkgs.haskellPackages.c-storable`,
  "CStorable class",
);

/**
 * Generate C-like storable instances from datatypes
 */
export const c_storable_deriving = mkPackage(
  nixRaw`pkgs.haskellPackages.c-storable-deriving`,
  "Generate C-like storable instances from datatypes",
);

/**
 * To make a wrapper for struct of C language
 */
export const c_struct = mkPackage(
  nixRaw`pkgs.haskellPackages.c-struct`,
  "To make a wrapper for struct of C language",
);

/**
 * Cellular Automata
 */
export const ca = mkPackage(
  nixRaw`pkgs.haskellPackages.ca`,
  "Cellular Automata",
);

/**
 * ISO 3166-2:CA Province Codes and Names
 */
export const ca_province_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.ca-province-codes`,
  "ISO 3166-2:CA Province Codes and Names",
);

/**
 * A maintenance command of Haskell cabal packages
 */
export const cab = mkPackage(
  nixRaw`pkgs.haskellPackages.cab`,
  "A maintenance command of Haskell cabal packages",
);

/**
 * Create Arch Linux packages from Cabal packages
 */
export const cabal2arch = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal2arch`,
  "Create Arch Linux packages from Cabal packages",
);

/**
 * Convert Cabal files into Nix build instructions
 */
export const cabal2nix = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal2nix`,
  "Convert Cabal files into Nix build instructions",
);

/**
 * Convert Cabal files into Nix build instructions
 */
export const cabal2nix_unstable = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal2nix-unstable`,
  "Convert Cabal files into Nix build instructions",
);

/**
 * Convert Cabal files into rpm spec files
 */
export const cabal2spec = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal2spec`,
  "Convert Cabal files into rpm spec files",
);

/**
 * Cabal support for creating AppImage applications
 */
export const cabal_appimage = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-appimage`,
  "Cabal support for creating AppImage applications",
);

/**
 * A command line program for managing the dependency versions in a cabal file
 */
export const cabal_bounds = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-bounds`,
  "A command line program for managing the dependency versions in a cabal file",
);

/**
 * Adds executable dependencies to the Cabal build
 */
export const cabal_build_programs = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-build-programs`,
  "Adds executable dependencies to the Cabal build",
);

/**
 * CI Assistant for Haskell projects
 */
export const cabal_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-cache`,
  "CI Assistant for Haskell projects",
);

/**
 * A command line program for extracting compiler arguments from a cabal file
 */
export const cabal_cargs = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-cargs`,
  "A command line program for extracting compiler arguments from a cabal file",
);

/**
 * Remove outdated cabal build artefacts from `dist-newstyle`
 */
export const cabal_clean = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-clean`,
  "Remove outdated cabal build artefacts from `dist-newstyle`",
);

/**
 * QuickCheck for Cabal tests
 */
export const cabal_detailed_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-detailed-quickcheck`,
  "QuickCheck for Cabal tests",
);

/**
 * A Setup.hs helper for running doctests
 */
export const cabal_doctest = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-doctest`,
  "A Setup.hs helper for running doctests",
);

/**
 * Cabal file access
 */
export const cabal_file = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-file`,
  "Cabal file access",
);

/**
 * Generate a FlatPak manifest from a Cabal package description
 */
export const cabal_flatpak = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-flatpak`,
  "Generate a FlatPak manifest from a Cabal package description",
);

/**
 * Format .cabal files
 */
export const cabal_fmt = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-fmt`,
  "Format .cabal files",
);

/**
 * Give Haskell development tools access to Cabal project environment
 */
export const cabal_helper = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-helper`,
  "Give Haskell development tools access to Cabal project environment",
);

/**
 * The command-line interface for Cabal and Hackage
 */
export const cabal_install = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-install`,
  "The command-line interface for Cabal and Hackage",
);

/**
 * Utilities to work with cabal-install files
 */
export const cabal_install_parsers = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-install-parsers`,
  "Utilities to work with cabal-install files",
);

/**
 * The command-line interface for Cabal and Hackage
 */
export const cabal_install_solver = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-install-solver`,
  "The command-line interface for Cabal and Hackage",
);

/**
 * The command-line interface for Cabal and Hackage
 */
export const cabal_install_solver_3_10_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-install-solver_3_10_1_0`,
  "The command-line interface for Cabal and Hackage",
);

/**
 * Cabal support for creating Mac OSX application bundles
 */
export const cabal_macosx = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-macosx`,
  "Cabal support for creating Mac OSX application bundles",
);

/**
 * Make Cabal aware of pkg-config package versions
 */
export const cabal_pkg_config_version_hook = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-pkg-config-version-hook`,
  "Make Cabal aware of pkg-config package versions",
);

/**
 * Derives cabal bounds from build plans
 */
export const cabal_plan_bounds = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-plan-bounds`,
  "Derives cabal bounds from build plans",
);

/**
 * Helpers for quering .cabal files or hackageDB's 00-index.tar
 */
export const cabal_query = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-query`,
  "Helpers for quering .cabal files or hackageDB's 00-index.tar",
);

/**
 * RPM packaging tool for Haskell Cabal-based packages
 */
export const cabal_rpm = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-rpm`,
  "RPM packaging tool for Haskell Cabal-based packages",
);

/**
 * Shell scripts for support of Cabal maintenance
 */
export const cabal_scripts = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-scripts`,
  "Shell scripts for support of Cabal maintenance",
);

/**
 * Sign and verify Cabal packages
 */
export const cabal_sign = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-sign`,
  "Sign and verify Cabal packages",
);

/**
 * Automated test tool for cabal projects
 */
export const cabal_test = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-test`,
  "Automated test tool for cabal projects",
);

/**
 * A program for finding temporary build file during cabal-test
 */
export const cabal_test_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-test-bin`,
  "A program for finding temporary build file during cabal-test",
);

/**
 * Compatibility interface of cabal test-suite
 */
export const cabal_test_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-test-compat`,
  "Compatibility interface of cabal test-suite",
);

/**
 * Uninstall cabal packages
 */
export const cabal_uninstall = mkPackage(
  nixRaw`pkgs.haskellPackages.cabal-uninstall`,
  "Uninstall cabal packages",
);

/**
 * alias for cabal install from given git repo
 */
export const cabalg = mkPackage(
  nixRaw`pkgs.haskellPackages.cabalg`,
  "alias for cabal install from given git repo",
);

/**
 * Create mandriva rpm from cabal package
 */
export const cabalmdvrpm = mkPackage(
  nixRaw`pkgs.haskellPackages.cabalmdvrpm`,
  "Create mandriva rpm from cabal package",
);

/**
 * Autogenerate rpm dependencies from cabal files
 */
export const cabalrpmdeps = mkPackage(
  nixRaw`pkgs.haskellPackages.cabalrpmdeps`,
  "Autogenerate rpm dependencies from cabal files",
);

/**
 * An in-memory key/value store with expiration support
 */
export const cache = mkPackage(
  nixRaw`pkgs.haskellPackages.cache`,
  "An in-memory key/value store with expiration support",
);

/**
 * A simple library to cache IO actions
 */
export const cached_io = mkPackage(
  nixRaw`pkgs.haskellPackages.cached-io`,
  "A simple library to cache IO actions",
);

/**
 * Locally cache a json file obtained by http
 */
export const cached_json_file = mkPackage(
  nixRaw`pkgs.haskellPackages.cached-json-file`,
  "Locally cache a json file obtained by http",
);

/**
 * Transparent, persistent caching of lazy, traversable structures
 */
export const cached_traversable = mkPackage(
  nixRaw`pkgs.haskellPackages.cached-traversable`,
  "Transparent, persistent caching of lazy, traversable structures",
);

/**
 * A vault-style cache implementation
 */
export const caching_vault = mkPackage(
  nixRaw`pkgs.haskellPackages.caching-vault`,
  "A vault-style cache implementation",
);

/**
 * Command-line client for Nix binary cache hosting https://cachix.org
 */
export const cachix = mkPackage(
  nixRaw`pkgs.haskellPackages.cachix`,
  "Command-line client for Nix binary cache hosting https://cachix.org",
);

/**
 * Command line client for Nix binary cache hosting https://cachix.org
 */
export const cachix_1_3_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.cachix_1_3_3`,
  "Command line client for Nix binary cache hosting https://cachix.org",
);

/**
 * Servant HTTP API specification for https://cachix.org
 */
export const cachix_api = mkPackage(
  nixRaw`pkgs.haskellPackages.cachix-api`,
  "Servant HTTP API specification for https://cachix.org",
);

/**
 * That rabbit's got a vicious streak a mile wide!
 */
export const caerbannog = mkPackage(
  nixRaw`pkgs.haskellPackages.caerbannog`,
  "That rabbit's got a vicious streak a mile wide!",
);

/**
 * A library of Concurrency Abstractions using Futures
 */
export const caf = mkPackage(
  nixRaw`pkgs.haskellPackages.caf`,
  "A library of Concurrency Abstractions using Futures",
);

export const caffegraph = mkPackage(
  nixRaw`pkgs.haskellPackages.caffegraph`,
  "",
);

/**
 * Binding to the Cairo library
 */
export const cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.cairo`,
  "Binding to the Cairo library",
);

/**
 * A template for building new GUI applications using GTK and Cairo
 */
export const cairo_appbase = mkPackage(
  nixRaw`pkgs.haskellPackages.cairo-appbase`,
  "A template for building new GUI applications using GTK and Cairo",
);

/**
 * Simpler drawing API for Cairo
 */
export const cairo_canvas = mkPackage(
  nixRaw`pkgs.haskellPackages.cairo-canvas`,
  "Simpler drawing API for Cairo",
);

/**
 * A build-system library and driver
 */
export const cake = mkPackage(
  nixRaw`pkgs.haskellPackages.cake`,
  "A build-system library and driver",
);

/**
 * run turtle like LOGO with lojban
 */
export const cakyrespa = mkPackage(
  nixRaw`pkgs.haskellPackages.cakyrespa`,
  "run turtle like LOGO with lojban",
);

/**
 * Examples for the Cal3d animation library
 */
export const cal3d_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.cal3d-examples`,
  "Examples for the Cal3d animation library",
);

/**
 * OpenGL rendering for the Cal3D animation library
 */
export const cal3d_opengl = mkPackage(
  nixRaw`pkgs.haskellPackages.cal3d-opengl`,
  "OpenGL rendering for the Cal3D animation library",
);

/**
 * A library for declaring, parsing, and invoking text-input based commands
 */
export const calamity_commands = mkPackage(
  nixRaw`pkgs.haskellPackages.calamity-commands`,
  "A library for declaring, parsing, and invoking text-input based commands",
);

/**
 * A small compiler for arithmetic expressions
 */
export const calc = mkPackage(
  nixRaw`pkgs.haskellPackages.calc`,
  "A small compiler for arithmetic expressions",
);

/**
 * A calculator repl, with variables, functions & Mathematica like dynamic plots
 */
export const calculator = mkPackage(
  nixRaw`pkgs.haskellPackages.calculator`,
  "A calculator repl, with variables, functions & Mathematica like dynamic plots",
);

/**
 * Calculation tool and library supporting units
 */
export const caldims = mkPackage(
  nixRaw`pkgs.haskellPackages.caldims`,
  "Calculation tool and library supporting units",
);

/**
 * List years with the same calendars
 */
export const calendar_recycling = mkPackage(
  nixRaw`pkgs.haskellPackages.calendar-recycling`,
  "List years with the same calendars",
);

/**
 * The call game engine
 */
export const call = mkPackage(
  nixRaw`pkgs.haskellPackages.call`,
  "The call game engine",
);

/**
 * Use GHC call-stacks in a backward compatible way
 */
export const call_stack = mkPackage(
  nixRaw`pkgs.haskellPackages.call-stack`,
  "Use GHC call-stacks in a backward compatible way",
);

/**
 * HIE-based Haskell call graph and source code visualizer
 */
export const calligraphy = mkPackage(
  nixRaw`pkgs.haskellPackages.calligraphy`,
  "HIE-based Haskell call graph and source code visualizer",
);

/**
 * CamFort - Cambridge Fortran infrastructure
 */
export const camfort = mkPackage(
  nixRaw`pkgs.haskellPackages.camfort`,
  "CamFort - Cambridge Fortran infrastructure",
);

/**
 * write image files onto 256(or 24bit) color terminals
 */
export const camh = mkPackage(
  nixRaw`pkgs.haskellPackages.camh`,
  "write image files onto 256(or 24bit) color terminals",
);

/**
 * Haskell implementation of the Campfire API
 */
export const campfire = mkPackage(
  nixRaw`pkgs.haskellPackages.campfire`,
  "Haskell implementation of the Campfire API",
);

/**
 * Generic implementation of the Has and CoHas patterns
 */
export const can_i_haz = mkPackage(
  nixRaw`pkgs.haskellPackages.can-i-haz`,
  "Generic implementation of the Has and CoHas patterns",
);

/**
 * Canadian income tax calculation
 */
export const canadian_income_tax = mkPackage(
  nixRaw`pkgs.haskellPackages.canadian-income-tax`,
  "Canadian income tax calculation",
);

/**
 * Candid integration
 */
export const candid = mkPackage(
  nixRaw`pkgs.haskellPackages.candid`,
  "Candid integration",
);

/**
 * Canonical JSON for signing and hashing JSON values
 */
export const canonical_json = mkPackage(
  nixRaw`pkgs.haskellPackages.canonical-json`,
  "Canonical JSON for signing and hashing JSON values",
);

/**
 * A pattern for configuring programs
 */
export const canteven_config = mkPackage(
  nixRaw`pkgs.haskellPackages.canteven-config`,
  "A pattern for configuring programs",
);

/**
 * Utilities for HTTP programming
 */
export const canteven_http = mkPackage(
  nixRaw`pkgs.haskellPackages.canteven-http`,
  "Utilities for HTTP programming",
);

/**
 * A few utilites and helpers for using Template Haskell in your projects
 */
export const canteven_template = mkPackage(
  nixRaw`pkgs.haskellPackages.canteven-template`,
  "A few utilites and helpers for using Template Haskell in your projects",
);

/**
 * Convert data to and from a natural number representation
 */
export const cantor_pairing = mkPackage(
  nixRaw`pkgs.haskellPackages.cantor-pairing`,
  "Convert data to and from a natural number representation",
);

/**
 * CAO Compiler
 */
export const cao = mkPackage(
  nixRaw`pkgs.haskellPackages.cao`,
  "CAO Compiler",
);

/**
 * Interprets and debug the cap language
 */
export const cap = mkPackage(
  nixRaw`pkgs.haskellPackages.cap`,
  "Interprets and debug the cap language",
);

/**
 * Extensional capabilities and deriving combinators
 */
export const capability = mkPackage(
  nixRaw`pkgs.haskellPackages.capability`,
  "Extensional capabilities and deriving combinators",
);

/**
 * Cap'n Proto for Haskell
 */
export const capnp = mkPackage(
  nixRaw`pkgs.haskellPackages.capnp`,
  "Cap'n Proto for Haskell",
);

/**
 * A package for integrating a variety of captcha solving services
 */
export const captcha_2captcha = mkPackage(
  nixRaw`pkgs.haskellPackages.captcha-2captcha`,
  "A package for integrating a variety of captcha solving services",
);

/**
 * A package for integrating a variety of captcha solving services
 */
export const captcha_capmonster = mkPackage(
  nixRaw`pkgs.haskellPackages.captcha-capmonster`,
  "A package for integrating a variety of captcha solving services",
);

/**
 * A package for integrating a variety of captcha solving services
 */
export const captcha_core = mkPackage(
  nixRaw`pkgs.haskellPackages.captcha-core`,
  "A package for integrating a variety of captcha solving services",
);

/**
 * Simple web-server for organizing car-pooling for an event
 */
export const car_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.car-pool`,
  "Simple web-server for organizing car-pooling for an event",
);

/**
 * Drop emails from threads being watched into special CC folder
 */
export const carboncopy = mkPackage(
  nixRaw`pkgs.haskellPackages.carboncopy`,
  "Drop emails from threads being watched into special CC folder",
);

/**
 * Algorithms for coin selection and fee balancing
 */
export const cardano_coin_selection = mkPackage(
  nixRaw`pkgs.haskellPackages.cardano-coin-selection`,
  "Algorithms for coin selection and fee balancing",
);

/**
 * A C-compatible array library
 */
export const carray = mkPackage(
  nixRaw`pkgs.haskellPackages.carray`,
  "A C-compatible array library",
);

/**
 * Specify Cabal files in Haskell
 */
export const cartel = mkPackage(
  nixRaw`pkgs.haskellPackages.cartel`,
  "Specify Cabal files in Haskell",
);

/**
 * ContentHashable instances for S3 objects
 */
export const cas_hashable_s3 = mkPackage(
  nixRaw`pkgs.haskellPackages.cas-hashable-s3`,
  "ContentHashable instances for S3 objects",
);

/**
 * A content-addressed storage
 */
export const cas_store = mkPackage(
  nixRaw`pkgs.haskellPackages.cas-store`,
  "A content-addressed storage",
);

/**
 * Client for Casa
 */
export const casa_client = mkPackage(
  nixRaw`pkgs.haskellPackages.casa-client`,
  "Client for Casa",
);

/**
 * Types for Casa
 */
export const casa_types = mkPackage(
  nixRaw`pkgs.haskellPackages.casa-types`,
  "Types for Casa",
);

/**
 * mid-level bindings to CasADi
 */
export const casadi_bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.casadi-bindings`,
  "mid-level bindings to CasADi",
);

/**
 * low level bindings to casadi-control
 */
export const casadi_bindings_control = mkPackage(
  nixRaw`pkgs.haskellPackages.casadi-bindings-control`,
  "low level bindings to casadi-control",
);

/**
 * autogenerated low level bindings to casadi
 */
export const casadi_bindings_core = mkPackage(
  nixRaw`pkgs.haskellPackages.casadi-bindings-core`,
  "autogenerated low level bindings to casadi",
);

/**
 * low level bindings to casadi-ipopt_interface
 */
export const casadi_bindings_ipopt_interface = mkPackage(
  nixRaw`pkgs.haskellPackages.casadi-bindings-ipopt-interface`,
  "low level bindings to casadi-ipopt_interface",
);

/**
 * low level bindings to casadi-snopt_interface
 */
export const casadi_bindings_snopt_interface = mkPackage(
  nixRaw`pkgs.haskellPackages.casadi-bindings-snopt-interface`,
  "low level bindings to casadi-snopt_interface",
);

/**
 * Convert between different cases
 */
export const case_conversion = mkPackage(
  nixRaw`pkgs.haskellPackages.case-conversion`,
  "Convert between different cases",
);

/**
 * Case insensitive string comparison
 */
export const case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.case-insensitive`,
  "Case insensitive string comparison",
);

/**
 * Track string casing in its type
 */
export const cased = mkPackage(
  nixRaw`pkgs.haskellPackages.cased`,
  "Track string casing in its type",
);

/**
 * A converter for spinal, snake and camel cases
 */
export const cases = mkPackage(
  nixRaw`pkgs.haskellPackages.cases`,
  "A converter for spinal, snake and camel cases",
);

/**
 * the Computer Algebra SHell
 */
export const cash = mkPackage(
  nixRaw`pkgs.haskellPackages.cash`,
  "the Computer Algebra SHell",
);

/**
 * Convert between various source code casing conventions
 */
export const casing = mkPackage(
  nixRaw`pkgs.haskellPackages.casing`,
  "Convert between various source code casing conventions",
);

/**
 * CASR 61.345 Pilot Personal Logbook HTML output
 */
export const casr_logbook_html = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-html`,
  "CASR 61.345 Pilot Personal Logbook HTML output",
);

/**
 * Meta-information about entries in a CASR 61.345 logbook (casr-logbook)
 */
export const casr_logbook_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-meta`,
  "Meta-information about entries in a CASR 61.345 logbook (casr-logbook)",
);

/**
 * Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output
 */
export const casr_logbook_meta_html = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-meta-html`,
  "Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output",
);

/**
 * CASR 61.345 logbook (casr-logbook) reports.
 */
export const casr_logbook_reports = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-reports`,
  "CASR 61.345 logbook (casr-logbook) reports.",
);

/**
 * CASR 61.345 logbook reports HTML output
 */
export const casr_logbook_reports_html = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-reports-html`,
  "CASR 61.345 logbook reports HTML output",
);

/**
 * Reports on meta-information about entries in a CASR 61.345 logbook (casr-logbook)
 */
export const casr_logbook_reports_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-reports-meta`,
  "Reports on meta-information about entries in a CASR 61.345 logbook (casr-logbook)",
);

/**
 * HTML output for reports on meta-information about entries in a CASR 61.345 logbook
 */
export const casr_logbook_reports_meta_html = mkPackage(
  nixRaw`pkgs.haskellPackages.casr-logbook-reports-meta-html`,
  "HTML output for reports on meta-information about entries in a CASR 61.345 logbook",
);

/**
 * thrift bindings to the cassandra database
 */
export const cassandra_thrift = mkPackage(
  nixRaw`pkgs.haskellPackages.cassandra-thrift`,
  "thrift bindings to the cassandra database",
);

/**
 * A CSV parsing and encoding library
 */
export const cassava = mkPackage(
  nixRaw`pkgs.haskellPackages.cassava`,
  "A CSV parsing and encoding library",
);

/**
 * CSV-file embedding library
 */
export const cassava_embed = mkPackage(
  nixRaw`pkgs.haskellPackages.cassava-embed`,
  "CSV-file embedding library",
);

/**
 * Cassave instances for functor-like datatypes like `Either String a`
 */
export const cassava_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.cassava-generic`,
  "Cassave instances for functor-like datatypes like `Either String a`",
);

/**
 * Megaparsec parser of CSV files that plays nicely with Cassava
 */
export const cassava_megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.cassava-megaparsec`,
  "Megaparsec parser of CSV files that plays nicely with Cassava",
);

/**
 * A high level driver for the Cassandra datastore
 */
export const cassy = mkPackage(
  nixRaw`pkgs.haskellPackages.cassy`,
  "A high level driver for the Cassandra datastore",
);

/**
 * Abstact cast pattern
 */
export const cast = mkPackage(
  nixRaw`pkgs.haskellPackages.cast`,
  "Abstact cast pattern",
);

/**
 * Multicast, thread-safe, and fast logger
 */
export const caster = mkPackage(
  nixRaw`pkgs.haskellPackages.caster`,
  "Multicast, thread-safe, and fast logger",
);

/**
 * Equation Manipulator
 */
export const casui = mkPackage(
  nixRaw`pkgs.haskellPackages.casui`,
  "Equation Manipulator",
);

/**
 * A Category typeclass hierarchy powerful enough to encode full programs
 */
export const catalyst = mkPackage(
  nixRaw`pkgs.haskellPackages.catalyst`,
  "A Category typeclass hierarchy powerful enough to encode full programs",
);

/**
 * Categorical Monoids and Semirings
 */
export const categorical_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.categorical-algebra`,
  "Categorical Monoids and Semirings",
);

/**
 * Categories
 */
export const categories = mkPackage(
  nixRaw`pkgs.haskellPackages.categories`,
  "Categories",
);

/**
 * Categorical types and classes
 */
export const category = mkPackage(
  nixRaw`pkgs.haskellPackages.category`,
  "Categorical types and classes",
);

/**
 * A meta-package documenting various packages inspired by category theory
 */
export const category_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.category-extras`,
  "A meta-package documenting various packages inspired by category theory",
);

/**
 * Lays out boxes according to the CSS Box Model
 */
export const cattrap = mkPackage(
  nixRaw`pkgs.haskellPackages.cattrap`,
  "Lays out boxes according to the CSS Box Model",
);

/**
 * Keep track of warnings and errors during calculations
 */
export const cautious = mkPackage(
  nixRaw`pkgs.haskellPackages.cautious`,
  "Keep track of warnings and errors during calculations",
);

/**
 * Cayenne Low Power Payload
 */
export const cayenne_lpp = mkPackage(
  nixRaw`pkgs.haskellPackages.cayenne-lpp`,
  "Cayenne Low Power Payload",
);

/**
 * Complex numbers, quaternions, octonions, sedenions, etc
 */
export const cayley_dickson = mkPackage(
  nixRaw`pkgs.haskellPackages.cayley-dickson`,
  "Complex numbers, quaternions, octonions, sedenions, etc",
);

/**
 * Concise Binary Object Representation (CBOR)
 */
export const cborg = mkPackage(
  nixRaw`pkgs.haskellPackages.cborg`,
  "Concise Binary Object Representation (CBOR)",
);

/**
 * A library for encoding JSON as CBOR
 */
export const cborg_json = mkPackage(
  nixRaw`pkgs.haskellPackages.cborg-json`,
  "A library for encoding JSON as CBOR",
);

/**
 * High-level interface to CCTools' WorkQueue library
 */
export const cctools_workqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.cctools-workqueue`,
  "High-level interface to CCTools' WorkQueue library",
);

/**
 * Exact real arithmetic using Centred Dyadic Approximations
 */
export const cdar_mBound = mkPackage(
  nixRaw`pkgs.haskellPackages.cdar-mBound`,
  "Exact real arithmetic using Centred Dyadic Approximations",
);

/**
 * Extract dependencies from C code
 */
export const cdeps = mkPackage(
  nixRaw`pkgs.haskellPackages.cdeps`,
  "Extract dependencies from C code",
);

/**
 * Simple wrapper around cef3-raw
 */
export const cef3_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.cef3-simple`,
  "Simple wrapper around cef3-raw",
);

/**
 * Common Haskell types and encoding for OpenStack Ceilometer
 */
export const ceilometer_common = mkPackage(
  nixRaw`pkgs.haskellPackages.ceilometer-common`,
  "Common Haskell types and encoding for OpenStack Ceilometer",
);

/**
 * A tool to build a novel
 */
export const celtchar = mkPackage(
  nixRaw`pkgs.haskellPackages.celtchar`,
  "A tool to build a novel",
);

/**
 * Protect and control API access with cerberus
 */
export const cerberus = mkPackage(
  nixRaw`pkgs.haskellPackages.cerberus`,
  "Protect and control API access with cerberus",
);

/**
 * A binary serialization library
 */
export const cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal`,
  "A binary serialization library",
);

/**
 * Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits
 */
export const cereal_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-conduit`,
  "Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits",
);

/**
 * Integration of "cereal" and "data-dword"
 */
export const cereal_data_dword = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-data-dword`,
  "Integration of \"cereal\" and \"data-dword\"",
);

/**
 * Deserialize things with cereal and enumerator
 */
export const cereal_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-enumerator`,
  "Deserialize things with cereal and enumerator",
);

/**
 * io-streams support for the cereal binary serialization library
 */
export const cereal_io_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-io-streams`,
  "io-streams support for the cereal binary serialization library",
);

/**
 * Use cereal to encode/decode io-streams
 */
export const cereal_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-streams`,
  "Use cereal to encode/decode io-streams",
);

/**
 * Data.Text instances for the cereal serialization library
 */
export const cereal_text = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-text`,
  "Data.Text instances for the cereal serialization library",
);

/**
 * Serialize instances for types from `time` package
 */
export const cereal_time = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-time`,
  "Serialize instances for types from `time` package",
);

/**
 * Integration of "cereal" and "unordered-containers"
 */
export const cereal_unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-unordered-containers`,
  "Integration of \"cereal\" and \"unordered-containers\"",
);

/**
 * Integration of "cereal" and "uuid"
 */
export const cereal_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-uuid`,
  "Integration of \"cereal\" and \"uuid\"",
);

/**
 * Serialize instances for Data.Vector types.
 */
export const cereal_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.cereal-vector`,
  "Serialize instances for Data.Vector types.",
);

/**
 * Certificates and Key Reader/Writer
 */
export const certificate = mkPackage(
  nixRaw`pkgs.haskellPackages.certificate`,
  "Certificates and Key Reader/Writer",
);

/**
 * cfipu processor for toy brainfuck-like language
 */
export const cfipu = mkPackage(
  nixRaw`pkgs.haskellPackages.cfipu`,
  "cfipu processor for toy brainfuck-like language",
);

/**
 * Constraint Functional-Logic Programming in Haskell
 */
export const cflp = mkPackage(
  nixRaw`pkgs.haskellPackages.cflp`,
  "Constraint Functional-Logic Programming in Haskell",
);

/**
 * cfopu processor
 */
export const cfopu = mkPackage(
  nixRaw`pkgs.haskellPackages.cfopu`,
  "cfopu processor",
);

/**
 * A library for writing CGI programs
 */
export const cgi = mkPackage(
  nixRaw`pkgs.haskellPackages.cgi`,
  "A library for writing CGI programs",
);

/**
 * Undecidable instances for the cgi package
 */
export const cgi_undecidable = mkPackage(
  nixRaw`pkgs.haskellPackages.cgi-undecidable`,
  "Undecidable instances for the cgi package",
);

/**
 * Command line tool
 */
export const cgrep = mkPackage(
  nixRaw`pkgs.haskellPackages.cgrep`,
  "Command line tool",
);

/**
 * Library decoding chain codes from images
 */
export const chain_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.chain-codes`,
  "Library decoding chain codes from images",
);

/**
 * Mining Client for Kadena Chainweb
 */
export const chainweb_mining_client = mkPackage(
  nixRaw`pkgs.haskellPackages.chainweb-mining-client`,
  "Mining Client for Kadena Chainweb",
);

/**
 * A REST Web Api server template for building (micro)services
 */
export const chakra = mkPackage(
  nixRaw`pkgs.haskellPackages.chakra`,
  "A REST Web Api server template for building (micro)services",
);

/**
 * Terminal string styling
 */
export const chalk = mkPackage(
  nixRaw`pkgs.haskellPackages.chalk`,
  "Terminal string styling",
);

/**
 * OpenGL based viewer for chalkboard rendered images
 */
export const chalkboard_viewer = mkPackage(
  nixRaw`pkgs.haskellPackages.chalkboard-viewer`,
  "OpenGL based viewer for chalkboard rendered images",
);

/**
 * Some extra kit for Chans
 */
export const chan = mkPackage(
  nixRaw`pkgs.haskellPackages.chan`,
  "Some extra kit for Chans",
);

/**
 * Concurrent Chans as read/write pairs. Also provides generic Chan pair class.
 */
export const chan_split = mkPackage(
  nixRaw`pkgs.haskellPackages.chan-split`,
  "Concurrent Chans as read/write pairs. Also provides generic Chan pair class.",
);

/**
 * Parse VCS changelogs into ChangeLogs
 */
export const change_monger = mkPackage(
  nixRaw`pkgs.haskellPackages.change-monger`,
  "Parse VCS changelogs into ChangeLogs",
);

/**
 * A diagnostics library for Haskell
 */
export const chapelure = mkPackage(
  nixRaw`pkgs.haskellPackages.chapelure`,
  "A diagnostics library for Haskell",
);

/**
 * Convert legacy byte encodings to and from Unicode
 */
export const char_decode = mkPackage(
  nixRaw`pkgs.haskellPackages.char-decode`,
  "Convert legacy byte encodings to and from Unicode",
);

/**
 * Quasiquoters for characters and codepoints
 */
export const char_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.char-qq`,
  "Quasiquoters for characters and codepoints",
);

/**
 * Rapid prototyping websites with Snap and Heist
 */
export const charade = mkPackage(
  nixRaw`pkgs.haskellPackages.charade`,
  "Rapid prototyping websites with Snap and Heist",
);

/**
 * Fast unicode character sets based on complemented PATRICIA tries
 */
export const charset = mkPackage(
  nixRaw`pkgs.haskellPackages.charset`,
  "Fast unicode character sets based on complemented PATRICIA tries",
);

/**
 * Character set detection using Mozilla's Universal Character Set Detector
 */
export const charsetdetect = mkPackage(
  nixRaw`pkgs.haskellPackages.charsetdetect`,
  "Character set detection using Mozilla's Universal Character Set Detector",
);

/**
 * Character set detection using Mozilla's Universal Character Set Detector
 */
export const charsetdetect_ae = mkPackage(
  nixRaw`pkgs.haskellPackages.charsetdetect-ae`,
  "Character set detection using Mozilla's Universal Character Set Detector",
);

/**
 * Command-line utility to draw charts from input data easily
 */
export const chart_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.chart-cli`,
  "Command-line utility to draw charts from input data easily",
);

/**
 * Charting library targetting SVGs
 */
export const chart_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.chart-svg`,
  "Charting library targetting SVGs",
);

/**
 * See readme.md
 */
export const chart_svg_various = mkPackage(
  nixRaw`pkgs.haskellPackages.chart-svg-various`,
  "See readme.md",
);

/**
 * Native haskell charts
 */
export const chart_unit = mkPackage(
  nixRaw`pkgs.haskellPackages.chart-unit`,
  "Native haskell charts",
);

/**
 * Polykinded Prelude Kernel
 */
export const chassis = mkPackage(
  nixRaw`pkgs.haskellPackages.chassis`,
  "Polykinded Prelude Kernel",
);

/**
 * A library of simple NLP algorithms
 */
export const chatter = mkPackage(
  nixRaw`pkgs.haskellPackages.chatter`,
  "A library of simple NLP algorithms",
);

/**
 * Some monad transformers and typeclasses for text in- and output abstraction
 */
export const chatty = mkPackage(
  nixRaw`pkgs.haskellPackages.chatty`,
  "Some monad transformers and typeclasses for text in- and output abstraction",
);

/**
 * Some utilities every serious chatty-based application may need
 */
export const chatty_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.chatty-utils`,
  "Some utilities every serious chatty-based application may need",
);

/**
 * Code highlighting for cheapskate
 */
export const cheapskate_highlight = mkPackage(
  nixRaw`pkgs.haskellPackages.cheapskate-highlight`,
  "Code highlighting for cheapskate",
);

/**
 * Use cheapskate with Lucid
 */
export const cheapskate_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.cheapskate-lucid`,
  "Use cheapskate with Lucid",
);

/**
 * Initial project template from stack
 */
export const cheapskate_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.cheapskate-terminal`,
  "Initial project template from stack",
);

/**
 * Confirm whether an email is valid and probably existant
 */
export const check_email = mkPackage(
  nixRaw`pkgs.haskellPackages.check-email`,
  "Confirm whether an email is valid and probably existant",
);

/**
 * Check whether module and package imports conform to the PVP
 */
export const check_pvp = mkPackage(
  nixRaw`pkgs.haskellPackages.check-pvp`,
  "Check whether module and package imports conform to the PVP",
);

/**
 * Check properties on standard classes and data structures
 */
export const checkers = mkPackage(
  nixRaw`pkgs.haskellPackages.checkers`,
  "Check properties on standard classes and data structures",
);

/**
 * Compute and verify checksums of ISBN, IBAN, etc
 */
export const checksum = mkPackage(
  nixRaw`pkgs.haskellPackages.checksum`,
  "Compute and verify checksums of ISBN, IBAN, etc",
);

/**
 * A simple and intuitive library for automated testing
 */
export const chell = mkPackage(
  nixRaw`pkgs.haskellPackages.chell`,
  "A simple and intuitive library for automated testing",
);

/**
 * HUnit support for Chell
 */
export const chell_hunit = mkPackage(
  nixRaw`pkgs.haskellPackages.chell-hunit`,
  "HUnit support for Chell",
);

/**
 * QuickCheck support for Chell
 */
export const chell_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.chell-quickcheck`,
  "QuickCheck support for Chell",
);

/**
 * Basic chess library
 */
export const chessIO = mkPackage(
  nixRaw`pkgs.haskellPackages.chessIO`,
  "Basic chess library",
);

/**
 * Simple library for validating chess moves and parsing PGN files
 */
export const chesshs = mkPackage(
  nixRaw`pkgs.haskellPackages.chesshs`,
  "Simple library for validating chess moves and parsing PGN files",
);

/**
 * A Library for Chess Game Logic
 */
export const chessica = mkPackage(
  nixRaw`pkgs.haskellPackages.chessica`,
  "A Library for Chess Game Logic",
);

/**
 * Query interface for Chevalier
 */
export const chevalier_common = mkPackage(
  nixRaw`pkgs.haskellPackages.chevalier-common`,
  "Query interface for Chevalier",
);

/**
 * A tmux client for Polysemy
 */
export const chiasma = mkPackage(
  nixRaw`pkgs.haskellPackages.chiasma`,
  "A tmux client for Polysemy",
);

/**
 * A tmux client for Polysemy
 */
export const chiasma_test = mkPackage(
  nixRaw`pkgs.haskellPackages.chiasma-test`,
  "A tmux client for Polysemy",
);

/**
 * Lazy infinite streams with O(1) indexing and applications for memoization
 */
export const chimera = mkPackage(
  nixRaw`pkgs.haskellPackages.chimera`,
  "Lazy infinite streams with O(1) indexing and applications for memoization",
);

/**
 * Helper for the Major System
 */
export const chitauri = mkPackage(
  nixRaw`pkgs.haskellPackages.chitauri`,
  "Helper for the Major System",
);

/**
 * A solution to boolean blindness
 */
export const choice = mkPackage(
  nixRaw`pkgs.haskellPackages.choice`,
  "A solution to boolean blindness",
);

/**
 * Command-line program to choose random element from a stream
 */
export const choose_exe = mkPackage(
  nixRaw`pkgs.haskellPackages.choose-exe`,
  "Command-line program to choose random element from a stream",
);

/**
 * A module containing basic geo functions
 */
export const chorale_geo = mkPackage(
  nixRaw`pkgs.haskellPackages.chorale-geo`,
  "A module containing basic geo functions",
);

/**
 * MTL class instances for the CHP library
 */
export const chp_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.chp-mtl`,
  "MTL class instances for the CHP library",
);

/**
 * A set of high-level concurrency utilities built on Communicating Haskell Processes
 */
export const chp_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.chp-plus`,
  "A set of high-level concurrency utilities built on Communicating Haskell Processes",
);

/**
 * A mirror implementation of chp that generates a specification of the program
 */
export const chp_spec = mkPackage(
  nixRaw`pkgs.haskellPackages.chp-spec`,
  "A mirror implementation of chp that generates a specification of the program",
);

/**
 * Transformers instances for the CHP library
 */
export const chp_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.chp-transformers`,
  "Transformers instances for the CHP library",
);

/**
 * Constraint Handling Rules
 */
export const chr_core = mkPackage(
  nixRaw`pkgs.haskellPackages.chr-core`,
  "Constraint Handling Rules",
);

/**
 * Datatypes required for chr library
 */
export const chr_data = mkPackage(
  nixRaw`pkgs.haskellPackages.chr-data`,
  "Datatypes required for chr library",
);

/**
 * AST + surface language around chr
 */
export const chr_lang = mkPackage(
  nixRaw`pkgs.haskellPackages.chr-lang`,
  "AST + surface language around chr",
);

/**
 * Pretty printing for chr library
 */
export const chr_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.chr-pretty`,
  "Pretty printing for chr library",
);

/**
 * neovim package manager
 */
export const chromatin = mkPackage(
  nixRaw`pkgs.haskellPackages.chromatin`,
  "neovim package manager",
);

/**
 * Time to manipulate time
 */
export const chronologique = mkPackage(
  nixRaw`pkgs.haskellPackages.chronologique`,
  "Time to manipulate time",
);

/**
 * A high-performance time library
 */
export const chronos = mkPackage(
  nixRaw`pkgs.haskellPackages.chronos`,
  "A high-performance time library",
);

/**
 * Benchmarking tool with focus on comparing results
 */
export const chronos_bench = mkPackage(
  nixRaw`pkgs.haskellPackages.chronos-bench`,
  "Benchmarking tool with focus on comparing results",
);

/**
 * Cabal with c2hs dependencies
 */
export const chs_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.chs-cabal`,
  "Cabal with c2hs dependencies",
);

/**
 * c2hs dependency analyzer
 */
export const chs_deps = mkPackage(
  nixRaw`pkgs.haskellPackages.chs-deps`,
  "c2hs dependency analyzer",
);

/**
 * FFI for Chu2 Agda Web Server Interface
 */
export const chu2 = mkPackage(
  nixRaw`pkgs.haskellPackages.chu2`,
  "FFI for Chu2 Agda Web Server Interface",
);

/**
 * Behaviour Driven Development like Cucumber for Haskell
 */
export const chuchu = mkPackage(
  nixRaw`pkgs.haskellPackages.chuchu`,
  "Behaviour Driven Development like Cucumber for Haskell",
);

/**
 * Typeclasses for dealing with various chunked data representations
 */
export const chunked_data = mkPackage(
  nixRaw`pkgs.haskellPackages.chunked-data`,
  "Typeclasses for dealing with various chunked data representations",
);

/**
 * Simple template library with static safety
 */
export const chunks = mkPackage(
  nixRaw`pkgs.haskellPackages.chunks`,
  "Simple template library with static safety",
);

/**
 * Removed; please see fmlist
 */
export const church_list = mkPackage(
  nixRaw`pkgs.haskellPackages.church-list`,
  "Removed; please see fmlist",
);

/**
 * Church encoded pair
 */
export const church_pair = mkPackage(
  nixRaw`pkgs.haskellPackages.church-pair`,
  "Church encoded pair",
);

export const ci_info = mkPackage(
  nixRaw`pkgs.haskellPackages.ci-info`,
  "",
);

/**
 * Fast AES cipher implementation with advanced mode of operations
 */
export const cipher_aes = mkPackage(
  nixRaw`pkgs.haskellPackages.cipher-aes`,
  "Fast AES cipher implementation with advanced mode of operations",
);

/**
 * Camellia block cipher primitives
 */
export const cipher_camellia = mkPackage(
  nixRaw`pkgs.haskellPackages.cipher-camellia`,
  "Camellia block cipher primitives",
);

/**
 * Fast RC4 cipher implementation
 */
export const cipher_rc4 = mkPackage(
  nixRaw`pkgs.haskellPackages.cipher-rc4`,
  "Fast RC4 cipher implementation",
);

/**
 * Pure RC5 implementation
 */
export const cipher_rc5 = mkPackage(
  nixRaw`pkgs.haskellPackages.cipher-rc5`,
  "Pure RC5 implementation",
);

/**
 * Implementation of CipherSaber2 RC4 cryptography
 */
export const ciphersaber2 = mkPackage(
  nixRaw`pkgs.haskellPackages.ciphersaber2`,
  "Implementation of CipherSaber2 RC4 cryptography",
);

/**
 * A Compiler IR Compiler
 */
export const circ = mkPackage(
  nixRaw`pkgs.haskellPackages.circ`,
  "A Compiler IR Compiler",
);

/**
 * Circle API client for Haskell
 */
export const circle = mkPackage(
  nixRaw`pkgs.haskellPackages.circle`,
  "Circle API client for Haskell",
);

/**
 * Simple heuristic for packing discs of varying radii in a circle
 */
export const circle_packing = mkPackage(
  nixRaw`pkgs.haskellPackages.circle-packing`,
  "Simple heuristic for packing discs of varying radii in a circle",
);

/**
 * An implementation of the "circuit breaker" pattern to disable repeated calls to a failing system
 */
export const circuit_breaker = mkPackage(
  nixRaw`pkgs.haskellPackages.circuit-breaker`,
  "An implementation of the \"circuit breaker\" pattern to disable repeated calls to a failing system",
);

/**
 * Circular fixed-sized mutable vectors
 */
export const circular = mkPackage(
  nixRaw`pkgs.haskellPackages.circular`,
  "Circular fixed-sized mutable vectors",
);

/**
 * Make bounded enum types circular
 */
export const circular_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.circular-enum`,
  "Make bounded enum types circular",
);

/**
 * Types and a small DSL for working with netlistsvg
 */
export const circus = mkPackage(
  nixRaw`pkgs.haskellPackages.circus`,
  "Types and a small DSL for working with netlistsvg",
);

/**
 * Cirru Parser in Haskell
 */
export const cirru_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.cirru-parser`,
  "Cirru Parser in Haskell",
);

/**
 * DEPRECATED in favor of webex-teams-api
 */
export const cisco_spark_api = mkPackage(
  nixRaw`pkgs.haskellPackages.cisco-spark-api`,
  "DEPRECATED in favor of webex-teams-api",
);

/**
 * convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference
 */
export const citation_resolve = mkPackage(
  nixRaw`pkgs.haskellPackages.citation-resolve`,
  "convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference",
);

/**
 * Generates citations and bibliography from CSL styles
 */
export const citeproc = mkPackage(
  nixRaw`pkgs.haskellPackages.citeproc`,
  "Generates citations and bibliography from CSL styles",
);

/**
 * A Pandoc filter for processing bibliographic references with citeproc-hs
 */
export const citeproc_hs_pandoc_filter = mkPackage(
  nixRaw`pkgs.haskellPackages.citeproc-hs-pandoc-filter`,
  "A Pandoc filter for processing bibliographic references with citeproc-hs",
);

/**
 * Bindings to CityHash
 */
export const cityhash = mkPackage(
  nixRaw`pkgs.haskellPackages.cityhash`,
  "Bindings to CityHash",
);

/**
 * Clifford Algebra of three dimensional space
 */
export const cl3 = mkPackage(
  nixRaw`pkgs.haskellPackages.cl3`,
  "Clifford Algebra of three dimensional space",
);

/**
 * Simple CLI RPN calculator
 */
export const clac = mkPackage(
  nixRaw`pkgs.haskellPackages.clac`,
  "Simple CLI RPN calculator",
);

/**
 * Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot
 */
export const clafer = mkPackage(
  nixRaw`pkgs.haskellPackages.clafer`,
  "Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot",
);

/**
 * claferIG is an interactive tool that generates instances of Clafer models
 */
export const claferIG = mkPackage(
  nixRaw`pkgs.haskellPackages.claferIG`,
  "claferIG is an interactive tool that generates instances of Clafer models",
);

/**
 * A wiki-based IDE for literate modeling with Clafer
 */
export const claferwiki = mkPackage(
  nixRaw`pkgs.haskellPackages.claferwiki`,
  "A wiki-based IDE for literate modeling with Clafer",
);

/**
 * CAES Language for Synchronous Hardware (CLaSH)
 */
export const clash = mkPackage(
  nixRaw`pkgs.haskellPackages.clash`,
  "CAES Language for Synchronous Hardware (CLaSH)",
);

/**
 * Clash: a functional hardware description language - GHC frontend
 */
export const clash_ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-ghc`,
  "Clash: a functional hardware description language - GHC frontend",
);

/**
 * Clash: a functional hardware description language - As a library
 */
export const clash_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-lib`,
  "Clash: a functional hardware description language - As a library",
);

/**
 * Hedgehog Generators for clash-lib
 */
export const clash_lib_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-lib-hedgehog`,
  "Hedgehog Generators for clash-lib",
);

export const clash_multisignal = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-multisignal`,
  "",
);

/**
 * Hedgehog Generators for clash-prelude
 */
export const clash_prelude_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-prelude-hedgehog`,
  "Hedgehog Generators for clash-prelude",
);

/**
 * QuickCheck instances for various types in the CaSH Prelude
 */
export const clash_prelude_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-prelude-quickcheck`,
  "QuickCheck instances for various types in the CaSH Prelude",
);

/**
 * Shake rules for building Clash programs
 */
export const clash_shake = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-shake`,
  "Shake rules for building Clash programs",
);

/**
 * CAES Language for Synchronous Hardware - SystemVerilog backend
 */
export const clash_systemverilog = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-systemverilog`,
  "CAES Language for Synchronous Hardware - SystemVerilog backend",
);

/**
 * CAES Language for Synchronous Hardware - Verilog backend
 */
export const clash_verilog = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-verilog`,
  "CAES Language for Synchronous Hardware - Verilog backend",
);

/**
 * CAES Language for Synchronous Hardware - VHDL backend
 */
export const clash_vhdl = mkPackage(
  nixRaw`pkgs.haskellPackages.clash-vhdl`,
  "CAES Language for Synchronous Hardware - VHDL backend",
);

/**
 * Automated Clash to Verilator bridge
 */
export const clashilator = mkPackage(
  nixRaw`pkgs.haskellPackages.clashilator`,
  "Automated Clash to Verilator bridge",
);

/**
 * Library for classification of media files
 */
export const classify = mkPackage(
  nixRaw`pkgs.haskellPackages.classify`,
  "Library for classification of media files",
);

/**
 * Classify sounds produced by Xenopus laevis
 */
export const classify_frog = mkPackage(
  nixRaw`pkgs.haskellPackages.classify-frog`,
  "Classify sounds produced by Xenopus laevis",
);

/**
 * An interface for a handler-independent, typeclass-based effect system
 */
export const classy_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-effects`,
  "An interface for a handler-independent, typeclass-based effect system",
);

/**
 * Automatic compliance with the classy-effects protocols
 */
export const classy_effects_th = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-effects-th`,
  "Automatic compliance with the classy-effects protocols",
);

/**
 * Typeclass based support for Miso, the Tasty Web Framework for Haskell
 */
export const classy_miso = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-miso`,
  "Typeclass based support for Miso, the Tasty Web Framework for Haskell",
);

/**
 * A typeclass-based Prelude
 */
export const classy_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-prelude`,
  "A typeclass-based Prelude",
);

/**
 * classy-prelude together with conduit functions
 */
export const classy_prelude_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-prelude-conduit`,
  "classy-prelude together with conduit functions",
);

/**
 * Provide a classy prelude including common Yesod functionality
 */
export const classy_prelude_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.classy-prelude-yesod`,
  "Provide a classy prelude including common Yesod functionality",
);

/**
 * CSS preprocessor as embedded Haskell
 */
export const clay = mkPackage(
  nixRaw`pkgs.haskellPackages.clay`,
  "CSS preprocessor as embedded Haskell",
);

/**
 * A secure, reliable content management system (CMS) and blogging platform
 */
export const clckwrks = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks`,
  "A secure, reliable content management system (CMS) and blogging platform",
);

/**
 * a command-line interface for adminstrating some aspects of clckwrks
 */
export const clckwrks_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-cli`,
  "a command-line interface for adminstrating some aspects of clckwrks",
);

/**
 * clckwrks.com
 */
export const clckwrks_dot_com = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-dot-com`,
  "clckwrks.com",
);

/**
 * bug tracking plugin for clckwrks
 */
export const clckwrks_plugin_bugs = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-bugs`,
  "bug tracking plugin for clckwrks",
);

/**
 * ircbot plugin for clckwrks
 */
export const clckwrks_plugin_ircbot = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-ircbot`,
  "ircbot plugin for clckwrks",
);

/**
 * mailing list plugin for clckwrks
 */
export const clckwrks_plugin_mailinglist = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-mailinglist`,
  "mailing list plugin for clckwrks",
);

/**
 * media plugin for clckwrks
 */
export const clckwrks_plugin_media = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-media`,
  "media plugin for clckwrks",
);

/**
 * support for CMS/Blogging in clckwrks
 */
export const clckwrks_plugin_page = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-page`,
  "support for CMS/Blogging in clckwrks",
);

/**
 * support redirects for CMS/Blogging in clckwrks
 */
export const clckwrks_plugin_redirect = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-plugin-redirect`,
  "support redirects for CMS/Blogging in clckwrks",
);

/**
 * simple bootstrap based template for clckwrks
 */
export const clckwrks_theme_bootstrap = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-theme-bootstrap`,
  "simple bootstrap based template for clckwrks",
);

/**
 * simple bootstrap based template for clckwrks
 */
export const clckwrks_theme_clckwrks = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-theme-clckwrks`,
  "simple bootstrap based template for clckwrks",
);

/**
 * geo bootstrap based template for clckwrks
 */
export const clckwrks_theme_geo_bootstrap = mkPackage(
  nixRaw`pkgs.haskellPackages.clckwrks-theme-geo-bootstrap`,
  "geo bootstrap based template for clckwrks",
);

/**
 * Keep your home dir clean by finding old conf files
 */
export const clean_home = mkPackage(
  nixRaw`pkgs.haskellPackages.clean-home`,
  "Keep your home dir clean by finding old conf files",
);

/**
 * Automatic disambiguation for extensible effects
 */
export const cleff_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.cleff-plugin`,
  "Automatic disambiguation for extensible effects",
);

/**
 * Declaratively describe spreadsheets
 */
export const clerk = mkPackage(
  nixRaw`pkgs.haskellPackages.clerk`,
  "Declaratively describe spreadsheets",
);

/**
 * Colorized LESS
 */
export const cless = mkPackage(
  nixRaw`pkgs.haskellPackages.cless`,
  "Colorized LESS",
);

/**
 * Testing framework for Morley
 */
export const cleveland = mkPackage(
  nixRaw`pkgs.haskellPackages.cleveland`,
  "Testing framework for Morley",
);

/**
 * CLI
 */
export const cli = mkPackage(
  nixRaw`pkgs.haskellPackages.cli`,
  "CLI",
);

/**
 * A library to process command line arguments in some more convenient way
 */
export const cli_arguments = mkPackage(
  nixRaw`pkgs.haskellPackages.cli-arguments`,
  "A library to process command line arguments in some more convenient way",
);

/**
 * A library to process command line arguments in some more convenient way
 */
export const cli_arguments_strict = mkPackage(
  nixRaw`pkgs.haskellPackages.cli-arguments-strict`,
  "A library to process command line arguments in some more convenient way",
);

/**
 * Bindings to the git command-line interface
 */
export const cli_git = mkPackage(
  nixRaw`pkgs.haskellPackages.cli-git`,
  "Bindings to the git command-line interface",
);

/**
 * Bindings to the nix command-line interface
 */
export const cli_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.cli-nix`,
  "Bindings to the nix command-line interface",
);

/**
 * Helper setup scripts for packaging command-line tools
 */
export const cli_setup = mkPackage(
  nixRaw`pkgs.haskellPackages.cli-setup`,
  "Helper setup scripts for packaging command-line tools",
);

/**
 * Toy game (tetris on billiard board). Hipmunk in action.
 */
export const click_clack = mkPackage(
  nixRaw`pkgs.haskellPackages.click-clack`,
  "Toy game (tetris on billiard board). Hipmunk in action.",
);

/**
 * A Haskell library as database client for Clickhouse
 */
export const clickhouse_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.clickhouse-haskell`,
  "A Haskell library as database client for Clickhouse",
);

/**
 * Securely store session data in a client-side cookie
 */
export const clientsession = mkPackage(
  nixRaw`pkgs.haskellPackages.clientsession`,
  "Securely store session data in a client-side cookie",
);

/**
 * A Clifford algebra library
 */
export const clifford = mkPackage(
  nixRaw`pkgs.haskellPackages.clifford`,
  "A Clifford algebra library",
);

/**
 * Building blocks for a GHCi-like REPL with colon-commands
 */
export const climb = mkPackage(
  nixRaw`pkgs.haskellPackages.climb`,
  "Building blocks for a GHCi-like REPL with colon-commands",
);

/**
 * A parser/generator for Kindle-format clipping files (`My Clippings.txt`),
 */
export const clippings = mkPackage(
  nixRaw`pkgs.haskellPackages.clippings`,
  "A parser/generator for Kindle-format clipping files (`My Clippings.txt`),",
);

/**
 * Counted list
 */
export const clist = mkPackage(
  nixRaw`pkgs.haskellPackages.clist`,
  "Counted list",
);

/**
 * High-resolution clock functions: monotonic, realtime, cputime
 */
export const clock = mkPackage(
  nixRaw`pkgs.haskellPackages.clock`,
  "High-resolution clock functions: monotonic, realtime, cputime",
);

/**
 * Integers bounded by a closed interval
 */
export const closed = mkPackage(
  nixRaw`pkgs.haskellPackages.closed`,
  "Integers bounded by a closed interval",
);

/**
 * The Cloud Haskell Application Platform
 */
export const cloud_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.cloud-haskell`,
  "The Cloud Haskell Application Platform",
);

/**
 * A tool for interacting with AWS CloudFormation
 */
export const cloud_seeder = mkPackage(
  nixRaw`pkgs.haskellPackages.cloud-seeder`,
  "A tool for interacting with AWS CloudFormation",
);

/**
 * Haskell CloudI API
 */
export const cloudi = mkPackage(
  nixRaw`pkgs.haskellPackages.cloudi`,
  "Haskell CloudI API",
);

/**
 * A cloud in the file system
 */
export const cloudyfs = mkPackage(
  nixRaw`pkgs.haskellPackages.cloudyfs`,
  "A cloud in the file system",
);

/**
 * Glue between clr-host and clr-typed
 */
export const clr_bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.clr-bindings`,
  "Glue between clr-host and clr-typed",
);

/**
 * Quasiquoters for inline C# and F#
 */
export const clr_inline = mkPackage(
  nixRaw`pkgs.haskellPackages.clr-inline`,
  "Quasiquoters for inline C# and F#",
);

/**
 * Marshaling for the clr
 */
export const clr_marshal = mkPackage(
  nixRaw`pkgs.haskellPackages.clr-marshal`,
  "Marshaling for the clr",
);

/**
 * A GHC linker wrapper tool to workaround a GHC >8.2 bug
 */
export const clr_win_linker = mkPackage(
  nixRaw`pkgs.haskellPackages.clr-win-linker`,
  "A GHC linker wrapper tool to workaround a GHC >8.2 bug",
);

/**
 * Command line Twitter utility
 */
export const cltw = mkPackage(
  nixRaw`pkgs.haskellPackages.cltw`,
  "Command line Twitter utility",
);

/**
 * C to Lua data wrapper generator
 */
export const clua = mkPackage(
  nixRaw`pkgs.haskellPackages.clua`,
  "C to Lua data wrapper generator",
);

/**
 * Calculate the clumpiness of leaf properties in a tree
 */
export const clumpiness = mkPackage(
  nixRaw`pkgs.haskellPackages.clumpiness`,
  "Calculate the clumpiness of leaf properties in a tree",
);

/**
 * High performance clustering algorithms
 */
export const clustering = mkPackage(
  nixRaw`pkgs.haskellPackages.clustering`,
  "High performance clustering algorithms",
);

/**
 * Tools for manipulating sequence clusters
 */
export const clustertools = mkPackage(
  nixRaw`pkgs.haskellPackages.clustertools`,
  "Tools for manipulating sequence clusters",
);

/**
 * Bindings to the Clutter animation library
 */
export const clutterhs = mkPackage(
  nixRaw`pkgs.haskellPackages.clutterhs`,
  "Bindings to the Clutter animation library",
);

/**
 * CMA-ES wrapper in Haskell
 */
export const cmaes = mkPackage(
  nixRaw`pkgs.haskellPackages.cmaes`,
  "CMA-ES wrapper in Haskell",
);

/**
 * Parser for the CMake syntax (CMakeLists.txt and .cmake files)
 */
export const cmake_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.cmake-syntax`,
  "Parser for the CMake syntax (CMakeLists.txt and .cmake files)",
);

/**
 * Fast, accurate CommonMark (Markdown) parser and renderer
 */
export const cmark = mkPackage(
  nixRaw`pkgs.haskellPackages.cmark`,
  "Fast, accurate CommonMark (Markdown) parser and renderer",
);

/**
 * Fast, accurate GitHub Flavored Markdown parser and renderer
 */
export const cmark_gfm = mkPackage(
  nixRaw`pkgs.haskellPackages.cmark-gfm`,
  "Fast, accurate GitHub Flavored Markdown parser and renderer",
);

/**
 * Use cmark with Lucid
 */
export const cmark_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.cmark-lucid`,
  "Use cmark with Lucid",
);

/**
 * Data model, parser, serialiser and transformations for Content MathML 3
 */
export const cmathml3 = mkPackage(
  nixRaw`pkgs.haskellPackages.cmathml3`,
  "Data model, parser, serialiser and transformations for Content MathML 3",
);

/**
 * Command line argument processing
 */
export const cmdargs = mkPackage(
  nixRaw`pkgs.haskellPackages.cmdargs`,
  "Command line argument processing",
);

/**
 * Helper to enter cmdargs command lines using a web browser
 */
export const cmdargs_browser = mkPackage(
  nixRaw`pkgs.haskellPackages.cmdargs-browser`,
  "Helper to enter cmdargs command lines using a web browser",
);

/**
 * Events and Channels as in Concurrent ML
 */
export const cml = mkPackage(
  nixRaw`pkgs.haskellPackages.cml`,
  "Events and Channels as in Concurrent ML",
);

/**
 * Compare types of any kinds
 */
export const cmptype = mkPackage(
  nixRaw`pkgs.haskellPackages.cmptype`,
  "Compare types of any kinds",
);

/**
 * Unification in a Commutative Monoid
 */
export const cmu = mkPackage(
  nixRaw`pkgs.haskellPackages.cmu`,
  "Unification in a Commutative Monoid",
);

/**
 * Detailed visualization of CMs, HMMs and their comparisions
 */
export const cmv = mkPackage(
  nixRaw`pkgs.haskellPackages.cmv`,
  "Detailed visualization of CMs, HMMs and their comparisions",
);

/**
 * Compiler/Translator for CnC Specification Files
 */
export const cnc_spec_compiler = mkPackage(
  nixRaw`pkgs.haskellPackages.cnc-spec-compiler`,
  "Compiler/Translator for CnC Specification Files",
);

/**
 * Chinese/Mandarin <-> English dictionary, Chinese lexer
 */
export const cndict = mkPackage(
  nixRaw`pkgs.haskellPackages.cndict`,
  "Chinese/Mandarin <-> English dictionary, Chinese lexer",
);

/**
 * Hardware software co-design Feldspar
 */
export const co_feldspar = mkPackage(
  nixRaw`pkgs.haskellPackages.co-feldspar`,
  "Hardware software co-design Feldspar",
);

/**
 * Composable Contravariant Comonadic Logging Library
 */
export const co_log = mkPackage(
  nixRaw`pkgs.haskellPackages.co-log`,
  "Composable Contravariant Comonadic Logging Library",
);

/**
 * Asynchronous backend for co-log library
 */
export const co_log_concurrent = mkPackage(
  nixRaw`pkgs.haskellPackages.co-log-concurrent`,
  "Asynchronous backend for co-log library",
);

/**
 * Composable Contravariant Comonadic Logging Library
 */
export const co_log_core = mkPackage(
  nixRaw`pkgs.haskellPackages.co-log-core`,
  "Composable Contravariant Comonadic Logging Library",
);

/**
 * Structured messages support in co-log ecosystem
 */
export const co_log_json = mkPackage(
  nixRaw`pkgs.haskellPackages.co-log-json`,
  "Structured messages support in co-log ecosystem",
);

/**
 * Composable Contravariant Comonadic Logging Library
 */
export const co_log_polysemy = mkPackage(
  nixRaw`pkgs.haskellPackages.co-log-polysemy`,
  "Composable Contravariant Comonadic Logging Library",
);

/**
 * Computational biology toolkit to collaborate with researchers in constructive protein engineering
 */
export const cobot = mkPackage(
  nixRaw`pkgs.haskellPackages.cobot`,
  "Computational biology toolkit to collaborate with researchers in constructive protein engineering",
);

/**
 * Biological data file formats and IO
 */
export const cobot_io = mkPackage(
  nixRaw`pkgs.haskellPackages.cobot-io`,
  "Biological data file formats and IO",
);

/**
 * synthesize Haskell functions out of partial definitions
 */
export const code_conjure = mkPackage(
  nixRaw`pkgs.haskellPackages.code-conjure`,
  "synthesize Haskell functions out of partial definitions",
);

/**
 * Windows code page library for Haskell
 */
export const code_page = mkPackage(
  nixRaw`pkgs.haskellPackages.code-page`,
  "Windows code page library for Haskell",
);

/**
 * Simple bidirectional serialization
 */
export const codec = mkPackage(
  nixRaw`pkgs.haskellPackages.codec`,
  "Simple bidirectional serialization",
);

/**
 * Cross-platform structure serialisation
 */
export const codec_libevent = mkPackage(
  nixRaw`pkgs.haskellPackages.codec-libevent`,
  "Cross-platform structure serialisation",
);

/**
 * A library to read and write mailboxes in mbox format
 */
export const codec_mbox = mkPackage(
  nixRaw`pkgs.haskellPackages.codec-mbox`,
  "A library to read and write mailboxes in mbox format",
);

/**
 * A library for manipulating RPM files
 */
export const codec_rpm = mkPackage(
  nixRaw`pkgs.haskellPackages.codec-rpm`,
  "A library for manipulating RPM files",
);

/**
 * Tool that automatically runs arbitrary commands when files change on disk
 */
export const codemonitor = mkPackage(
  nixRaw`pkgs.haskellPackages.codemonitor`,
  "Tool that automatically runs arbitrary commands when files change on disk",
);

/**
 * Graphics library for CodeWorld
 */
export const codeworld_api = mkPackage(
  nixRaw`pkgs.haskellPackages.codeworld-api`,
  "Graphics library for CodeWorld",
);

/**
 * Having trouble deriving instances because of type roles? Solve it here!
 */
export const coerce_role = mkPackage(
  nixRaw`pkgs.haskellPackages.coerce-role`,
  "Having trouble deriving instances because of type roles? Solve it here!",
);

/**
 * utils for Data.Coerce
 */
export const coerce_util = mkPackage(
  nixRaw`pkgs.haskellPackages.coerce-util`,
  "utils for Data.Coerce",
);

/**
 * Coercible but only in one direction
 */
export const coercible_subtypes = mkPackage(
  nixRaw`pkgs.haskellPackages.coercible-subtypes`,
  "Coercible but only in one direction",
);

/**
 * Extra utilities for manipulating nominal and representational coercions
 */
export const coercion_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.coercion-extras`,
  "Extra utilities for manipulating nominal and representational coercions",
);

/**
 * Generate clang-format config based on some existing code base
 */
export const coformat = mkPackage(
  nixRaw`pkgs.haskellPackages.coformat`,
  "Generate clang-format config based on some existing code base",
);

/**
 * DEPRECATED: use the "contravariant" package
 */
export const cofunctor = mkPackage(
  nixRaw`pkgs.haskellPackages.cofunctor`,
  "DEPRECATED: use the \"contravariant\" package",
);

/**
 * Utilities for Cognimeta products (such as perdure). API may change often.
 */
export const cognimeta_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.cognimeta-utils`,
  "Utilities for Cognimeta products (such as perdure). API may change often.",
);

/**
 * Connector library for the coinbase exchange
 */
export const coinbase_exchange = mkPackage(
  nixRaw`pkgs.haskellPackages.coinbase-exchange`,
  "Connector library for the coinbase exchange",
);

/**
 * Equivariant CSM classes of coincident root loci
 */
export const coincident_root_loci = mkPackage(
  nixRaw`pkgs.haskellPackages.coincident-root-loci`,
  "Equivariant CSM classes of coincident root loci",
);

/**
 * Linear Programming using COIN-OR/CLP and comfort-array
 */
export const coinor_clp = mkPackage(
  nixRaw`pkgs.haskellPackages.coinor-clp`,
  "Linear Programming using COIN-OR/CLP and comfort-array",
);

/**
 * Generate CSV & XLSX files for importing into CoinTracking
 */
export const cointracking_imports = mkPackage(
  nixRaw`pkgs.haskellPackages.cointracking-imports`,
  "Generate CSV & XLSX files for importing into CoinTracking",
);

/**
 * Colada implements incremental word class class induction using online LDA
 */
export const colada = mkPackage(
  nixRaw`pkgs.haskellPackages.colada`,
  "Colada implements incremental word class class induction using online LDA",
);

/**
 * File transfer via QR Codes
 */
export const cold_widow = mkPackage(
  nixRaw`pkgs.haskellPackages.cold-widow`,
  "File transfer via QR Codes",
);

/**
 * Data exchange between graphics applications
 */
export const collada_types = mkPackage(
  nixRaw`pkgs.haskellPackages.collada-types`,
  "Data exchange between graphics applications",
);

/**
 * Collapse the duplication output into clones and return their frequencies
 */
export const collapse_duplication = mkPackage(
  nixRaw`pkgs.haskellPackages.collapse-duplication`,
  "Collapse the duplication output into clones and return their frequencies",
);

/**
 * Error monad with a Float instance
 */
export const collect_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.collect-errors`,
  "Error monad with a Float instance",
);

/**
 * Collection+JSONHypermedia Type Tools
 */
export const collection_json = mkPackage(
  nixRaw`pkgs.haskellPackages.collection-json`,
  "Collection+JSONHypermedia Type Tools",
);

/**
 * Useful standard collections types and related functions
 */
export const collections_base_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.collections-base-instances`,
  "Useful standard collections types and related functions",
);

/**
 * thread-friendly file locks that don't block the entire program
 */
export const colock = mkPackage(
  nixRaw`pkgs.haskellPackages.colock`,
  "thread-friendly file locks that don't block the entire program",
);

/**
 * Count colors in images
 */
export const color_counter = mkPackage(
  nixRaw`pkgs.haskellPackages.color-counter`,
  "Count colors in images",
);

/**
 * Styled console text output using ANSI escape sequences
 */
export const colorful_monoids = mkPackage(
  nixRaw`pkgs.haskellPackages.colorful-monoids`,
  "Styled console text output using ANSI escape sequences",
);

/**
 * Highligt Haskell source
 */
export const colorize_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.colorize-haskell`,
  "Highligt Haskell source",
);

/**
 * Http Client addon for Colorless
 */
export const colorless_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.colorless-http-client`,
  "Http Client addon for Colorless",
);

/**
 * Scotty server add-on for Colorless
 */
export const colorless_scotty = mkPackage(
  nixRaw`pkgs.haskellPackages.colorless-scotty`,
  "Scotty server add-on for Colorless",
);

/**
 * A type for colors
 */
export const colors = mkPackage(
  nixRaw`pkgs.haskellPackages.colors`,
  "A type for colors",
);

/**
 * A model for human colour/color perception
 */
export const colour = mkPackage(
  nixRaw`pkgs.haskellPackages.colour`,
  "A model for human colour/color perception",
);

/**
 * Working with colours in Accelerate
 */
export const colour_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.colour-accelerate`,
  "Working with colours in Accelerate",
);

/**
 * Instances of the manifold-classes for colour types
 */
export const colour_space = mkPackage(
  nixRaw`pkgs.haskellPackages.colour-space`,
  "Instances of the manifold-classes for colour types",
);

/**
 * Print and parse colors
 */
export const colour_text = mkPackage(
  nixRaw`pkgs.haskellPackages.colour-text`,
  "Print and parse colors",
);

/**
 * Convenient interface for printing colourful messages
 */
export const colourista = mkPackage(
  nixRaw`pkgs.haskellPackages.colourista`,
  "Convenient interface for printing colourful messages",
);

/**
 * Enhanced serialization using seeking
 */
export const columbia = mkPackage(
  nixRaw`pkgs.haskellPackages.columbia`,
  "Enhanced serialization using seeking",
);

/**
 * A CSV toolkit based on cassava and enum-text
 */
export const columnar = mkPackage(
  nixRaw`pkgs.haskellPackages.columnar`,
  "A CSV toolkit based on cassava and enum-text",
);

/**
 * Commonmark processing in pure haskell
 */
export const comark = mkPackage(
  nixRaw`pkgs.haskellPackages.comark`,
  "Commonmark processing in pure haskell",
);

/**
 * Graphical representations for various combinatorial objects
 */
export const combinat_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.combinat-diagrams`,
  "Graphical representations for various combinatorial objects",
);

/**
 * Count, enumerate, rank and unrank combinatorial objects
 */
export const combinatorial = mkPackage(
  nixRaw`pkgs.haskellPackages.combinatorial`,
  "Count, enumerate, rank and unrank combinatorial objects",
);

/**
 * Efficient computation of common combinatoric functions
 */
export const combinatorics = mkPackage(
  nixRaw`pkgs.haskellPackages.combinatorics`,
  "Efficient computation of common combinatoric functions",
);

/**
 * Arrays where the index type is a function of the shape type
 */
export const comfort_array = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-array`,
  "Arrays where the index type is a function of the shape type",
);

/**
 * Additional shape types for the comfort-array package
 */
export const comfort_array_shape = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-array-shape`,
  "Additional shape types for the comfort-array package",
);

/**
 * Numerical Basic Linear Algebra using BLAS
 */
export const comfort_blas = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-blas`,
  "Numerical Basic Linear Algebra using BLAS",
);

/**
 * High-level interface to FFTW (Fast Fourier Transform) based on comfort-array
 */
export const comfort_fftw = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-fftw`,
  "High-level interface to FFTW (Fast Fourier Transform) based on comfort-array",
);

/**
 * Linear Programming using GLPK and comfort-array
 */
export const comfort_glpk = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-glpk`,
  "Linear Programming using GLPK and comfort-array",
);

/**
 * Graph structure with type parameters for nodes and edges
 */
export const comfort_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.comfort-graph`,
  "Graph structure with type parameters for nodes and edges",
);

/**
 * A format for describing comics
 */
export const comic = mkPackage(
  nixRaw`pkgs.haskellPackages.comic`,
  "A format for describing comics",
);

/**
 * CSV Parser & Producer
 */
export const comma = mkPackage(
  nixRaw`pkgs.haskellPackages.comma`,
  "CSV Parser & Producer",
);

/**
 * Conveniently run shell commands
 */
export const command = mkPackage(
  nixRaw`pkgs.haskellPackages.command`,
  "Conveniently run shell commands",
);

/**
 * Quasiquoters for external commands
 */
export const command_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.command-qq`,
  "Quasiquoters for external commands",
);

/**
 * A command line argument/option parser library
 */
export const commander_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.commander-cli`,
  "A command line argument/option parser library",
);

/**
 * A monad for commanders
 */
export const commandert = mkPackage(
  nixRaw`pkgs.haskellPackages.commandert`,
  "A monad for commanders",
);

/**
 * Pure Haskell commonmark parser
 */
export const commonmark = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark`,
  "Pure Haskell commonmark parser",
);

/**
 * Command-line commonmark converter and highlighter
 */
export const commonmark_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-cli`,
  "Command-line commonmark converter and highlighter",
);

/**
 * Pure Haskell commonmark parser
 */
export const commonmark_extensions = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-extensions`,
  "Pure Haskell commonmark parser",
);

/**
 * Pure Haskell commonmark parser
 */
export const commonmark_extensions_0_2_3_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-extensions_0_2_3_2`,
  "Pure Haskell commonmark parser",
);

/**
 * Bridge between commonmark and pandoc AST
 */
export const commonmark_pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-pandoc`,
  "Bridge between commonmark and pandoc AST",
);

/**
 * Simple interface to commonmark-hs
 */
export const commonmark_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-simple`,
  "Simple interface to commonmark-hs",
);

/**
 * Obsidian-friendly commonmark wikilink parser
 */
export const commonmark_wikilink = mkPackage(
  nixRaw`pkgs.haskellPackages.commonmark-wikilink`,
  "Obsidian-friendly commonmark wikilink parser",
);

/**
 * Provide communications security using symmetric ephemeral keys
 */
export const commsec = mkPackage(
  nixRaw`pkgs.haskellPackages.commsec`,
  "Provide communications security using symmetric ephemeral keys",
);

/**
 * Key agreement for commsec
 */
export const commsec_keyexchange = mkPackage(
  nixRaw`pkgs.haskellPackages.commsec-keyexchange`,
  "Key agreement for commsec",
);

/**
 * Commutative binary operations
 */
export const commutative = mkPackage(
  nixRaw`pkgs.haskellPackages.commutative`,
  "Commutative binary operations",
);

/**
 * Commutative semigroups
 */
export const commutative_semigroups = mkPackage(
  nixRaw`pkgs.haskellPackages.commutative-semigroups`,
  "Commutative semigroups",
);

/**
 * Comonads
 */
export const comonad = mkPackage(
  nixRaw`pkgs.haskellPackages.comonad`,
  "Comonads",
);

/**
 * Exotic comonad transformers
 */
export const comonad_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.comonad-extras`,
  "Exotic comonad transformers",
);

/**
 * Comonadic interface for random values
 */
export const comonad_random = mkPackage(
  nixRaw`pkgs.haskellPackages.comonad-random`,
  "Comonadic interface for random values",
);

/**
 * This package has been merged into comonad 4.0
 */
export const comonad_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.comonad-transformers`,
  "This package has been merged into comonad 4.0",
);

/**
 * This package has been merged into comonad 4.0
 */
export const comonads_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.comonads-fd`,
  "This package has been merged into comonad 4.0",
);

/**
 * Compatibility checker for OpenAPI
 */
export const compaREST = mkPackage(
  nixRaw`pkgs.haskellPackages.compaREST`,
  "Compatibility checker for OpenAPI",
);

/**
 * Mutable arrays living on the compact heap
 */
export const compact_mutable = mkPackage(
  nixRaw`pkgs.haskellPackages.compact-mutable`,
  "Mutable arrays living on the compact heap",
);

/**
 * Mutable vector with different GC characteristics
 */
export const compact_mutable_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.compact-mutable-vector`,
  "Mutable vector with different GC characteristics",
);

/**
 * Socket functions for compact normal form
 */
export const compact_socket = mkPackage(
  nixRaw`pkgs.haskellPackages.compact-socket`,
  "Socket functions for compact normal form",
);

/**
 * Small vectors of small integers stored very compactly
 */
export const compact_word_vectors = mkPackage(
  nixRaw`pkgs.haskellPackages.compact-word-vectors`,
  "Small vectors of small integers stored very compactly",
);

/**
 * A read-only memory-efficient key-value store
 */
export const compactmap = mkPackage(
  nixRaw`pkgs.haskellPackages.compactmap`,
  "A read-only memory-efficient key-value store",
);

/**
 * A Haskell library to provide companion threads
 */
export const companion = mkPackage(
  nixRaw`pkgs.haskellPackages.companion`,
  "A Haskell library to provide companion threads",
);

/**
 * compare types of any kinds in haskell
 */
export const compare_type = mkPackage(
  nixRaw`pkgs.haskellPackages.compare-type`,
  "compare types of any kinds in haskell",
);

/**
 * Compositional Data Types
 */
export const compdata = mkPackage(
  nixRaw`pkgs.haskellPackages.compdata`,
  "Compositional Data Types",
);

/**
 * Tree automata on Compositional Data Types
 */
export const compdata_automata = mkPackage(
  nixRaw`pkgs.haskellPackages.compdata-automata`,
  "Tree automata on Compositional Data Types",
);

/**
 * Compdata basics implemented on top of Fixplate
 */
export const compdata_fixplate = mkPackage(
  nixRaw`pkgs.haskellPackages.compdata-fixplate`,
  "Compdata basics implemented on top of Fixplate",
);

/**
 * Parse a Pandoc to a composite value
 */
export const compdoc = mkPackage(
  nixRaw`pkgs.haskellPackages.compdoc`,
  "Parse a Pandoc to a composite value",
);

/**
 * Allows you to write FromDhall instances for Compdoc
 */
export const compdoc_dhall_decoder = mkPackage(
  nixRaw`pkgs.haskellPackages.compdoc-dhall-decoder`,
  "Allows you to write FromDhall instances for Compdoc",
);

/**
 * Compensated floating-point arithmetic
 */
export const compensated = mkPackage(
  nixRaw`pkgs.haskellPackages.compensated`,
  "Compensated floating-point arithmetic",
);

/**
 * Parser for common compiler warning formats
 */
export const compiler_warnings = mkPackage(
  nixRaw`pkgs.haskellPackages.compiler-warnings`,
  "Parser for common compiler warning formats",
);

/**
 * A simple integration function to integrate a complex-valued complex functions
 */
export const complex_integrate = mkPackage(
  nixRaw`pkgs.haskellPackages.complex-integrate`,
  "A simple integration function to integrate a complex-valued complex functions",
);

/**
 * Empirical algorithmic complexity
 */
export const complexity = mkPackage(
  nixRaw`pkgs.haskellPackages.complexity`,
  "Empirical algorithmic complexity",
);

/**
 * Monad for allocation and cleanup of application resources
 */
export const componentm = mkPackage(
  nixRaw`pkgs.haskellPackages.componentm`,
  "Monad for allocation and cleanup of application resources",
);

/**
 * Easy REPL driven development using ComponentM
 */
export const componentm_devel = mkPackage(
  nixRaw`pkgs.haskellPackages.componentm-devel`,
  "Easy REPL driven development using ComponentM",
);

/**
 * Types and helpers for composing types into a single larger key-value type
 */
export const composable_associations = mkPackage(
  nixRaw`pkgs.haskellPackages.composable-associations`,
  "Types and helpers for composing types into a single larger key-value type",
);

/**
 * More intuitive, left-to-right function composition
 */
export const compose_ltr = mkPackage(
  nixRaw`pkgs.haskellPackages.compose-ltr`,
  "More intuitive, left-to-right function composition",
);

/**
 * JSON for Vinyl records
 */
export const composite_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-aeson`,
  "JSON for Vinyl records",
);

/**
 * Print a Cofree [] as a JSON value
 */
export const composite_aeson_cofree_list = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-aeson-cofree-list`,
  "Print a Cofree [] as a JSON value",
);

/**
 * MonadThrow behaviour for composite-aeson
 */
export const composite_aeson_throw = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-aeson-throw`,
  "MonadThrow behaviour for composite-aeson",
);

/**
 * WriteOnly indicators for composite-aeson
 */
export const composite_aeson_writeonly = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-aeson-writeonly`,
  "WriteOnly indicators for composite-aeson",
);

/**
 * Shared utilities for composite-* packages
 */
export const composite_base = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-base`,
  "Shared utilities for composite-* packages",
);

/**
 * Orphan binary instances
 */
export const composite_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-binary`,
  "Orphan binary instances",
);

/**
 * Dhall instances for composite records
 */
export const composite_dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-dhall`,
  "Dhall instances for composite records",
);

/**
 * Orphan hashable instances
 */
export const composite_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-hashable`,
  "Orphan hashable instances",
);

/**
 * Indexing utilities for composite records
 */
export const composite_ix = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-ix`,
  "Indexing utilities for composite records",
);

/**
 * Extra lens functions for composite
 */
export const composite_lens_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-lens-extra`,
  "Extra lens functions for composite",
);

/**
 * Tuple functions for composite records
 */
export const composite_tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-tuple`,
  "Tuple functions for composite records",
);

/**
 * RecXML Type
 */
export const composite_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-xml`,
  "RecXML Type",
);

/**
 * ReaderT transformer pattern for higher kinded composite data
 */
export const composite_xstep = mkPackage(
  nixRaw`pkgs.haskellPackages.composite-xstep`,
  "ReaderT transformer pattern for higher kinded composite data",
);

/**
 * Combinators for unorthodox function composition
 */
export const composition = mkPackage(
  nixRaw`pkgs.haskellPackages.composition`,
  "Combinators for unorthodox function composition",
);

/**
 * Combinators for unorthodox structure composition
 */
export const composition_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.composition-extra`,
  "Combinators for unorthodox structure composition",
);

/**
 * Higher-order function combinators
 */
export const composition_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.composition-prelude`,
  "Higher-order function combinators",
);

/**
 * Sum and Product types and such
 */
export const compound_types = mkPackage(
  nixRaw`pkgs.haskellPackages.compound-types`,
  "Sum and Product types and such",
);

/**
 * Plugin to generalize comprehensions
 */
export const comprehensions_ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.comprehensions-ghc`,
  "Plugin to generalize comprehensions",
);

/**
 * Well-kinded computational algebra library, currently supporting Groebner basis
 */
export const computational_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.computational-algebra`,
  "Well-kinded computational algebra library, currently supporting Groebner basis",
);

/**
 * A library for postfix control flow
 */
export const concatenative = mkPackage(
  nixRaw`pkgs.haskellPackages.concatenative`,
  "A library for postfix control flow",
);

/**
 * Concurrent actions that may fail with a value
 */
export const conceit = mkPackage(
  nixRaw`pkgs.haskellPackages.conceit`,
  "Concurrent actions that may fail with a value",
);

/**
 * Utilities for Control.Lens.Cons
 */
export const concise = mkPackage(
  nixRaw`pkgs.haskellPackages.concise`,
  "Utilities for Control.Lens.Cons",
);

/**
 * Simple interface to the Concorde solver for the Traveling Salesperson Problem
 */
export const concorde = mkPackage(
  nixRaw`pkgs.haskellPackages.concorde`,
  "Simple interface to the Concorde solver for the Traveling Salesperson Problem",
);

/**
 * Morphological disambiguation based on constrained CRFs
 */
export const concraft = mkPackage(
  nixRaw`pkgs.haskellPackages.concraft`,
  "Morphological disambiguation based on constrained CRFs",
);

/**
 * Part-of-speech tagger for Croatian
 */
export const concraft_hr = mkPackage(
  nixRaw`pkgs.haskellPackages.concraft-hr`,
  "Part-of-speech tagger for Croatian",
);

/**
 * Morphological tagger for Polish
 */
export const concraft_pl = mkPackage(
  nixRaw`pkgs.haskellPackages.concraft-pl`,
  "Morphological tagger for Polish",
);

/**
 * Library for the Concrete data format
 */
export const concrete_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.concrete-haskell`,
  "Library for the Concrete data format",
);

/**
 * Automatically generated Thrift definitions for the Concrete data format
 */
export const concrete_haskell_autogen = mkPackage(
  nixRaw`pkgs.haskellPackages.concrete-haskell-autogen`,
  "Automatically generated Thrift definitions for the Concrete data format",
);

/**
 * A client side web UI framework for Haskell. Core framework.
 */
export const concur_core = mkPackage(
  nixRaw`pkgs.haskellPackages.concur-core`,
  "A client side web UI framework for Haskell. Core framework.",
);

/**
 * Typeclasses, functions, and data types for concurrency and STM
 */
export const concurrency = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrency`,
  "Typeclasses, functions, and data types for concurrency and STM",
);

/**
 * Benchmarks to compare concurrency APIs
 */
export const concurrency_benchmarks = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrency-benchmarks`,
  "Benchmarks to compare concurrency APIs",
);

/**
 * Simple thread barriers
 */
export const concurrent_barrier = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-barrier`,
  "Simple thread barriers",
);

/**
 * Concurrent batching queue based on STM with timeout
 */
export const concurrent_batch = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-batch`,
  "Concurrent batching queue based on STM with timeout",
);

/**
 * Concurrent DNS cache
 */
export const concurrent_dns_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-dns-cache`,
  "Concurrent DNS cache",
);

/**
 * Extra concurrency primitives
 */
export const concurrent_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-extra`,
  "Extra concurrency primitives",
);

/**
 * Concurrent networked stream transducers
 */
export const concurrent_machines = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-machines`,
  "Concurrent networked stream transducers",
);

/**
 * Ungarble output from several threads or commands
 */
export const concurrent_output = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-output`,
  "Ungarble output from several threads or commands",
);

/**
 * Concurrent resource map
 */
export const concurrent_resource_map = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-resource-map`,
  "Concurrent resource map",
);

/**
 * An abstraction for inter-thread RPC based on MVars
 */
export const concurrent_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-rpc`,
  "An abstraction for inter-thread RPC based on MVars",
);

/**
 * Concurrent simulated annealing system
 */
export const concurrent_sa = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-sa`,
  "Concurrent simulated annealing system",
);

/**
 * MVars and Channels with distinguished input and output side
 */
export const concurrent_split = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-split`,
  "MVars and Channels with distinguished input and output side",
);

/**
 * A fast concurrent unique identifier supply with a pure API
 */
export const concurrent_supply = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrent-supply`,
  "A fast concurrent unique identifier supply with a pure API",
);

/**
 * Ungarble output from several threads
 */
export const concurrentoutput = mkPackage(
  nixRaw`pkgs.haskellPackages.concurrentoutput`,
  "Ungarble output from several threads",
);

/**
 * Basic conditional and boolean operators with monadic variants
 */
export const cond = mkPackage(
  nixRaw`pkgs.haskellPackages.cond`,
  "Basic conditional and boolean operators with monadic variants",
);

/**
 * Information retrieval library
 */
export const condor = mkPackage(
  nixRaw`pkgs.haskellPackages.condor`,
  "Information retrieval library",
);

/**
 * a library for displaying musical time in a terminal-based clock
 */
export const conductive_clock = mkPackage(
  nixRaw`pkgs.haskellPackages.conductive-clock`,
  "a library for displaying musical time in a terminal-based clock",
);

/**
 * a library with examples of using Conductive with hsc3
 */
export const conductive_hsc3 = mkPackage(
  nixRaw`pkgs.haskellPackages.conductive-hsc3`,
  "a library with examples of using Conductive with hsc3",
);

/**
 * a library of functions which are useful for composing music
 */
export const conductive_song = mkPackage(
  nixRaw`pkgs.haskellPackages.conductive-song`,
  "a library of functions which are useful for composing music",
);

/**
 * Lightweight composable continuation-based stream processors
 */
export const conduino = mkPackage(
  nixRaw`pkgs.haskellPackages.conduino`,
  "Lightweight composable continuation-based stream processors",
);

/**
 * Streaming data processing library
 */
export const conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit`,
  "Streaming data processing library",
);

/**
 * Short description
 */
export const conduit_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-aeson`,
  "Short description",
);

/**
 * Conduit-based algorithms
 */
export const conduit_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-algorithms`,
  "Conduit-based algorithms",
);

/**
 * Combinators to efficiently slice and dice audio streams
 */
export const conduit_audio = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-audio`,
  "Combinators to efficiently slice and dice audio streams",
);

/**
 * conduit-audio interface to the libsndfile audio file library
 */
export const conduit_audio_sndfile = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-audio-sndfile`,
  "conduit-audio interface to the libsndfile audio file library",
);

/**
 * DEPRECATED Functionality merged into the conduit package itself
 */
export const conduit_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-combinators`,
  "DEPRECATED Functionality merged into the conduit package itself",
);

/**
 * Concurrent, order-preserving mapping Conduit
 */
export const conduit_concurrent_map = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-concurrent-map`,
  "Concurrent, order-preserving mapping Conduit",
);

/**
 * Batteries included conduit: adapters for common libraries
 */
export const conduit_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-extra`,
  "Batteries included conduit: adapters for common libraries",
);

/**
 * Merge multiple sorted conduits
 */
export const conduit_merge = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-merge`,
  "Merge multiple sorted conduits",
);

/**
 * Parsing framework based on conduit
 */
export const conduit_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-parse`,
  "Parsing framework based on conduit",
);

/**
 * Throttle Conduit Producers
 */
export const conduit_throttle = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-throttle`,
  "Throttle Conduit Producers",
);

/**
 * Zip archive interface for the Conduit Virtual File System
 */
export const conduit_vfs_zip = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-vfs-zip`,
  "Zip archive interface for the Conduit Virtual File System",
);

/**
 * Conduit-based ZStd Compression
 */
export const conduit_zstd = mkPackage(
  nixRaw`pkgs.haskellPackages.conduit-zstd`,
  "Conduit-based ZStd Compression",
);

/**
 * read, parse json config
 */
export const conf_json = mkPackage(
  nixRaw`pkgs.haskellPackages.conf-json`,
  "read, parse json config",
);

export const confcrypt = mkPackage(
  nixRaw`pkgs.haskellPackages.confcrypt`,
  "",
);

/**
 * Configuration management library
 */
export const conferer = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer`,
  "Configuration management library",
);

/**
 * conferer's source for reading json files
 */
export const conferer_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-aeson`,
  "conferer's source for reading json files",
);

/**
 * conferer's FromConfig instances for hedis settings
 */
export const conferer_hedis = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-hedis`,
  "conferer's FromConfig instances for hedis settings",
);

/**
 * Configuration for reading dhall files
 */
export const conferer_provider_dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-provider-dhall`,
  "Configuration for reading dhall files",
);

/**
 * Configuration for reading yaml files
 */
export const conferer_provider_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-provider-yaml`,
  "Configuration for reading yaml files",
);

/**
 * Configuration for reading dhall files
 */
export const conferer_source_dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-source-dhall`,
  "Configuration for reading dhall files",
);

/**
 * Configuration for reading yaml files
 */
export const conferer_source_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-source-yaml`,
  "Configuration for reading yaml files",
);

/**
 * conferer's FromConfig instances for warp settings
 */
export const conferer_warp = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-warp`,
  "conferer's FromConfig instances for warp settings",
);

/**
 * Configuration for reading yaml files
 */
export const conferer_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.conferer-yaml`,
  "Configuration for reading yaml files",
);

/**
 * A simple config file swapping tool
 */
export const confetti = mkPackage(
  nixRaw`pkgs.haskellPackages.confetti`,
  "A simple config file swapping tool",
);

/**
 * A .conf file formatter
 */
export const conffmt = mkPackage(
  nixRaw`pkgs.haskellPackages.conffmt`,
  "A .conf file formatter",
);

/**
 * derive typeclass instances for decoding types from HOCON conf
 */
export const confide = mkPackage(
  nixRaw`pkgs.haskellPackages.confide`,
  "derive typeclass instances for decoding types from HOCON conf",
);

/**
 * A library for simple INI-based configuration files
 */
export const config_ini = mkPackage(
  nixRaw`pkgs.haskellPackages.config-ini`,
  "A library for simple INI-based configuration files",
);

/**
 * Configuration management
 */
export const config_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.config-manager`,
  "Configuration management",
);

/**
 * Schema definitions for the config-value package
 */
export const config_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.config-schema`,
  "Schema definitions for the config-value package",
);

/**
 * A small program for swapping out dot files
 */
export const config_select = mkPackage(
  nixRaw`pkgs.haskellPackages.config-select`,
  "A small program for swapping out dot files",
);

/**
 * Simple, layout-based value language similar to YAML or JSON
 */
export const config_value = mkPackage(
  nixRaw`pkgs.haskellPackages.config-value`,
  "Simple, layout-based value language similar to YAML or JSON",
);

/**
 * parser for config files, shell variables, command line args
 */
export const configifier = mkPackage(
  nixRaw`pkgs.haskellPackages.configifier`,
  "parser for config files, shell variables, command line args",
);

/**
 * Tools for specifying and parsing configurations
 */
export const configuration_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.configuration-tools`,
  "Tools for specifying and parsing configurations",
);

/**
 * Tools for specifying and parsing configurations
 */
export const configuration_tools_0_7_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.configuration-tools_0_7_0`,
  "Tools for specifying and parsing configurations",
);

/**
 * Configuration management
 */
export const configurator = mkPackage(
  nixRaw`pkgs.haskellPackages.configurator`,
  "Configuration management",
);

/**
 * Pretty printer and exporter for configurations from the "configurator" library
 */
export const configurator_export = mkPackage(
  nixRaw`pkgs.haskellPackages.configurator-export`,
  "Pretty printer and exporter for configurations from the \"configurator\" library",
);

/**
 * The next generation of configuration management
 */
export const configurator_ng = mkPackage(
  nixRaw`pkgs.haskellPackages.configurator-ng`,
  "The next generation of configuration management",
);

/**
 * Vinyl-style extensible graphs
 */
export const conic_graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.conic-graphs`,
  "Vinyl-style extensible graphs",
);

/**
 * Sparse matrix linear-equation solver
 */
export const conjugateGradient = mkPackage(
  nixRaw`pkgs.haskellPackages.conjugateGradient`,
  "Sparse matrix linear-equation solver",
);

/**
 * Simple and easy network connections API
 */
export const connection = mkPackage(
  nixRaw`pkgs.haskellPackages.connection`,
  "Simple and easy network connections API",
);

/**
 * console user prompts
 */
export const console_prompt = mkPackage(
  nixRaw`pkgs.haskellPackages.console-prompt`,
  "console user prompts",
);

/**
 * Styled console text output using ANSI escape sequences
 */
export const console_style = mkPackage(
  nixRaw`pkgs.haskellPackages.console-style`,
  "Styled console text output using ANSI escape sequences",
);

/**
 * Parse ByteStrings of a prescribed length
 */
export const constaparser = mkPackage(
  nixRaw`pkgs.haskellPackages.constaparser`,
  "Parse ByteStrings of a prescribed length",
);

/**
 * Constrained clones of the category-theory type classes, using ConstraintKinds
 */
export const constrained_categories = mkPackage(
  nixRaw`pkgs.haskellPackages.constrained-categories`,
  "Constrained clones of the category-theory type classes, using ConstraintKinds",
);

/**
 * Constrained Categories
 */
export const constrained_category = mkPackage(
  nixRaw`pkgs.haskellPackages.constrained-category`,
  "Constrained Categories",
);

/**
 * Normalised Deep Embeddings for Constrained Type-Class Instances
 */
export const constrained_normal = mkPackage(
  nixRaw`pkgs.haskellPackages.constrained-normal`,
  "Normalised Deep Embeddings for Constrained Type-Class Instances",
);

/**
 * Instances of standard platform types for 'constrained' package
 */
export const constrained_platform_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.constrained-platform-instances`,
  "Instances of standard platform types for 'constrained' package",
);

/**
 * Reified constraints
 */
export const constraint = mkPackage(
  nixRaw`pkgs.haskellPackages.constraint`,
  "Reified constraints",
);

/**
 * Various typeclasses using ConstraintKinds
 */
export const constraint_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.constraint-classes`,
  "Various typeclasses using ConstraintKinds",
);

/**
 * Some conviencience type functions for manipulating constraints
 */
export const constraint_manip = mkPackage(
  nixRaw`pkgs.haskellPackages.constraint-manip`,
  "Some conviencience type functions for manipulating constraints",
);

/**
 * Constraint reflection
 */
export const constraint_reflection = mkPackage(
  nixRaw`pkgs.haskellPackages.constraint-reflection`,
  "Constraint reflection",
);

/**
 * Partially applicable constraint tuples
 */
export const constraint_tuples = mkPackage(
  nixRaw`pkgs.haskellPackages.constraint-tuples`,
  "Partially applicable constraint tuples",
);

/**
 * Constraint manipulation
 */
export const constraints = mkPackage(
  nixRaw`pkgs.haskellPackages.constraints`,
  "Constraint manipulation",
);

/**
 * Utility package for constraints
 */
export const constraints_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.constraints-extras`,
  "Utility package for constraints",
);

/**
 * strict versions of many things in base
 */
export const constrictor = mkPackage(
  nixRaw`pkgs.haskellPackages.constrictor`,
  "strict versions of many things in base",
);

/**
 * Exact computation with constructible real numbers
 */
export const constructible = mkPackage(
  nixRaw`pkgs.haskellPackages.constructible`,
  "Exact computation with constructible real numbers",
);

/**
 * Concurrent PostgreSQL data consumers
 */
export const consumers = mkPackage(
  nixRaw`pkgs.haskellPackages.consumers`,
  "Concurrent PostgreSQL data consumers",
);

/**
 * Containers abstraction and utilities
 */
export const container = mkPackage(
  nixRaw`pkgs.haskellPackages.container`,
  "Containers abstraction and utilities",
);

/**
 * Functions for building containers from a known number of elements
 */
export const container_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.container-builder`,
  "Functions for building containers from a known number of elements",
);

/**
 * Generic classes for interacting with different container types
 */
export const container_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.container-classes`,
  "Generic classes for interacting with different container types",
);

/**
 * Assorted concrete container types
 */
export const containers_0_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.containers_0_7`,
  "Assorted concrete container types",
);

/**
 * Hashing-based container types
 */
export const containers_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.containers-accelerate`,
  "Hashing-based container types",
);

/**
 * Provide orphan NFData instances for containers as needed. (deprecated)
 */
export const containers_deepseq = mkPackage(
  nixRaw`pkgs.haskellPackages.containers-deepseq`,
  "Provide orphan NFData instances for containers as needed. (deprecated)",
);

/**
 * Data.Graph, but it doesn't suck!
 */
export const containers_good_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.containers-good-graph`,
  "Data.Graph, but it doesn't suck!",
);

/**
 * Store and retrieve data from an on-disk store
 */
export const content_store = mkPackage(
  nixRaw`pkgs.haskellPackages.content-store`,
  "Store and retrieve data from an on-disk store",
);

/**
 * Thread-indexed, nested contexts
 */
export const context = mkPackage(
  nixRaw`pkgs.haskellPackages.context`,
  "Thread-indexed, nested contexts",
);

/**
 * Generate art from context-free grammars
 */
export const context_free_art = mkPackage(
  nixRaw`pkgs.haskellPackages.context-free-art`,
  "Generate art from context-free grammars",
);

/**
 * Basic algorithms on context-free grammars
 */
export const context_free_grammar = mkPackage(
  nixRaw`pkgs.haskellPackages.context-free-grammar`,
  "Basic algorithms on context-free grammars",
);

/**
 * Modify HTTP requests/responses using context
 */
export const context_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.context-http-client`,
  "Modify HTTP requests/responses using context",
);

/**
 * Thread-safe, pool-compatible resource provider
 */
export const context_resource = mkPackage(
  nixRaw`pkgs.haskellPackages.context-resource`,
  "Thread-safe, pool-compatible resource provider",
);

/**
 * Add request-specific (or not!) context to your WAI applications
 */
export const context_wai_middleware = mkPackage(
  nixRaw`pkgs.haskellPackages.context-wai-middleware`,
  "Add request-specific (or not!) context to your WAI applications",
);

/**
 * Unified interface for primitive arrays
 */
export const contiguous = mkPackage(
  nixRaw`pkgs.haskellPackages.contiguous`,
  "Unified interface for primitive arrays",
);

/**
 * Unified interface for primitive arrays
 */
export const contiguous_0_6_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.contiguous_0_6_4_0`,
  "Unified interface for primitive arrays",
);

/**
 * Types and functions for working with continued fractions in Haskell
 */
export const continued_fraction = mkPackage(
  nixRaw`pkgs.haskellPackages.continued-fraction`,
  "Types and functions for working with continued fractions in Haskell",
);

export const continuum = mkPackage(
  nixRaw`pkgs.haskellPackages.continuum`,
  "",
);

export const continuum_client = mkPackage(
  nixRaw`pkgs.haskellPackages.continuum-client`,
  "",
);

/**
 * Arrow and contravariant tracers
 */
export const contra_tracer = mkPackage(
  nixRaw`pkgs.haskellPackages.contra-tracer`,
  "Arrow and contravariant tracers",
);

/**
 * Contravariant functors
 */
export const contravariant = mkPackage(
  nixRaw`pkgs.haskellPackages.contravariant`,
  "Contravariant functors",
);

/**
 * Extras for the "contravariant" package
 */
export const contravariant_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.contravariant-extras`,
  "Extras for the \"contravariant\" package",
);

/**
 * Class of monad transformers which control operations can be lifted thru
 */
export const control = mkPackage(
  nixRaw`pkgs.haskellPackages.control`,
  "Class of monad transformers which control operations can be lifted thru",
);

/**
 * Higher-order functions with their function arguments at the end
 */
export const control_block = mkPackage(
  nixRaw`pkgs.haskellPackages.control-block`,
  "Higher-order functions with their function arguments at the end",
);

/**
 * Useful combinators for boolean expressions
 */
export const control_bool = mkPackage(
  nixRaw`pkgs.haskellPackages.control-bool`,
  "Useful combinators for boolean expressions",
);

/**
 * Haskell operator `g ... f = \x1 .. xn -> g (f x1 .. xn)`.
 */
export const control_dotdotdot = mkPackage(
  nixRaw`pkgs.haskellPackages.control-dotdotdot`,
  "Haskell operator `g ... f = \\x1 .. xn -> g (f x1 .. xn)`.",
);

/**
 * Event scheduling system
 */
export const control_event = mkPackage(
  nixRaw`pkgs.haskellPackages.control-event`,
  "Event scheduling system",
);

/**
 * Monad transformer for attempt. (deprecated)
 */
export const control_monad_attempt = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-attempt`,
  "Monad transformer for attempt. (deprecated)",
);

/**
 * Explicitly typed, checked exceptions with stack traces
 */
export const control_monad_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-exception`,
  "Explicitly typed, checked exceptions with stack traces",
);

/**
 * Monads-fd instances for the EMT exceptions monad transformer
 */
export const control_monad_exception_monadsfd = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-exception-monadsfd`,
  "Monads-fd instances for the EMT exceptions monad transformer",
);

/**
 * Monads-tf instances for the EMT exceptions monad transformer
 */
export const control_monad_exception_monadstf = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-exception-monadstf`,
  "Monads-tf instances for the EMT exceptions monad transformer",
);

/**
 * MTL instances for the EMT exceptions monad transformer
 */
export const control_monad_exception_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-exception-mtl`,
  "MTL instances for the EMT exceptions monad transformer",
);

/**
 * Free monads and monad transformers
 */
export const control_monad_free = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-free`,
  "Free monads and monad transformers",
);

/**
 * Simple monad transformer for imperative-style loops
 */
export const control_monad_loop = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-loop`,
  "Simple monad transformer for imperative-style loops",
);

/**
 * A breadth-first list monad
 */
export const control_monad_omega = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-omega`,
  "A breadth-first list monad",
);

/**
 * Reusable corecursive queues, via continuations
 */
export const control_monad_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.control-monad-queue`,
  "Reusable corecursive queues, via continuations",
);

/**
 * Timeout handling
 */
export const control_timeout = mkPackage(
  nixRaw`pkgs.haskellPackages.control-timeout`,
  "Timeout handling",
);

/**
 * Fast, easy to use CPS-based monad transformers
 */
export const contstuff = mkPackage(
  nixRaw`pkgs.haskellPackages.contstuff`,
  "Fast, easy to use CPS-based monad transformers",
);

/**
 * Limit operations for converging sequences
 */
export const converge = mkPackage(
  nixRaw`pkgs.haskellPackages.converge`,
  "Limit operations for converging sequences",
);

/**
 * Universal converter between values of different types
 */
export const conversion = mkPackage(
  nixRaw`pkgs.haskellPackages.conversion`,
  "Universal converter between values of different types",
);

/**
 * "Conversion" instances for the "bytestring" library
 */
export const conversion_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.conversion-bytestring`,
  "\"Conversion\" instances for the \"bytestring\" library",
);

/**
 * "Conversion" instances for the "case-insensitive" library
 */
export const conversion_case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.conversion-case-insensitive`,
  "\"Conversion\" instances for the \"case-insensitive\" library",
);

/**
 * "Conversion" instances for the "text" library
 */
export const conversion_text = mkPackage(
  nixRaw`pkgs.haskellPackages.conversion-text`,
  "\"Conversion\" instances for the \"text\" library",
);

/**
 * Injective explicit total and partial conversions
 */
export const conversions = mkPackage(
  nixRaw`pkgs.haskellPackages.conversions`,
  "Injective explicit total and partial conversions",
);

/**
 * Safe and unsafe data conversion utilities with strong type-level operation. checking.
 */
export const convert = mkPackage(
  nixRaw`pkgs.haskellPackages.convert`,
  "Safe and unsafe data conversion utilities with strong type-level operation. checking.",
);

/**
 * Convert the annotation of a gene to another in a delimited file using a variety of different databases
 */
export const convert_annotation = mkPackage(
  nixRaw`pkgs.haskellPackages.convert-annotation`,
  "Convert the annotation of a gene to another in a delimited file using a variety of different databases",
);

/**
 * Typeclasses and instances for converting between types
 */
export const convertible = mkPackage(
  nixRaw`pkgs.haskellPackages.convertible`,
  "Typeclasses and instances for converting between types",
);

/**
 * convertible instances for ascii
 */
export const convertible_ascii = mkPackage(
  nixRaw`pkgs.haskellPackages.convertible-ascii`,
  "convertible instances for ascii",
);

/**
 * Typeclasses and instances for converting between types (deprecated)
 */
export const convertible_text = mkPackage(
  nixRaw`pkgs.haskellPackages.convertible-text`,
  "Typeclasses and instances for converting between types (deprecated)",
);

/**
 * Tiered general-purpose libraries with domain-specific applications
 */
export const cookbook = mkPackage(
  nixRaw`pkgs.haskellPackages.cookbook`,
  "Tiered general-purpose libraries with domain-specific applications",
);

/**
 * HTTP cookie parsing and rendering
 */
export const cookie = mkPackage(
  nixRaw`pkgs.haskellPackages.cookie`,
  "HTTP cookie parsing and rendering",
);

/**
 * For serving cookies
 */
export const cookie_tray = mkPackage(
  nixRaw`pkgs.haskellPackages.cookie-tray`,
  "For serving cookies",
);

/**
 * web cookies
 */
export const cookies = mkPackage(
  nixRaw`pkgs.haskellPackages.cookies`,
  "web cookies",
);

/**
 * A representation of latitude and longitude
 */
export const coordinate = mkPackage(
  nixRaw`pkgs.haskellPackages.coordinate`,
  "A representation of latitude and longitude",
);

/**
 * A stream DSL for writing embedded C programs
 */
export const copilot = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot`,
  "A stream DSL for writing embedded C programs",
);

/**
 * Copilot interface to a C model-checker
 */
export const copilot_cbmc = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-cbmc`,
  "Copilot interface to a C model-checker",
);

/**
 * An intermediate representation for Copilot
 */
export const copilot_core = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-core`,
  "An intermediate representation for Copilot",
);

/**
 * FRP sketch programming with Copilot
 */
export const copilot_frp_sketch = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-frp-sketch`,
  "FRP sketch programming with Copilot",
);

/**
 * Interpreter for Copilot
 */
export const copilot_interpreter = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-interpreter`,
  "Interpreter for Copilot",
);

/**
 * A Haskell-embedded DSL for monitoring hard real-time distributed systems
 */
export const copilot_language = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-language`,
  "A Haskell-embedded DSL for monitoring hard real-time distributed systems",
);

/**
 * Libraries for the Copilot language
 */
export const copilot_libraries = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-libraries`,
  "Libraries for the Copilot language",
);

/**
 * A prettyprinter of Copilot Specifications
 */
export const copilot_prettyprinter = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-prettyprinter`,
  "A prettyprinter of Copilot Specifications",
);

/**
 * A compiler for CoPilot targeting SBV
 */
export const copilot_sbv = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-sbv`,
  "A compiler for CoPilot targeting SBV",
);

/**
 * k-induction for Copilot
 */
export const copilot_theorem = mkPackage(
  nixRaw`pkgs.haskellPackages.copilot-theorem`,
  "k-induction for Copilot",
);

/**
 * Copr API client libary
 */
export const copr_api = mkPackage(
  nixRaw`pkgs.haskellPackages.copr-api`,
  "Copr API client libary",
);

/**
 * Convenience wrappers around common data structures and encodings
 */
export const core_data = mkPackage(
  nixRaw`pkgs.haskellPackages.core-data`,
  "Convenience wrappers around common data structures and encodings",
);

/**
 * Interoperability with the effectful effects system
 */
export const core_effect_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.core-effect-effectful`,
  "Interoperability with the effectful effects system",
);

/**
 * Opinionated Haskell Interoperability
 */
export const core_program = mkPackage(
  nixRaw`pkgs.haskellPackages.core-program`,
  "Opinionated Haskell Interoperability",
);

/**
 * Advanced telemetry
 */
export const core_telemetry = mkPackage(
  nixRaw`pkgs.haskellPackages.core-telemetry`,
  "Advanced telemetry",
);

/**
 * A rope type based on a finger tree over UTF-8 fragments
 */
export const core_text = mkPackage(
  nixRaw`pkgs.haskellPackages.core-text`,
  "A rope type based on a finger tree over UTF-8 fragments",
);

/**
 * Interoperability with Servant
 */
export const core_webserver_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.core-webserver-servant`,
  "Interoperability with Servant",
);

/**
 * Interoperability with Wai/Warp
 */
export const core_webserver_warp = mkPackage(
  nixRaw`pkgs.haskellPackages.core-webserver-warp`,
  "Interoperability with Wai/Warp",
);

/**
 * Write your main like it can call itself back
 */
export const corecursive_main = mkPackage(
  nixRaw`pkgs.haskellPackages.corecursive-main`,
  "Write your main like it can call itself back",
);

/**
 * Launches CoreNLP and parses the JSON output
 */
export const corenlp_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.corenlp-parser`,
  "Launches CoreNLP and parses the JSON output",
);

/**
 * classy optical monadic state
 */
export const cornea = mkPackage(
  nixRaw`pkgs.haskellPackages.cornea`,
  "classy optical monadic state",
);

/**
 * Bridge between the monad-coroutine and enumerator packages
 */
export const coroutine_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.coroutine-enumerator`,
  "Bridge between the monad-coroutine and enumerator packages",
);

/**
 * Bridge between the monad-coroutine and iteratee packages
 */
export const coroutine_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.coroutine-iteratee`,
  "Bridge between the monad-coroutine and iteratee packages",
);

/**
 * A modern, lightweight, complete client for CouchDB
 */
export const couch_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.couch-simple`,
  "A modern, lightweight, complete client for CouchDB",
);

/**
 * Couch DB client library using http-enumerator and aeson
 */
export const couchdb_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.couchdb-enumerator`,
  "Couch DB client library using http-enumerator and aeson",
);

/**
 * Bijective mappings between values and possibly infinite prefixes of [0..]
 */
export const count = mkPackage(
  nixRaw`pkgs.haskellPackages.count`,
  "Bijective mappings between values and possibly infinite prefixes of [0..]",
);

/**
 * Countable, Searchable, Finite, Empty classes
 */
export const countable = mkPackage(
  nixRaw`pkgs.haskellPackages.countable`,
  "Countable, Searchable, Finite, Empty classes",
);

/**
 * Countable Text Inflections
 */
export const countable_inflections = mkPackage(
  nixRaw`pkgs.haskellPackages.countable-inflections`,
  "Countable Text Inflections",
);

/**
 * Country data type and functions
 */
export const country = mkPackage(
  nixRaw`pkgs.haskellPackages.country`,
  "Country data type and functions",
);

/**
 * Country data type and functions
 */
export const country_0_2_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.country_0_2_4_0`,
  "Country data type and functions",
);

/**
 * Well-conditioned estimation of large-dimensional covariance matrices
 */
export const covariance = mkPackage(
  nixRaw`pkgs.haskellPackages.covariance`,
  "Well-conditioned estimation of large-dimensional covariance matrices",
);

/**
 * Coya monoids
 */
export const coya = mkPackage(
  nixRaw`pkgs.haskellPackages.coya`,
  "Coya monoids",
);

/**
 * Build tool for C
 */
export const cpkg = mkPackage(
  nixRaw`pkgs.haskellPackages.cpkg`,
  "Build tool for C",
);

/**
 * high-level CPLEX interface
 */
export const cplex_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.cplex-hs`,
  "high-level CPLEX interface",
);

/**
 * Bindings for C++ demangling routines
 */
export const cppfilt = mkPackage(
  nixRaw`pkgs.haskellPackages.cppfilt`,
  "Bindings for C++ demangling routines",
);

/**
 * A liberalised re-implementation of cpp, the C pre-processor
 */
export const cpphs = mkPackage(
  nixRaw`pkgs.haskellPackages.cpphs`,
  "A liberalised re-implementation of cpp, the C pre-processor",
);

/**
 * Crypto Pseudo Random Number Generator using AES in counter mode
 */
export const cprng_aes = mkPackage(
  nixRaw`pkgs.haskellPackages.cprng-aes`,
  "Crypto Pseudo Random Number Generator using AES in counter mode",
);

/**
 * Run random effect using cprng-aes, a crypto pseudo number generator
 */
export const cprng_aes_effect = mkPackage(
  nixRaw`pkgs.haskellPackages.cprng-aes-effect`,
  "Run random effect using cprng-aes, a crypto pseudo number generator",
);

/**
 * ExceptT replacement in CPS style
 */
export const cps_except = mkPackage(
  nixRaw`pkgs.haskellPackages.cps-except`,
  "ExceptT replacement in CPS style",
);

/**
 * Symbolic cryptographic protocol analyzer
 */
export const cpsa = mkPackage(
  nixRaw`pkgs.haskellPackages.cpsa`,
  "Symbolic cryptographic protocol analyzer",
);

/**
 * Cpu information and properties helpers
 */
export const cpu = mkPackage(
  nixRaw`pkgs.haskellPackages.cpu`,
  "Cpu information and properties helpers",
);

/**
 * Binding for the cpuid machine instruction on x86 compatible processors
 */
export const cpuid = mkPackage(
  nixRaw`pkgs.haskellPackages.cpuid`,
  "Binding for the cpuid machine instruction on x86 compatible processors",
);

/**
 * Haskell Library for Checking CPU Information
 */
export const cpuinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.cpuinfo`,
  "Haskell Library for Checking CPU Information",
);

/**
 * Cassandra CQL binary protocol
 */
export const cql = mkPackage(
  nixRaw`pkgs.haskellPackages.cql`,
  "Cassandra CQL binary protocol",
);

/**
 * Tinylog integration for cql-io
 */
export const cql_io_tinylog = mkPackage(
  nixRaw`pkgs.haskellPackages.cql-io-tinylog`,
  "Tinylog integration for cql-io",
);

/**
 * Command-Query Responsibility Segregation
 */
export const cqrs = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs`,
  "Command-Query Responsibility Segregation",
);

/**
 * Example for cqrs package
 */
export const cqrs_example = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-example`,
  "Example for cqrs package",
);

/**
 * Memory backend for the cqrs package
 */
export const cqrs_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-memory`,
  "Memory backend for the cqrs package",
);

/**
 * PostgreSQL backend for the cqrs package
 */
export const cqrs_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-postgresql`,
  "PostgreSQL backend for the cqrs package",
);

/**
 * SQLite3 backend for the cqrs package
 */
export const cqrs_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-sqlite3`,
  "SQLite3 backend for the cqrs package",
);

/**
 * Command-Query Responsibility Segregation Test Support
 */
export const cqrs_test = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-test`,
  "Command-Query Responsibility Segregation Test Support",
);

/**
 * Command-Query Responsibility Segregation Test Support
 */
export const cqrs_testkit = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-testkit`,
  "Command-Query Responsibility Segregation Test Support",
);

/**
 * Command-Query Responsibility Segregation. Modules for the basic types.
 */
export const cqrs_types = mkPackage(
  nixRaw`pkgs.haskellPackages.cqrs-types`,
  "Command-Query Responsibility Segregation. Modules for the basic types.",
);

/**
 * Crack various integer and floating-point data formats
 */
export const crackNum = mkPackage(
  nixRaw`pkgs.haskellPackages.crackNum`,
  "Crack various integer and floating-point data formats",
);

/**
 * Crack various integer, floating-point data formats
 */
export const crackNum_2_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.crackNum_2_4`,
  "Crack various integer, floating-point data formats",
);

/**
 * A UNIX configuration management library in Haskell
 */
export const craft = mkPackage(
  nixRaw`pkgs.haskellPackages.craft`,
  "A UNIX configuration management library in Haskell",
);

/**
 * Cairo backend for Craftwerk
 */
export const craftwerk_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.craftwerk-cairo`,
  "Cairo backend for Craftwerk",
);

/**
 * Gtk UI for Craftwerk
 */
export const craftwerk_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.craftwerk-gtk`,
  "Gtk UI for Craftwerk",
);

/**
 * HTTP Racing Library
 */
export const craze = mkPackage(
  nixRaw`pkgs.haskellPackages.craze`,
  "HTTP Racing Library",
);

/**
 * Implements various Cyclic Redundancy Checks (CRC)
 */
export const crc = mkPackage(
  nixRaw`pkgs.haskellPackages.crc`,
  "Implements various Cyclic Redundancy Checks (CRC)",
);

/**
 * Compute CRC16 checksums using a lookup table
 */
export const crc16_table = mkPackage(
  nixRaw`pkgs.haskellPackages.crc16-table`,
  "Compute CRC16 checksums using a lookup table",
);

/**
 * Secure Credentials Administration
 */
export const credentials_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.credentials-cli`,
  "Secure Credentials Administration",
);

/**
 * First-order, linear-chain conditional random fields
 */
export const crf_chain1 = mkPackage(
  nixRaw`pkgs.haskellPackages.crf-chain1`,
  "First-order, linear-chain conditional random fields",
);

/**
 * First-order, constrained, linear-chain conditional random fields
 */
export const crf_chain1_constrained = mkPackage(
  nixRaw`pkgs.haskellPackages.crf-chain1-constrained`,
  "First-order, constrained, linear-chain conditional random fields",
);

/**
 * Second-order, generic, constrained, linear conditional random fields
 */
export const crf_chain2_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.crf-chain2-generic`,
  "Second-order, generic, constrained, linear conditional random fields",
);

/**
 * Second-order, tiered, constrained, linear conditional random fields
 */
export const crf_chain2_tiers = mkPackage(
  nixRaw`pkgs.haskellPackages.crf-chain2-tiers`,
  "Second-order, tiered, constrained, linear conditional random fields",
);

/**
 * Robust, reliable performance measurement and analysis
 */
export const criterion = mkPackage(
  nixRaw`pkgs.haskellPackages.criterion`,
  "Robust, reliable performance measurement and analysis",
);

/**
 * Robust, reliable performance measurement and analysis
 */
export const criterion_1_6_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.criterion_1_6_3_0`,
  "Robust, reliable performance measurement and analysis",
);

/**
 * Criterion measurement functionality and associated types
 */
export const criterion_measurement = mkPackage(
  nixRaw`pkgs.haskellPackages.criterion-measurement`,
  "Criterion measurement functionality and associated types",
);

/**
 * CRIU RPC client
 */
export const criu_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.criu-rpc`,
  "CRIU RPC client",
);

/**
 * Criu RPC protocol buffer types
 */
export const criu_rpc_types = mkPackage(
  nixRaw`pkgs.haskellPackages.criu-rpc-types`,
  "Criu RPC protocol buffer types",
);

/**
 * Cron datatypes and Attoparsec parser
 */
export const cron = mkPackage(
  nixRaw`pkgs.haskellPackages.cron`,
  "Cron datatypes and Attoparsec parser",
);

/**
 * Cron datatypes and Attoparsec parser
 */
export const cron_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.cron-compat`,
  "Cron datatypes and Attoparsec parser",
);

/**
 * Encryption and decryption
 */
export const cropty = mkPackage(
  nixRaw`pkgs.haskellPackages.cropty`,
  "Encryption and decryption",
);

/**
 * Pure Haskell implelementation for GNU SHA512 crypt algorithm
 */
export const crypt_sha512 = mkPackage(
  nixRaw`pkgs.haskellPackages.crypt-sha512`,
  "Pure Haskell implelementation for GNU SHA512 crypt algorithm",
);

/**
 * A generic interface for cryptographic operations
 */
export const crypto_api = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-api`,
  "A generic interface for cryptographic operations",
);

/**
 * A test framework and KATs for cryptographic operations
 */
export const crypto_api_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-api-tests`,
  "A test framework and KATs for cryptographic operations",
);

/**
 * Generic cryptography cipher tests
 */
export const crypto_cipher_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-cipher-tests`,
  "Generic cryptography cipher tests",
);

/**
 * Generic cryptography cipher types
 */
export const crypto_cipher_types = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-cipher-types`,
  "Generic cryptography cipher types",
);

/**
 * An educational tool for studying classical cryptography schemes
 */
export const crypto_classical = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-classical`,
  "An educational tool for studying classical cryptography schemes",
);

/**
 * Conduit interface for cryptographic operations (from crypto-api)
 */
export const crypto_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-conduit`,
  "Conduit interface for cryptographic operations (from crypto-api)",
);

/**
 * An Enigma machine simulator with display
 */
export const crypto_enigma = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-enigma`,
  "An Enigma machine simulator with display",
);

/**
 * Public Key cryptography
 */
export const crypto_pubkey = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-pubkey`,
  "Public Key cryptography",
);

/**
 * Generic cryptography Public keys algorithm types
 */
export const crypto_pubkey_types = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-pubkey-types`,
  "Generic cryptography Public keys algorithm types",
);

/**
 * Simple cryptographic random related types
 */
export const crypto_random = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-random`,
  "Simple cryptographic random related types",
);

/**
 * Simple random generators API for cryptography related code
 */
export const crypto_random_api = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-random-api`,
  "Simple random generators API for cryptography related code",
);

/**
 * Cryptographic random number generator
 */
export const crypto_rng = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-rng`,
  "Cryptographic random number generator",
);

/**
 * Adaptation of the crypto-rng library for the effectful ecosystem
 */
export const crypto_rng_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-rng-effectful`,
  "Adaptation of the crypto-rng library for the effectful ecosystem",
);

/**
 * Easy-and-safe-to-use high-level cryptography based on Sodium
 */
export const crypto_sodium = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-sodium`,
  "Easy-and-safe-to-use high-level cryptography based on Sodium",
);

/**
 * crypto tokens
 */
export const crypto_token = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-token`,
  "crypto tokens",
);

/**
 * Provides generation and verification services for time-based one-time keys
 */
export const crypto_totp = mkPackage(
  nixRaw`pkgs.haskellPackages.crypto-totp`,
  "Provides generation and verification services for time-based one-time keys",
);

/**
 * Symmetrical block and stream ciphers
 */
export const cryptocipher = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptocipher`,
  "Symmetrical block and stream ciphers",
);

/**
 * collection of crypto hashes, fast, pure and practical
 */
export const cryptohash = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash`,
  "collection of crypto hashes, fast, pure and practical",
);

/**
 * cryptohash conduit
 */
export const cryptohash_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-conduit`,
  "cryptohash conduit",
);

/**
 * Crypto-api interfaces for cryptohash
 */
export const cryptohash_cryptoapi = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-cryptoapi`,
  "Crypto-api interfaces for cryptohash",
);

/**
 * Fast, pure and practical MD5 implementation
 */
export const cryptohash_md5 = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-md5`,
  "Fast, pure and practical MD5 implementation",
);

/**
 * Fast, pure and practical SHA-1 implementation
 */
export const cryptohash_sha1 = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-sha1`,
  "Fast, pure and practical SHA-1 implementation",
);

/**
 * Fast, pure and practical SHA-256 implementation
 */
export const cryptohash_sha256 = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-sha256`,
  "Fast, pure and practical SHA-256 implementation",
);

/**
 * Fast, pure and practical SHA-512 implementation
 */
export const cryptohash_sha512 = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptohash-sha512`,
  "Fast, pure and practical SHA-512 implementation",
);

/**
 * Reversable and secure encoding of object ids as a bytestring
 */
export const cryptoids = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptoids`,
  "Reversable and secure encoding of object ids as a bytestring",
);

/**
 * Typeclass-based interface to cryptoids
 */
export const cryptoids_class = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptoids-class`,
  "Typeclass-based interface to cryptoids",
);

/**
 * Cryptol: The Language of Cryptography
 */
export const cryptol = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptol`,
  "Cryptol: The Language of Cryptography",
);

/**
 * Cryptography Primitives sink
 */
export const crypton = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton`,
  "Cryptography Primitives sink",
);

/**
 * Cryptography Primitives sink
 */
export const crypton_0_33 = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton_0_33`,
  "Cryptography Primitives sink",
);

/**
 * crypton conduit
 */
export const crypton_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-conduit`,
  "crypton conduit",
);

/**
 * Simple and easy network connections API
 */
export const crypton_connection = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-connection`,
  "Simple and easy network connections API",
);

/**
 * X509 reader and writer
 */
export const crypton_x509 = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-x509`,
  "X509 reader and writer",
);

/**
 * X.509 collection accessing and storing methods
 */
export const crypton_x509_store = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-x509-store`,
  "X.509 collection accessing and storing methods",
);

/**
 * Handle per-operating-system X.509 accessors and storage
 */
export const crypton_x509_system = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-x509-system`,
  "Handle per-operating-system X.509 accessors and storage",
);

/**
 * X.509 Certificate and CRL validation
 */
export const crypton_x509_validation = mkPackage(
  nixRaw`pkgs.haskellPackages.crypton-x509-validation`,
  "X.509 Certificate and CRL validation",
);

/**
 * Cryptography Primitives sink
 */
export const cryptonite = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptonite`,
  "Cryptography Primitives sink",
);

/**
 * Cryptography Primitives sink
 */
export const cryptonite_cd = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptonite-cd`,
  "Cryptography Primitives sink",
);

/**
 * cryptonite conduit
 */
export const cryptonite_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptonite-conduit`,
  "cryptonite conduit",
);

/**
 * Crypto stuff using OpenSSL cryptographic library
 */
export const cryptonite_openssl = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptonite-openssl`,
  "Crypto stuff using OpenSSL cryptographic library",
);

/**
 * Serialization of cryptographic data types
 */
export const cryptostore = mkPackage(
  nixRaw`pkgs.haskellPackages.cryptostore`,
  "Serialization of cryptographic data types",
);

/**
 * Control Crystalfontz LCD displays
 */
export const crystalfontz = mkPackage(
  nixRaw`pkgs.haskellPackages.crystalfontz`,
  "Control Crystalfontz LCD displays",
);

/**
 * Analytical CSG (Constructive Solid Geometry) library
 */
export const csg = mkPackage(
  nixRaw`pkgs.haskellPackages.csg`,
  "Analytical CSG (Constructive Solid Geometry) library",
);

/**
 * a gallery of Csound instruments
 */
export const csound_catalog = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-catalog`,
  "a gallery of Csound instruments",
);

export const csound_controllers = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-controllers`,
  "",
);

/**
 * library to make electronic music
 */
export const csound_expression = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-expression`,
  "library to make electronic music",
);

/**
 * opcodes for the library csound-expression
 */
export const csound_expression_opcodes = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-expression-opcodes`,
  "opcodes for the library csound-expression",
);

/**
 * typed core for the library csound-expression
 */
export const csound_expression_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-expression-typed`,
  "typed core for the library csound-expression",
);

/**
 * A musical sampler based on Csound
 */
export const csound_sampler = mkPackage(
  nixRaw`pkgs.haskellPackages.csound-sampler`,
  "A musical sampler based on Csound",
);

/**
 * Discrete constraint satisfaction problem (CSP) solver
 */
export const csp = mkPackage(
  nixRaw`pkgs.haskellPackages.csp`,
  "Discrete constraint satisfaction problem (CSP) solver",
);

/**
 * A command line type checker for CSPM files
 */
export const cspmchecker = mkPackage(
  nixRaw`pkgs.haskellPackages.cspmchecker`,
  "A command line type checker for CSPM files",
);

/**
 * High-performance CSS tokenizer and serializer
 */
export const css_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.css-syntax`,
  "High-performance CSS tokenizer and serializer",
);

/**
 * CSS parser and renderer
 */
export const css_text = mkPackage(
  nixRaw`pkgs.haskellPackages.css-text`,
  "CSS parser and renderer",
);

/**
 * CSV loader and dumper
 */
export const csv = mkPackage(
  nixRaw`pkgs.haskellPackages.csv`,
  "CSV loader and dumper",
);

/**
 * A flexible, fast, conduit-based CSV parser library for Haskell
 */
export const csv_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.csv-conduit`,
  "A flexible, fast, conduit-based CSV parser library for Haskell",
);

/**
 * A flexible, fast, enumerator-based CSV parser library for Haskell
 */
export const csv_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.csv-enumerator`,
  "A flexible, fast, enumerator-based CSV parser library for Haskell",
);

/**
 * Scripts for manipulating tables stored as CSV files
 */
export const csv_table = mkPackage(
  nixRaw`pkgs.haskellPackages.csv-table`,
  "Scripts for manipulating tables stored as CSV files",
);

/**
 * A small program that will read csv files and create qif files
 */
export const csv_to_qif = mkPackage(
  nixRaw`pkgs.haskellPackages.csv-to-qif`,
  "A small program that will read csv files and create qif files",
);

/**
 * A programming language for text modification
 */
export const ctpl = mkPackage(
  nixRaw`pkgs.haskellPackages.ctpl`,
  "A programming language for text modification",
);

/**
 * Non-blocking concurrent map
 */
export const ctrie = mkPackage(
  nixRaw`pkgs.haskellPackages.ctrie`,
  "Non-blocking concurrent map",
);

/**
 * Cubic DSL for 3D printing
 */
export const cube = mkPackage(
  nixRaw`pkgs.haskellPackages.cube`,
  "Cubic DSL for 3D printing",
);

/**
 * Implementation of Univalence in Cubical Sets
 */
export const cubical = mkPackage(
  nixRaw`pkgs.haskellPackages.cubical`,
  "Implementation of Univalence in Cubical Sets",
);

/**
 * Efficient manipulating of 2D cubic bezier curves
 */
export const cubicbezier = mkPackage(
  nixRaw`pkgs.haskellPackages.cubicbezier`,
  "Efficient manipulating of 2D cubic bezier curves",
);

/**
 * Natural cubic spline interpolation
 */
export const cubicspline = mkPackage(
  nixRaw`pkgs.haskellPackages.cubicspline`,
  "Natural cubic spline interpolation",
);

/**
 * FFI bindings to the CUDA BLAS library
 */
export const cublas = mkPackage(
  nixRaw`pkgs.haskellPackages.cublas`,
  "FFI bindings to the CUDA BLAS library",
);

/**
 * FFI binding to the CUDA interface for programming NVIDIA GPUs
 */
export const cuda = mkPackage(
  nixRaw`pkgs.haskellPackages.cuda`,
  "FFI binding to the CUDA interface for programming NVIDIA GPUs",
);

/**
 * Bindings to the CUDD binary decision diagrams library
 */
export const cudd = mkPackage(
  nixRaw`pkgs.haskellPackages.cudd`,
  "Bindings to the CUDD binary decision diagrams library",
);

/**
 * Support for construction, rendering, and parsing of CUE sheets
 */
export const cue_sheet = mkPackage(
  nixRaw`pkgs.haskellPackages.cue-sheet`,
  "Support for construction, rendering, and parsing of CUE sheets",
);

/**
 * Haskell bindings for the CUFFT library
 */
export const cufft = mkPackage(
  nixRaw`pkgs.haskellPackages.cufft`,
  "Haskell bindings for the CUFFT library",
);

/**
 * Haskell binding to libcurl
 */
export const curl = mkPackage(
  nixRaw`pkgs.haskellPackages.curl`,
  "Haskell binding to libcurl",
);

/**
 * Parsing and pretty-printing of cURL/wget cookie jars
 */
export const curl_cookiejar = mkPackage(
  nixRaw`pkgs.haskellPackages.curl-cookiejar`,
  "Parsing and pretty-printing of cURL/wget cookie jars",
);

/**
 * bindings to libcurl, the multiprotocol file transfer library
 */
export const curlhs = mkPackage(
  nixRaw`pkgs.haskellPackages.curlhs`,
  "bindings to libcurl, the multiprotocol file transfer library",
);

/**
 * Types representing standard and non-standard currencies
 */
export const currency = mkPackage(
  nixRaw`pkgs.haskellPackages.currency`,
  "Types representing standard and non-standard currencies",
);

/**
 * ISO-4217 Currency Codes
 */
export const currency_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.currency-codes`,
  "ISO-4217 Currency Codes",
);

/**
 * Get the current system locale in System.Locale format
 */
export const current_locale = mkPackage(
  nixRaw`pkgs.haskellPackages.current-locale`,
  "Get the current system locale in System.Locale format",
);

/**
 * Curry types
 */
export const curry = mkPackage(
  nixRaw`pkgs.haskellPackages.curry`,
  "Curry types",
);

/**
 * A package for simple, fast radiocarbon calibration
 */
export const currycarbon = mkPackage(
  nixRaw`pkgs.haskellPackages.currycarbon`,
  "A package for simple, fast radiocarbon calibration",
);

/**
 * A simple HTTP server framework
 */
export const curryer = mkPackage(
  nixRaw`pkgs.haskellPackages.curryer`,
  "A simple HTTP server framework",
);

/**
 * Fast, Haskell RPC
 */
export const curryer_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.curryer-rpc`,
  "Fast, Haskell RPC",
);

/**
 * Purely Functional Cursors
 */
export const cursor = mkPackage(
  nixRaw`pkgs.haskellPackages.cursor`,
  "Purely Functional Cursors",
);

export const cursor_brick = mkPackage(
  nixRaw`pkgs.haskellPackages.cursor-brick`,
  "",
);

export const cursor_fuzzy_time = mkPackage(
  nixRaw`pkgs.haskellPackages.cursor-fuzzy-time`,
  "",
);

export const cursor_fuzzy_time_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.cursor-fuzzy-time-gen`,
  "",
);

/**
 * Generators for Purely Functional Cursors
 */
export const cursor_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.cursor-gen`,
  "Generators for Purely Functional Cursors",
);

/**
 * Fast implementations of the curve25519 elliptic curve primitives
 */
export const curve25519 = mkPackage(
  nixRaw`pkgs.haskellPackages.curve25519`,
  "Fast implementations of the curve25519 elliptic curve primitives",
);

/**
 * FFI bindings to CUDA Solver, a LAPACK-like library
 */
export const cusolver = mkPackage(
  nixRaw`pkgs.haskellPackages.cusolver`,
  "FFI bindings to CUDA Solver, a LAPACK-like library",
);

/**
 * FFI bindings to the CUDA Sparse BLAS library
 */
export const cusparse = mkPackage(
  nixRaw`pkgs.haskellPackages.cusparse`,
  "FFI bindings to the CUDA Sparse BLAS library",
);

/**
 * Customizable string interpolation quasiquoters
 */
export const custom_interpolation = mkPackage(
  nixRaw`pkgs.haskellPackages.custom-interpolation`,
  "Customizable string interpolation quasiquoters",
);

/**
 * Cut files according to a position list
 */
export const cutter = mkPackage(
  nixRaw`pkgs.haskellPackages.cutter`,
  "Cut files according to a position list",
);

/**
 * Functional Combinators for Computer Vision
 */
export const cv_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.cv-combinators`,
  "Functional Combinators for Computer Vision",
);

/**
 * simple and efficient cve datatype
 */
export const cve = mkPackage(
  nixRaw`pkgs.haskellPackages.cve`,
  "simple and efficient cve datatype",
);

/**
 * multi-dimensional arrays
 */
export const cybus = mkPackage(
  nixRaw`pkgs.haskellPackages.cybus`,
  "multi-dimensional arrays",
);

/**
 * A subfield of the complex numbers for exact calculation
 */
export const cyclotomic = mkPackage(
  nixRaw`pkgs.haskellPackages.cyclotomic`,
  "A subfield of the complex numbers for exact calculation",
);

/**
 * Haskell bindings for the neo4j "cypher" query language
 */
export const cypher = mkPackage(
  nixRaw`pkgs.haskellPackages.cypher`,
  "Haskell bindings for the neo4j \"cypher\" query language",
);

/**
 * CZipWith class and deriving via TH
 */
export const czipwith = mkPackage(
  nixRaw`pkgs.haskellPackages.czipwith`,
  "CZipWith class and deriving via TH",
);

/**
 * Digits 0-9
 */
export const d10 = mkPackage(
  nixRaw`pkgs.haskellPackages.d10`,
  "Digits 0-9",
);

/**
 * A raw binding for the directX 11
 */
export const d3d11binding = mkPackage(
  nixRaw`pkgs.haskellPackages.d3d11binding`,
  "A raw binding for the directX 11",
);

/**
 * Start background daemons by double-forking
 */
export const daemonize_doublefork = mkPackage(
  nixRaw`pkgs.haskellPackages.daemonize-doublefork`,
  "Start background daemons by double-forking",
);

/**
 * daino is a static site generator (SSG) using shake and pandoc
 */
export const daino = mkPackage(
  nixRaw`pkgs.haskellPackages.daino`,
  "daino is a static site generator (SSG) using shake and pandoc",
);

/**
 * Prints a series of dates
 */
export const dapi = mkPackage(
  nixRaw`pkgs.haskellPackages.dapi`,
  "Prints a series of dates",
);

/**
 * a distributed, interactive, smart revision control system
 */
export const darcs = mkPackage(
  nixRaw`pkgs.haskellPackages.darcs`,
  "a distributed, interactive, smart revision control system",
);

/**
 * Comparative benchmark suite for darcs
 */
export const darcs_benchmark = mkPackage(
  nixRaw`pkgs.haskellPackages.darcs-benchmark`,
  "Comparative benchmark suite for darcs",
);

/**
 * a distributed, interactive, smart revision control system
 */
export const darcs_beta = mkPackage(
  nixRaw`pkgs.haskellPackages.darcs-beta`,
  "a distributed, interactive, smart revision control system",
);

/**
 * Import/export git fast-import streams to/from darcs
 */
export const darcs_fastconvert = mkPackage(
  nixRaw`pkgs.haskellPackages.darcs-fastconvert`,
  "Import/export git fast-import streams to/from darcs",
);

/**
 * Shell scripts for support of darcs workflow
 */
export const darcs_scripts = mkPackage(
  nixRaw`pkgs.haskellPackages.darcs-scripts`,
  "Shell scripts for support of darcs workflow",
);

/**
 * Darcs repository UI and hosting/collaboration app (hub.darcs.net branch).
 */
export const darcsden = mkPackage(
  nixRaw`pkgs.haskellPackages.darcsden`,
  "Darcs repository UI and hosting/collaboration app (hub.darcs.net branch).",
);

/**
 * Track application of Darcs patches
 */
export const darcswatch = mkPackage(
  nixRaw`pkgs.haskellPackages.darcswatch`,
  "Track application of Darcs patches",
);

/**
 * Utility and parser for DarkPlaces demo files
 */
export const darkplaces_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.darkplaces-demo`,
  "Utility and parser for DarkPlaces demo files",
);

/**
 * Darplaces rcon utility
 */
export const darkplaces_rcon_util = mkPackage(
  nixRaw`pkgs.haskellPackages.darkplaces-rcon-util`,
  "Darplaces rcon utility",
);

/**
 * Convert package Haddock to Dash docsets (IDE docs)
 */
export const dash_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.dash-haskell`,
  "Convert package Haddock to Dash docsets (IDE docs)",
);

/**
 * Utilities for accessing and manipulating fields of records
 */
export const data_accessor = mkPackage(
  nixRaw`pkgs.haskellPackages.data-accessor`,
  "Utilities for accessing and manipulating fields of records",
);

/**
 * Use Accessor to access state in mtl State monad class
 */
export const data_accessor_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.data-accessor-mtl`,
  "Use Accessor to access state in mtl State monad class",
);

/**
 * Use Accessor to access state in transformers State monad
 */
export const data_accessor_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.data-accessor-transformers`,
  "Use Accessor to access state in transformers State monad",
);

/**
 * Compatibility layer for Data.Array.Byte
 */
export const data_array_byte = mkPackage(
  nixRaw`pkgs.haskellPackages.data-array-byte`,
  "Compatibility layer for Data.Array.Byte",
);

/**
 * Simple extensible sum
 */
export const data_as = mkPackage(
  nixRaw`pkgs.haskellPackages.data-as`,
  "Simple extensible sum",
);

/**
 * A database library with a focus on ease of use, type safety and useful error messages
 */
export const data_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.data-basic`,
  "A database library with a focus on ease of use, type safety and useful error messages",
);

/**
 * Parser/Serialiser for IEEE-754 floating-point values
 */
export const data_binary_ieee754 = mkPackage(
  nixRaw`pkgs.haskellPackages.data-binary-ieee754`,
  "Parser/Serialiser for IEEE-754 floating-point values",
);

/**
 * Extra operations on binary words of fixed length
 */
export const data_bword = mkPackage(
  nixRaw`pkgs.haskellPackages.data-bword`,
  "Extra operations on binary words of fixed length",
);

/**
 * A rotating sequence data structure
 */
export const data_carousel = mkPackage(
  nixRaw`pkgs.haskellPackages.data-carousel`,
  "A rotating sequence data structure",
);

/**
 * Category theory
 */
export const data_category = mkPackage(
  nixRaw`pkgs.haskellPackages.data-category`,
  "Category theory",
);

/**
 * Generic cellular data representation library
 */
export const data_cell = mkPackage(
  nixRaw`pkgs.haskellPackages.data-cell`,
  "Generic cellular data representation library",
);

/**
 * Type-indexed runtime-checked properties
 */
export const data_checked = mkPackage(
  nixRaw`pkgs.haskellPackages.data-checked`,
  "Type-indexed runtime-checked properties",
);

/**
 * Simple functional ring type
 */
export const data_clist = mkPackage(
  nixRaw`pkgs.haskellPackages.data-clist`,
  "Simple functional ring type",
);

/**
 * Define Backwards Compatibility Schemes for Arbitrary Data
 */
export const data_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.data-compat`,
  "Define Backwards Compatibility Schemes for Arbitrary Data",
);

/**
 * a cyclic doubly linked list
 */
export const data_cycle = mkPackage(
  nixRaw`pkgs.haskellPackages.data-cycle`,
  "a cyclic doubly linked list",
);

/**
 * A class for types with a default value
 */
export const data_default = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default`,
  "A class for types with a default value",
);

/**
 * A class for types with a default value
 */
export const data_default_class = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-class`,
  "A class for types with a default value",
);

/**
 * A class for types with a default value
 */
export const data_default_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-extra`,
  "A class for types with a default value",
);

/**
 * A class for types with a default value
 */
export const data_default_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-generics`,
  "A class for types with a default value",
);

/**
 * Default instances for types in base
 */
export const data_default_instances_base = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-base`,
  "Default instances for types in base",
);

/**
 * Default instances for (lazy and strict) ByteString, Builder and ShortByteString
 */
export const data_default_instances_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-bytestring`,
  "Default instances for (lazy and strict) ByteString, Builder and ShortByteString",
);

/**
 * Default instance for CI type from case-insensitive package
 */
export const data_default_instances_case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-case-insensitive`,
  "Default instance for CI type from case-insensitive package",
);

/**
 * Default instances for types in containers
 */
export const data_default_instances_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-containers`,
  "Default instances for types in containers",
);

/**
 * Default instances for types in dlist
 */
export const data_default_instances_dlist = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-dlist`,
  "Default instances for types in dlist",
);

/**
 * Default instances for types in old-locale
 */
export const data_default_instances_old_locale = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-old-locale`,
  "Default instances for types in old-locale",
);

/**
 * Default instances for unordered-containers
 */
export const data_default_instances_unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-unordered-containers`,
  "Default instances for unordered-containers",
);

/**
 * Default instances for types defined in vector package
 */
export const data_default_instances_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.data-default-instances-vector`,
  "Default instances for types defined in vector package",
);

/**
 * Extensible records and polymorphic variants
 */
export const data_diverse = mkPackage(
  nixRaw`pkgs.haskellPackages.data-diverse`,
  "Extensible records and polymorphic variants",
);

/**
 * Stick two binary words together to get a bigger one
 */
export const data_dword = mkPackage(
  nixRaw`pkgs.haskellPackages.data-dword`,
  "Stick two binary words together to get a bigger one",
);

/**
 * Coerce between unlifted boxed and lifted types
 */
export const data_elevator = mkPackage(
  nixRaw`pkgs.haskellPackages.data-elevator`,
  "Coerce between unlifted boxed and lifted types",
);

/**
 * Executable and Linkable Format (ELF) data structures
 */
export const data_elf = mkPackage(
  nixRaw`pkgs.haskellPackages.data-elf`,
  "Executable and Linkable Format (ELF) data structures",
);

/**
 * Endian-sensitive data
 */
export const data_endian = mkPackage(
  nixRaw`pkgs.haskellPackages.data-endian`,
  "Endian-sensitive data",
);

/**
 * Extend Haskell data or newtype like in OOP languages
 */
export const data_extend_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.data-extend-generic`,
  "Extend Haskell data or newtype like in OOP languages",
);

/**
 * None
 */
export const data_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.data-extra`,
  "None",
);

/**
 * Generate data-files Cabal file field from existing files
 */
export const data_files_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.data-files-gen`,
  "Generate data-files Cabal file field from existing files",
);

/**
 * Fixpoint data types
 */
export const data_fix = mkPackage(
  nixRaw`pkgs.haskellPackages.data-fix`,
  "Fixpoint data types",
);

/**
 * Common subexpression elimination for the fixploint types
 */
export const data_fix_cse = mkPackage(
  nixRaw`pkgs.haskellPackages.data-fix-cse`,
  "Common subexpression elimination for the fixploint types",
);

/**
 * A package for working with bit masks and flags in general
 */
export const data_flags = mkPackage(
  nixRaw`pkgs.haskellPackages.data-flags`,
  "A package for working with bit masks and flags in general",
);

/**
 * Fold function applications. Framework for variadic functions.
 */
export const data_foldapp = mkPackage(
  nixRaw`pkgs.haskellPackages.data-foldapp`,
  "Fold function applications. Framework for variadic functions.",
);

/**
 * A simple multi-way tree data structure
 */
export const data_forest = mkPackage(
  nixRaw`pkgs.haskellPackages.data-forest`,
  "A simple multi-way tree data structure",
);

/**
 * Interface and functor transformers for fresh values
 */
export const data_fresh = mkPackage(
  nixRaw`pkgs.haskellPackages.data-fresh`,
  "Interface and functor transformers for fresh values",
);

/**
 * Map the arguments and return value of functions
 */
export const data_function_meld = mkPackage(
  nixRaw`pkgs.haskellPackages.data-function-meld`,
  "Map the arguments and return value of functions",
);

/**
 * Write functions in tacit (pointless) style using Applicative and De Bruijn index notation
 */
export const data_function_tacit = mkPackage(
  nixRaw`pkgs.haskellPackages.data-function-tacit`,
  "Write functions in tacit (pointless) style using Applicative and De Bruijn index notation",
);

/**
 * Updatable analogue of Distributive functors
 */
export const data_functor_logistic = mkPackage(
  nixRaw`pkgs.haskellPackages.data-functor-logistic`,
  "Updatable analogue of Distributive functors",
);

/**
 * Simple extensible product
 */
export const data_has = mkPackage(
  nixRaw`pkgs.haskellPackages.data-has`,
  "Simple extensible product",
);

/**
 * Combinators for building fast hashing functions
 */
export const data_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.data-hash`,
  "Combinators for building fast hashing functions",
);

/**
 * Interval datatype, interval arithmetic and interval-based containers
 */
export const data_interval = mkPackage(
  nixRaw`pkgs.haskellPackages.data-interval`,
  "Interval datatype, interval arithmetic and interval-based containers",
);

/**
 * A simple lazy, infinite trie from integers
 */
export const data_inttrie = mkPackage(
  nixRaw`pkgs.haskellPackages.data-inttrie`,
  "A simple lazy, infinite trie from integers",
);

/**
 * Json Token datatype
 */
export const data_json_token = mkPackage(
  nixRaw`pkgs.haskellPackages.data-json-token`,
  "Json Token datatype",
);

/**
 * Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.
 */
export const data_layer = mkPackage(
  nixRaw`pkgs.haskellPackages.data-layer`,
  "Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.",
);

/**
 * Read/write arbitrary binary layouts to a "Data.Vector.Storable".
 */
export const data_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.data-layout`,
  "Read/write arbitrary binary layouts to a \"Data.Vector.Storable\".",
);

/**
 * Used to be Haskell 98 Lenses
 */
export const data_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.data-lens`,
  "Used to be Haskell 98 Lenses",
);

/**
 * A Lens for IxSet
 */
export const data_lens_ixset = mkPackage(
  nixRaw`pkgs.haskellPackages.data-lens-ixset`,
  "A Lens for IxSet",
);

/**
 * Simple lenses, minimum dependencies
 */
export const data_lens_light = mkPackage(
  nixRaw`pkgs.haskellPackages.data-lens-light`,
  "Simple lenses, minimum dependencies",
);

/**
 * Utilities for working with sequences within lists
 */
export const data_list_sequences = mkPackage(
  nixRaw`pkgs.haskellPackages.data-list-sequences`,
  "Utilities for working with sequences within lists",
);

/**
 * A list but with a balanced enumeration of Cartesian product
 */
export const data_list_zigzag = mkPackage(
  nixRaw`pkgs.haskellPackages.data-list-zigzag`,
  "A list but with a balanced enumeration of Cartesian product",
);

/**
 * Combinators for building memo tables
 */
export const data_memocombinators = mkPackage(
  nixRaw`pkgs.haskellPackages.data-memocombinators`,
  "Combinators for building memo tables",
);

/**
 * A Haskell implementation of MessagePack
 */
export const data_msgpack = mkPackage(
  nixRaw`pkgs.haskellPackages.data-msgpack`,
  "A Haskell implementation of MessagePack",
);

/**
 * A Haskell implementation of MessagePack
 */
export const data_msgpack_types = mkPackage(
  nixRaw`pkgs.haskellPackages.data-msgpack-types`,
  "A Haskell implementation of MessagePack",
);

/**
 * Serialize JSON data to/from Haskell using the data-object library. (deprecated)
 */
export const data_object_json = mkPackage(
  nixRaw`pkgs.haskellPackages.data-object-json`,
  "Serialize JSON data to/from Haskell using the data-object library. (deprecated)",
);

/**
 * Serialize data to and from Yaml files (deprecated)
 */
export const data_object_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.data-object-yaml`,
  "Serialize data to and from Yaml files (deprecated)",
);

/**
 * A data type for non-exclusive disjunction
 */
export const data_or = mkPackage(
  nixRaw`pkgs.haskellPackages.data-or`,
  "A data type for non-exclusive disjunction",
);

/**
 * Set and bag operations on ordered lists
 */
export const data_ordlist = mkPackage(
  nixRaw`pkgs.haskellPackages.data-ordlist`,
  "Set and bag operations on ordered lists",
);

/**
 * A pure disjoint set (union find) data structure
 */
export const data_partition = mkPackage(
  nixRaw`pkgs.haskellPackages.data-partition`,
  "A pure disjoint set (union find) data structure",
);

/**
 * Unify STRef and IORef in plain Haskell 98
 */
export const data_ref = mkPackage(
  nixRaw`pkgs.haskellPackages.data-ref`,
  "Unify STRef and IORef in plain Haskell 98",
);

/**
 * Reify a recursive data structure into an explicit graph
 */
export const data_reify = mkPackage(
  nixRaw`pkgs.haskellPackages.data-reify`,
  "Reify a recursive data structure into an explicit graph",
);

/**
 * Data types for returning results distinguishable by types
 */
export const data_result = mkPackage(
  nixRaw`pkgs.haskellPackages.data-result`,
  "Data types for returning results distinguishable by types",
);

/**
 * Recursive tuple data structure. It is very usefull when implementing some lo-level operations, allowing to traverse different elements using Haskell's type classes.
 */
export const data_rtuple = mkPackage(
  nixRaw`pkgs.haskellPackages.data-rtuple`,
  "Recursive tuple data structure. It is very usefull when implementing some lo-level operations, allowing to traverse different elements using Haskell's type classes.",
);

/**
 * Common API for serialization libraries
 */
export const data_serializer = mkPackage(
  nixRaw`pkgs.haskellPackages.data-serializer`,
  "Common API for serialization libraries",
);

export const data_sketches = mkPackage(
  nixRaw`pkgs.haskellPackages.data-sketches`,
  "",
);

export const data_sketches_core = mkPackage(
  nixRaw`pkgs.haskellPackages.data-sketches-core`,
  "",
);

/**
 * ARM SVD and CubeMX XML parser and pretty printer for STM32 family
 */
export const data_stm32 = mkPackage(
  nixRaw`pkgs.haskellPackages.data-stm32`,
  "ARM SVD and CubeMX XML parser and pretty printer for STM32 family",
);

/**
 * Program that infers the fastest data structure available for your program
 */
export const data_structure_inferrer = mkPackage(
  nixRaw`pkgs.haskellPackages.data-structure-inferrer`,
  "Program that infers the fastest data structure available for your program",
);

/**
 * Shorter binary words
 */
export const data_sword = mkPackage(
  nixRaw`pkgs.haskellPackages.data-sword`,
  "Shorter binary words",
);

/**
 * Tensor and Group typeclasses
 */
export const data_tensor = mkPackage(
  nixRaw`pkgs.haskellPackages.data-tensor`,
  "Tensor and Group typeclasses",
);

/**
 * Human-friendly textual representations
 */
export const data_textual = mkPackage(
  nixRaw`pkgs.haskellPackages.data-textual`,
  "Human-friendly textual representations",
);

/**
 * 64-bit timeouts of nanosecond precision
 */
export const data_timeout = mkPackage(
  nixRaw`pkgs.haskellPackages.data-timeout`,
  "64-bit timeouts of nanosecond precision",
);

/**
 * Functions to transform data structures
 */
export const data_transform = mkPackage(
  nixRaw`pkgs.haskellPackages.data-transform`,
  "Functions to transform data structures",
);

/**
 * Print Data instances as a nested tree
 */
export const data_tree_print = mkPackage(
  nixRaw`pkgs.haskellPackages.data-tree-print`,
  "Print Data instances as a nested tree",
);

/**
 * Reify a recursive data structure into an explicit graph
 */
export const data_treify = mkPackage(
  nixRaw`pkgs.haskellPackages.data-treify`,
  "Reify a recursive data structure into an explicit graph",
);

/**
 * Class for types with a database id
 */
export const database_id_class = mkPackage(
  nixRaw`pkgs.haskellPackages.database-id-class`,
  "Class for types with a database id",
);

/**
 * HasId/Groundhog interop
 */
export const database_id_groundhog = mkPackage(
  nixRaw`pkgs.haskellPackages.database-id-groundhog`,
  "HasId/Groundhog interop",
);

/**
 * Datadog tracing client and mock agent
 */
export const datadog_tracing = mkPackage(
  nixRaw`pkgs.haskellPackages.datadog-tracing`,
  "Datadog tracing client and mock agent",
);

/**
 * Data encoding library
 */
export const dataenc = mkPackage(
  nixRaw`pkgs.haskellPackages.dataenc`,
  "Data encoding library",
);

/**
 * Fixing data-flow problems
 */
export const datafix = mkPackage(
  nixRaw`pkgs.haskellPackages.datafix`,
  "Fixing data-flow problems",
);

/**
 * Generate Graphviz documents from a Haskell representation
 */
export const dataflow = mkPackage(
  nixRaw`pkgs.haskellPackages.dataflow`,
  "Generate Graphviz documents from a Haskell representation",
);

/**
 * A Pure-Haskell Timely Dataflow System
 */
export const dataflower = mkPackage(
  nixRaw`pkgs.haskellPackages.dataflower`,
  "A Pure-Haskell Timely Dataflow System",
);

/**
 * Classical data sets for statistics and machine learning
 */
export const datasets = mkPackage(
  nixRaw`pkgs.haskellPackages.datasets`,
  "Classical data sets for statistics and machine learning",
);

/**
 * Handle data-urls
 */
export const dataurl = mkPackage(
  nixRaw`pkgs.haskellPackages.dataurl`,
  "Handle data-urls",
);

/**
 * Date cacher
 */
export const date_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.date-cache`,
  "Date cacher",
);

/**
 * Date conversions
 */
export const date_conversions = mkPackage(
  nixRaw`pkgs.haskellPackages.date-conversions`,
  "Date conversions",
);

/**
 * Decompiler Bytecode Java
 */
export const dbjava = mkPackage(
  nixRaw`pkgs.haskellPackages.dbjava`,
  "Decompiler Bytecode Java",
);

/**
 * The dbmigrations tool built for MySQL databases
 */
export const dbmigrations_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.dbmigrations-mysql`,
  "The dbmigrations tool built for MySQL databases",
);

/**
 * The dbmigrations tool built for PostgreSQL databases
 */
export const dbmigrations_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.dbmigrations-postgresql`,
  "The dbmigrations tool built for PostgreSQL databases",
);

/**
 * The dbmigrations tool built for SQLite databases
 */
export const dbmigrations_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.dbmigrations-sqlite`,
  "The dbmigrations tool built for SQLite databases",
);

/**
 * A client library for the D-Bus IPC system
 */
export const dbus = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus`,
  "A client library for the D-Bus IPC system",
);

/**
 * A client library for the D-Bus IPC system
 */
export const dbus_1_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus_1_3_1`,
  "A client library for the D-Bus IPC system",
);

/**
 * Monadic and object-oriented interfaces to DBus
 */
export const dbus_client = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus-client`,
  "Monadic and object-oriented interfaces to DBus",
);

/**
 * Expose a dbus server to control hslogger
 */
export const dbus_hslogger = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus-hslogger`,
  "Expose a dbus server to control hslogger",
);

/**
 * TemplateHaskell generator of DBus bindings
 */
export const dbus_th = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus-th`,
  "TemplateHaskell generator of DBus bindings",
);

/**
 * Generate bindings for DBus calls by using DBus introspection and dbus-th
 */
export const dbus_th_introspection = mkPackage(
  nixRaw`pkgs.haskellPackages.dbus-th-introspection`,
  "Generate bindings for DBus calls by using DBus introspection and dbus-th",
);

/**
 * Convert dconf files to Nix, as expected by Home Manager
 */
export const dconf2nix = mkPackage(
  nixRaw`pkgs.haskellPackages.dconf2nix`,
  "Convert dconf files to Nix, as expected by Home Manager",
);

/**
 * Discordian Date Types for Haskell
 */
export const ddate = mkPackage(
  nixRaw`pkgs.haskellPackages.ddate`,
  "Discordian Date Types for Haskell",
);

/**
 * Disciplined Disciple Compiler build framework
 */
export const ddc_build = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-build`,
  "Disciplined Disciple Compiler build framework",
);

/**
 * Disciplined Disciple Compiler core language and type checker
 */
export const ddc_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core`,
  "Disciplined Disciple Compiler core language and type checker",
);

/**
 * Disciplined Disciple Compiler PHP code generator
 */
export const ddc_core_babel = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-babel`,
  "Disciplined Disciple Compiler PHP code generator",
);

/**
 * Disciplined Disciple Compiler semantic evaluator for the core language
 */
export const ddc_core_eval = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-eval`,
  "Disciplined Disciple Compiler semantic evaluator for the core language",
);

/**
 * Disciplined Disciple Compiler data flow compiler
 */
export const ddc_core_flow = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-flow`,
  "Disciplined Disciple Compiler data flow compiler",
);

/**
 * Disciplined Disciple Compiler LLVM code generator
 */
export const ddc_core_llvm = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-llvm`,
  "Disciplined Disciple Compiler LLVM code generator",
);

/**
 * Disciplined Disciple Compiler C code generator
 */
export const ddc_core_salt = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-salt`,
  "Disciplined Disciple Compiler C code generator",
);

/**
 * Disciplined Disciple Compiler code transformations
 */
export const ddc_core_simpl = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-simpl`,
  "Disciplined Disciple Compiler code transformations",
);

/**
 * Disciplined Disciple Compiler intermediate language
 */
export const ddc_core_tetra = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-core-tetra`,
  "Disciplined Disciple Compiler intermediate language",
);

/**
 * Disciplined Disciple Compiler top-level driver
 */
export const ddc_driver = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-driver`,
  "Disciplined Disciple Compiler top-level driver",
);

/**
 * Disciplined Disciple Compiler user interface support
 */
export const ddc_interface = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-interface`,
  "Disciplined Disciple Compiler user interface support",
);

/**
 * Disciplined Disciple Compiler source language
 */
export const ddc_source_tetra = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-source-tetra`,
  "Disciplined Disciple Compiler source language",
);

/**
 * Disciplined Disciple Compiler command line tools
 */
export const ddc_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-tools`,
  "Disciplined Disciple Compiler command line tools",
);

/**
 * Disciplined Disciple Compiler test driver and buildbot
 */
export const ddc_war = mkPackage(
  nixRaw`pkgs.haskellPackages.ddc-war`,
  "Disciplined Disciple Compiler test driver and buildbot",
);

/**
 * Disciple Core language interactive interpreter
 */
export const ddci_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ddci-core`,
  "Disciple Core language interactive interpreter",
);

/**
 * Delay differential equations
 */
export const dde = mkPackage(
  nixRaw`pkgs.haskellPackages.dde`,
  "Delay differential equations",
);

/**
 * Modules for working with the Debian package system
 */
export const debian = mkPackage(
  nixRaw`pkgs.haskellPackages.debian`,
  "Modules for working with the Debian package system",
);

/**
 * Utilities to work with debian binary packages
 */
export const debian_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.debian-binary`,
  "Utilities to work with debian binary packages",
);

/**
 * Debian package build sequence tools
 */
export const debian_build = mkPackage(
  nixRaw`pkgs.haskellPackages.debian-build`,
  "Debian package build sequence tools",
);

/**
 * Simple trace-based debugger
 */
export const debug = mkPackage(
  nixRaw`pkgs.haskellPackages.debug`,
  "Simple trace-based debugger",
);

/**
 * Display a colorized diff between two Haskell values
 */
export const debug_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.debug-diff`,
  "Display a colorized diff between two Haskell values",
);

/**
 * File-based debug output
 */
export const debug_dump = mkPackage(
  nixRaw`pkgs.haskellPackages.debug-dump`,
  "File-based debug output",
);

/**
 * Debug.Trace equivalent for timing computations
 */
export const debug_time = mkPackage(
  nixRaw`pkgs.haskellPackages.debug-time`,
  "Debug.Trace equivalent for timing computations",
);

/**
 * You do not have to write variable names twice in Debug.Trace
 */
export const debug_trace_var = mkPackage(
  nixRaw`pkgs.haskellPackages.debug-trace-var`,
  "You do not have to write variable names twice in Debug.Trace",
);

/**
 * Convert Unicode characters with burrs to their ASCII counterparts
 */
export const deburr = mkPackage(
  nixRaw`pkgs.haskellPackages.deburr`,
  "Convert Unicode characters with burrs to their ASCII counterparts",
);

/**
 * Decidable propositions
 */
export const dec = mkPackage(
  nixRaw`pkgs.haskellPackages.dec`,
  "Decidable propositions",
);

/**
 * Combinators for manipulating dependently-typed predicates
 */
export const decidable = mkPackage(
  nixRaw`pkgs.haskellPackages.decidable`,
  "Combinators for manipulating dependently-typed predicates",
);

/**
 * An implementation of the General Decimal Arithmetic Specification
 */
export const decimal_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.decimal-arithmetic`,
  "An implementation of the General Decimal Arithmetic Specification",
);

/**
 * Preprocessing decimal literals more or less as they are (instead of via fractions)
 */
export const decimal_literals = mkPackage(
  nixRaw`pkgs.haskellPackages.decimal-literals`,
  "Preprocessing decimal literals more or less as they are (instead of via fractions)",
);

/**
 * DIY Markov Chains
 */
export const declarative = mkPackage(
  nixRaw`pkgs.haskellPackages.declarative`,
  "DIY Markov Chains",
);

/**
 * Decode a UTF-8 byte stream on standard input
 */
export const decode_utf8 = mkPackage(
  nixRaw`pkgs.haskellPackages.decode-utf8`,
  "Decode a UTF-8 byte stream on standard input",
);

/**
 * A type-checker for the -modulo calculus
 */
export const dedukti = mkPackage(
  nixRaw`pkgs.haskellPackages.dedukti`,
  "A type-checker for the -modulo calculus",
);

/**
 * Deeply-nested, multiple key type maps
 */
export const deep_map = mkPackage(
  nixRaw`pkgs.haskellPackages.deep-map`,
  "Deeply-nested, multiple key type maps",
);

/**
 * Deep natural and unnatural tree transformations, including attribute grammars
 */
export const deep_transformations = mkPackage(
  nixRaw`pkgs.haskellPackages.deep-transformations`,
  "Deep natural and unnatural tree transformations, including attribute grammars",
);

/**
 * Deep Learning in Haskell
 */
export const deeplearning_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.deeplearning-hs`,
  "Deep Learning in Haskell",
);

/**
 * Deep evaluation of data structures
 */
export const deepseq_1_5_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.deepseq_1_5_0_0`,
  "Deep evaluation of data structures",
);

/**
 * GHC.Generics-based Control.DeepSeq.rnf implementation
 */
export const deepseq_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.deepseq-generics`,
  "GHC.Generics-based Control.DeepSeq.rnf implementation",
);

/**
 * A DeepZoom image slicer. Only known to work on 32bit Linux
 */
export const deepzoom = mkPackage(
  nixRaw`pkgs.haskellPackages.deepzoom`,
  "A DeepZoom image slicer. Only known to work on 32bit Linux",
);

/**
 * default arguments in haskell
 */
export const defargs = mkPackage(
  nixRaw`pkgs.haskellPackages.defargs`,
  "default arguments in haskell",
);

/**
 * Applicative maps
 */
export const defaultable_map = mkPackage(
  nixRaw`pkgs.haskellPackages.defaultable-map`,
  "Applicative maps",
);

/**
 * Abstractions over deferred folds
 */
export const deferred_folds = mkPackage(
  nixRaw`pkgs.haskellPackages.deferred-folds`,
  "Abstractions over deferred folds",
);

/**
 * A library that enable you to interact with the filesystem in a definitive way
 */
export const definitive_filesystem = mkPackage(
  nixRaw`pkgs.haskellPackages.definitive-filesystem`,
  "A library that enable you to interact with the filesystem in a definitive way",
);

/**
 * A definitive package allowing you to open windows, read image files and render text to be displayed or saved
 */
export const definitive_graphics = mkPackage(
  nixRaw`pkgs.haskellPackages.definitive-graphics`,
  "A definitive package allowing you to open windows, read image files and render text to be displayed or saved",
);

/**
 * A parser combinator library for the Definitive framework
 */
export const definitive_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.definitive-parser`,
  "A parser combinator library for the Definitive framework",
);

/**
 * A simple Reactive library
 */
export const definitive_reactive = mkPackage(
  nixRaw`pkgs.haskellPackages.definitive-reactive`,
  "A simple Reactive library",
);

/**
 * A definitive package to handle sound and play it back
 */
export const definitive_sound = mkPackage(
  nixRaw`pkgs.haskellPackages.definitive-sound`,
  "A definitive package to handle sound and play it back",
);

/**
 * A library for unit-testing concurrent programs
 */
export const dejafu = mkPackage(
  nixRaw`pkgs.haskellPackages.dejafu`,
  "A library for unit-testing concurrent programs",
);

/**
 * Tests for deka, decimal floating point arithmetic
 */
export const deka_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.deka-tests`,
  "Tests for deka, decimal floating point arithmetic",
);

/**
 * Build a Delaunay triangulation of a set of points
 */
export const delaunay = mkPackage(
  nixRaw`pkgs.haskellPackages.delaunay`,
  "Build a Delaunay triangulation of a set of points",
);

/**
 * More useful and humain delaying functions
 */
export const delay = mkPackage(
  nixRaw`pkgs.haskellPackages.delay`,
  "More useful and humain delaying functions",
);

/**
 * Accessing the del.icio.us APIs from Haskell (v2)
 */
export const delicious = mkPackage(
  nixRaw`pkgs.haskellPackages.delicious`,
  "Accessing the del.icio.us APIs from Haskell (v2)",
);

/**
 * Parse character delimited textual data
 */
export const delimited_text = mkPackage(
  nixRaw`pkgs.haskellPackages.delimited-text`,
  "Parse character delimited textual data",
);

/**
 * Library for dealing with tab and/or comma (or other) separated files
 */
export const delimiter_separated = mkPackage(
  nixRaw`pkgs.haskellPackages.delimiter-separated`,
  "Library for dealing with tab and/or comma (or other) separated files",
);

/**
 * A library for detecting file changes
 */
export const delta = mkPackage(
  nixRaw`pkgs.haskellPackages.delta`,
  "A library for detecting file changes",
);

/**
 * Online entropy-based model of lexical category acquisition
 */
export const delta_h = mkPackage(
  nixRaw`pkgs.haskellPackages.delta-h`,
  "Online entropy-based model of lexical category acquisition",
);

/**
 * Simple and incomplete pure haskell implementation of linear algebra
 */
export const dense_linear_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.dense-linear-algebra`,
  "Simple and incomplete pure haskell implementation of linear algebra",
);

/**
 * Giving good advice to functions in records-of-functions
 */
export const dep_t_advice = mkPackage(
  nixRaw`pkgs.haskellPackages.dep-t-advice`,
  "Giving good advice to functions in records-of-functions",
);

/**
 * A dynamic environment for dependency injection
 */
export const dep_t_dynamic = mkPackage(
  nixRaw`pkgs.haskellPackages.dep-t-dynamic`,
  "A dynamic environment for dependency injection",
);

/**
 * Pair resources files with types within your program
 */
export const dep_t_value = mkPackage(
  nixRaw`pkgs.haskellPackages.dep-t-value`,
  "Pair resources files with types within your program",
);

/**
 * Dependency resolution for package management
 */
export const dependency = mkPackage(
  nixRaw`pkgs.haskellPackages.dependency`,
  "Dependency resolution for package management",
);

/**
 * Library for dependent-literals-plugin
 */
export const dependent_literals = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-literals`,
  "Library for dependent-literals-plugin",
);

/**
 * Dependent integer literals
 */
export const dependent_literals_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-literals-plugin`,
  "Dependent integer literals",
);

/**
 * Dependent finite maps (partial dependent products)
 */
export const dependent_map = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-map`,
  "Dependent finite maps (partial dependent products)",
);

/**
 * Dependent finite maps (partial dependent products)
 */
export const dependent_map_0_2_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-map_0_2_4_0`,
  "Dependent finite maps (partial dependent products)",
);

/**
 * Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.
 */
export const dependent_state = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-state`,
  "Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.",
);

/**
 * Dependent sum type
 */
export const dependent_sum = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-sum`,
  "Dependent sum type",
);

/**
 * Dependent sum type
 */
export const dependent_sum_0_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-sum_0_4`,
  "Dependent sum type",
);

/**
 * JSON instances for DSum, DMap, and Some
 */
export const dependent_sum_aeson_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-sum-aeson-orphans`,
  "JSON instances for DSum, DMap, and Some",
);

/**
 * Template Haskell code to generate instances of classes in dependent-sum package
 */
export const dependent_sum_template = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-sum-template`,
  "Template Haskell code to generate instances of classes in dependent-sum package",
);

/**
 * Template Haskell code to generate instances of classes in some package
 */
export const dependent_sum_template_0_2_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dependent-sum-template_0_2_0_0`,
  "Template Haskell code to generate instances of classes in some package",
);

/**
 * A simple configuration management tool for Haskell
 */
export const depends = mkPackage(
  nixRaw`pkgs.haskellPackages.depends`,
  "A simple configuration management tool for Haskell",
);

/**
 * Analyze quality of nucleotide sequences
 */
export const dephd = mkPackage(
  nixRaw`pkgs.haskellPackages.dephd`,
  "Analyze quality of nucleotide sequences",
);

/**
 * Double-ended priority queues
 */
export const depq = mkPackage(
  nixRaw`pkgs.haskellPackages.depq`,
  "Double-ended priority queues",
);

/**
 * DepTrack applied to DevOps
 */
export const deptrack_devops = mkPackage(
  nixRaw`pkgs.haskellPackages.deptrack-devops`,
  "DepTrack applied to DevOps",
);

/**
 * Facilitate Graphviz representations of DepTrack dependencies
 */
export const deptrack_dot = mkPackage(
  nixRaw`pkgs.haskellPackages.deptrack-dot`,
  "Facilitate Graphviz representations of DepTrack dependencies",
);

/**
 * Double-ended queues
 */
export const deque = mkPackage(
  nixRaw`pkgs.haskellPackages.deque`,
  "Double-ended queues",
);

/**
 * A typeclass and an implementation for double-ended queues
 */
export const dequeue = mkPackage(
  nixRaw`pkgs.haskellPackages.dequeue`,
  "A typeclass and an implementation for double-ended queues",
);

/**
 * Macro to derive instances for Instant-Generics using Template Haskell
 */
export const derive_IG = mkPackage(
  nixRaw`pkgs.haskellPackages.derive-IG`,
  "Macro to derive instances for Instant-Generics using Template Haskell",
);

/**
 * Derive HasField instances with Template Haskell
 */
export const derive_has_field = mkPackage(
  nixRaw`pkgs.haskellPackages.derive-has-field`,
  "Derive HasField instances with Template Haskell",
);

/**
 * Derive Storable instances with GHC.Generics.
 */
export const derive_storable = mkPackage(
  nixRaw`pkgs.haskellPackages.derive-storable`,
  "Derive Storable instances with GHC.Generics.",
);

/**
 * GHC core plugin supporting the derive-storable package
 */
export const derive_storable_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.derive-storable-plugin`,
  "GHC core plugin supporting the derive-storable package",
);

/**
 * Help Haskellers derive class instances for composited data types
 */
export const derive_topdown = mkPackage(
  nixRaw`pkgs.haskellPackages.derive-topdown`,
  "Help Haskellers derive class instances for composited data types",
);

/**
 * Type driven generic aeson instance customisation
 */
export const deriving_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-aeson`,
  "Type driven generic aeson instance customisation",
);

/**
 * Backports of GHC deriving extensions
 */
export const deriving_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-compat`,
  "Backports of GHC deriving extensions",
);

/**
 * DerivingVia for OpenAPI 3
 */
export const deriving_openapi3 = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-openapi3`,
  "DerivingVia for OpenAPI 3",
);

/**
 * Derive a Show instance without field selector names
 */
export const deriving_show_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-show-simple`,
  "Derive a Show instance without field selector names",
);

/**
 * Derive instances for monad transformer stacks
 */
export const deriving_trans = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-trans`,
  "Derive instances for monad transformer stacks",
);

/**
 * Derive instances for monad transformer stacks
 */
export const deriving_trans_0_9_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.deriving-trans_0_9_1_0`,
  "Derive instances for monad transformer stacks",
);

/**
 * DerivingVia extras - Miscellaneous /via/ types
 */
export const derivingvia_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.derivingvia-extras`,
  "DerivingVia extras - Miscellaneous /via/ types",
);

/**
 * Derivative Parsing
 */
export const derp = mkPackage(
  nixRaw`pkgs.haskellPackages.derp`,
  "Derivative Parsing",
);

/**
 * Parse and render JSON simply
 */
export const derulo = mkPackage(
  nixRaw`pkgs.haskellPackages.derulo`,
  "Parse and render JSON simply",
);

/**
 * Loads a list of items with fields
 */
export const descrilo = mkPackage(
  nixRaw`pkgs.haskellPackages.descrilo`,
  "Loads a list of items with fields",
);

/**
 * Library, interpreter, and CLI for Descript programming language
 */
export const descript_lang = mkPackage(
  nixRaw`pkgs.haskellPackages.descript-lang`,
  "Library, interpreter, and CLI for Descript programming language",
);

/**
 * a simple build tool for OCaml projects
 */
export const desert = mkPackage(
  nixRaw`pkgs.haskellPackages.desert`,
  "a simple build tool for OCaml projects",
);

/**
 * Despair
 */
export const despair = mkPackage(
  nixRaw`pkgs.haskellPackages.despair`,
  "Despair",
);

/**
 * JSON and CSV encoding for rationals as decimal point numbers
 */
export const detour_via_sci = mkPackage(
  nixRaw`pkgs.haskellPackages.detour-via-sci`,
  "JSON and CSV encoding for rationals as decimal point numbers",
);

/**
 * JSON and CSV encoding for quantities
 */
export const detour_via_uom = mkPackage(
  nixRaw`pkgs.haskellPackages.detour-via-uom`,
  "JSON and CSV encoding for quantities",
);

/**
 * Haskell development tool agregate
 */
export const devtools = mkPackage(
  nixRaw`pkgs.haskellPackages.devtools`,
  "Haskell development tool agregate",
);

/**
 * Find gadgets for return-oriented programming on x86
 */
export const dewdrop = mkPackage(
  nixRaw`pkgs.haskellPackages.dewdrop`,
  "Find gadgets for return-oriented programming on x86",
);

/**
 * Type, render and parse the df1 hierarchical structured log format
 */
export const df1 = mkPackage(
  nixRaw`pkgs.haskellPackages.df1`,
  "Type, render and parse the df1 hierarchical structured log format",
);

/**
 * A generic data integrity layer
 */
export const dfinity_radix_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.dfinity-radix-tree`,
  "A generic data integrity layer",
);

/**
 * A package for precise decimal arithmatic using rationals
 */
export const dfrac = mkPackage(
  nixRaw`pkgs.haskellPackages.dfrac`,
  "A package for precise decimal arithmatic using rationals",
);

/**
 * A configuration language guaranteed to terminate
 */
export const dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall`,
  "A configuration language guaranteed to terminate",
);

/**
 * A configuration language guaranteed to terminate
 */
export const dhall_1_29_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall_1_29_0`,
  "A configuration language guaranteed to terminate",
);

/**
 * A configuration language guaranteed to terminate
 */
export const dhall_1_38_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall_1_38_1`,
  "A configuration language guaranteed to terminate",
);

/**
 * A configuration language guaranteed to terminate
 */
export const dhall_1_42_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall_1_42_0`,
  "A configuration language guaranteed to terminate",
);

/**
 * Compile Dhall to Bash
 */
export const dhall_bash = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-bash`,
  "Compile Dhall to Bash",
);

/**
 * Compile Dhall to Bash
 */
export const dhall_bash_1_0_41 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-bash_1_0_41`,
  "Compile Dhall to Bash",
);

/**
 * Generate HTML docs from a dhall package
 */
export const dhall_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-docs`,
  "Generate HTML docs from a dhall package",
);

/**
 * Convert between Dhall and JSON or YAML
 */
export const dhall_json = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-json`,
  "Convert between Dhall and JSON or YAML",
);

/**
 * Convert between Dhall and JSON or YAML
 */
export const dhall_json_1_7_12 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-json_1_7_12`,
  "Convert between Dhall and JSON or YAML",
);

/**
 * Lexer for the Dhall language
 */
export const dhall_lex = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-lex`,
  "Lexer for the Dhall language",
);

/**
 * Dhall to Nix compiler
 */
export const dhall_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-nix`,
  "Dhall to Nix compiler",
);

/**
 * Dhall to Nix compiler
 */
export const dhall_nix_1_1_26 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-nix_1_1_26`,
  "Dhall to Nix compiler",
);

/**
 * Convert Dhall projects to Nix packages
 */
export const dhall_nixpkgs = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-nixpkgs`,
  "Convert Dhall projects to Nix packages",
);

/**
 * Convert Dhall projects to Nix packages
 */
export const dhall_nixpkgs_1_0_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-nixpkgs_1_0_10`,
  "Convert Dhall projects to Nix packages",
);

/**
 * Convert an OpenAPI specification to a Dhall package
 */
export const dhall_openapi = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-openapi`,
  "Convert an OpenAPI specification to a Dhall package",
);

/**
 * Encrypt Decrypt Dhall expressions
 */
export const dhall_secret = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-secret`,
  "Encrypt Decrypt Dhall expressions",
);

/**
 * Render dhall text with shell commands as function arguments
 */
export const dhall_text_shell = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-text-shell`,
  "Render dhall text with shell commands as function arguments",
);

/**
 * Convert between Dhall and TOML
 */
export const dhall_toml = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-toml`,
  "Convert between Dhall and TOML",
);

/**
 * Convert between Dhall and YAML
 */
export const dhall_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.dhall-yaml`,
  "Convert between Dhall and YAML",
);

/**
 * Typeful hierarchical structured logging using di, mtl and df1
 */
export const di = mkPackage(
  nixRaw`pkgs.haskellPackages.di`,
  "Typeful hierarchical structured logging using di, mtl and df1",
);

/**
 * Typeful hierarchical structured logging without monad towers
 */
export const di_core = mkPackage(
  nixRaw`pkgs.haskellPackages.di-core`,
  "Typeful hierarchical structured logging without monad towers",
);

/**
 * Write logs in the df1 format using the di logging framework
 */
export const di_df1 = mkPackage(
  nixRaw`pkgs.haskellPackages.di-df1`,
  "Write logs in the df1 format using the di logging framework",
);

/**
 * IO support for file handles in di-core
 */
export const di_handle = mkPackage(
  nixRaw`pkgs.haskellPackages.di-handle`,
  "IO support for file handles in di-core",
);

/**
 * mtl flavoured typeful hierarchical structured logging for di-core
 */
export const di_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.di-monad`,
  "mtl flavoured typeful hierarchical structured logging for di-core",
);

/**
 * DI logger wrapped for Polysemy
 */
export const di_polysemy = mkPackage(
  nixRaw`pkgs.haskellPackages.di-polysemy`,
  "DI logger wrapped for Polysemy",
);

/**
 * An EDSL for teaching Haskell with diagrams - functions
 */
export const dia_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.dia-functions`,
  "An EDSL for teaching Haskell with diagrams - functions",
);

/**
 * Embedded domain-specific language for declarative vector graphics
 */
export const diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams`,
  "Embedded domain-specific language for declarative vector graphics",
);

/**
 * Braille diagrams with plain text
 */
export const diagrams_braille = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-braille`,
  "Braille diagrams with plain text",
);

/**
 * hint-based build service for the diagrams graphics EDSL
 */
export const diagrams_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-builder`,
  "hint-based build service for the diagrams graphics EDSL",
);

/**
 * Cairo backend for diagrams drawing EDSL
 */
export const diagrams_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-cairo`,
  "Cairo backend for diagrams drawing EDSL",
);

/**
 * HTML5 canvas backend for diagrams drawing EDSL
 */
export const diagrams_canvas = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-canvas`,
  "HTML5 canvas backend for diagrams drawing EDSL",
);

/**
 * Collection of user contributions to diagrams EDSL
 */
export const diagrams_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-contrib`,
  "Collection of user contributions to diagrams EDSL",
);

/**
 * Core libraries for diagrams EDSL
 */
export const diagrams_core = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-core`,
  "Core libraries for diagrams EDSL",
);

/**
 * Cairo backend for diagrams drawing EDSL
 */
export const diagrams_gi_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-gi-cairo`,
  "Cairo backend for diagrams drawing EDSL",
);

/**
 * Graph layout and drawing with GraphViz and diagrams
 */
export const diagrams_graphviz = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-graphviz`,
  "Graph layout and drawing with GraphViz and diagrams",
);

/**
 * Backend for rendering diagrams directly to GTK windows
 */
export const diagrams_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-gtk`,
  "Backend for rendering diagrams directly to GTK windows",
);

/**
 * Preprocessor for embedding diagrams in Haddock documentation
 */
export const diagrams_haddock = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-haddock`,
  "Preprocessor for embedding diagrams in Haddock documentation",
);

/**
 * HsQML (Qt5) backend for Diagrams
 */
export const diagrams_hsqml = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-hsqml`,
  "HsQML (Qt5) backend for Diagrams",
);

/**
 * HTML5 canvas backend for diagrams drawing EDSL
 */
export const diagrams_html5 = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-html5`,
  "HTML5 canvas backend for diagrams drawing EDSL",
);

/**
 * Parse raster and SVG files for diagrams
 */
export const diagrams_input = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-input`,
  "Parse raster and SVG files for diagrams",
);

/**
 * Embedded domain-specific language for declarative graphics
 */
export const diagrams_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-lib`,
  "Embedded domain-specific language for declarative graphics",
);

/**
 * A Pandoc filter to express diagrams inline using the Haskell EDSL _Diagrams_
 */
export const diagrams_pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-pandoc`,
  "A Pandoc filter to express diagrams inline using the Haskell EDSL _Diagrams_",
);

/**
 * PGF backend for diagrams drawing EDSL
 */
export const diagrams_pgf = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-pgf`,
  "PGF backend for diagrams drawing EDSL",
);

/**
 * Postscript backend for diagrams drawing EDSL
 */
export const diagrams_postscript = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-postscript`,
  "Postscript backend for diagrams drawing EDSL",
);

/**
 * Rasterific backend for diagrams
 */
export const diagrams_rasterific = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-rasterific`,
  "Rasterific backend for diagrams",
);

/**
 * reflex backend for diagrams drawing EDSL
 */
export const diagrams_reflex = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-reflex`,
  "reflex backend for diagrams drawing EDSL",
);

/**
 * Pure Haskell solver routines used by diagrams
 */
export const diagrams_solve = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-solve`,
  "Pure Haskell solver routines used by diagrams",
);

/**
 * SVG backend for diagrams drawing EDSL
 */
export const diagrams_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-svg`,
  "SVG backend for diagrams drawing EDSL",
);

/**
 * Backend for rendering diagrams in wxWidgets
 */
export const diagrams_wx = mkPackage(
  nixRaw`pkgs.haskellPackages.diagrams-wx`,
  "Backend for rendering diagrams in wxWidgets",
);

/**
 * Simple dialog-based user interfaces
 */
export const dialog = mkPackage(
  nixRaw`pkgs.haskellPackages.dialog`,
  "Simple dialog-based user interfaces",
);

/**
 * Simplistic D&D style dice-rolling system
 */
export const dice = mkPackage(
  nixRaw`pkgs.haskellPackages.dice`,
  "Simplistic D&D style dice-rolling system",
);

/**
 * Cryptographically secure n-sided dice via rejection sampling
 */
export const dice_entropy_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.dice-entropy-conduit`,
  "Cryptographically secure n-sided dice via rejection sampling",
);

/**
 * Sharing/memoization of class members
 */
export const dictionary_sharing = mkPackage(
  nixRaw`pkgs.haskellPackages.dictionary-sharing`,
  "Sharing/memoization of class members",
);

/**
 * Diff and patch
 */
export const diff = mkPackage(
  nixRaw`pkgs.haskellPackages.diff`,
  "Diff and patch",
);

/**
 * Perform a 3-way difference of documents
 */
export const diff3 = mkPackage(
  nixRaw`pkgs.haskellPackages.diff3`,
  "Perform a 3-way difference of documents",
);

/**
 * Map file locations across diffs
 */
export const diff_loc = mkPackage(
  nixRaw`pkgs.haskellPackages.diff-loc`,
  "Map file locations across diffs",
);

/**
 * A parser for diff file formats
 */
export const diff_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.diff-parse`,
  "A parser for diff file formats",
);

/**
 * DiffArray
 */
export const diffarray = mkPackage(
  nixRaw`pkgs.haskellPackages.diffarray`,
  "DiffArray",
);

/**
 * Tools for diffing stdout
 */
export const diffdump = mkPackage(
  nixRaw`pkgs.haskellPackages.diffdump`,
  "Tools for diffing stdout",
);

export const difference_monoid = mkPackage(
  nixRaw`pkgs.haskellPackages.difference-monoid`,
  "",
);

/**
 * Finds out whether an entity comes from different distributions (statuses)
 */
export const differential = mkPackage(
  nixRaw`pkgs.haskellPackages.differential`,
  "Finds out whether an entity comes from different distributions (statuses)",
);

/**
 * A (deprecated) implementation of the digamma function
 */
export const digamma = mkPackage(
  nixRaw`pkgs.haskellPackages.digamma`,
  "A (deprecated) implementation of the digamma function",
);

/**
 * Various hashes for bytestrings; CRC32 and Adler32 for now
 */
export const digest = mkPackage(
  nixRaw`pkgs.haskellPackages.digest`,
  "Various hashes for bytestrings; CRC32 and Adler32 for now",
);

/**
 * Signature for digest
 */
export const digest_sig = mkPackage(
  nixRaw`pkgs.haskellPackages.digest-sig`,
  "Signature for digest",
);

/**
 * Speed up form designing using digestive functors and foundation
 */
export const digestive_foundation_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-foundation-lucid`,
  "Speed up form designing using digestive functors and foundation",
);

/**
 * A practical formlet library
 */
export const digestive_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-functors`,
  "A practical formlet library",
);

/**
 * Blaze frontend for the digestive-functors library
 */
export const digestive_functors_blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-functors-blaze`,
  "Blaze frontend for the digestive-functors library",
);

/**
 * Heist frontend for the digestive-functors library
 */
export const digestive_functors_heist = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-functors-heist`,
  "Heist frontend for the digestive-functors library",
);

/**
 * HSP support for digestive-functors
 */
export const digestive_functors_hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-functors-hsp`,
  "HSP support for digestive-functors",
);

/**
 * Scotty backend for the digestive-functors library
 */
export const digestive_functors_scotty = mkPackage(
  nixRaw`pkgs.haskellPackages.digestive-functors-scotty`,
  "Scotty backend for the digestive-functors library",
);

/**
 * Converts integers to lists of digits and back
 */
export const digits = mkPackage(
  nixRaw`pkgs.haskellPackages.digits`,
  "Converts integers to lists of digits and back",
);

/**
 * Directed Graphs
 */
export const digraph = mkPackage(
  nixRaw`pkgs.haskellPackages.digraph`,
  "Directed Graphs",
);

/**
 * ASCII based Diagram drawing in Haskell (Idea based on ditaa)
 */
export const dihaa = mkPackage(
  nixRaw`pkgs.haskellPackages.dihaa`,
  "ASCII based Diagram drawing in Haskell (Idea based on ditaa)",
);

/**
 * Statically checked physical dimensions
 */
export const dimensional = mkPackage(
  nixRaw`pkgs.haskellPackages.dimensional`,
  "Statically checked physical dimensions",
);

/**
 * CODATA Recommended Physical Constants with Dimensional Types
 */
export const dimensional_codata = mkPackage(
  nixRaw`pkgs.haskellPackages.dimensional-codata`,
  "CODATA Recommended Physical Constants with Dimensional Types",
);

/**
 * Statically checked physical dimensions, implemented using type families
 */
export const dimensional_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.dimensional-tf`,
  "Statically checked physical dimensions, implemented using type families",
);

/**
 * Safe type-level dimensionality for multidimensional data
 */
export const dimensions = mkPackage(
  nixRaw`pkgs.haskellPackages.dimensions`,
  "Safe type-level dimensionality for multidimensional data",
);

/**
 * Dingo is a Rich Internet Application platform based on the Warp web server
 */
export const dingo_core = mkPackage(
  nixRaw`pkgs.haskellPackages.dingo-core`,
  "Dingo is a Rich Internet Application platform based on the Warp web server",
);

/**
 * Dingo Example
 */
export const dingo_example = mkPackage(
  nixRaw`pkgs.haskellPackages.dingo-example`,
  "Dingo Example",
);

/**
 * Dingo Widgets
 */
export const dingo_widgets = mkPackage(
  nixRaw`pkgs.haskellPackages.dingo-widgets`,
  "Dingo Widgets",
);

/**
 * A convenient tagless EDSL
 */
export const dino = mkPackage(
  nixRaw`pkgs.haskellPackages.dino`,
  "A convenient tagless EDSL",
);

/**
 * Gemini client
 */
export const diohsc = mkPackage(
  nixRaw`pkgs.haskellPackages.diohsc`,
  "Gemini client",
);

/**
 * Play Diplomacy over HTTP
 */
export const diplomacy_server = mkPackage(
  nixRaw`pkgs.haskellPackages.diplomacy-server`,
  "Play Diplomacy over HTTP",
);

/**
 * Simple directory traversal library
 */
export const dir_traverse = mkPackage(
  nixRaw`pkgs.haskellPackages.dir-traverse`,
  "Simple directory traversal library",
);

/**
 * Library to switch to daemon mode using built-in OS facilities
 */
export const direct_daemonize = mkPackage(
  nixRaw`pkgs.haskellPackages.direct-daemonize`,
  "Library to switch to daemon mode using built-in OS facilities",
);

/**
 * An implementation of the MurmurHash3 algorithm
 */
export const direct_murmur_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.direct-murmur-hash`,
  "An implementation of the MurmurHash3 algorithm",
);

/**
 * Bindings to RocksDB
 */
export const direct_rocksdb = mkPackage(
  nixRaw`pkgs.haskellPackages.direct-rocksdb`,
  "Bindings to RocksDB",
);

/**
 * Low-level binding to SQLite3. Includes UTF8 and BLOB support.
 */
export const direct_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.direct-sqlite`,
  "Low-level binding to SQLite3. Includes UTF8 and BLOB support.",
);

/**
 * Platform-agnostic library for filesystem operations
 */
export const directory_1_3_7_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.directory_1_3_7_1`,
  "Platform-agnostic library for filesystem operations",
);

/**
 * Platform-agnostic library for filesystem operations
 */
export const directory_1_3_8_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.directory_1_3_8_1`,
  "Platform-agnostic library for filesystem operations",
);

/**
 * Recursively build, navigate, and operate on a tree of directory contents
 */
export const directory_contents = mkPackage(
  nixRaw`pkgs.haskellPackages.directory-contents`,
  "Recursively build, navigate, and operate on a tree of directory contents",
);

/**
 * Directory layout DSL
 */
export const directory_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.directory-layout`,
  "Directory layout DSL",
);

/**
 * directory listing webpage parser
 */
export const directory_listing_webpage_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.directory-listing-webpage-parser`,
  "directory listing webpage parser",
);

/**
 * A simple directory-like tree datatype, with useful IO functions
 */
export const directory_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.directory-tree`,
  "A simple directory-like tree datatype, with useful IO functions",
);

export const dirfiles = mkPackage(
  nixRaw`pkgs.haskellPackages.dirfiles`,
  "",
);

/**
 * Typed directory forest
 */
export const dirforest = mkPackage(
  nixRaw`pkgs.haskellPackages.dirforest`,
  "Typed directory forest",
);

/**
 * Multivariate Dirichlet distribution
 */
export const dirichlet = mkPackage(
  nixRaw`pkgs.haskellPackages.dirichlet`,
  "Multivariate Dirichlet distribution",
);

/**
 * Easily stream directory contents in constant memory
 */
export const dirstream = mkPackage(
  nixRaw`pkgs.haskellPackages.dirstream`,
  "Easily stream directory contents in constant memory",
);

/**
 * A small library for working with directories
 */
export const dirtree = mkPackage(
  nixRaw`pkgs.haskellPackages.dirtree`,
  "A small library for working with directories",
);

/**
 * Disassembler for X86 & AMD64 machine code
 */
export const disassembler = mkPackage(
  nixRaw`pkgs.haskellPackages.disassembler`,
  "Disassembler for X86 & AMD64 machine code",
);

/**
 * Client for Discogs REST API
 */
export const discogs_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.discogs-haskell`,
  "Client for Discogs REST API",
);

/**
 * DisCoCat implementation
 */
export const discokitty = mkPackage(
  nixRaw`pkgs.haskellPackages.discokitty`,
  "DisCoCat implementation",
);

/**
 * An API wrapper for Discord in Haskell
 */
export const discord_gateway = mkPackage(
  nixRaw`pkgs.haskellPackages.discord-gateway`,
  "An API wrapper for Discord in Haskell",
);

/**
 * Write bots for Discord in Haskell
 */
export const discord_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.discord-haskell`,
  "Write bots for Discord in Haskell",
);

/**
 * An API wrapper for Discord in Haskell
 */
export const discord_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.discord-hs`,
  "An API wrapper for Discord in Haskell",
);

/**
 * Discord verification bot
 */
export const discord_register = mkPackage(
  nixRaw`pkgs.haskellPackages.discord-register`,
  "Discord verification bot",
);

/**
 * An API wrapper for Discord in Haskell
 */
export const discord_rest = mkPackage(
  nixRaw`pkgs.haskellPackages.discord-rest`,
  "An API wrapper for Discord in Haskell",
);

/**
 * Haskell bindings to the discount Markdown library
 */
export const discount = mkPackage(
  nixRaw`pkgs.haskellPackages.discount`,
  "Haskell bindings to the discount Markdown library",
);

export const discover_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.discover-instances`,
  "",
);

/**
 * Discrete Intervals
 */
export const discrete_intervals = mkPackage(
  nixRaw`pkgs.haskellPackages.discrete-intervals`,
  "Discrete Intervals",
);

/**
 * A discrete space map
 */
export const discrete_space_map = mkPackage(
  nixRaw`pkgs.haskellPackages.discrete-space-map`,
  "A discrete space map",
);

/**
 * Fast generic linear-time sorting, joins and container construction
 */
export const discrimination = mkPackage(
  nixRaw`pkgs.haskellPackages.discrimination`,
  "Fast generic linear-time sorting, joins and container construction",
);

/**
 * Imperative ST/IO based disjoint set data structure
 */
export const disjoint_sets_st = mkPackage(
  nixRaw`pkgs.haskellPackages.disjoint-sets-st`,
  "Imperative ST/IO based disjoint set data structure",
);

/**
 * On-disk storage, but referentially transparent
 */
export const disk_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.disk-bytes`,
  "On-disk storage, but referentially transparent",
);

/**
 * Retrieve information about disk space usage
 */
export const disk_free_space = mkPackage(
  nixRaw`pkgs.haskellPackages.disk-free-space`,
  "Retrieve information about disk space usage",
);

/**
 * Display things for humans to read
 */
export const display = mkPackage(
  nixRaw`pkgs.haskellPackages.display`,
  "Display things for humans to read",
);

/**
 * A display API for HaskellDO
 */
export const display_haskell_do = mkPackage(
  nixRaw`pkgs.haskellPackages.display-haskell-do`,
  "A display API for HaskellDO",
);

/**
 * Allows storing different resource-releasing actions together
 */
export const disposable = mkPackage(
  nixRaw`pkgs.haskellPackages.disposable`,
  "Allows storing different resource-releasing actions together",
);

/**
 * Generate readable distances between times
 */
export const distance_of_time = mkPackage(
  nixRaw`pkgs.haskellPackages.distance-of-time`,
  "Generate readable distances between times",
);

/**
 * Like 'forkIO', but uses remote machines instead of local threads
 */
export const distributed_fork = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-fork`,
  "Like 'forkIO', but uses remote machines instead of local threads",
);

/**
 * AWS Lambda backend for distributed-fork
 */
export const distributed_fork_aws_lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-fork-aws-lambda`,
  "AWS Lambda backend for distributed-fork",
);

/**
 * Cloud Haskell: Erlang-style concurrency in Haskell
 */
export const distributed_process = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process`,
  "Cloud Haskell: Erlang-style concurrency in Haskell",
);

/**
 * Cloud Haskell Async API
 */
export const distributed_process_async = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-async`,
  "Cloud Haskell Async API",
);

/**
 * Microsoft Azure backend for Cloud Haskell
 */
export const distributed_process_azure = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-azure`,
  "Microsoft Azure backend for Cloud Haskell",
);

/**
 * The Cloud Haskell Application Platform
 */
export const distributed_process_client_server = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-client-server`,
  "The Cloud Haskell Application Platform",
);

/**
 * Collect node stats for EKG
 */
export const distributed_process_ekg = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-ekg`,
  "Collect node stats for EKG",
);

/**
 * Execution Framework for The Cloud Haskell Application Platform
 */
export const distributed_process_execution = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-execution`,
  "Execution Framework for The Cloud Haskell Application Platform",
);

/**
 * Cloud Haskell Extras
 */
export const distributed_process_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-extras`,
  "Cloud Haskell Extras",
);

/**
 * The Cloud Haskell implementation of Erlang/OTP gen_statem
 */
export const distributed_process_fsm = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-fsm`,
  "The Cloud Haskell implementation of Erlang/OTP gen_statem",
);

/**
 * monad-control style typeclass and transformer instances for Process monad
 */
export const distributed_process_lifted = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-lifted`,
  "monad-control style typeclass and transformer instances for Process monad",
);

/**
 * Orphan instances for MonadBase and MonadBaseControl
 */
export const distributed_process_monad_control = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-monad-control`,
  "Orphan instances for MonadBase and MonadBaseControl",
);

/**
 * Peer-to-peer node discovery for Cloud Haskell
 */
export const distributed_process_p2p = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-p2p`,
  "Peer-to-peer node discovery for Cloud Haskell",
);

/**
 * The Cloud Haskell Application Platform
 */
export const distributed_process_platform = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-platform`,
  "The Cloud Haskell Application Platform",
);

/**
 * Cloud Haskell Extended Process Registry
 */
export const distributed_process_registry = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-registry`,
  "Cloud Haskell Extended Process Registry",
);

/**
 * Simple zero-configuration backend for Cloud Haskell
 */
export const distributed_process_simplelocalnet = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-simplelocalnet`,
  "Simple zero-configuration backend for Cloud Haskell",
);

/**
 * Supervisors for The Cloud Haskell Application Platform
 */
export const distributed_process_supervisor = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-supervisor`,
  "Supervisors for The Cloud Haskell Application Platform",
);

/**
 * Cloud Haskell Test Support
 */
export const distributed_process_systest = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-systest`,
  "Cloud Haskell Test Support",
);

/**
 * Task Framework for The Cloud Haskell Application Platform
 */
export const distributed_process_task = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-task`,
  "Task Framework for The Cloud Haskell Application Platform",
);

/**
 * Tests and test support tools for distributed-process
 */
export const distributed_process_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-tests`,
  "Tests and test support tools for distributed-process",
);

/**
 * A Zookeeper back-end for Cloud Haskell
 */
export const distributed_process_zookeeper = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-process-zookeeper`,
  "A Zookeeper back-end for Cloud Haskell",
);

/**
 * Compositional, type-safe, polymorphic static values and closures
 */
export const distributed_static = mkPackage(
  nixRaw`pkgs.haskellPackages.distributed-static`,
  "Compositional, type-safe, polymorphic static values and closures",
);

/**
 * Types and functions to manipulate the Nixpkgs distribution
 */
export const distribution_nixpkgs = mkPackage(
  nixRaw`pkgs.haskellPackages.distribution-nixpkgs`,
  "Types and functions to manipulate the Nixpkgs distribution",
);

/**
 * Types, functions, and tools to manipulate the openSUSE distribution
 */
export const distribution_opensuse = mkPackage(
  nixRaw`pkgs.haskellPackages.distribution-opensuse`,
  "Types, functions, and tools to manipulate the openSUSE distribution",
);

/**
 * Easily plot distributions from the distribution package..
 */
export const distribution_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.distribution-plot`,
  "Easily plot distributions from the distribution package..",
);

/**
 * Distributive functors -- Dual to Traversable
 */
export const distributive = mkPackage(
  nixRaw`pkgs.haskellPackages.distributive`,
  "Distributive functors -- Dual to Traversable",
);

/**
 * ditto is a type-safe HTML form generation and validation library
 */
export const ditto = mkPackage(
  nixRaw`pkgs.haskellPackages.ditto`,
  "ditto is a type-safe HTML form generation and validation library",
);

/**
 * Quantify the diversity of a population
 */
export const diversity = mkPackage(
  nixRaw`pkgs.haskellPackages.diversity`,
  "Quantify the diversity of a population",
);

/**
 * A wiki implemented with a firm theoretical foundation
 */
export const dixi = mkPackage(
  nixRaw`pkgs.haskellPackages.dixi`,
  "A wiki implemented with a firm theoretical foundation",
);

/**
 * Generate Haskell code from a type
 */
export const djinn = mkPackage(
  nixRaw`pkgs.haskellPackages.djinn`,
  "Generate Haskell code from a type",
);

/**
 * Generate Haskell code from a type. Library extracted from djinn package.
 */
export const djinn_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.djinn-lib`,
  "Generate Haskell code from a type. Library extracted from djinn package.",
);

/**
 * Fedora image download tool
 */
export const dl_fedora = mkPackage(
  nixRaw`pkgs.haskellPackages.dl-fedora`,
  "Fedora image download tool",
);

/**
 * Fedora image download tool
 */
export const dl_fedora_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dl-fedora_1_0`,
  "Fedora image download tool",
);

/**
 * Difference lists
 */
export const dlist = mkPackage(
  nixRaw`pkgs.haskellPackages.dlist`,
  "Difference lists",
);

/**
 * Difference lists instances
 */
export const dlist_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.dlist-instances`,
  "Difference lists instances",
);

/**
 * Non-empty difference lists
 */
export const dlist_nonempty = mkPackage(
  nixRaw`pkgs.haskellPackages.dlist-nonempty`,
  "Non-empty difference lists",
);

/**
 * cmd for common cases
 */
export const dmc = mkPackage(
  nixRaw`pkgs.haskellPackages.dmc`,
  "cmd for common cases",
);

/**
 * dmenu script for killing applications. Sortable by process id or CPU/MEM usage.
 */
export const dmenu_pkill = mkPackage(
  nixRaw`pkgs.haskellPackages.dmenu-pkill`,
  "dmenu script for killing applications. Sortable by process id or CPU/MEM usage.",
);

/**
 * Mounting and unmounting linux devices as user with dmenu and pmount
 */
export const dmenu_pmount = mkPackage(
  nixRaw`pkgs.haskellPackages.dmenu-pmount`,
  "Mounting and unmounting linux devices as user with dmenu and pmount",
);

/**
 * dmenu script for searching the web with customizable search engines
 */
export const dmenu_search = mkPackage(
  nixRaw`pkgs.haskellPackages.dmenu-search`,
  "dmenu script for searching the web with customizable search engines",
);

/**
 * DNF wrapper tool to control repos
 */
export const dnf_repo = mkPackage(
  nixRaw`pkgs.haskellPackages.dnf-repo`,
  "DNF wrapper tool to control repos",
);

/**
 * DNS library in Haskell
 */
export const dns = mkPackage(
  nixRaw`pkgs.haskellPackages.dns`,
  "DNS library in Haskell",
);

/**
 * DNS library in Haskell
 */
export const dns_4_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.dns_4_2_0`,
  "DNS library in Haskell",
);

/**
 * Do notation for free
 */
export const do_list = mkPackage(
  nixRaw`pkgs.haskellPackages.do-list`,
  "Do notation for free",
);

/**
 * Generalize do-notation to work on monads and indexed monads simultaneously
 */
export const do_notation = mkPackage(
  nixRaw`pkgs.haskellPackages.do-notation`,
  "Generalize do-notation to work on monads and indexed monads simultaneously",
);

/**
 * Helps to create experimental music from a file (or its part) and a Ukrainian text
 */
export const dobutokO2 = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO2`,
  "Helps to create experimental music from a file (or its part) and a Ukrainian text",
);

/**
 * Helps to create more complex experimental music from a file (especially timbre)
 */
export const dobutokO3 = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO3`,
  "Helps to create more complex experimental music from a file (especially timbre)",
);

/**
 * Helps to create experimental music. Uses SoX inside.
 */
export const dobutokO4 = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO4`,
  "Helps to create experimental music. Uses SoX inside.",
);

/**
 * A library to deal with SoX effects and possibilities
 */
export const dobutokO_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO-effects`,
  "A library to deal with SoX effects and possibilities",
);

/**
 * Helps to create experimental music. Working with frequencies and types.
 */
export const dobutokO_frequency = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO-frequency`,
  "Helps to create experimental music. Working with frequencies and types.",
);

/**
 * Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text
 */
export const dobutokO_poetry = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO-poetry`,
  "Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text",
);

/**
 * Helps to order the 7 or less words (first of all the Ukrainian ones) to obtain somewhat suitable for poetry or music text
 */
export const dobutokO_poetry_general = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO-poetry-general`,
  "Helps to order the 7 or less words (first of all the Ukrainian ones) to obtain somewhat suitable for poetry or music text",
);

/**
 * Helps to order the 7 or less words to obtain somewhat suitable for poetry or music text
 */
export const dobutokO_poetry_general_languages = mkPackage(
  nixRaw`pkgs.haskellPackages.dobutokO-poetry-general-languages`,
  "Helps to order the 7 or less words to obtain somewhat suitable for poetry or music text",
);

/**
 * Document review Web application, like http://book.realworldhaskell.org/
 */
export const doc_review = mkPackage(
  nixRaw`pkgs.haskellPackages.doc-review`,
  "Document review Web application, like http://book.realworldhaskell.org/",
);

/**
 * A Haskell DSL for generating Dockerfiles
 */
export const dockerfile = mkPackage(
  nixRaw`pkgs.haskellPackages.dockerfile`,
  "A Haskell DSL for generating Dockerfiles",
);

/**
 * A prettyprinting library for laying out text documents
 */
export const doclayout = mkPackage(
  nixRaw`pkgs.haskellPackages.doclayout`,
  "A prettyprinting library for laying out text documents",
);

/**
 * Docstrings for documentation in the repl
 */
export const docstrings = mkPackage(
  nixRaw`pkgs.haskellPackages.docstrings`,
  "Docstrings for documentation in the repl",
);

/**
 * Pandoc-style document templates
 */
export const doctemplates = mkPackage(
  nixRaw`pkgs.haskellPackages.doctemplates`,
  "Pandoc-style document templates",
);

/**
 * Test interactive Haskell examples
 */
export const doctest = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest`,
  "Test interactive Haskell examples",
);

/**
 * Test interactive Haskell examples
 */
export const doctest_0_18_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest_0_18_2`,
  "Test interactive Haskell examples",
);

/**
 * Test interactive Haskell examples
 */
export const doctest_0_22_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest_0_22_1`,
  "Test interactive Haskell examples",
);

/**
 * Easy way to run doctests via cabal
 */
export const doctest_discover = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-discover`,
  "Easy way to run doctests via cabal",
);

/**
 * Generate driver file for doctest's cabal integration
 */
export const doctest_driver_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-driver-gen`,
  "Generate driver file for doctest's cabal integration",
);

/**
 * Run doctest's in a Cabal.Test.exitcode-stdio environment
 */
export const doctest_exitcode_stdio = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-exitcode-stdio`,
  "Run doctest's in a Cabal.Test.exitcode-stdio environment",
);

/**
 * Alternative doctest implementation that extracts comments to modules
 */
export const doctest_extract = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-extract`,
  "Alternative doctest implementation that extracts comments to modules",
);

/**
 * Parts of doctest exposed as library
 */
export const doctest_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-lib`,
  "Parts of doctest exposed as library",
);

/**
 * Test interactive Haskell examples
 */
export const doctest_parallel = mkPackage(
  nixRaw`pkgs.haskellPackages.doctest-parallel`,
  "Test interactive Haskell examples",
);

/**
 * Low-level bindings to the DocuSign API
 */
export const docusign_base = mkPackage(
  nixRaw`pkgs.haskellPackages.docusign-base`,
  "Low-level bindings to the DocuSign API",
);

/**
 * Low-level bindings to the DocuSign API (only what is necessary for docusign-client)
 */
export const docusign_base_minimal = mkPackage(
  nixRaw`pkgs.haskellPackages.docusign-base-minimal`,
  "Low-level bindings to the DocuSign API (only what is necessary for docusign-client)",
);

/**
 * Client bindings for the DocuSign API
 */
export const docusign_client = mkPackage(
  nixRaw`pkgs.haskellPackages.docusign-client`,
  "Client bindings for the DocuSign API",
);

/**
 * Automatic Bibtex and fulltext of scientific articles
 */
export const doi = mkPackage(
  nixRaw`pkgs.haskellPackages.doi`,
  "Automatic Bibtex and fulltext of scientific articles",
);

/**
 * Flag packer & handler for flaggable data
 */
export const doldol = mkPackage(
  nixRaw`pkgs.haskellPackages.doldol`,
  "Flag packer & handler for flaggable data",
);

/**
 * A newtype for monetary values
 */
export const dollaridoos = mkPackage(
  nixRaw`pkgs.haskellPackages.dollaridoos`,
  "A newtype for monetary values",
);

/**
 * The Lengauer-Tarjan graph dominators algorithm
 */
export const dom_lt = mkPackage(
  nixRaw`pkgs.haskellPackages.dom-lt`,
  "The Lengauer-Tarjan graph dominators algorithm",
);

/**
 * Codegen helping you define domain models
 */
export const domain = mkPackage(
  nixRaw`pkgs.haskellPackages.domain`,
  "Codegen helping you define domain models",
);

/**
 * Integration of domain with aeson
 */
export const domain_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.domain-aeson`,
  "Integration of domain with aeson",
);

/**
 * Domain authentication library
 */
export const domain_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.domain-auth`,
  "Domain authentication library",
);

/**
 * Integration of domain with cereal
 */
export const domain_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.domain-cereal`,
  "Integration of domain with cereal",
);

/**
 * Low-level API of "domain"
 */
export const domain_core = mkPackage(
  nixRaw`pkgs.haskellPackages.domain-core`,
  "Low-level API of \"domain\"",
);

/**
 * Batteries included event sourcing and CQRS
 */
export const domaindriven = mkPackage(
  nixRaw`pkgs.haskellPackages.domaindriven`,
  "Batteries included event sourcing and CQRS",
);

/**
 * A simulator for the board game Dominion
 */
export const dominion = mkPackage(
  nixRaw`pkgs.haskellPackages.dominion`,
  "A simulator for the board game Dominion",
);

/**
 * Simple, type-safe and testable HTTP client
 */
export const dormouse_client = mkPackage(
  nixRaw`pkgs.haskellPackages.dormouse-client`,
  "Simple, type-safe and testable HTTP client",
);

/**
 * Datatypes and encoding for graphviz dot files
 */
export const dot = mkPackage(
  nixRaw`pkgs.haskellPackages.dot`,
  "Datatypes and encoding for graphviz dot files",
);

/**
 * Converter from GraphViz .dot format to yEd GraphML
 */
export const dot2graphml = mkPackage(
  nixRaw`pkgs.haskellPackages.dot2graphml`,
  "Converter from GraphViz .dot format to yEd GraphML",
);

/**
 * Loads environment variables from dotenv files
 */
export const dotenv = mkPackage(
  nixRaw`pkgs.haskellPackages.dotenv`,
  "Loads environment variables from dotenv files",
);

/**
 * Tiny dotenv library
 */
export const dotenv_micro = mkPackage(
  nixRaw`pkgs.haskellPackages.dotenv-micro`,
  "Tiny dotenv library",
);

/**
 * A simple interface for building .dot graph files.
 */
export const dotgen = mkPackage(
  nixRaw`pkgs.haskellPackages.dotgen`,
  "A simple interface for building .dot graph files.",
);

/**
 * .NET TimeSpan
 */
export const dotnet_timespan = mkPackage(
  nixRaw`pkgs.haskellPackages.dotnet-timespan`,
  ".NET TimeSpan",
);

/**
 * dot language parsing and printing
 */
export const dotparse = mkPackage(
  nixRaw`pkgs.haskellPackages.dotparse`,
  "dot language parsing and printing",
);

/**
 * Fast conversion between single and double precision floating point and text
 */
export const double_conversion = mkPackage(
  nixRaw`pkgs.haskellPackages.double-conversion`,
  "Fast conversion between single and double precision floating point and text",
);

/**
 * Missing presentations for Double numbers (fixed, scientific etc.)
 */
export const double_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.double-extra`,
  "Missing presentations for Double numbers (fixed, scientific etc.)",
);

/**
 * Haskell bindings to a C double-metaphone implementation
 */
export const double_metaphone = mkPackage(
  nixRaw`pkgs.haskellPackages.double-metaphone`,
  "Haskell bindings to a C double-metaphone implementation",
);

/**
 * The Dove verification language
 */
export const dove = mkPackage(
  nixRaw`pkgs.haskellPackages.dove`,
  "The Dove verification language",
);

/**
 * A PureScript interpreter with a Haskell FFI
 */
export const dovetail = mkPackage(
  nixRaw`pkgs.haskellPackages.dovetail`,
  "A PureScript interpreter with a Haskell FFI",
);

/**
 * Use Aeson from your Dovetail programs
 */
export const dovetail_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.dovetail-aeson`,
  "Use Aeson from your Dovetail programs",
);

/**
 * A proof assistant for Magic: The Gathering puzzles
 */
export const dovin = mkPackage(
  nixRaw`pkgs.haskellPackages.dovin`,
  "A proof assistant for Magic: The Gathering puzzles",
);

/**
 * Dungeons of Wor
 */
export const dow = mkPackage(
  nixRaw`pkgs.haskellPackages.dow`,
  "Dungeons of Wor",
);

/**
 * Reverse mode automatic differentiation
 */
export const downhill = mkPackage(
  nixRaw`pkgs.haskellPackages.downhill`,
  "Reverse mode automatic differentiation",
);

/**
 * High-level file download based on URLs
 */
export const download = mkPackage(
  nixRaw`pkgs.haskellPackages.download`,
  "High-level file download based on URLs",
);

/**
 * High-level file download based on URLs
 */
export const download_curl = mkPackage(
  nixRaw`pkgs.haskellPackages.download-curl`,
  "High-level file download based on URLs",
);

/**
 * Simple tool to download images from RSS feeds (e.g. Flickr, Picasa)
 */
export const download_media_content = mkPackage(
  nixRaw`pkgs.haskellPackages.download-media-content`,
  "Simple tool to download images from RSS feeds (e.g. Flickr, Picasa)",
);

/**
 * Data Parallel Haskell example programs
 */
export const dph_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-examples`,
  "Data Parallel Haskell example programs",
);

/**
 * Data Parallel Haskell common definitions used by other dph-lifted packages
 */
export const dph_lifted_base = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-lifted-base`,
  "Data Parallel Haskell common definitions used by other dph-lifted packages",
);

/**
 * Data Parallel Haskell lifted array combinators. (deprecated version)
 */
export const dph_lifted_copy = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-lifted-copy`,
  "Data Parallel Haskell lifted array combinators. (deprecated version)",
);

/**
 * Data Parallel Haskell lifted array combinators
 */
export const dph_lifted_vseg = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-lifted-vseg`,
  "Data Parallel Haskell lifted array combinators",
);

/**
 * (deprecated)
 */
export const dph_par = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-par`,
  "(deprecated)",
);

/**
 * Data Parallel Haskell segmented arrays. (abstract interface)
 */
export const dph_prim_interface = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-prim-interface`,
  "Data Parallel Haskell segmented arrays. (abstract interface)",
);

/**
 * Data Parallel Haskell segmented arrays. (production version)
 */
export const dph_prim_par = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-prim-par`,
  "Data Parallel Haskell segmented arrays. (production version)",
);

/**
 * Data Parallel Haskell segmented arrays. (sequential implementation)
 */
export const dph_prim_seq = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-prim-seq`,
  "Data Parallel Haskell segmented arrays. (sequential implementation)",
);

/**
 * (deprecated)
 */
export const dph_seq = mkPackage(
  nixRaw`pkgs.haskellPackages.dph-seq`,
  "(deprecated)",
);

/**
 * a lightweight DNS proxy server, compatible with dnsmasq-china-list
 */
export const dprox = mkPackage(
  nixRaw`pkgs.haskellPackages.dprox`,
  "a lightweight DNS proxy server, compatible with dnsmasq-china-list",
);

/**
 * Actor library for Haskell
 */
export const drama = mkPackage(
  nixRaw`pkgs.haskellPackages.drama`,
  "Actor library for Haskell",
);

/**
 * playing draw poker
 */
export const draw_poker = mkPackage(
  nixRaw`pkgs.haskellPackages.draw-poker`,
  "playing draw poker",
);

/**
 * Simple schema management for arbitrary databases
 */
export const drifter = mkPackage(
  nixRaw`pkgs.haskellPackages.drifter`,
  "Simple schema management for arbitrary databases",
);

/**
 * SQLite support for the drifter schema migraiton tool
 */
export const drifter_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.drifter-sqlite`,
  "SQLite support for the drifter schema migraiton tool",
);

/**
 * Boozy streaming library
 */
export const drinkery = mkPackage(
  nixRaw`pkgs.haskellPackages.drinkery`,
  "Boozy streaming library",
);

/**
 * Deriving without spelling out "deriving"
 */
export const driving_classes_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.driving-classes-plugin`,
  "Deriving without spelling out \"deriving\"",
);

/**
 * A library to access the Dropbox HTTP API
 */
export const dropbox_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.dropbox-sdk`,
  "A library to access the Dropbox HTTP API",
);

/**
 * A command line tool for resolving dropbox conflicts. Deprecated! Please use confsolve.
 */
export const dropsolve = mkPackage(
  nixRaw`pkgs.haskellPackages.dropsolve`,
  "A command line tool for resolving dropbox conflicts. Deprecated! Please use confsolve.",
);

/**
 * An implementation of the Drunken Bishop visual fingerprinting algorithm
 */
export const drunken_bishop = mkPackage(
  nixRaw`pkgs.haskellPackages.drunken-bishop`,
  "An implementation of the Drunken Bishop visual fingerprinting algorithm",
);

/**
 * SQL backend for Database Supported Haskell (DSH)
 */
export const dsh_sql = mkPackage(
  nixRaw`pkgs.haskellPackages.dsh-sql`,
  "SQL backend for Database Supported Haskell (DSH)",
);

/**
 * DSMC library for rarefied gas dynamics
 */
export const dsmc = mkPackage(
  nixRaw`pkgs.haskellPackages.dsmc`,
  "DSMC library for rarefied gas dynamics",
);

/**
 * DSMC toolkit for rarefied gas dynamics
 */
export const dsmc_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.dsmc-tools`,
  "DSMC toolkit for rarefied gas dynamics",
);

/**
 * Haskell Digital Signal Processing
 */
export const dsp = mkPackage(
  nixRaw`pkgs.haskellPackages.dsp`,
  "Haskell Digital Signal Processing",
);

/**
 * Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library
 */
export const dtab = mkPackage(
  nixRaw`pkgs.haskellPackages.dtab`,
  "Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library",
);

/**
 * Parse and render DTD files (deprecated)
 */
export const dtd = mkPackage(
  nixRaw`pkgs.haskellPackages.dtd`,
  "Parse and render DTD files (deprecated)",
);

/**
 * Basic types for representing XML DTDs
 */
export const dtd_types = mkPackage(
  nixRaw`pkgs.haskellPackages.dtd-types`,
  "Basic types for representing XML DTDs",
);

/**
 * Haskell interface to the DTrace system tracing utility
 */
export const dtrace = mkPackage(
  nixRaw`pkgs.haskellPackages.dtrace`,
  "Haskell interface to the DTrace system tracing utility",
);

/**
 * Dual category
 */
export const dual = mkPackage(
  nixRaw`pkgs.haskellPackages.dual`,
  "Dual category",
);

/**
 * Rose trees with cached and accumulating monoidal annotations
 */
export const dual_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.dual-tree`,
  "Rose trees with cached and accumulating monoidal annotations",
);

/**
 * XML streaming parser/renderer for the Dublin Core standard elements
 */
export const dublincore_xml_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.dublincore-xml-conduit`,
  "XML streaming parser/renderer for the Dublin Core standard elements",
);

/**
 * A computer algebra system that knows nothing about algebra, at the core
 */
export const dumb_cas = mkPackage(
  nixRaw`pkgs.haskellPackages.dumb-cas`,
  "A computer algebra system that knows nothing about algebra, at the core",
);

/**
 * Dumps the names and values of expressions to ease debugging
 */
export const dump = mkPackage(
  nixRaw`pkgs.haskellPackages.dump`,
  "Dumps the names and values of expressions to ease debugging",
);

/**
 * Generalised reactive framework supporting classic, arrowized and monadic FRP
 */
export const dunai = mkPackage(
  nixRaw`pkgs.haskellPackages.dunai`,
  "Generalised reactive framework supporting classic, arrowized and monadic FRP",
);

/**
 * Testing library for Dunai
 */
export const dunai_test = mkPackage(
  nixRaw`pkgs.haskellPackages.dunai-test`,
  "Testing library for Dunai",
);

/**
 * Initial project template from stack
 */
export const dustme = mkPackage(
  nixRaw`pkgs.haskellPackages.dustme`,
  "Initial project template from stack",
);

/**
 * Efficient automatic differentiation and code generation
 */
export const dvda = mkPackage(
  nixRaw`pkgs.haskellPackages.dvda`,
  "Efficient automatic differentiation and code generation",
);

/**
 * Dvorak encoding for Haskell
 */
export const dvorak = mkPackage(
  nixRaw`pkgs.haskellPackages.dvorak`,
  "Dvorak encoding for Haskell",
);

/**
 * Parser for DWARF debug format
 */
export const dwarf_el = mkPackage(
  nixRaw`pkgs.haskellPackages.dwarf-el`,
  "Parser for DWARF debug format",
);

/**
 * A minimal testing library
 */
export const dwergaz = mkPackage(
  nixRaw`pkgs.haskellPackages.dwergaz`,
  "A minimal testing library",
);

/**
 * Backend for a binding to the Microsoft DirectX 9 API
 */
export const dx9base = mkPackage(
  nixRaw`pkgs.haskellPackages.dx9base`,
  "Backend for a binding to the Microsoft DirectX 9 API",
);

/**
 * A binding to the Microsoft DirectX 9 API
 */
export const dx9d3d = mkPackage(
  nixRaw`pkgs.haskellPackages.dx9d3d`,
  "A binding to the Microsoft DirectX 9 API",
);

/**
 * A binding to the Microsoft DirectX 9 D3DX API
 */
export const dx9d3dx = mkPackage(
  nixRaw`pkgs.haskellPackages.dx9d3dx`,
  "A binding to the Microsoft DirectX 9 D3DX API",
);

/**
 * Programatically identify space leaks in your program
 */
export const dyepack = mkPackage(
  nixRaw`pkgs.haskellPackages.dyepack`,
  "Programatically identify space leaks in your program",
);

/**
 * Minimal FRP library
 */
export const dyna = mkPackage(
  nixRaw`pkgs.haskellPackages.dyna`,
  "Minimal FRP library",
);

/**
 * FRP for gloss graphics and animation library
 */
export const dyna_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.dyna-gloss`,
  "FRP for gloss graphics and animation library",
);

/**
 * A dynamic type for Haskell
 */
export const dynamic = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic`,
  "A dynamic type for Haskell",
);

/**
 * Access the functions from the Cabal library without depending on it
 */
export const dynamic_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-cabal`,
  "Access the functions from the Cabal library without depending on it",
);

/**
 * Draw and update graphs in real time with OpenGL
 */
export const dynamic_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-graph`,
  "Draw and update graphs in real time with OpenGL",
);

/**
 * Automatically derive dynamic linking methods from a data type
 */
export const dynamic_linker_template = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-linker-template`,
  "Automatically derive dynamic linking methods from a data type",
);

/**
 * lightweight loader of GHC-based modules or packages
 */
export const dynamic_loader = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-loader`,
  "lightweight loader of GHC-based modules or packages",
);

/**
 * Library Type Safe implementation of Dynamic Pipeline Paradigm (DPP)
 */
export const dynamic_pipeline = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-pipeline`,
  "Library Type Safe implementation of Dynamic Pipeline Paradigm (DPP)",
);

/**
 * Interactive diagram windows
 */
export const dynamic_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-plot`,
  "Interactive diagram windows",
);

/**
 * A pretty-print library that employs a dynamic programming algorithm for optimal rendering
 */
export const dynamic_pp = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-pp`,
  "A pretty-print library that employs a dynamic programming algorithm for optimal rendering",
);

/**
 * Optionally serializable dynamic state keyed by type
 */
export const dynamic_state = mkPackage(
  nixRaw`pkgs.haskellPackages.dynamic-state`,
  "Optionally serializable dynamic state keyed by type",
);

/**
 * your dynamic optimization buddy
 */
export const dynobud = mkPackage(
  nixRaw`pkgs.haskellPackages.dynobud`,
  "your dynamic optimization buddy",
);

/**
 * Dynamic reconfiguration in Haskell
 */
export const dyre = mkPackage(
  nixRaw`pkgs.haskellPackages.dyre`,
  "Dynamic reconfiguration in Haskell",
);

/**
 * Extensible Authentication Protocol (EAP)
 */
export const eap = mkPackage(
  nixRaw`pkgs.haskellPackages.eap`,
  "Extensible Authentication Protocol (EAP)",
);

/**
 * Robert Penner's easing equations
 */
export const ease = mkPackage(
  nixRaw`pkgs.haskellPackages.ease`,
  "Robert Penner's easing equations",
);

/**
 * Cross-platform File handling
 */
export const easy_file = mkPackage(
  nixRaw`pkgs.haskellPackages.easy-file`,
  "Cross-platform File handling",
);

/**
 * Logging made easy
 */
export const easy_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.easy-logger`,
  "Logging made easy",
);

/**
 * User-friendly creation of EPS, PostScript, and PDF files
 */
export const easyrender = mkPackage(
  nixRaw`pkgs.haskellPackages.easyrender`,
  "User-friendly creation of EPS, PostScript, and PDF files",
);

/**
 * Pure, type-indexed haskell vector, matrix, and tensor library
 */
export const easytensor = mkPackage(
  nixRaw`pkgs.haskellPackages.easytensor`,
  "Pure, type-indexed haskell vector, matrix, and tensor library",
);

/**
 * Use easytensor with vulkan-api
 */
export const easytensor_vulkan = mkPackage(
  nixRaw`pkgs.haskellPackages.easytensor-vulkan`,
  "Use easytensor with vulkan-api",
);

/**
 * A Haskell description of the eBird API
 */
export const ebird_api = mkPackage(
  nixRaw`pkgs.haskellPackages.ebird-api`,
  "A Haskell description of the eBird API",
);

/**
 * A command-line utility for interacting with the eBird API
 */
export const ebird_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.ebird-cli`,
  "A command-line utility for interacting with the eBird API",
);

/**
 * Client functions for querying the eBird API
 */
export const ebird_client = mkPackage(
  nixRaw`pkgs.haskellPackages.ebird-client`,
  "Client functions for querying the eBird API",
);

/**
 * A pure EBML parser
 */
export const ebml = mkPackage(
  nixRaw`pkgs.haskellPackages.ebml`,
  "A pure EBML parser",
);

/**
 * The Amazon EC2 style signature calculator
 */
export const ec2_signature = mkPackage(
  nixRaw`pkgs.haskellPackages.ec2-signature`,
  "The Amazon EC2 style signature calculator",
);

/**
 * Elliptic Curve Cryptography for Haskell
 */
export const eccrypto = mkPackage(
  nixRaw`pkgs.haskellPackages.eccrypto`,
  "Elliptic Curve Cryptography for Haskell",
);

/**
 * Basic ECDSA signing implementation
 */
export const ecdsa = mkPackage(
  nixRaw`pkgs.haskellPackages.ecdsa`,
  "Basic ECDSA signing implementation",
);

/**
 * A cross-platform, cross-console way to handle echoing terminal input
 */
export const echo = mkPackage(
  nixRaw`pkgs.haskellPackages.echo`,
  "A cross-platform, cross-console way to handle echoing terminal input",
);

/**
 * A GHC.Generics based entity component system.
 */
export const ecstasy = mkPackage(
  nixRaw`pkgs.haskellPackages.ecstasy`,
  "A GHC.Generics based entity component system.",
);

export const ecta = mkPackage(
  nixRaw`pkgs.haskellPackages.ecta`,
  "",
);

/**
 * Ed25519 cryptographic signatures
 */
export const ed25519 = mkPackage(
  nixRaw`pkgs.haskellPackages.ed25519`,
  "Ed25519 cryptographic signatures",
);

/**
 * Haskell bindings to ed25519-donna (Elliptical Curve Signature Scheme)
 */
export const ed25519_donna = mkPackage(
  nixRaw`pkgs.haskellPackages.ed25519-donna`,
  "Haskell bindings to ed25519-donna (Elliptical Curve Signature Scheme)",
);

/**
 * Semi-explicit parallel programming skeleton library
 */
export const edenskel = mkPackage(
  nixRaw`pkgs.haskellPackages.edenskel`,
  "Semi-explicit parallel programming skeleton library",
);

/**
 * A Tool to Visualize Parallel Functional Program Executions
 */
export const edentv = mkPackage(
  nixRaw`pkgs.haskellPackages.edentv`,
  "A Tool to Visualize Parallel Functional Program Executions",
);

/**
 * Top view space combat arcade game
 */
export const edge = mkPackage(
  nixRaw`pkgs.haskellPackages.edge`,
  "Top view space combat arcade game",
);

/**
 * Tools for efficient immutable graphs
 */
export const edges = mkPackage(
  nixRaw`pkgs.haskellPackages.edges`,
  "Tools for efficient immutable graphs",
);

/**
 * Levenshtein and restricted Damerau-Levenshtein edit distances
 */
export const edit_distance = mkPackage(
  nixRaw`pkgs.haskellPackages.edit-distance`,
  "Levenshtein and restricted Damerau-Levenshtein edit distances",
);

/**
 * Efficient implementation of the Levenshtein edit distance in linear memory
 */
export const edit_distance_linear = mkPackage(
  nixRaw`pkgs.haskellPackages.edit-distance-linear`,
  "Efficient implementation of the Levenshtein edit distance in linear memory",
);

/**
 * Calculate edit distances and edit scripts between vectors
 */
export const edit_distance_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.edit-distance-vector`,
  "Calculate edit distances and edit scripts between vectors",
);

/**
 * Programs demoing the use of symmetric, stateful edit lenses
 */
export const edit_lenses_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.edit-lenses-demo`,
  "Programs demoing the use of symmetric, stateful edit lenses",
);

/**
 * Interactive editors for Generics
 */
export const editable = mkPackage(
  nixRaw`pkgs.haskellPackages.editable`,
  "Interactive editors for Generics",
);

/**
 * Open the user's $VISUAL or $EDITOR for text input
 */
export const editor_open = mkPackage(
  nixRaw`pkgs.haskellPackages.editor-open`,
  "Open the user's $VISUAL or $EDITOR for text input",
);

/**
 * Edit stdin using an editor before sending to stdout
 */
export const editpipe = mkPackage(
  nixRaw`pkgs.haskellPackages.editpipe`,
  "Edit stdin using an editor before sending to stdout",
);

/**
 * show the differences between 2 pieces of Text using the Levenshtein distance
 */
export const edits = mkPackage(
  nixRaw`pkgs.haskellPackages.edits`,
  "show the differences between 2 pieces of Text using the Levenshtein distance",
);

/**
 * Embeds effect systems and program logics into Haskell using graded monads and parameterised monads
 */
export const effect_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.effect-monad`,
  "Embeds effect systems and program logics into Haskell using graded monads and parameterised monads",
);

/**
 * An easy to use, performant extensible effects library
 */
export const effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful`,
  "An easy to use, performant extensible effects library",
);

/**
 * An easy to use, performant extensible effects library
 */
export const effectful_2_3_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful_2_3_0_0`,
  "An easy to use, performant extensible effects library",
);

/**
 * An easy to use, performant extensible effects library
 */
export const effectful_core = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful-core`,
  "An easy to use, performant extensible effects library",
);

/**
 * An easy to use, performant extensible effects library
 */
export const effectful_core_2_3_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful-core_2_3_0_0`,
  "An easy to use, performant extensible effects library",
);

/**
 * A GHC plugin for improving disambiguation of effects
 */
export const effectful_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful-plugin`,
  "A GHC plugin for improving disambiguation of effects",
);

/**
 * Template Haskell utilities for the effectful library
 */
export const effectful_th = mkPackage(
  nixRaw`pkgs.haskellPackages.effectful-th`,
  "Template Haskell utilities for the effectful library",
);

/**
 * A monadic embedding of aspect oriented programming, using "Monads, Zippers and Views" instead of mtl
 */
export const effective_aspects_mzv = mkPackage(
  nixRaw`pkgs.haskellPackages.effective-aspects-mzv`,
  "A monadic embedding of aspect oriented programming, using \"Monads, Zippers and Views\" instead of mtl",
);

/**
 * Computational Effects
 */
export const effects = mkPackage(
  nixRaw`pkgs.haskellPackages.effects`,
  "Computational Effects",
);

/**
 * Parser Effect for the Control.Effects Library
 */
export const effects_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.effects-parser`,
  "Parser Effect for the Control.Effects Library",
);

/**
 * Simulation interpreter for FLINT policy descriptions
 */
export const eflint = mkPackage(
  nixRaw`pkgs.haskellPackages.eflint`,
  "Simulation interpreter for FLINT policy descriptions",
);

/**
 * Programming language with non-linear pattern-matching against non-free data
 */
export const egison = mkPackage(
  nixRaw`pkgs.haskellPackages.egison`,
  "Programming language with non-linear pattern-matching against non-free data",
);

/**
 * Parser and pretty printer for Egison pattern expressions in Haskell source code
 */
export const egison_pattern_src_haskell_mode = mkPackage(
  nixRaw`pkgs.haskellPackages.egison-pattern-src-haskell-mode`,
  "Parser and pretty printer for Egison pattern expressions in Haskell source code",
);

/**
 * Parser and pretty printer for Egison pattern expressions to use with TH
 */
export const egison_pattern_src_th_mode = mkPackage(
  nixRaw`pkgs.haskellPackages.egison-pattern-src-th-mode`,
  "Parser and pretty printer for Egison pattern expressions to use with TH",
);

/**
 * A quasi quotes for using Egison expression in Haskell code
 */
export const egison_quote = mkPackage(
  nixRaw`pkgs.haskellPackages.egison-quote`,
  "A quasi quotes for using Egison expression in Haskell code",
);

/**
 * A tutorial program for the Egison programming language
 */
export const egison_tutorial = mkPackage(
  nixRaw`pkgs.haskellPackages.egison-tutorial`,
  "A tutorial program for the Egison programming language",
);

/**
 * Egyptian fractions in Haskell
 */
export const egyptian_fractions = mkPackage(
  nixRaw`pkgs.haskellPackages.egyptian-fractions`,
  "Egyptian fractions in Haskell",
);

/**
 * Minimalistic SMTP client for Haskell
 */
export const ehlo = mkPackage(
  nixRaw`pkgs.haskellPackages.ehlo`,
  "Minimalistic SMTP client for Haskell",
);

/**
 * Combinators for working with sums
 */
export const either = mkPackage(
  nixRaw`pkgs.haskellPackages.either`,
  "Combinators for working with sums",
);

/**
 * Either or both
 */
export const either_both = mkPackage(
  nixRaw`pkgs.haskellPackages.either-both`,
  "Either or both",
);

/**
 * Functions involving lists of Either
 */
export const either_list_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.either-list-functions`,
  "Functions involving lists of Either",
);

/**
 * The simplest MonadFail instance
 */
export const either_result = mkPackage(
  nixRaw`pkgs.haskellPackages.either-result`,
  "The simplest MonadFail instance",
);

/**
 * None
 */
export const eithers = mkPackage(
  nixRaw`pkgs.haskellPackages.eithers`,
  "None",
);

/**
 * Remote monitoring of processes
 */
export const ekg = mkPackage(
  nixRaw`pkgs.haskellPackages.ekg`,
  "Remote monitoring of processes",
);

/**
 * An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)
 */
export const ekg_carbon = mkPackage(
  nixRaw`pkgs.haskellPackages.ekg-carbon`,
  "An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)",
);

/**
 * Tracking of system metrics
 */
export const ekg_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ekg-core`,
  "Tracking of system metrics",
);

/**
 * An EKG backend to send statistics to influxdb
 */
export const ekg_influxdb = mkPackage(
  nixRaw`pkgs.haskellPackages.ekg-influxdb`,
  "An EKG backend to send statistics to influxdb",
);

/**
 * Remote monitoring of processes
 */
export const ekg_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.ekg-wai`,
  "Remote monitoring of processes",
);

/**
 * Serialization of Elasticsearch requests and responses
 */
export const elasticsearch_interchange = mkPackage(
  nixRaw`pkgs.haskellPackages.elasticsearch-interchange`,
  "Serialization of Elasticsearch requests and responses",
);

/**
 * Find the elbow point
 */
export const elbow = mkPackage(
  nixRaw`pkgs.haskellPackages.elbow`,
  "Find the elbow point",
);

/**
 * Electrs client library for Haskell
 */
export const electrs_client = mkPackage(
  nixRaw`pkgs.haskellPackages.electrs-client`,
  "Electrs client library for Haskell",
);

/**
 * easy to remember mnemonic for a high-entropy value
 */
export const electrum_mnemonic = mkPackage(
  nixRaw`pkgs.haskellPackages.electrum-mnemonic`,
  "easy to remember mnemonic for a high-entropy value",
);

/**
 * make tree from a list
 */
export const elenco_albero = mkPackage(
  nixRaw`pkgs.haskellPackages.elenco-albero`,
  "make tree from a list",
);

/**
 * A minimalistic FRP library
 */
export const elerea = mkPackage(
  nixRaw`pkgs.haskellPackages.elerea`,
  "A minimalistic FRP library",
);

/**
 * Example applications for Elerea
 */
export const elerea_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.elerea-examples`,
  "Example applications for Elerea",
);

/**
 * Elerea FRP wrapper for SDL
 */
export const elerea_sdl = mkPackage(
  nixRaw`pkgs.haskellPackages.elerea-sdl`,
  "Elerea FRP wrapper for SDL",
);

/**
 * An Elf parser
 */
export const elf = mkPackage(
  nixRaw`pkgs.haskellPackages.elf`,
  "An Elf parser",
);

/**
 * Dependently typed elimination functions using singletons
 */
export const eliminators = mkPackage(
  nixRaw`pkgs.haskellPackages.eliminators`,
  "Dependently typed elimination functions using singletons",
);

/**
 * Dependently typed elimination functions using singletons
 */
export const eliminators_0_9_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.eliminators_0_9_3`,
  "Dependently typed elimination functions using singletons",
);

/**
 * Elliptic curve library
 */
export const elliptic_curve = mkPackage(
  nixRaw`pkgs.haskellPackages.elliptic-curve`,
  "Elliptic curve library",
);

/**
 * Carlson Elliptic Integrals and Incomplete Elliptic Integrals
 */
export const elliptic_integrals = mkPackage(
  nixRaw`pkgs.haskellPackages.elliptic-integrals`,
  "Carlson Elliptic Integrals and Incomplete Elliptic Integrals",
);

/**
 * Turn your Elm project into buildable Nix project
 */
export const elm2nix = mkPackage(
  nixRaw`pkgs.haskellPackages.elm2nix`,
  "Turn your Elm project into buildable Nix project",
);

/**
 * Derive Elm types and Json code from Haskell types, using aeson's options
 */
export const elm_bridge = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-bridge`,
  "Derive Elm types and Json code from Haskell types, using aeson's options",
);

/**
 * Source files for the Elm runtime and standard libraries
 */
export const elm_core_sources = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-core-sources`,
  "Source files for the Elm runtime and standard libraries",
);

/**
 * A library to generate Elm types from Haskell source
 */
export const elm_export = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-export`,
  "A library to generate Elm types from Haskell source",
);

/**
 * Combine Elm with Haskell for data based applications
 */
export const elm_hybrid = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-hybrid`,
  "Combine Elm with Haskell for data based applications",
);

/**
 * Set up basic structure for an elm project
 */
export const elm_init = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-init`,
  "Set up basic structure for an elm project",
);

/**
 * Crossing the road between Haskell and Elm
 */
export const elm_street = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-street`,
  "Crossing the road between Haskell and Elm",
);

/**
 * Elm syntax and pretty-printing
 */
export const elm_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.elm-syntax`,
  "Elm syntax and pretty-printing",
);

/**
 * Generate ELM types/encoders/decoders from Haskell types
 */
export const elminator = mkPackage(
  nixRaw`pkgs.haskellPackages.elminator`,
  "Generate ELM types/encoders/decoders from Haskell types",
);

/**
 * Elo Rating Library
 */
export const elo = mkPackage(
  nixRaw`pkgs.haskellPackages.elo`,
  "Elo Rating Library",
);

/**
 * A tiny language for understanding the lambda-calculus
 */
export const elsa = mkPackage(
  nixRaw`pkgs.haskellPackages.elsa`,
  "A tiny language for understanding the lambda-calculus",
);

/**
 * Validate and (optionally) redo ELynx analyses
 */
export const elynx = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx`,
  "Validate and (optionally) redo ELynx analyses",
);

/**
 * Simulate molecular sequences along trees
 */
export const elynx_markov = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-markov`,
  "Simulate molecular sequences along trees",
);

/**
 * Import and export Nexus files
 */
export const elynx_nexus = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-nexus`,
  "Import and export Nexus files",
);

/**
 * Handle molecular sequences
 */
export const elynx_seq = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-seq`,
  "Handle molecular sequences",
);

/**
 * Tools for ELynx
 */
export const elynx_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-tools`,
  "Tools for ELynx",
);

/**
 * Tools for ELynx
 */
export const elynx_tools_0_7_2_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-tools_0_7_2_2`,
  "Tools for ELynx",
);

/**
 * Handle phylogenetic trees
 */
export const elynx_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.elynx-tree`,
  "Handle phylogenetic trees",
);

/**
 * Static site generator library with hot reload
 */
export const ema = mkPackage(
  nixRaw`pkgs.haskellPackages.ema`,
  "Static site generator library with hot reload",
);

/**
 * Useful route types for Ema
 */
export const ema_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ema-extra`,
  "Useful route types for Ema",
);

/**
 * library to parse emacs style keybinding into the modifiers and the chars
 */
export const emacs_keys = mkPackage(
  nixRaw`pkgs.haskellPackages.emacs-keys`,
  "library to parse emacs style keybinding into the modifiers and the chars",
);

/**
 * Utilities to write Emacs dynamic modules
 */
export const emacs_module = mkPackage(
  nixRaw`pkgs.haskellPackages.emacs-module`,
  "Utilities to write Emacs dynamic modules",
);

/**
 * Utilities to write Emacs dynamic modules
 */
export const emacs_module_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.emacs-module_0_2`,
  "Utilities to write Emacs dynamic modules",
);

/**
 * Sending eMail in Haskell made easy
 */
export const email = mkPackage(
  nixRaw`pkgs.haskellPackages.email`,
  "Sending eMail in Haskell made easy",
);

/**
 * Email address validation
 */
export const email_validate = mkPackage(
  nixRaw`pkgs.haskellPackages.email-validate`,
  "Email address validation",
);

/**
 * Aeson instances for email-validate
 */
export const email_validate_json = mkPackage(
  nixRaw`pkgs.haskellPackages.email-validate-json`,
  "Aeson instances for email-validate",
);

/**
 * Perform basic syntax and deliverability checks on email addresses
 */
export const email_validator = mkPackage(
  nixRaw`pkgs.haskellPackages.email-validator`,
  "Perform basic syntax and deliverability checks on email addresses",
);

/**
 * An email parser that will parse everything
 */
export const emailparse = mkPackage(
  nixRaw`pkgs.haskellPackages.emailparse`,
  "An email parser that will parse everything",
);

/**
 * Emanate a structured view of your plain-text notes
 */
export const emanote = mkPackage(
  nixRaw`pkgs.haskellPackages.emanote`,
  "Emanate a structured view of your plain-text notes",
);

/**
 * Embed the values in scope in the haddock documentation of the module
 */
export const embeddock = mkPackage(
  nixRaw`pkgs.haskellPackages.embeddock`,
  "Embed the values in scope in the haddock documentation of the module",
);

/**
 * Example of using embeddock
 */
export const embeddock_example = mkPackage(
  nixRaw`pkgs.haskellPackages.embeddock-example`,
  "Example of using embeddock",
);

/**
 * support for embroidery formats in haskell
 */
export const embroidery = mkPackage(
  nixRaw`pkgs.haskellPackages.embroidery`,
  "support for embroidery formats in haskell",
);

/**
 * Empirical Mode Decomposition and Hilbert-Huang Transform
 */
export const emd = mkPackage(
  nixRaw`pkgs.haskellPackages.emd`,
  "Empirical Mode Decomposition and Hilbert-Huang Transform",
);

/**
 * emoji utility
 */
export const emoji = mkPackage(
  nixRaw`pkgs.haskellPackages.emoji`,
  "emoji utility",
);

/**
 * Conversion between emoji characters and their names
 */
export const emojis = mkPackage(
  nixRaw`pkgs.haskellPackages.emojis`,
  "Conversion between emoji characters and their names",
);

/**
 * Ceci n'est pas une package
 */
export const empty = mkPackage(
  nixRaw`pkgs.haskellPackages.empty`,
  "Ceci n'est pas une package",
);

/**
 * Catching all exceptions from within an enclosed computation
 */
export const enclosed_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.enclosed-exceptions`,
  "Catching all exceptions from within an enclosed computation",
);

/**
 * An English language stemmer (Porter2)
 */
export const eng_stemmer = mkPackage(
  nixRaw`pkgs.haskellPackages.eng-stemmer`,
  "An English language stemmer (Porter2)",
);

export const engine_io_growler = mkPackage(
  nixRaw`pkgs.haskellPackages.engine-io-growler`,
  "",
);

export const engine_io_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.engine-io-snap`,
  "",
);

/**
 * An @engine-io@ @ServerAPI@ that is compatible with @Wai@
 */
export const engine_io_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.engine-io-wai`,
  "An @engine-io@ @ServerAPI@ that is compatible with @Wai@",
);

export const engine_io_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.engine-io-yesod`,
  "",
);

/**
 * A numeric type for managing and automating engineering units
 */
export const engineering_units = mkPackage(
  nixRaw`pkgs.haskellPackages.engineering-units`,
  "A numeric type for managing and automating engineering units",
);

/**
 * An application (and library) to convert quipper circuits into Qpmc models
 */
export const entangle = mkPackage(
  nixRaw`pkgs.haskellPackages.entangle`,
  "An application (and library) to convert quipper circuits into Qpmc models",
);

/**
 * A platform independent entropy source
 */
export const entropy = mkPackage(
  nixRaw`pkgs.haskellPackages.entropy`,
  "A platform independent entropy source",
);

/**
 * Generate an ADT being a subset of another ADT, and the corresponding mappings
 */
export const enum_subset_generate = mkPackage(
  nixRaw`pkgs.haskellPackages.enum-subset-generate`,
  "Generate an ADT being a subset of another ADT, and the corresponding mappings",
);

/**
 * Making fmt available with rio
 */
export const enum_text_rio = mkPackage(
  nixRaw`pkgs.haskellPackages.enum-text-rio`,
  "Making fmt available with rio",
);

/**
 * small enum types
 */
export const enum_types = mkPackage(
  nixRaw`pkgs.haskellPackages.enum-types`,
  "small enum types",
);

/**
 * A typeclass for enumerating all values a type
 */
export const enumerable = mkPackage(
  nixRaw`pkgs.haskellPackages.enumerable`,
  "A typeclass for enumerating all values a type",
);

/**
 * enumerate all the values in a finite type (automatically)
 */
export const enumerate = mkPackage(
  nixRaw`pkgs.haskellPackages.enumerate`,
  "enumerate all the values in a finite type (automatically)",
);

/**
 * simple package for inverting functions and testing totality, via brute enumeration of the domain
 */
export const enumerate_function = mkPackage(
  nixRaw`pkgs.haskellPackages.enumerate-function`,
  "simple package for inverting functions and testing totality, via brute enumeration of the domain",
);

/**
 * A practical API for building recursive enumeration procedures and enumerating datatypes
 */
export const enumeration = mkPackage(
  nixRaw`pkgs.haskellPackages.enumeration`,
  "A practical API for building recursive enumeration procedures and enumerating datatypes",
);

/**
 * Enumerator instances for monads-fd classes
 */
export const enumerator_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.enumerator-fd`,
  "Enumerator instances for monads-fd classes",
);

/**
 * Enumerator instances for monads-tf classes
 */
export const enumerator_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.enumerator-tf`,
  "Enumerator instances for monads-tf classes",
);

/**
 * Finitely represented /total/ EnumMaps
 */
export const enumfun = mkPackage(
  nixRaw`pkgs.haskellPackages.enumfun`,
  "Finitely represented /total/ EnumMaps",
);

/**
 * IntMap and IntSet with Enum keys/elements
 */
export const enummapset = mkPackage(
  nixRaw`pkgs.haskellPackages.enummapset`,
  "IntMap and IntSet with Enum keys/elements",
);

/**
 * Sets of enumeration values represented by machine words
 */
export const enumset = mkPackage(
  nixRaw`pkgs.haskellPackages.enumset`,
  "Sets of enumeration values represented by machine words",
);

/**
 * Safe helpers for accessing and modifying environment variables
 */
export const env_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.env-extra`,
  "Safe helpers for accessing and modifying environment variables",
);

/**
 * Conditionally running IO actions based on environment variables
 */
export const env_guard = mkPackage(
  nixRaw`pkgs.haskellPackages.env-guard`,
  "Conditionally running IO actions based on environment variables",
);

/**
 * A (non-forking) interface to the current locale
 */
export const env_locale = mkPackage(
  nixRaw`pkgs.haskellPackages.env-locale`,
  "A (non-forking) interface to the current locale",
);

/**
 * Parse environment variables
 */
export const envparse = mkPackage(
  nixRaw`pkgs.haskellPackages.envparse`,
  "Parse environment variables",
);

/**
 * An environmentally friendly way to deal with environment variables
 */
export const envy = mkPackage(
  nixRaw`pkgs.haskellPackages.envy`,
  "An environmentally friendly way to deal with environment variables",
);

/**
 * See readme.md
 */
export const ephemeral = mkPackage(
  nixRaw`pkgs.haskellPackages.ephemeral`,
  "See readme.md",
);

/**
 * Basic Erlang-like process support for Haskell
 */
export const eprocess = mkPackage(
  nixRaw`pkgs.haskellPackages.eprocess`,
  "Basic Erlang-like process support for Haskell",
);

/**
 * EPUB E-Book construction support library
 */
export const epub = mkPackage(
  nixRaw`pkgs.haskellPackages.epub`,
  "EPUB E-Book construction support library",
);

/**
 * Library for parsing epub document metadata
 */
export const epub_metadata = mkPackage(
  nixRaw`pkgs.haskellPackages.epub-metadata`,
  "Library for parsing epub document metadata",
);

/**
 * Command line utilities for working with epub files
 */
export const epub_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.epub-tools`,
  "Command line utilities for working with epub files",
);

/**
 * Leibnizian equality
 */
export const eq = mkPackage(
  nixRaw`pkgs.haskellPackages.eq`,
  "Leibnizian equality",
);

/**
 * Shell command for finding equal files
 */
export const equal_files = mkPackage(
  nixRaw`pkgs.haskellPackages.equal-files`,
  "Shell command for finding equal files",
);

/**
 * Proof assistant for Haskell using DataKinds & PolyKinds
 */
export const equational_reasoning = mkPackage(
  nixRaw`pkgs.haskellPackages.equational-reasoning`,
  "Proof assistant for Haskell using DataKinds & PolyKinds",
);

/**
 * Maintaining an equivalence relation implemented as union-find using STT
 */
export const equivalence = mkPackage(
  nixRaw`pkgs.haskellPackages.equivalence`,
  "Maintaining an equivalence relation implemented as union-find using STT",
);

/**
 * The error function, erf, and related functions
 */
export const erf = mkPackage(
  nixRaw`pkgs.haskellPackages.erf`,
  "The error function, erf, and related functions",
);

/**
 * Native Haskell implementation of the interface from the erf package
 */
export const erf_native = mkPackage(
  nixRaw`pkgs.haskellPackages.erf-native`,
  "Native Haskell implementation of the interface from the erf package",
);

/**
 * DEPRECATED in favor of eros-http
 */
export const eros_client = mkPackage(
  nixRaw`pkgs.haskellPackages.eros-client`,
  "DEPRECATED in favor of eros-http",
);

/**
 * JSON HTTP interface to Eros
 */
export const eros_http = mkPackage(
  nixRaw`pkgs.haskellPackages.eros-http`,
  "JSON HTTP interface to Eros",
);

/**
 * Source code error pretty printing
 */
export const errata = mkPackage(
  nixRaw`pkgs.haskellPackages.errata`,
  "Source code error pretty printing",
);

/**
 * a FFI utility
 */
export const errno = mkPackage(
  nixRaw`pkgs.haskellPackages.errno`,
  "a FFI utility",
);

/**
 * The canonical error type
 */
export const error = mkPackage(
  nixRaw`pkgs.haskellPackages.error`,
  "The canonical error type",
);

/**
 * Parse ghc and cabal error messages and give their causes for easier resolution
 */
export const error_analyze = mkPackage(
  nixRaw`pkgs.haskellPackages.error-analyze`,
  "Parse ghc and cabal error messages and give their causes for easier resolution",
);

/**
 * Error code functions
 */
export const error_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.error-codes`,
  "Error code functions",
);

/**
 * error functions that show file location information
 */
export const error_location = mkPackage(
  nixRaw`pkgs.haskellPackages.error-location`,
  "error functions that show file location information",
);

/**
 * Composable error messages
 */
export const error_message = mkPackage(
  nixRaw`pkgs.haskellPackages.error-message`,
  "Composable error messages",
);

/**
 * Composable, hierarchical errors
 */
export const error_or = mkPackage(
  nixRaw`pkgs.haskellPackages.error-or`,
  "Composable, hierarchical errors",
);

/**
 * Utilities using ErrorOr datatype
 */
export const error_or_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.error-or-utils`,
  "Utilities using ErrorOr datatype",
);

/**
 * An orphan Eq instance for ErrorCall
 */
export const errorcall_eq_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.errorcall-eq-instance`,
  "An orphan Eq instance for ErrorCall",
);

/**
 * Simplified error-handling
 */
export const errors = mkPackage(
  nixRaw`pkgs.haskellPackages.errors`,
  "Simplified error-handling",
);

/**
 * `bracket`-like functions for `ExceptT` over `IO` monad
 */
export const errors_ext = mkPackage(
  nixRaw`pkgs.haskellPackages.errors-ext`,
  "`bracket`-like functions for `ExceptT` over `IO` monad",
);

/**
 * toysat driver as backend for ersatz
 */
export const ersatz_toysat = mkPackage(
  nixRaw`pkgs.haskellPackages.ersatz-toysat`,
  "toysat driver as backend for ersatz",
);

/**
 * Produce Text with terminal escape sequences
 */
export const escaped = mkPackage(
  nixRaw`pkgs.haskellPackages.escaped`,
  "Produce Text with terminal escape sequences",
);

/**
 * Esotericbot is a sophisticated, lightweight IRC bot
 */
export const esotericbot = mkPackage(
  nixRaw`pkgs.haskellPackages.esotericbot`,
  "Esotericbot is a sophisticated, lightweight IRC bot",
);

/**
 * Espial is an open-source, web-based bookmarking server
 */
export const espial = mkPackage(
  nixRaw`pkgs.haskellPackages.espial`,
  "Espial is an open-source, web-based bookmarking server",
);

/**
 * Type-safe EDSL for SQL queries on persistent backends
 */
export const esqueleto = mkPackage(
  nixRaw`pkgs.haskellPackages.esqueleto`,
  "Type-safe EDSL for SQL queries on persistent backends",
);

/**
 * Memory-constant streaming of Esqueleto results from PostgreSQL
 */
export const esqueleto_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.esqueleto-streaming`,
  "Memory-constant streaming of Esqueleto results from PostgreSQL",
);

/**
 * General purpose live coding framework - PortMidi backend
 */
export const essence_of_live_coding_PortMidi = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-PortMidi`,
  "General purpose live coding framework - PortMidi backend",
);

/**
 * General purpose live coding framework - Gloss backend
 */
export const essence_of_live_coding_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-gloss`,
  "General purpose live coding framework - Gloss backend",
);

/**
 * General purpose live coding framework - Gloss example
 */
export const essence_of_live_coding_gloss_example = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-gloss-example`,
  "General purpose live coding framework - Gloss example",
);

/**
 * General purpose live coding framework - pulse backend
 */
export const essence_of_live_coding_pulse = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-pulse`,
  "General purpose live coding framework - pulse backend",
);

/**
 * General purpose live coding framework - pulse backend example
 */
export const essence_of_live_coding_pulse_example = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-pulse-example`,
  "General purpose live coding framework - pulse backend example",
);

/**
 * General purpose live coding framework - QuickCheck integration
 */
export const essence_of_live_coding_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-quickcheck`,
  "General purpose live coding framework - QuickCheck integration",
);

/**
 * General purpose live coding framework - vivid backend
 */
export const essence_of_live_coding_vivid = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-vivid`,
  "General purpose live coding framework - vivid backend",
);

/**
 * General purpose live coding framework
 */
export const essence_of_live_coding_warp = mkPackage(
  nixRaw`pkgs.haskellPackages.essence-of-live-coding-warp`,
  "General purpose live coding framework",
);

/**
 * State-space estimation algorithms such as Kalman Filters
 */
export const estimator = mkPackage(
  nixRaw`pkgs.haskellPackages.estimator`,
  "State-space estimation algorithms such as Kalman Filters",
);

/**
 * Tool for managing probability estimation
 */
export const estimators = mkPackage(
  nixRaw`pkgs.haskellPackages.estimators`,
  "Tool for managing probability estimation",
);

/**
 * Repeats from ESTs
 */
export const estreps = mkPackage(
  nixRaw`pkgs.haskellPackages.estreps`,
  "Repeats from ESTs",
);

/**
 * everything breaking the Fairbairn threshold
 */
export const eternal = mkPackage(
  nixRaw`pkgs.haskellPackages.eternal`,
  "everything breaking the Fairbairn threshold",
);

/**
 * Native event-sourcing database
 */
export const eternity = mkPackage(
  nixRaw`pkgs.haskellPackages.eternity`,
  "Native event-sourcing database",
);

/**
 * Automatic timestamping for Eternity
 */
export const eternity_timestamped = mkPackage(
  nixRaw`pkgs.haskellPackages.eternity-timestamped`,
  "Automatic timestamping for Eternity",
);

/**
 * Monad transformers and classes
 */
export const ether = mkPackage(
  nixRaw`pkgs.haskellPackages.ether`,
  "Monad transformers and classes",
);

/**
 * A Ethereum contract analyzer
 */
export const ethereum_analyzer = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-analyzer`,
  "A Ethereum contract analyzer",
);

/**
 * A CLI frontend for ethereum-analyzer
 */
export const ethereum_analyzer_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-analyzer-cli`,
  "A CLI frontend for ethereum-analyzer",
);

/**
 * Stripped dependencies of ethereum-analyzer
 */
export const ethereum_analyzer_deps = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-analyzer-deps`,
  "Stripped dependencies of ethereum-analyzer",
);

/**
 * A web frontend for ethereum-analyzer
 */
export const ethereum_analyzer_webui = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-analyzer-webui`,
  "A web frontend for ethereum-analyzer",
);

/**
 * A Haskell version of an Ethereum client
 */
export const ethereum_client_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-client-haskell`,
  "A Haskell version of an Ethereum client",
);

/**
 * A modified Merkle Patricia DB
 */
export const ethereum_merkle_patricia_db = mkPackage(
  nixRaw`pkgs.haskellPackages.ethereum-merkle-patricia-db`,
  "A modified Merkle Patricia DB",
);

/**
 * Ethereum Recursive Length Prefix Encoding
 */
export const eths_rlp = mkPackage(
  nixRaw`pkgs.haskellPackages.eths-rlp`,
  "Ethereum Recursive Length Prefix Encoding",
);

/**
 * Random etymology online entry
 */
export const ety = mkPackage(
  nixRaw`pkgs.haskellPackages.ety`,
  "Random etymology online entry",
);

/**
 * Mathematics utilities for Haskell
 */
export const euler = mkPackage(
  nixRaw`pkgs.haskellPackages.euler`,
  "Mathematics utilities for Haskell",
);

/**
 * Euler tour trees
 */
export const euler_tour_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.euler-tour-tree`,
  "Euler tour trees",
);

/**
 * Dynamic network FRP with events and continuous values
 */
export const euphoria = mkPackage(
  nixRaw`pkgs.haskellPackages.euphoria`,
  "Dynamic network FRP with events and continuous values",
);

/**
 * Bridge for working with evdev and streamly
 */
export const evdev_streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.evdev-streamly`,
  "Bridge for working with evdev and streamly",
);

/**
 * An extensible event framework
 */
export const eve = mkPackage(
  nixRaw`pkgs.haskellPackages.eve`,
  "An extensible event framework",
);

/**
 * Efficient effect handlers based on evidence translation
 */
export const eveff = mkPackage(
  nixRaw`pkgs.haskellPackages.eveff`,
  "Efficient effect handlers based on evidence translation",
);

/**
 * Event handlers
 */
export const event_handlers = mkPackage(
  nixRaw`pkgs.haskellPackages.event-handlers`,
  "Event handlers",
);

/**
 * Event lists with relative or absolute time stamps
 */
export const event_list = mkPackage(
  nixRaw`pkgs.haskellPackages.event-list`,
  "Event lists with relative or absolute time stamps",
);

/**
 * Event-graph simulation monad transformer
 */
export const event_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.event-monad`,
  "Event-graph simulation monad transformer",
);

/**
 * Initial project template from stack
 */
export const event_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.event-transformer`,
  "Initial project template from stack",
);

/**
 * Core module for eventful
 */
export const eventful_core = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-core`,
  "Core module for eventful",
);

/**
 * Library for eventful DynamoDB event stores
 */
export const eventful_dynamodb = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-dynamodb`,
  "Library for eventful DynamoDB event stores",
);

/**
 * In-memory implementations for eventful
 */
export const eventful_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-memory`,
  "In-memory implementations for eventful",
);

/**
 * Postgres implementations for eventful
 */
export const eventful_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-postgresql`,
  "Postgres implementations for eventful",
);

/**
 * Common library for SQL event stores
 */
export const eventful_sql_common = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-sql-common`,
  "Common library for SQL event stores",
);

/**
 * SQLite implementations for eventful
 */
export const eventful_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-sqlite`,
  "SQLite implementations for eventful",
);

/**
 * Common module used for eventful tests
 */
export const eventful_test_helpers = mkPackage(
  nixRaw`pkgs.haskellPackages.eventful-test-helpers`,
  "Common module used for eventful tests",
);

/**
 * Visualise an eventlog
 */
export const eventlog2html = mkPackage(
  nixRaw`pkgs.haskellPackages.eventlog2html`,
  "Visualise an eventlog",
);

/**
 * Stream GHC eventlog events to external processes
 */
export const eventlog_socket = mkPackage(
  nixRaw`pkgs.haskellPackages.eventlog-socket`,
  "Stream GHC eventlog events to external processes",
);

/**
 * A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.
 */
export const eventloop = mkPackage(
  nixRaw`pkgs.haskellPackages.eventloop`,
  "A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.",
);

/**
 * GetEventStore store implementation
 */
export const eventsource_geteventstore_store = mkPackage(
  nixRaw`pkgs.haskellPackages.eventsource-geteventstore-store`,
  "GetEventStore store implementation",
);

/**
 * Provides common test specification for Store implementation
 */
export const eventsource_store_specs = mkPackage(
  nixRaw`pkgs.haskellPackages.eventsource-store-specs`,
  "Provides common test specification for Store implementation",
);

/**
 * An in-memory stub store implementation
 */
export const eventsource_stub_store = mkPackage(
  nixRaw`pkgs.haskellPackages.eventsource-stub-store`,
  "An in-memory stub store implementation",
);

/**
 * CQRS/ES library
 */
export const eventsourcing = mkPackage(
  nixRaw`pkgs.haskellPackages.eventsourcing`,
  "CQRS/ES library",
);

/**
 * PostgreSQL adaptor for eventsourcing
 */
export const eventsourcing_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.eventsourcing-postgresql`,
  "PostgreSQL adaptor for eventsourcing",
);

/**
 * An event-oriented observability library
 */
export const eventuo11y = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y`,
  "An event-oriented observability library",
);

/**
 * Grab bag of eventuo11y-enriched functionality
 */
export const eventuo11y_batteries = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y-batteries`,
  "Grab bag of eventuo11y-enriched functionality",
);

/**
 * DSL for defining eventuo11y fields and selectors
 */
export const eventuo11y_dsl = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y-dsl`,
  "DSL for defining eventuo11y fields and selectors",
);

/**
 * aeson-based rendering for eventuo11y
 */
export const eventuo11y_json = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y-json`,
  "aeson-based rendering for eventuo11y",
);

/**
 * OpenTelemetry-based rendering for eventuo11y
 */
export const eventuo11y_otel = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y-otel`,
  "OpenTelemetry-based rendering for eventuo11y",
);

/**
 * Prometheus backend for eventuo11y
 */
export const eventuo11y_prometheus = mkPackage(
  nixRaw`pkgs.haskellPackages.eventuo11y-prometheus`,
  "Prometheus backend for eventuo11y",
);

/**
 * Run a process every so often
 */
export const every = mkPackage(
  nixRaw`pkgs.haskellPackages.every`,
  "Run a process every so often",
);

/**
 * A functional pearl on encoding and decoding using question-and-answer strategies
 */
export const every_bit_counts = mkPackage(
  nixRaw`pkgs.haskellPackages.every-bit-counts`,
  "A functional pearl on encoding and decoding using question-and-answer strategies",
);

/**
 * Opcode types for Ethereum Virtual Machine (EVM)
 */
export const evm_opcodes = mkPackage(
  nixRaw`pkgs.haskellPackages.evm-opcodes`,
  "Opcode types for Ethereum Virtual Machine (EVM)",
);

/**
 * Another fork of resource-pool, with a MonadIO and MonadCatch constraint
 */
export const ex_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.ex-pool`,
  "Another fork of resource-pool, with a MonadIO and MonadCatch constraint",
);

/**
 * Efficient exact computation of combinatoric functions
 */
export const exact_combinatorics = mkPackage(
  nixRaw`pkgs.haskellPackages.exact-combinatorics`,
  "Efficient exact computation of combinatoric functions",
);

/**
 * Exact rational multiples of pi (and integer powers of pi)
 */
export const exact_pi = mkPackage(
  nixRaw`pkgs.haskellPackages.exact-pi`,
  "Exact rational multiples of pi (and integer powers of pi)",
);

/**
 * Exact real arithmetic
 */
export const exact_real = mkPackage(
  nixRaw`pkgs.haskellPackages.exact-real`,
  "Exact real arithmetic",
);

/**
 * Example Haskell Project
 */
export const example_haskell_project = mkPackage(
  nixRaw`pkgs.haskellPackages.example-haskell-project`,
  "Example Haskell Project",
);

/**
 * Exception type hierarchy with TemplateHaskell
 */
export const exception_hierarchy = mkPackage(
  nixRaw`pkgs.haskellPackages.exception-hierarchy`,
  "Exception type hierarchy with TemplateHaskell",
);

/**
 * Catch all runtime exceptions and send an email
 */
export const exception_mailer = mkPackage(
  nixRaw`pkgs.haskellPackages.exception-mailer`,
  "Catch all runtime exceptions and send an email",
);

/**
 * Exception monad transformer instances for monads-tf classes
 */
export const exception_monads_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.exception-monads-tf`,
  "Exception monad transformer instances for monads-tf classes",
);

/**
 * Exception monad transformer instances for mtl classes
 */
export const exception_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.exception-mtl`,
  "Exception monad transformer instances for mtl classes",
);

/**
 * Type classes and monads for unchecked extensible exceptions
 */
export const exception_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.exception-transformers`,
  "Type classes and monads for unchecked extensible exceptions",
);

/**
 * Extensible optionally-pure exceptions
 */
export const exceptions_0_10_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.exceptions_0_10_7`,
  "Extensible optionally-pure exceptions",
);

/**
 * ExceptT, but uses IO instead of Either
 */
export const exceptiot = mkPackage(
  nixRaw`pkgs.haskellPackages.exceptiot`,
  "ExceptT, but uses IO instead of Either",
);

/**
 * Provides the SHA1 hash of the program executable
 */
export const executable_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.executable-hash`,
  "Provides the SHA1 hash of the program executable",
);

/**
 * Finding out the full path of the executable
 */
export const executable_path = mkPackage(
  nixRaw`pkgs.haskellPackages.executable-path`,
  "Finding out the full path of the executable",
);

/**
 * Tool to search/generate (haskell) expressions with a given type
 */
export const exference = mkPackage(
  nixRaw`pkgs.haskellPackages.exference`,
  "Tool to search/generate (haskell) expressions with a given type",
);

/**
 * Haskell bindings to ExifTool
 */
export const exiftool = mkPackage(
  nixRaw`pkgs.haskellPackages.exiftool`,
  "Haskell bindings to ExifTool",
);

/**
 * Dependent pairs and their instances
 */
export const exinst = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst`,
  "Dependent pairs and their instances",
);

/**
 * @exinst@ support for @aeson@ package
 */
export const exinst_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst-aeson`,
  "@exinst@ support for @aeson@ package",
);

/**
 * @exinst@ support for @base@ package
 */
export const exinst_base = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst-base`,
  "@exinst@ support for @base@ package",
);

/**
 * @exinst@ support for @bytes@ package
 */
export const exinst_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst-bytes`,
  "@exinst@ support for @bytes@ package",
);

/**
 * @exinst@ support for @cereal@ package
 */
export const exinst_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst-cereal`,
  "@exinst@ support for @cereal@ package",
);

/**
 * Dependent pairs and their instances
 */
export const exinst_serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.exinst-serialise`,
  "Dependent pairs and their instances",
);

/**
 * Dependent sum type
 */
export const exist = mkPackage(
  nixRaw`pkgs.haskellPackages.exist`,
  "Dependent sum type",
);

/**
 * Instances for "exist" package (requires more language extensions and dependencies)
 */
export const exist_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.exist-instances`,
  "Instances for \"exist\" package (requires more language extensions and dependencies)",
);

/**
 * Exit codes as defined by BSD
 */
export const exit_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.exit-codes`,
  "Exit codes as defined by BSD",
);

/**
 * Compression and decompression in the exomizer format
 */
export const exomizer = mkPackage(
  nixRaw`pkgs.haskellPackages.exomizer`,
  "Compression and decompression in the exomizer format",
);

/**
 * Customizable quasiquote interpolation
 */
export const exon = mkPackage(
  nixRaw`pkgs.haskellPackages.exon`,
  "Customizable quasiquote interpolation",
);

/**
 * Non-standard monads on lists and non-empty lists
 */
export const exotic_list_monads = mkPackage(
  nixRaw`pkgs.haskellPackages.exotic-list-monads`,
  "Non-standard monads on lists and non-empty lists",
);

/**
 * Linear programming over exponent pairs
 */
export const exp_pairs = mkPackage(
  nixRaw`pkgs.haskellPackages.exp-pairs`,
  "Linear programming over exponent pairs",
);

/**
 * Extensible Pandoc
 */
export const expand = mkPackage(
  nixRaw`pkgs.haskellPackages.expand`,
  "Extensible Pandoc",
);

/**
 * Enumerator-based API for Expat
 */
export const expat_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.expat-enumerator`,
  "Enumerator-based API for Expat",
);

/**
 * Perform scientific experiments stored in a DB, and generate reports
 */
export const experimenter = mkPackage(
  nixRaw`pkgs.haskellPackages.experimenter`,
  "Perform scientific experiments stored in a DB, and generate reports",
);

/**
 * General purpose simple caching
 */
export const expiring_cache_map = mkPackage(
  nixRaw`pkgs.haskellPackages.expiring-cache-map`,
  "General purpose simple caching",
);

/**
 * Expiring containers
 */
export const expiring_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.expiring-containers`,
  "Expiring containers",
);

/**
 * Create values which expire after a period of time
 */
export const expiring_mvar = mkPackage(
  nixRaw`pkgs.haskellPackages.expiring-mvar`,
  "Create values which expire after a period of time",
);

/**
 * Predicates that can explain themselves
 */
export const explainable_predicates = mkPackage(
  nixRaw`pkgs.haskellPackages.explainable-predicates`,
  "Predicates that can explain themselves",
);

/**
 * Exceptions which are explicit in the type signature
 */
export const explicit_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.explicit-exception`,
  "Exceptions which are explicit in the type signature",
);

/**
 * Extends explicit-iomodes with ByteString operations
 */
export const explicit_iomodes_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.explicit-iomodes-bytestring`,
  "Extends explicit-iomodes with ByteString operations",
);

/**
 * Extends explicit-iomodes with Text operations
 */
export const explicit_iomodes_text = mkPackage(
  nixRaw`pkgs.haskellPackages.explicit-iomodes-text`,
  "Extends explicit-iomodes with Text operations",
);

/**
 * Explicit Sharing of Monadic Effects
 */
export const explicit_sharing = mkPackage(
  nixRaw`pkgs.haskellPackages.explicit-sharing`,
  "Explicit Sharing of Monadic Effects",
);

/**
 * Experimental Plot data Reconstructor
 */
export const explore = mkPackage(
  nixRaw`pkgs.haskellPackages.explore`,
  "Experimental Plot data Reconstructor",
);

/**
 * Dynamically-typed expressions involving function application and variables
 */
export const express = mkPackage(
  nixRaw`pkgs.haskellPackages.express`,
  "Dynamically-typed expressions involving function application and variables",
);

/**
 * Encode and Decode expressions from Z3 ASTs
 */
export const expressions_z3 = mkPackage(
  nixRaw`pkgs.haskellPackages.expressions-z3`,
  "Encode and Decode expressions from Z3 ASTs",
);

/**
 * automated printing for extemp speakers
 */
export const extemp = mkPackage(
  nixRaw`pkgs.haskellPackages.extemp`,
  "automated printing for extemp speakers",
);

/**
 * TH to define a new record data type that extends the existing record data type
 */
export const extend_record_data_th = mkPackage(
  nixRaw`pkgs.haskellPackages.extend-record-data-th`,
  "TH to define a new record data type that extends the existing record data type",
);

/**
 * lens instances for extended-containers
 */
export const extended_containers_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.extended-containers-lens`,
  "lens instances for extended-containers",
);

/**
 * Extension of real numbers with positive/negative infinities
 */
export const extended_reals = mkPackage(
  nixRaw`pkgs.haskellPackages.extended-reals`,
  "Extension of real numbers with positive/negative infinities",
);

/**
 * Extensible, efficient, optics-friendly data types and effects
 */
export const extensible = mkPackage(
  nixRaw`pkgs.haskellPackages.extensible`,
  "Extensible, efficient, optics-friendly data types and effects",
);

/**
 * An Alternative to Monad Transformers
 */
export const extensible_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.extensible-effects`,
  "An Alternative to Monad Transformers",
);

/**
 * Extensible exceptions
 */
export const extensible_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.extensible-exceptions`,
  "Extensible exceptions",
);

/**
 * Operational-based extensible effect library
 */
export const extensible_skeleton = mkPackage(
  nixRaw`pkgs.haskellPackages.extensible-skeleton`,
  "Operational-based extensible effect library",
);

/**
 * light-weight, extensible sums and products over types and kinds
 */
export const extensible_sp = mkPackage(
  nixRaw`pkgs.haskellPackages.extensible-sp`,
  "light-weight, extensible sums and products over types and kinds",
);

/**
 * Parse Haskell Language Extensions
 */
export const extensions = mkPackage(
  nixRaw`pkgs.haskellPackages.extensions`,
  "Parse Haskell Language Extensions",
);

/**
 * Extism manifest bindings
 */
export const extism_manifest = mkPackage(
  nixRaw`pkgs.haskellPackages.extism-manifest`,
  "Extism manifest bindings",
);

/**
 * Extra functions I use
 */
export const extra = mkPackage(
  nixRaw`pkgs.haskellPackages.extra`,
  "Extra functions I use",
);

/**
 * Given a hackage package outputs the list of its dependencies
 */
export const extract_dependencies = mkPackage(
  nixRaw`pkgs.haskellPackages.extract-dependencies`,
  "Given a hackage package outputs the list of its dependencies",
);

/**
 * A functor, where the "stored" value is isomorphic to Identity
 */
export const extractable_singleton = mkPackage(
  nixRaw`pkgs.haskellPackages.extractable-singleton`,
  "A functor, where the \"stored\" value is isomorphic to Identity",
);

/**
 * generalize counter-examples of test properties
 */
export const extrapolate = mkPackage(
  nixRaw`pkgs.haskellPackages.extrapolate`,
  "generalize counter-examples of test properties",
);

/**
 * Factoring integers and polynomials
 */
export const factor = mkPackage(
  nixRaw`pkgs.haskellPackages.factor`,
  "Factoring integers and polynomials",
);

/**
 * A driver for the Factual API
 */
export const factual_api = mkPackage(
  nixRaw`pkgs.haskellPackages.factual-api`,
  "A driver for the Factual API",
);

/**
 * Forward Automatic Differentiation
 */
export const fad = mkPackage(
  nixRaw`pkgs.haskellPackages.fad`,
  "Forward Automatic Differentiation",
);

/**
 * Minimal library for music generation and notation
 */
export const fadno = mkPackage(
  nixRaw`pkgs.haskellPackages.fadno`,
  "Minimal library for music generation and notation",
);

/**
 * Forward-compatible MonadFail class
 */
export const fail = mkPackage(
  nixRaw`pkgs.haskellPackages.fail`,
  "Forward-compatible MonadFail class",
);

/**
 * A 'Failable' error monad class to unify failure across monads that can fail
 */
export const failable = mkPackage(
  nixRaw`pkgs.haskellPackages.failable`,
  "A 'Failable' error monad class to unify failure across monads that can fail",
);

/**
 * A simple type class for success/failure computations. (deprecated)
 */
export const failure = mkPackage(
  nixRaw`pkgs.haskellPackages.failure`,
  "A simple type class for success/failure computations. (deprecated)",
);

/**
 * Lists with fair choice
 */
export const fair = mkPackage(
  nixRaw`pkgs.haskellPackages.fair`,
  "Lists with fair choice",
);

/**
 * Fair Predicates
 */
export const fair_predicates = mkPackage(
  nixRaw`pkgs.haskellPackages.fair-predicates`,
  "Fair Predicates",
);

/**
 * Library for producing fake data
 */
export const fakedata = mkPackage(
  nixRaw`pkgs.haskellPackages.fakedata`,
  "Library for producing fake data",
);

export const fakedata_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.fakedata-parser`,
  "",
);

/**
 * Fake a -> Gen a
 */
export const fakedata_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.fakedata-quickcheck`,
  "Fake a -> Gen a",
);

/**
 * Extensible fake file system for testing
 */
export const fakefs = mkPackage(
  nixRaw`pkgs.haskellPackages.fakefs`,
  "Extensible fake file system for testing",
);

/**
 * Monad to pull from fake stream-like objects
 */
export const fakepull = mkPackage(
  nixRaw`pkgs.haskellPackages.fakepull`,
  "Monad to pull from fake stream-like objects",
);

/**
 * Pure Haskell library for generating fake data
 */
export const faker = mkPackage(
  nixRaw`pkgs.haskellPackages.faker`,
  "Pure Haskell library for generating fake data",
);

export const fallible = mkPackage(
  nixRaw`pkgs.haskellPackages.fallible`,
  "",
);

/**
 * Falling sand game/cellular automata simulation using regular parallel arrays
 */
export const falling_turnip = mkPackage(
  nixRaw`pkgs.haskellPackages.falling-turnip`,
  "Falling sand game/cellular automata simulation using regular parallel arrays",
);

/**
 * A fun falling blocks game
 */
export const fallingblocks = mkPackage(
  nixRaw`pkgs.haskellPackages.fallingblocks`,
  "A fun falling blocks game",
);

/**
 * Property-based testing with internal integrated shrinking
 */
export const falsify = mkPackage(
  nixRaw`pkgs.haskellPackages.falsify`,
  "Property-based testing with internal integrated shrinking",
);

/**
 * Reifies arbitrary terms into types that can be reflected back into terms
 */
export const familiar_reflection = mkPackage(
  nixRaw`pkgs.haskellPackages.familiar-reflection`,
  "Reifies arbitrary terms into types that can be reflected back into terms",
);

/**
 * A family tree library for the Haskell programming language
 */
export const family_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.family-tree`,
  "A family tree library for the Haskell programming language",
);

/**
 * Fast hash functions
 */
export const farmhash = mkPackage(
  nixRaw`pkgs.haskellPackages.farmhash`,
  "Fast hash functions",
);

/**
 * Fast functions on integers
 */
export const fast_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-arithmetic`,
  "Fast functions on integers",
);

/**
 * Fast implementation of the Bech32 encoding format
 */
export const fast_bech32 = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-bech32`,
  "Fast implementation of the Bech32 encoding format",
);

/**
 * Fast ByteString Builder
 */
export const fast_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-builder`,
  "Fast ByteString Builder",
);

/**
 * Integer-to-digits conversion
 */
export const fast_digits = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-digits`,
  "Integer-to-digits conversion",
);

/**
 * Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward
 */
export const fast_downward = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-downward`,
  "Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward",
);

/**
 * A fast logging system
 */
export const fast_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-logger`,
  "A fast logging system",
);

/**
 * Non IEEE-754 compliant compile-time floating-point optimisations
 */
export const fast_math = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-math`,
  "Non IEEE-754 compliant compile-time floating-point optimisations",
);

/**
 * Numeric type with asymptotically faster multiplications
 */
export const fast_mult = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-mult`,
  "Numeric type with asymptotically faster multiplications",
);

/**
 * A fast implementation of the Myers diff algorithm
 */
export const fast_myers_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-myers-diff`,
  "A fast implementation of the Myers diff algorithm",
);

/**
 * Fast incremental vi and emacs tags
 */
export const fast_tags = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-tags`,
  "Fast incremental vi and emacs tags",
);

/**
 * Fast parsing and extracting information from (possibly malformed) HTML/XML documents
 */
export const fast_tagsoup = mkPackage(
  nixRaw`pkgs.haskellPackages.fast-tagsoup`,
  "Fast parsing and extracting information from (possibly malformed) HTML/XML documents",
);

/**
 * A simple, mindless parser for fasta files
 */
export const fasta = mkPackage(
  nixRaw`pkgs.haskellPackages.fasta`,
  "A simple, mindless parser for fasta files",
);

/**
 * An implementation of FastCDC, a content-defined chunking algorithm based on the Gear hash rolling hash algorithm
 */
export const fastcdc = mkPackage(
  nixRaw`pkgs.haskellPackages.fastcdc`,
  "An implementation of FastCDC, a content-defined chunking algorithm based on the Gear hash rolling hash algorithm",
);

/**
 * A Haskell library for writing FastCGI programs
 */
export const fastcgi = mkPackage(
  nixRaw`pkgs.haskellPackages.fastcgi`,
  "A Haskell library for writing FastCGI programs",
);

/**
 * Speed up Megaparsec parsing when parsing succeeds
 */
export const faster_megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.faster-megaparsec`,
  "Speed up Megaparsec parsing when parsing succeeds",
);

/**
 * Fast Internet Relay Chat (IRC) library
 */
export const fastirc = mkPackage(
  nixRaw`pkgs.haskellPackages.fastirc`,
  "Fast Internet Relay Chat (IRC) library",
);

/**
 * Memoize functions on Generic types
 */
export const fastmemo = mkPackage(
  nixRaw`pkgs.haskellPackages.fastmemo`,
  "Memoize functions on Generic types",
);

/**
 * A fast, but bare bones, bytestring parser combinators library
 */
export const fastparser = mkPackage(
  nixRaw`pkgs.haskellPackages.fastparser`,
  "A fast, but bare bones, bytestring parser combinators library",
);

/**
 * A fast open-union type suitable for 100+ contained alternatives
 */
export const fastsum = mkPackage(
  nixRaw`pkgs.haskellPackages.fastsum`,
  "A fast open-union type suitable for 100+ contained alternatives",
);

/**
 * A fault tree analysis library
 */
export const fault_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.fault-tree`,
  "A fault tree analysis library",
);

/**
 * The base package for Fay
 */
export const fay_base = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-base`,
  "The base package for Fay",
);

/**
 * Compile Fay code on cabal install, and ad-hoc recompile during development
 */
export const fay_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-builder`,
  "Compile Fay code on cabal install, and ad-hoc recompile during development",
);

/**
 * DOM FFI wrapper library for Fay
 */
export const fay_dom = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-dom`,
  "DOM FFI wrapper library for Fay",
);

/**
 * W3C compliant implementation of GeoPosition API
 */
export const fay_geoposition = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-geoposition`,
  "W3C compliant implementation of GeoPosition API",
);

/**
 * Clientside HTML generation for fay
 */
export const fay_hsx = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-hsx`,
  "Clientside HTML generation for fay",
);

/**
 * jQuery bindings for Fay
 */
export const fay_jquery = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-jquery`,
  "jQuery bindings for Fay",
);

/**
 * Like IORef but for Fay
 */
export const fay_ref = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-ref`,
  "Like IORef but for Fay",
);

/**
 * SimpleJSON library for Fay
 */
export const fay_simplejson = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-simplejson`,
  "SimpleJSON library for Fay",
);

/**
 * Fay Text type represented as JavaScript strings
 */
export const fay_text = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-text`,
  "Fay Text type represented as JavaScript strings",
);

/**
 * Persistent FFI bindings for using jsUri in Fay
 */
export const fay_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-uri`,
  "Persistent FFI bindings for using jsUri in Fay",
);

/**
 * Websockets FFI library for Fay
 */
export const fay_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.fay-websockets`,
  "Websockets FFI library for Fay",
);

/**
 * Bindings to Facebook's API
 */
export const fb = mkPackage(
  nixRaw`pkgs.haskellPackages.fb`,
  "Bindings to Facebook's API",
);

/**
 * Fedora packager tool to build package branches
 */
export const fbrnch = mkPackage(
  nixRaw`pkgs.haskellPackages.fbrnch`,
  "Fedora packager tool to build package branches",
);

/**
 * A faster way to navigate directories using the command line
 */
export const fcd = mkPackage(
  nixRaw`pkgs.haskellPackages.fcd`,
  "A faster way to navigate directories using the command line",
);

/**
 * Family-of-families instances for base
 */
export const fcf_base = mkPackage(
  nixRaw`pkgs.haskellPackages.fcf-base`,
  "Family-of-families instances for base",
);

/**
 * Data structures and algorithms for first-class-families
 */
export const fcf_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.fcf-containers`,
  "Data structures and algorithms for first-class-families",
);

/**
 * Family of families: featherweight defunctionalization
 */
export const fcf_family = mkPackage(
  nixRaw`pkgs.haskellPackages.fcf-family`,
  "Family of families: featherweight defunctionalization",
);

/**
 * Vinyl compatibility with first-class-families
 */
export const fcf_vinyl = mkPackage(
  nixRaw`pkgs.haskellPackages.fcf-vinyl`,
  "Vinyl compatibility with first-class-families",
);

/**
 * First class accessor labels implemented as lenses
 */
export const fclabels = mkPackage(
  nixRaw`pkgs.haskellPackages.fclabels`,
  "First class accessor labels implemented as lenses",
);

/**
 * Desktop Notifications client
 */
export const fdo_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.fdo-notify`,
  "Desktop Notifications client",
);

/**
 * A simple library for dynamically enabling and disabling functionality
 */
export const feature_flags = mkPackage(
  nixRaw`pkgs.haskellPackages.feature-flags`,
  "A simple library for dynamically enabling and disabling functionality",
);

/**
 * A minimally obtrusive feature flag library
 */
export const feature_flipper_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.feature-flipper-postgres`,
  "A minimally obtrusive feature flag library",
);

/**
 * Forward error correction of ByteStrings
 */
export const fec = mkPackage(
  nixRaw`pkgs.haskellPackages.fec`,
  "Forward error correction of ByteStrings",
);

/**
 * Query Fedora composes
 */
export const fedora_composes = mkPackage(
  nixRaw`pkgs.haskellPackages.fedora-composes`,
  "Query Fedora composes",
);

/**
 * Library for Fedora distribution versions
 */
export const fedora_dists = mkPackage(
  nixRaw`pkgs.haskellPackages.fedora-dists`,
  "Library for Fedora distribution versions",
);

/**
 * Building and maintenance tools for Fedora Haskell
 */
export const fedora_haskell_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.fedora-haskell-tools`,
  "Building and maintenance tools for Fedora Haskell",
);

/**
 * Fedora image download tool
 */
export const fedora_img_dl = mkPackage(
  nixRaw`pkgs.haskellPackages.fedora-img-dl`,
  "Fedora image download tool",
);

/**
 * Fedora repoquery tool
 */
export const fedora_repoquery = mkPackage(
  nixRaw`pkgs.haskellPackages.fedora-repoquery`,
  "Fedora repoquery tool",
);

/**
 * Short description of your package
 */
export const fee_estimate = mkPackage(
  nixRaw`pkgs.haskellPackages.fee-estimate`,
  "Short description of your package",
);

/**
 * Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.
 */
export const feed = mkPackage(
  nixRaw`pkgs.haskellPackages.feed`,
  "Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.",
);

/**
 * (unsupported)
 */
export const feed2lj = mkPackage(
  nixRaw`pkgs.haskellPackages.feed2lj`,
  "(unsupported)",
);

/**
 * Send posts from a feed to Twitter
 */
export const feed2twitter = mkPackage(
  nixRaw`pkgs.haskellPackages.feed2twitter`,
  "Send posts from a feed to Twitter",
);

/**
 * CI service around gipeda
 */
export const feed_gipeda = mkPackage(
  nixRaw`pkgs.haskellPackages.feed-gipeda`,
  "CI service around gipeda",
);

/**
 * Translate syndication feeds
 */
export const feed_translator = mkPackage(
  nixRaw`pkgs.haskellPackages.feed-translator`,
  "Translate syndication feeds",
);

/**
 * Declarative feedback loop manager
 */
export const feedback = mkPackage(
  nixRaw`pkgs.haskellPackages.feedback`,
  "Declarative feedback loop manager",
);

/**
 * FFI to MXNet
 */
export const fei_base = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-base`,
  "FFI to MXNet",
);

/**
 * Cocodataset with cocoapi
 */
export const fei_cocoapi = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-cocoapi`,
  "Cocodataset with cocoapi",
);

/**
 * mxnet dataiters
 */
export const fei_dataiter = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-dataiter`,
  "mxnet dataiters",
);

/**
 * Some datasets
 */
export const fei_datasets = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-datasets`,
  "Some datasets",
);

/**
 * fei examples
 */
export const fei_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-examples`,
  "fei examples",
);

/**
 * A collection of standard models
 */
export const fei_modelzoo = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-modelzoo`,
  "A collection of standard models",
);

/**
 * Train a neural network with MXNet in Haskell
 */
export const fei_nn = mkPackage(
  nixRaw`pkgs.haskellPackages.fei-nn`,
  "Train a neural network with MXNet in Haskell",
);

/**
 * Compiler for the Feldspar language
 */
export const feldspar_compiler = mkPackage(
  nixRaw`pkgs.haskellPackages.feldspar-compiler`,
  "Compiler for the Feldspar language",
);

/**
 * A functional embedded language for DSP and parallelism
 */
export const feldspar_language = mkPackage(
  nixRaw`pkgs.haskellPackages.feldspar-language`,
  "A functional embedded language for DSP and parallelism",
);

/**
 * Converting a chess position from FEN notation to text
 */
export const fen2s = mkPackage(
  nixRaw`pkgs.haskellPackages.fen2s`,
  "Converting a chess position from FEN notation to text",
);

/**
 * To be written
 */
export const fences = mkPackage(
  nixRaw`pkgs.haskellPackages.fences`,
  "To be written",
);

/**
 * Remote multi-db SQLCipher server
 */
export const festung = mkPackage(
  nixRaw`pkgs.haskellPackages.festung`,
  "Remote multi-db SQLCipher server",
);

/**
 * Automatic C++ binding generation
 */
export const fficxx = mkPackage(
  nixRaw`pkgs.haskellPackages.fficxx`,
  "Automatic C++ binding generation",
);

/**
 * Runtime for fficxx-generated library
 */
export const fficxx_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.fficxx-runtime`,
  "Runtime for fficxx-generated library",
);

/**
 * Tutorials on ffmpeg usage to play video/audio
 */
export const ffmpeg_tutorials = mkPackage(
  nixRaw`pkgs.haskellPackages.ffmpeg-tutorials`,
  "Tutorials on ffmpeg usage to play video/audio",
);

/**
 * Bindings to the FFTW library
 */
export const fft = mkPackage(
  nixRaw`pkgs.haskellPackages.fft`,
  "Bindings to the FFTW library",
);

/**
 * Low level bindings to FFTW
 */
export const fftwRaw = mkPackage(
  nixRaw`pkgs.haskellPackages.fftwRaw`,
  "Low level bindings to FFTW",
);

/**
 * Low-level interface to FFTW (Fast Fourier Transform)
 */
export const fftw_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.fftw-ffi`,
  "Low-level interface to FFTW (Fast Fourier Transform)",
);

/**
 * Martin Erwig's Functional Graph Library
 */
export const fgl = mkPackage(
  nixRaw`pkgs.haskellPackages.fgl`,
  "Martin Erwig's Functional Graph Library",
);

/**
 * Martin Erwig's Functional Graph Library
 */
export const fgl_5_8_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.fgl_5_8_1_1`,
  "Martin Erwig's Functional Graph Library",
);

/**
 * QuickCheck support for fgl
 */
export const fgl_arbitrary = mkPackage(
  nixRaw`pkgs.haskellPackages.fgl-arbitrary`,
  "QuickCheck support for fgl",
);

/**
 * Convert FGL graphs to dot (graphviz) files
 */
export const fgl_visualize = mkPackage(
  nixRaw`pkgs.haskellPackages.fgl-visualize`,
  "Convert FGL graphs to dot (graphviz) files",
);

/**
 * Fast computation of Fibonacci numbers
 */
export const fibonacci = mkPackage(
  nixRaw`pkgs.haskellPackages.fibonacci`,
  "Fast computation of Fibonacci numbers",
);

/**
 * update statically hosted file in a push stule through socketed
 */
export const ficketed = mkPackage(
  nixRaw`pkgs.haskellPackages.ficketed`,
  "update statically hosted file in a push stule through socketed",
);

/**
 * Abusing monadic syntax JSON objects generation
 */
export const fields_json = mkPackage(
  nixRaw`pkgs.haskellPackages.fields-json`,
  "Abusing monadic syntax JSON objects generation",
);

/**
 * Use Template Haskell to embed file contents directly
 */
export const file_embed = mkPackage(
  nixRaw`pkgs.haskellPackages.file-embed`,
  "Use Template Haskell to embed file contents directly",
);

/**
 * Use Template Haskell to embed (LZMA compressed) data
 */
export const file_embed_lzma = mkPackage(
  nixRaw`pkgs.haskellPackages.file-embed-lzma`,
  "Use Template Haskell to embed (LZMA compressed) data",
);

/**
 * Takes a Haskell source-code file and outputs its modules
 */
export const file_modules = mkPackage(
  nixRaw`pkgs.haskellPackages.file-modules`,
  "Takes a Haskell source-code file and outputs its modules",
);

/**
 * Template Haskell utilities for filepaths
 */
export const file_path_th = mkPackage(
  nixRaw`pkgs.haskellPackages.file-path-th`,
  "Template Haskell utilities for filepaths",
);

/**
 * Portable interface to file locking (flock / LockFileEx)
 */
export const filelock = mkPackage(
  nixRaw`pkgs.haskellPackages.filelock`,
  "Portable interface to file locking (flock / LockFileEx)",
);

/**
 * Expressive file and directory manipulation for Haskell
 */
export const filemanip = mkPackage(
  nixRaw`pkgs.haskellPackages.filemanip`,
  "Expressive file and directory manipulation for Haskell",
);

/**
 * Library for manipulating FilePaths in a cross platform way
 */
export const filepath_1_4_100_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.filepath_1_4_100_4`,
  "Library for manipulating FilePaths in a cross platform way",
);

/**
 * Library for manipulating RawFilePaths in a cross platform way
 */
export const filepath_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.filepath-bytestring`,
  "Library for manipulating RawFilePaths in a cross platform way",
);

/**
 * Reversable and secure encoding of object ids as filepaths
 */
export const filepath_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.filepath-crypto`,
  "Reversable and secure encoding of object ids as filepaths",
);

/**
 * IO Access for filepath
 */
export const filepath_io_access = mkPackage(
  nixRaw`pkgs.haskellPackages.filepath-io-access`,
  "IO Access for filepath",
);

/**
 * File path glob-like matching
 */
export const filepattern = mkPackage(
  nixRaw`pkgs.haskellPackages.filepattern`,
  "File path glob-like matching",
);

/**
 * Library to process and search large files or a collection of files
 */
export const fileplow = mkPackage(
  nixRaw`pkgs.haskellPackages.fileplow`,
  "Library to process and search large files or a collection of files",
);

/**
 * Interface for versioning file stores
 */
export const filestore = mkPackage(
  nixRaw`pkgs.haskellPackages.filestore`,
  "Interface for versioning file stores",
);

/**
 * A shared set of abstractions and types for representing filessytem data
 */
export const filesystem_abstractions = mkPackage(
  nixRaw`pkgs.haskellPackages.filesystem-abstractions`,
  "A shared set of abstractions and types for representing filessytem data",
);

/**
 * Enumerator-based API for manipulating the filesystem
 */
export const filesystem_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.filesystem-enumerator`,
  "Enumerator-based API for manipulating the filesystem",
);

/**
 * Filterable request logging wai middleware. Change how data is logged and when.
 */
export const filter_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.filter-logger`,
  "Filterable request logging wai middleware. Change how data is logged and when.",
);

/**
 * Allows to change the structure of the function output
 */
export const filters_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.filters-basic`,
  "Allows to change the structure of the function output",
);

/**
 * Class of filtrable containers
 */
export const filtrable = mkPackage(
  nixRaw`pkgs.haskellPackages.filtrable`,
  "Class of filtrable containers",
);

/**
 * Nat and Fin: peano naturals and finite numbers
 */
export const fin = mkPackage(
  nixRaw`pkgs.haskellPackages.fin`,
  "Nat and Fin: peano naturals and finite numbers",
);

/**
 * Finite sets of static size
 */
export const fin_int = mkPackage(
  nixRaw`pkgs.haskellPackages.fin-int`,
  "Finite sets of static size",
);

/**
 * utility to add extra safety to monadic returns
 */
export const final = mkPackage(
  nixRaw`pkgs.haskellPackages.final`,
  "utility to add extra safety to monadic returns",
);

/**
 * Find the clumpiness of labels in a tree
 */
export const find_clumpiness = mkPackage(
  nixRaw`pkgs.haskellPackages.find-clumpiness`,
  "Find the clumpiness of labels in a tree",
);

/**
 * List http/html files
 */
export const findhttp = mkPackage(
  nixRaw`pkgs.haskellPackages.findhttp`,
  "List http/html files",
);

/**
 * Generic finger-tree structure, with example instances
 */
export const fingertree = mkPackage(
  nixRaw`pkgs.haskellPackages.fingertree`,
  "Generic finger-tree structure, with example instances",
);

/**
 * A better, more type-safe Enum
 */
export const finitary = mkPackage(
  nixRaw`pkgs.haskellPackages.finitary`,
  "A better, more type-safe Enum",
);

/**
 * Flexible and easy deriving of type classes for finitary types
 */
export const finitary_derive = mkPackage(
  nixRaw`pkgs.haskellPackages.finitary-derive`,
  "Flexible and easy deriving of type classes for finitary types",
);

/**
 * Prisms and Isos between finitary types
 */
export const finitary_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.finitary-optics`,
  "Prisms and Isos between finitary types",
);

/**
 * Finite Fields
 */
export const finite_field = mkPackage(
  nixRaw`pkgs.haskellPackages.finite-field`,
  "Finite Fields",
);

/**
 * Types isomorphic to Fin, and Tables indexed by them
 */
export const finite_table = mkPackage(
  nixRaw`pkgs.haskellPackages.finite-table`,
  "Types isomorphic to Fin, and Tables indexed by them",
);

/**
 * A type inhabited by finitely many values, indexed by type-level naturals
 */
export const finite_typelits = mkPackage(
  nixRaw`pkgs.haskellPackages.finite-typelits`,
  "A type inhabited by finitely many values, indexed by type-level naturals",
);

/**
 * Constraint Solver for Finite Domains
 */
export const finito = mkPackage(
  nixRaw`pkgs.haskellPackages.finito`,
  "Constraint Solver for Finite Domains",
);

/**
 * A simple HTTP server framework
 */
export const firefly = mkPackage(
  nixRaw`pkgs.haskellPackages.firefly`,
  "A simple HTTP server framework",
);

/**
 * Wrapper for Google Firestore/Datastore API
 */
export const firestore = mkPackage(
  nixRaw`pkgs.haskellPackages.firestore`,
  "Wrapper for Google Firestore/Datastore API",
);

/**
 * First-class type families
 */
export const first_class_families = mkPackage(
  nixRaw`pkgs.haskellPackages.first-class-families`,
  "First-class type families",
);

/**
 * First class patterns and pattern matching, using type families
 */
export const first_class_patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.first-class-patterns`,
  "First class patterns and pattern matching, using type families",
);

/**
 * Defunctionalisation for Yhc Core
 */
export const firstify = mkPackage(
  nixRaw`pkgs.haskellPackages.firstify`,
  "Defunctionalisation for Yhc Core",
);

/**
 * Calculates file-size frequency-distribution
 */
export const fishfood = mkPackage(
  nixRaw`pkgs.haskellPackages.fishfood`,
  "Calculates file-size frequency-distribution",
);

/**
 * refining property sets for testing Haskell programs
 */
export const fitspec = mkPackage(
  nixRaw`pkgs.haskellPackages.fitspec`,
  "refining property sets for testing Haskell programs",
);

/**
 * Simple fix-expression parser
 */
export const fix_parser_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.fix-parser-simple`,
  "Simple fix-expression parser",
);

/**
 * Fixes whitespace issues
 */
export const fix_whitespace = mkPackage(
  nixRaw`pkgs.haskellPackages.fix-whitespace`,
  "Fixes whitespace issues",
);

/**
 * Fixes whitespace issues
 */
export const fix_whitespace_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.fix-whitespace_0_1`,
  "Fixes whitespace issues",
);

/**
 * Signed 15.16 precision fixed point arithmetic
 */
export const fixed = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed`,
  "Signed 15.16 precision fixed point arithmetic",
);

/**
 * Lists with statically known length based on non-empty package
 */
export const fixed_length = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-length`,
  "Lists with statically known length based on non-empty package",
);

/**
 * A fixed length list type
 */
export const fixed_list = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-list`,
  "A fixed length list type",
);

/**
 * Unbox instances for the fixed-point package
 */
export const fixed_point_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-point-vector`,
  "Unbox instances for the fixed-point package",
);

/**
 * vector-space instances for the fixed-point package
 */
export const fixed_point_vector_space = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-point-vector-space`,
  "vector-space instances for the fixed-point package",
);

/**
 * Generic vectors with statically known size
 */
export const fixed_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-vector`,
  "Generic vectors with statically known size",
);

/**
 * Binary instances for fixed-vector
 */
export const fixed_vector_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-vector-binary`,
  "Binary instances for fixed-vector",
);

/**
 * Binary instances for fixed-vector
 */
export const fixed_vector_cborg = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-vector-cborg`,
  "Binary instances for fixed-vector",
);

/**
 * Cereal instances for fixed-vector
 */
export const fixed_vector_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.fixed-vector-cereal`,
  "Cereal instances for fixed-vector",
);

/**
 * Quick parsing of fixed-width data formats
 */
export const fixedwidth_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.fixedwidth-hs`,
  "Quick parsing of fixed-width data formats",
);

/**
 * FIX (co)parser
 */
export const fixhs = mkPackage(
  nixRaw`pkgs.haskellPackages.fixhs`,
  "FIX (co)parser",
);

/**
 * Uniplate-style generic traversals for optionally annotated fixed-point types
 */
export const fixplate = mkPackage(
  nixRaw`pkgs.haskellPackages.fixplate`,
  "Uniplate-style generic traversals for optionally annotated fixed-point types",
);

/**
 * Data types as fixpoints
 */
export const fixpoint = mkPackage(
  nixRaw`pkgs.haskellPackages.fixpoint`,
  "Data types as fixpoints",
);

/**
 * Some fixes to the time package
 */
export const fixtime = mkPackage(
  nixRaw`pkgs.haskellPackages.fixtime`,
  "Some fixes to the time package",
);

/**
 * Functional Fizz/Buzz
 */
export const fizz_buzz = mkPackage(
  nixRaw`pkgs.haskellPackages.fizz-buzz`,
  "Functional Fizz/Buzz",
);

/**
 * Complete high-level binding to libFLAC
 */
export const flac = mkPackage(
  nixRaw`pkgs.haskellPackages.flac`,
  "Complete high-level binding to libFLAC",
);

/**
 * Support for writing picture to FLAC metadata blocks with JuicyPixels
 */
export const flac_picture = mkPackage(
  nixRaw`pkgs.haskellPackages.flac-picture`,
  "Support for writing picture to FLAC metadata blocks with JuicyPixels",
);

/**
 * A simple flag type
 */
export const flag = mkPackage(
  nixRaw`pkgs.haskellPackages.flag`,
  "A simple flag type",
);

/**
 * FromDhall and ToDhall instances for flag
 */
export const flag_dhall_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.flag-dhall-instance`,
  "FromDhall and ToDhall instances for flag",
);

/**
 * Applicative flag parsing
 */
export const flags_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.flags-applicative`,
  "Applicative flag parsing",
);

/**
 * Generate language learning flashcards from video
 */
export const flashblast = mkPackage(
  nixRaw`pkgs.haskellPackages.flashblast`,
  "Generate language learning flashcards from video",
);

/**
 * Principled and efficient bit-oriented binary serialization
 */
export const flat = mkPackage(
  nixRaw`pkgs.haskellPackages.flat`,
  "Principled and efficient bit-oriented binary serialization",
);

/**
 * flatten a latex multi-file latex document and remove all comments
 */
export const flat_tex = mkPackage(
  nixRaw`pkgs.haskellPackages.flat-tex`,
  "flatten a latex multi-file latex document and remove all comments",
);

/**
 * Haskell implementation of the FlatBuffers protocol
 */
export const flatbuffers = mkPackage(
  nixRaw`pkgs.haskellPackages.flatbuffers`,
  "Haskell implementation of the FlatBuffers protocol",
);

/**
 * High-performance parsing from strict bytestrings
 */
export const flatparse = mkPackage(
  nixRaw`pkgs.haskellPackages.flatparse`,
  "High-performance parsing from strict bytestrings",
);

/**
 * High-performance parsing from strict bytestrings
 */
export const flatparse_0_5_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.flatparse_0_5_0_1`,
  "High-performance parsing from strict bytestrings",
);

/**
 * Generate default function implementations for complex type classes
 */
export const flexible_defaults = mkPackage(
  nixRaw`pkgs.haskellPackages.flexible-defaults`,
  "Generate default function implementations for complex type classes",
);

/**
 * Flexible numeric parsers for real-world programming languages
 */
export const flexible_numeric_parsers = mkPackage(
  nixRaw`pkgs.haskellPackages.flexible-numeric-parsers`,
  "Flexible numeric parsers for real-world programming languages",
);

/**
 * A configurable reimplementation of unlit
 */
export const flexible_unlit = mkPackage(
  nixRaw`pkgs.haskellPackages.flexible-unlit`,
  "A configurable reimplementation of unlit",
);

/**
 * Flexible wrappers
 */
export const flexiwrap = mkPackage(
  nixRaw`pkgs.haskellPackages.flexiwrap`,
  "Flexible wrappers",
);

/**
 * SmallCheck (Serial) instances for flexiwrap
 */
export const flexiwrap_smallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.flexiwrap-smallcheck`,
  "SmallCheck (Serial) instances for flexiwrap",
);

/**
 * work with durations of time using the Flick as the smallest unit
 */
export const flick_duration = mkPackage(
  nixRaw`pkgs.haskellPackages.flick-duration`,
  "work with durations of time using the Flick as the smallest unit",
);

/**
 * A parser for IGC files
 */
export const flight_igc = mkPackage(
  nixRaw`pkgs.haskellPackages.flight-igc`,
  "A parser for IGC files",
);

/**
 * Parsing of pilot tracklogs dumped as KML
 */
export const flight_kml = mkPackage(
  nixRaw`pkgs.haskellPackages.flight-kml`,
  "Parsing of pilot tracklogs dumped as KML",
);

/**
 * Flink stateful functions SDK
 */
export const flink_statefulfun = mkPackage(
  nixRaw`pkgs.haskellPackages.flink-statefulfun`,
  "Flink stateful functions SDK",
);

/**
 * e.g. `flip systemctl foo.service start` does `systemctl start foo.service`
 */
export const flip_cmd = mkPackage(
  nixRaw`pkgs.haskellPackages.flip-cmd`,
  "e.g. `flip systemctl foo.service start` does `systemctl start foo.service`",
);

/**
 * Variations on flip for multiple arguments
 */
export const flippers = mkPackage(
  nixRaw`pkgs.haskellPackages.flippers`,
  "Variations on flip for multiple arguments",
);

/**
 * f-lite compiler, interpreter and libraries
 */
export const flite = mkPackage(
  nixRaw`pkgs.haskellPackages.flite`,
  "f-lite compiler, interpreter and libraries",
);

/**
 * Generate flow charts from your code base
 */
export const flo = mkPackage(
  nixRaw`pkgs.haskellPackages.flo`,
  "Generate flow charts from your code base",
);

/**
 * FFI bindings for C _Float128
 */
export const float128 = mkPackage(
  nixRaw`pkgs.haskellPackages.float128`,
  "FFI bindings for C _Float128",
);

/**
 * Alternative faster String representations for Double and Float, String representations for more general numeric types
 */
export const floatshow = mkPackage(
  nixRaw`pkgs.haskellPackages.floatshow`,
  "Alternative faster String representations for Double and Float, String representations for more general numeric types",
);

/**
 * A flexible Haskell source code pretty printer
 */
export const floskell = mkPackage(
  nixRaw`pkgs.haskellPackages.floskell`,
  "A flexible Haskell source code pretty printer",
);

/**
 * A flexible Haskell source code pretty printer
 */
export const floskell_0_11_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.floskell_0_11_0`,
  "A flexible Haskell source code pretty printer",
);

/**
 * Write more understandable Haskell
 */
export const flow = mkPackage(
  nixRaw`pkgs.haskellPackages.flow`,
  "Write more understandable Haskell",
);

/**
 * Library and binary to generate sequence/flow diagrams from plain text source
 */
export const flow2dot = mkPackage(
  nixRaw`pkgs.haskellPackages.flow2dot`,
  "Library and binary to generate sequence/flow diagrams from plain text source",
);

/**
 * Analyze 454 flowgrams (.SFF files)
 */
export const flower = mkPackage(
  nixRaw`pkgs.haskellPackages.flower`,
  "Analyze 454 flowgrams (.SFF files)",
);

/**
 * Simulate 454 pyrosequencing
 */
export const flowsim = mkPackage(
  nixRaw`pkgs.haskellPackages.flowsim`,
  "Simulate 454 pyrosequencing",
);

/**
 * FLTKHS demos. Please scroll to the bottom for more information.
 */
export const fltkhs_demos = mkPackage(
  nixRaw`pkgs.haskellPackages.fltkhs-demos`,
  "FLTKHS demos. Please scroll to the bottom for more information.",
);

/**
 * Fltkhs Fluid Demos
 */
export const fltkhs_fluid_demos = mkPackage(
  nixRaw`pkgs.haskellPackages.fltkhs-fluid-demos`,
  "Fltkhs Fluid Demos",
);

/**
 * Fltkhs Fluid Examples
 */
export const fltkhs_fluid_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.fltkhs-fluid-examples`,
  "Fltkhs Fluid Examples",
);

/**
 * Fltkhs template project
 */
export const fltkhs_hello_world = mkPackage(
  nixRaw`pkgs.haskellPackages.fltkhs-hello-world`,
  "Fltkhs template project",
);

/**
 * A set of themed widgets that provides drop in replacements to the ones in FLTKHS
 */
export const fltkhs_themes = mkPackage(
  nixRaw`pkgs.haskellPackages.fltkhs-themes`,
  "A set of themed widgets that provides drop in replacements to the ones in FLTKHS",
);

/**
 * A structured logger for Fluentd (Haskell)
 */
export const fluent_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.fluent-logger`,
  "A structured logger for Fluentd (Haskell)",
);

/**
 * Conduit interface for fluent-logger
 */
export const fluent_logger_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.fluent-logger-conduit`,
  "Conduit interface for fluent-logger",
);

/**
 * A simple web application as a online practice website for XDU SE 2017 fall SPM
 */
export const fluffy = mkPackage(
  nixRaw`pkgs.haskellPackages.fluffy`,
  "A simple web application as a online practice website for XDU SE 2017 fall SPM",
);

/**
 * Concurrent bouded blocking queues optimized for flushing. Both IO and STM implementations.
 */
export const flush_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.flush-queue`,
  "Concurrent bouded blocking queues optimized for flushing. Both IO and STM implementations.",
);

/**
 * FoldMap lists
 */
export const fmlist = mkPackage(
  nixRaw`pkgs.haskellPackages.fmlist`,
  "FoldMap lists",
);

/**
 * Fields for Monadic Records library
 */
export const fmr = mkPackage(
  nixRaw`pkgs.haskellPackages.fmr`,
  "Fields for Monadic Records library",
);

/**
 * A new formatting library
 */
export const fmt = mkPackage(
  nixRaw`pkgs.haskellPackages.fmt`,
  "A new formatting library",
);

/**
 * Adaptor for getting fmt to work with rio
 */
export const fmt_for_rio = mkPackage(
  nixRaw`pkgs.haskellPackages.fmt-for-rio`,
  "Adaptor for getting fmt to work with rio",
);

/**
 * ANSI terminal colors formatters for fmt library
 */
export const fmt_terminal_colors = mkPackage(
  nixRaw`pkgs.haskellPackages.fmt-terminal-colors`,
  "ANSI terminal colors formatters for fmt library",
);

/**
 * A functional web framework
 */
export const fn = mkPackage(
  nixRaw`pkgs.haskellPackages.fn`,
  "A functional web framework",
);

/**
 * Extras for Fn, a functional web framework
 */
export const fn_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.fn-extra`,
  "Extras for Fn, a functional web framework",
);

/**
 * A general abstraction for manipulating elements of container data structures
 */
export const focus = mkPackage(
  nixRaw`pkgs.haskellPackages.focus`,
  "A general abstraction for manipulating elements of container data structures",
);

/**
 * Lists with a focused element
 */
export const focuslist = mkPackage(
  nixRaw`pkgs.haskellPackages.focuslist`,
  "Lists with a focused element",
);

/**
 * Fold multiple events that happen in a given period of time
 */
export const fold_debounce = mkPackage(
  nixRaw`pkgs.haskellPackages.fold-debounce`,
  "Fold multiple events that happen in a given period of time",
);

/**
 * Foldable types with at least 1 element
 */
export const foldable1 = mkPackage(
  nixRaw`pkgs.haskellPackages.foldable1`,
  "Foldable types with at least 1 element",
);

/**
 * Compatibility package for the Foldable1 and Bifoldable1 type classes
 */
export const foldable1_classes_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.foldable1-classes-compat`,
  "Compatibility package for the Foldable1 and Bifoldable1 type classes",
);

/**
 * Functions to find out the indices of the elements in the Foldable structures
 */
export const foldable_ix = mkPackage(
  nixRaw`pkgs.haskellPackages.foldable-ix`,
  "Functions to find out the indices of the elements in the Foldable structures",
);

/**
 * Composable, streaming, and efficient left folds
 */
export const foldl = mkPackage(
  nixRaw`pkgs.haskellPackages.foldl`,
  "Composable, streaming, and efficient left folds",
);

/**
 * Exception handling with FoldM
 */
export const foldl_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.foldl-exceptions`,
  "Exception handling with FoldM",
);

/**
 * Attoparsec and foldl-transduce integration
 */
export const foldl_transduce_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.foldl-transduce-attoparsec`,
  "Attoparsec and foldl-transduce integration",
);

/**
 * Beautiful Folding
 */
export const folds = mkPackage(
  nixRaw`pkgs.haskellPackages.folds`,
  "Beautiful Folding",
);

/**
 * Toolset for Folger Shakespeare Library's XML annotated plays
 */
export const folgerhs = mkPackage(
  nixRaw`pkgs.haskellPackages.folgerhs`,
  "Toolset for Folger Shakespeare Library's XML annotated plays",
);

/**
 * Be notified when a file gets appended, solely with what was added. Warning - only works on linux and for files that are strictly appended, like log files.
 */
export const follow_file = mkPackage(
  nixRaw`pkgs.haskellPackages.follow-file`,
  "Be notified when a file gets appended, solely with what was added. Warning - only works on linux and for files that are strictly appended, like log files.",
);

/**
 * Follow Tweets anonymously
 */
export const follower = mkPackage(
  nixRaw`pkgs.haskellPackages.follower`,
  "Follow Tweets anonymously",
);

/**
 * Simple Haskell bindings for Foma
 */
export const foma = mkPackage(
  nixRaw`pkgs.haskellPackages.foma`,
  "Simple Haskell bindings for Foma",
);

/**
 * A Font Awesome data type enumerating all icon classes
 */
export const font_awesome_type = mkPackage(
  nixRaw`pkgs.haskellPackages.font-awesome-type`,
  "A Font Awesome data type enumerating all icon classes",
);

/**
 * Paper soccer, an OpenGL game
 */
export const foo = mkPackage(
  nixRaw`pkgs.haskellPackages.foo`,
  "Paper soccer, an OpenGL game",
);

/**
 * Initial project template from stack
 */
export const foobar = mkPackage(
  nixRaw`pkgs.haskellPackages.foobar`,
  "Initial project template from stack",
);

/**
 * Simple force-directed layout
 */
export const force_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.force-layout`,
  "Simple force-directed layout",
);

/**
 * Types and instances for implementing a Storable with different peek and poke
 */
export const foreign_storable_asymmetric = mkPackage(
  nixRaw`pkgs.haskellPackages.foreign-storable-asymmetric`,
  "Types and instances for implementing a Storable with different peek and poke",
);

/**
 * Store a stable pointer in a foreign context to be retrieved later
 */
export const foreign_store = mkPackage(
  nixRaw`pkgs.haskellPackages.foreign-store`,
  "Store a stable pointer in a foreign context to be retrieved later",
);

/**
 * An implementation of forkIO for monad stacks
 */
export const forkable_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.forkable-monad`,
  "An implementation of forkIO for monad stacks",
);

/**
 * A statically typed, functional programming language
 */
export const formal = mkPackage(
  nixRaw`pkgs.haskellPackages.formal`,
  "A statically typed, functional programming language",
);

/**
 * Rendering from and scanning to format strings
 */
export const format = mkPackage(
  nixRaw`pkgs.haskellPackages.format`,
  "Rendering from and scanning to format strings",
);

/**
 * Various number formatting functions
 */
export const format_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.format-numbers`,
  "Various number formatting functions",
);

/**
 * A utility for writing the date to dzen2
 */
export const format_status = mkPackage(
  nixRaw`pkgs.haskellPackages.format-status`,
  "A utility for writing the date to dzen2",
);

/**
 * Formatting of doubles
 */
export const formatn = mkPackage(
  nixRaw`pkgs.haskellPackages.formatn`,
  "Formatting of doubles",
);

/**
 * Combinator-based type-safe formatting (like printf() or FORMAT)
 */
export const formatting = mkPackage(
  nixRaw`pkgs.haskellPackages.formatting`,
  "Combinator-based type-safe formatting (like printf() or FORMAT)",
);

/**
 * A statically typed, functional programming language
 */
export const forml = mkPackage(
  nixRaw`pkgs.haskellPackages.forml`,
  "A statically typed, functional programming language",
);

/**
 * Formlets implemented in Haskell
 */
export const formlets = mkPackage(
  nixRaw`pkgs.haskellPackages.formlets`,
  "Formlets implemented in Haskell",
);

/**
 * HSP support for Formlets
 */
export const formlets_hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.formlets-hsp`,
  "HSP support for Formlets",
);

/**
 * Parse and serialize FDF, the Forms Data Format
 */
export const forms_data_format = mkPackage(
  nixRaw`pkgs.haskellPackages.forms-data-format`,
  "Parse and serialize FDF, the Forms Data Format",
);

/**
 * ForSyDe's Haskell-embedded Domain Specific Language
 */
export const forsyde_deep = mkPackage(
  nixRaw`pkgs.haskellPackages.forsyde-deep`,
  "ForSyDe's Haskell-embedded Domain Specific Language",
);

/**
 * ForSyDe's Haskell-embedded Domain Specific Language
 */
export const forsyde_shallow = mkPackage(
  nixRaw`pkgs.haskellPackages.forsyde-shallow`,
  "ForSyDe's Haskell-embedded Domain Specific Language",
);

/**
 * A simple eDSL for generating arrayForth code
 */
export const forth_hll = mkPackage(
  nixRaw`pkgs.haskellPackages.forth-hll`,
  "A simple eDSL for generating arrayForth code",
);

/**
 * Parsers and analyses for Fortran standards 66, 77, 90, 95 and 2003 (partial)
 */
export const fortran_src = mkPackage(
  nixRaw`pkgs.haskellPackages.fortran-src`,
  "Parsers and analyses for Fortran standards 66, 77, 90, 95 and 2003 (partial)",
);

/**
 * Common functions and utils for fortran-src
 */
export const fortran_src_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.fortran-src-extras`,
  "Common functions and utils for fortran-src",
);

/**
 * Concurrent channels with a forwarding primitive
 */
export const forward_chan = mkPackage(
  nixRaw`pkgs.haskellPackages.forward-chan`,
  "Concurrent channels with a forwarding primitive",
);

/**
 * Foscam File format
 */
export const foscam_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.foscam-directory`,
  "Foscam File format",
);

/**
 * Foscam File format
 */
export const foscam_sort = mkPackage(
  nixRaw`pkgs.haskellPackages.foscam-sort`,
  "Foscam File format",
);

/**
 * Alternative prelude with batteries and no dependencies
 */
export const foundation = mkPackage(
  nixRaw`pkgs.haskellPackages.foundation`,
  "Alternative prelude with batteries and no dependencies",
);

/**
 * Alternative prelude with batteries and no dependencies
 */
export const foundation_0_0_28 = mkPackage(
  nixRaw`pkgs.haskellPackages.foundation_0_0_28`,
  "Alternative prelude with batteries and no dependencies",
);

/**
 * foundation's edge with the conventional set of packages
 */
export const foundation_edge = mkPackage(
  nixRaw`pkgs.haskellPackages.foundation-edge`,
  "foundation's edge with the conventional set of packages",
);

/**
 * A fountain codec
 */
export const fountain = mkPackage(
  nixRaw`pkgs.haskellPackages.fountain`,
  "A fountain codec",
);

/**
 * A formatter for Haskell source code
 */
export const fourmolu = mkPackage(
  nixRaw`pkgs.haskellPackages.fourmolu`,
  "A formatter for Haskell source code",
);

/**
 * A formatter for Haskell source code
 */
export const fourmolu_0_14_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.fourmolu_0_14_0_0`,
  "A formatter for Haskell source code",
);

/**
 * IEEE 754-2019 compliant operations
 */
export const fp_ieee = mkPackage(
  nixRaw`pkgs.haskellPackages.fp-ieee`,
  "IEEE 754-2019 compliant operations",
);

/**
 * Simple interface to the FP Complete IDE API
 */
export const fpco_api = mkPackage(
  nixRaw`pkgs.haskellPackages.fpco-api`,
  "Simple interface to the FP Complete IDE API",
);

/**
 * Format-preserving encryption
 */
export const fpe = mkPackage(
  nixRaw`pkgs.haskellPackages.fpe`,
  "Format-preserving encryption",
);

/**
 * F#-style composition and application
 */
export const fpipe = mkPackage(
  nixRaw`pkgs.haskellPackages.fpipe`,
  "F#-style composition and application",
);

/**
 * Haskell bindings to <https://fplll.github.io/fplll/ fplll>
 */
export const fplll = mkPackage(
  nixRaw`pkgs.haskellPackages.fplll`,
  "Haskell bindings to <https://fplll.github.io/fplll/ fplll>",
);

/**
 * A library for NLA operations
 */
export const fpnla = mkPackage(
  nixRaw`pkgs.haskellPackages.fpnla`,
  "A library for NLA operations",
);

/**
 * Example implementations for FPNLA library
 */
export const fpnla_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.fpnla-examples`,
  "Example implementations for FPNLA library",
);

/**
 * Draw Newton, Julia and Mandelbrot fractals
 */
export const fractal = mkPackage(
  nixRaw`pkgs.haskellPackages.fractal`,
  "Draw Newton, Julia and Mandelbrot fractals",
);

/**
 * Allows to approximate the fractional numbers in the range [0.005, 1] with sum of 2 or 3 unit fractions of special types.
 */
export const fractionizer = mkPackage(
  nixRaw`pkgs.haskellPackages.fractionizer`,
  "Allows to approximate the fractional numbers in the range [0.005, 1] with sum of 2 or 3 unit fractions of special types.",
);

/**
 * A markdown to Frame GUI writer for Pandoc
 */
export const frame_markdown = mkPackage(
  nixRaw`pkgs.haskellPackages.frame-markdown`,
  "A markdown to Frame GUI writer for Pandoc",
);

/**
 * Append-only database
 */
export const franz = mkPackage(
  nixRaw`pkgs.haskellPackages.franz`,
  "Append-only database",
);

/**
 * CLI frecency history
 */
export const frecently = mkPackage(
  nixRaw`pkgs.haskellPackages.frecently`,
  "CLI frecency history",
);

/**
 * Haskell application toolkit used at Freckle
 */
export const freckle_app = mkPackage(
  nixRaw`pkgs.haskellPackages.freckle-app`,
  "Haskell application toolkit used at Freckle",
);

/**
 * Monads for free
 */
export const free = mkPackage(
  nixRaw`pkgs.haskellPackages.free`,
  "Monads for free",
);

/**
 * Monads for free
 */
export const free_5_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.free_5_2`,
  "Monads for free",
);

/**
 * Free algebras
 */
export const free_algebras = mkPackage(
  nixRaw`pkgs.haskellPackages.free-algebras`,
  "Free algebras",
);

/**
 * Free Applicative Transformer
 */
export const free_applicative_t = mkPackage(
  nixRaw`pkgs.haskellPackages.free-applicative-t`,
  "Free Applicative Transformer",
);

/**
 * free categories
 */
export const free_categories = mkPackage(
  nixRaw`pkgs.haskellPackages.free-categories`,
  "free categories",
);

/**
 * efficient data types for free categories and arrows
 */
export const free_category = mkPackage(
  nixRaw`pkgs.haskellPackages.free-category`,
  "efficient data types for free categories and arrows",
);

/**
 * An extensible effects library
 */
export const free_er = mkPackage(
  nixRaw`pkgs.haskellPackages.free-er`,
  "An extensible effects library",
);

/**
 * Free functors, adjoint to functors that forget class constraints
 */
export const free_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.free-functors`,
  "Free functors, adjoint to functors that forget class constraints",
);

/**
 * Create games for free
 */
export const free_game = mkPackage(
  nixRaw`pkgs.haskellPackages.free-game`,
  "Create games for free",
);

/**
 * Automatic generation of free theorems
 */
export const free_theorems = mkPackage(
  nixRaw`pkgs.haskellPackages.free-theorems`,
  "Automatic generation of free theorems",
);

/**
 * Taming Selective Strictness
 */
export const free_theorems_seq_webui = mkPackage(
  nixRaw`pkgs.haskellPackages.free-theorems-seq-webui`,
  "Taming Selective Strictness",
);

/**
 * Instantiate the classes from the vector-space package with types from linear
 */
export const free_vector_spaces = mkPackage(
  nixRaw`pkgs.haskellPackages.free-vector-spaces`,
  "Instantiate the classes from the vector-space package with types from linear",
);

/**
 * van Laarhoven encoded Free Monad with Extensible Effects
 */
export const free_vl = mkPackage(
  nixRaw`pkgs.haskellPackages.free-vl`,
  "van Laarhoven encoded Free Monad with Extensible Effects",
);

/**
 * A soccer game
 */
export const freekick2 = mkPackage(
  nixRaw`pkgs.haskellPackages.freekick2`,
  "A soccer game",
);

/**
 * A generalisation of the Category->Functor->Applicative->Monad hierarchy and more
 */
export const freelude = mkPackage(
  nixRaw`pkgs.haskellPackages.freelude`,
  "A generalisation of the Category->Functor->Applicative->Monad hierarchy and more",
);

/**
 * Implementation of the Freer Monad
 */
export const freer = mkPackage(
  nixRaw`pkgs.haskellPackages.freer`,
  "Implementation of the Freer Monad",
);

/**
 * Handle effects conversely using monadic conversation
 */
export const freer_converse = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-converse`,
  "Handle effects conversely using monadic conversation",
);

/**
 * Freer indexed monad for type-level resource-aware effectual operations
 */
export const freer_indexed = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-indexed`,
  "Freer indexed monad for type-level resource-aware effectual operations",
);

/**
 * Checked runtime exceptions with freer-simple
 */
export const freer_simple_catching = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-simple-catching`,
  "Checked runtime exceptions with freer-simple",
);

/**
 * Make HTTP requests with freer-simple!
 */
export const freer_simple_http = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-simple-http`,
  "Make HTTP requests with freer-simple!",
);

/**
 * Automatic profling of freer-simple programs
 */
export const freer_simple_profiling = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-simple-profiling`,
  "Automatic profling of freer-simple programs",
);

/**
 * Random number generators using freer-simple
 */
export const freer_simple_random = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-simple-random`,
  "Random number generators using freer-simple",
);

/**
 * freer-simple interface to IO based time functions
 */
export const freer_simple_time = mkPackage(
  nixRaw`pkgs.haskellPackages.freer-simple-time`,
  "freer-simple interface to IO based time functions",
);

/**
 * Haskell bindings for FreeType 2 library
 */
export const freetype2 = mkPackage(
  nixRaw`pkgs.haskellPackages.freetype2`,
  "Haskell bindings for FreeType 2 library",
);

/**
 * A functional DSL for vertex-centric large-scale graph processing
 */
export const fregel = mkPackage(
  nixRaw`pkgs.haskellPackages.fregel`,
  "A functional DSL for vertex-centric large-scale graph processing",
);

/**
 * French Playing Cards
 */
export const french_cards = mkPackage(
  nixRaw`pkgs.haskellPackages.french-cards`,
  "French Playing Cards",
);

/**
 * Fresco binding for Haskell
 */
export const fresco_binding = mkPackage(
  nixRaw`pkgs.haskellPackages.fresco-binding`,
  "Fresco binding for Haskell",
);

/**
 * fresnel/fused-effects integration
 */
export const fresnel_fused_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.fresnel-fused-effects`,
  "fresnel/fused-effects integration",
);

/**
 * Uses the DevIL C library to read and write images from and to files and memory buffers
 */
export const friday_devil = mkPackage(
  nixRaw`pkgs.haskellPackages.friday-devil`,
  "Uses the DevIL C library to read and write images from and to files and memory buffers",
);

/**
 * Converts between the Friday and JuicyPixels image types
 */
export const friday_juicypixels = mkPackage(
  nixRaw`pkgs.haskellPackages.friday-juicypixels`,
  "Converts between the Friday and JuicyPixels image types",
);

/**
 * Scale Friday images with DCT
 */
export const friday_scale_dct = mkPackage(
  nixRaw`pkgs.haskellPackages.friday-scale-dct`,
  "Scale Friday images with DCT",
);

/**
 * Print time information in friendly ways
 */
export const friendly_time = mkPackage(
  nixRaw`pkgs.haskellPackages.friendly-time`,
  "Print time information in friendly ways",
);

/**
 * Linear time composable parser for PEG grammars
 */
export const frisby = mkPackage(
  nixRaw`pkgs.haskellPackages.frisby`,
  "Linear time composable parser for PEG grammars",
);

/**
 * Combinators for working with Maybe and Either
 */
export const from_sum = mkPackage(
  nixRaw`pkgs.haskellPackages.from-sum`,
  "Combinators for working with Maybe and Either",
);

/**
 * Simple adapter for transformation of HTML to other formats
 */
export const fromhtml = mkPackage(
  nixRaw`pkgs.haskellPackages.fromhtml`,
  "Simple adapter for transformation of HTML to other formats",
);

/**
 * A reactive frontend web framework
 */
export const front = mkPackage(
  nixRaw`pkgs.haskellPackages.front`,
  "A reactive frontend web framework",
);

/**
 * Parses frontmatter as used in Jekyll markdown files
 */
export const frontmatter = mkPackage(
  nixRaw`pkgs.haskellPackages.frontmatter`,
  "Parses frontmatter as used in Jekyll markdown files",
);

/**
 * Advanced rotation of backups and other things
 */
export const frotate = mkPackage(
  nixRaw`pkgs.haskellPackages.frotate`,
  "Advanced rotation of backups and other things",
);

/**
 * Program awesome stuff with Gloss and frpnow!
 */
export const frpnow_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.frpnow-gloss`,
  "Program awesome stuff with Gloss and frpnow!",
);

/**
 * Program GUIs with GTK and frpnow!
 */
export const frpnow_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.frpnow-gtk`,
  "Program GUIs with GTK and frpnow!",
);

/**
 * Program GUIs with GTK3 and frpnow!
 */
export const frpnow_gtk3 = mkPackage(
  nixRaw`pkgs.haskellPackages.frpnow-gtk3`,
  "Program GUIs with GTK3 and frpnow!",
);

/**
 * Program terminal applications with vty and frpnow!
 */
export const frpnow_vty = mkPackage(
  nixRaw`pkgs.haskellPackages.frpnow-vty`,
  "Program terminal applications with vty and frpnow!",
);

/**
 * Lexical extension for Quasi-Quotations using French-Quotes
 */
export const frquotes = mkPackage(
  nixRaw`pkgs.haskellPackages.frquotes`,
  "Lexical extension for Quasi-Quotations using French-Quotes",
);

/**
 * some F# operators, high priority pipes
 */
export const fsharp = mkPackage(
  nixRaw`pkgs.haskellPackages.fsharp`,
  "some F# operators, high priority pipes",
);

/**
 * Cross platform library for file change notification
 */
export const fsnotify = mkPackage(
  nixRaw`pkgs.haskellPackages.fsnotify`,
  "Cross platform library for file change notification",
);

/**
 * A thin layer over USB to communicate with FTDI chips
 */
export const ftdi = mkPackage(
  nixRaw`pkgs.haskellPackages.ftdi`,
  "A thin layer over USB to communicate with FTDI chips",
);

/**
 * Transfer file with FTP and FTPS with Conduit
 */
export const ftp_client_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.ftp-client-conduit`,
  "Transfer file with FTP and FTPS with Conduit",
);

/**
 * Depth-typed functor-based trees, both top-down and bottom-up
 */
export const ftree = mkPackage(
  nixRaw`pkgs.haskellPackages.ftree`,
  "Depth-typed functor-based trees, both top-down and bottom-up",
);

/**
 * Shell interface to the FreeTheorems library
 */
export const ftshell = mkPackage(
  nixRaw`pkgs.haskellPackages.ftshell`,
  "Shell interface to the FreeTheorems library",
);

/**
 * The Fudgets Library
 */
export const fudgets = mkPackage(
  nixRaw`pkgs.haskellPackages.fudgets`,
  "The Fudgets Library",
);

/**
 * A recapitulated prelude with minimal dependencies and profligate exports
 */
export const fugue = mkPackage(
  nixRaw`pkgs.haskellPackages.fugue`,
  "A recapitulated prelude with minimal dependencies and profligate exports",
);

/**
 * In-memory full text search engine
 */
export const full_text_search = mkPackage(
  nixRaw`pkgs.haskellPackages.full-text-search`,
  "In-memory full text search engine",
);

/**
 * Simple sentence segmenter
 */
export const fullstop = mkPackage(
  nixRaw`pkgs.haskellPackages.fullstop`,
  "Simple sentence segmenter",
);

/**
 * IRC bot for fun, learning, creativity and collaboration
 */
export const funbot = mkPackage(
  nixRaw`pkgs.haskellPackages.funbot`,
  "IRC bot for fun, learning, creativity and collaboration",
);

/**
 * Interact with FunBot's external events
 */
export const funbot_ext_events = mkPackage(
  nixRaw`pkgs.haskellPackages.funbot-ext-events`,
  "Interact with FunBot's external events",
);

/**
 * Git hook which sends events to FunBot
 */
export const funbot_git_hook = mkPackage(
  nixRaw`pkgs.haskellPackages.funbot-git-hook`,
  "Git hook which sends events to FunBot",
);

/**
 * Functional MetaPost is a Haskell frontend to the MetaPost language
 */
export const funcmp = mkPackage(
  nixRaw`pkgs.haskellPackages.funcmp`,
  "Functional MetaPost is a Haskell frontend to the MetaPost language",
);

/**
 * call-by-value lambda-calculus with meta-programming
 */
export const funcons_lambda_cbv_mp = mkPackage(
  nixRaw`pkgs.haskellPackages.funcons-lambda-cbv-mp`,
  "call-by-value lambda-calculus with meta-programming",
);

/**
 * A modular interpreter for executing SIMPLE funcons
 */
export const funcons_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.funcons-simple`,
  "A modular interpreter for executing SIMPLE funcons",
);

/**
 * A modular interpreter for executing funcons
 */
export const funcons_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.funcons-tools`,
  "A modular interpreter for executing funcons",
);

/**
 * Create poly variadic functions for monoidal results
 */
export const function_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.function-builder`,
  "Create poly variadic functions for monoidal results",
);

/**
 * Combining functions
 */
export const function_combine = mkPackage(
  nixRaw`pkgs.haskellPackages.function-combine`,
  "Combining functions",
);

/**
 * Combinators that allow for a more functional/monadic style of Arrow programming
 */
export const functional_arrow = mkPackage(
  nixRaw`pkgs.haskellPackages.functional-arrow`,
  "Combinators that allow for a more functional/monadic style of Arrow programming",
);

/**
 * KMP implemented on haskell's built-in cons-cell-based lists
 */
export const functional_kmp = mkPackage(
  nixRaw`pkgs.haskellPackages.functional-kmp`,
  "KMP implemented on haskell's built-in cons-cell-based lists",
);

/**
 * Functors
 */
export const functor = mkPackage(
  nixRaw`pkgs.haskellPackages.functor`,
  "Functors",
);

/**
 * This package has been subsumed by semigroupoids
 */
export const functor_apply = mkPackage(
  nixRaw`pkgs.haskellPackages.functor-apply`,
  "This package has been subsumed by semigroupoids",
);

/**
 * Data.Functor.Classes instances for core packages
 */
export const functor_classes_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.functor-classes-compat`,
  "Data.Functor.Classes instances for core packages",
);

/**
 * Tools for functor combinator-based program design
 */
export const functor_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.functor-combinators`,
  "Tools for functor combinator-based program design",
);

/**
 * Functor combinators with tries & zippers
 */
export const functor_combo = mkPackage(
  nixRaw`pkgs.haskellPackages.functor-combo`,
  "Functor combinators with tries & zippers",
);

/**
 * Monad-style combinators for functors
 */
export const functor_monadic = mkPackage(
  nixRaw`pkgs.haskellPackages.functor-monadic`,
  "Monad-style combinators for functors",
);

/**
 * (.:) and friends, syntax for Functor and Applicative.
 */
export const functors = mkPackage(
  nixRaw`pkgs.haskellPackages.functors`,
  "(.:) and friends, syntax for Functor and Applicative.",
);

/**
 * Workflows with arrows
 */
export const funflow = mkPackage(
  nixRaw`pkgs.haskellPackages.funflow`,
  "Workflows with arrows",
);

/**
 * Utility functions for using funflow with nix
 */
export const funflow_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.funflow-nix`,
  "Utility functions for using funflow with nix",
);

/**
 * GLL parser with simple combinator interface
 */
export const fungll_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.fungll-combinators`,
  "GLL parser with simple combinator interface",
);

/**
 * A unioning file-system using HFuse
 */
export const funion = mkPackage(
  nixRaw`pkgs.haskellPackages.funion`,
  "A unioning file-system using HFuse",
);

/**
 * funnyPrint function to colorize GHCi output
 */
export const funnyprint = mkPackage(
  nixRaw`pkgs.haskellPackages.funnyprint`,
  "funnyPrint function to colorize GHCi output",
);

/**
 * A modern DPLL-style SAT solver
 */
export const funsat = mkPackage(
  nixRaw`pkgs.haskellPackages.funsat`,
  "A modern DPLL-style SAT solver",
);

/**
 * A fast, flexible, fused effect system
 */
export const fused_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects`,
  "A fast, flexible, fused effect system",
);

/**
 * Monadic lens combinators for fused-effects
 */
export const fused_effects_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects-lens`,
  "Monadic lens combinators for fused-effects",
);

/**
 * Bridge between the optics and fused-effects ecosystems
 */
export const fused_effects_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects-optics`,
  "Bridge between the optics and fused-effects ecosystems",
);

/**
 * Random number generation for fused-effects
 */
export const fused_effects_random = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects-random`,
  "Random number generation for fused-effects",
);

/**
 * A readline-like effect and carrier for fused-effects
 */
export const fused_effects_readline = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects-readline`,
  "A readline-like effect and carrier for fused-effects",
);

/**
 * A fused-effects adapter for squeal-postgresql
 */
export const fused_effects_squeal = mkPackage(
  nixRaw`pkgs.haskellPackages.fused-effects-squeal`,
  "A fused-effects adapter for squeal-postgresql",
);

/**
 * GHC plugin to make stream fusion more predictable
 */
export const fusion_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.fusion-plugin`,
  "GHC plugin to make stream fusion more predictable",
);

/**
 * Types for the fusion-plugin package
 */
export const fusion_plugin_types = mkPackage(
  nixRaw`pkgs.haskellPackages.fusion-plugin-types`,
  "Types for the fusion-plugin package",
);

/**
 * An implementation of the Futhark data format
 */
export const futhark_data = mkPackage(
  nixRaw`pkgs.haskellPackages.futhark-data`,
  "An implementation of the Futhark data format",
);

/**
 * Definition and serialisation instances for Futhark manifests
 */
export const futhark_manifest = mkPackage(
  nixRaw`pkgs.haskellPackages.futhark-manifest`,
  "Definition and serialisation instances for Futhark manifests",
);

/**
 * Client implementation of the Futhark server protocol
 */
export const futhark_server = mkPackage(
  nixRaw`pkgs.haskellPackages.futhark-server`,
  "Client implementation of the Futhark server protocol",
);

/**
 * realtime resource handling with manual concurrency
 */
export const future_resource = mkPackage(
  nixRaw`pkgs.haskellPackages.future-resource`,
  "realtime resource handling with manual concurrency",
);

/**
 * A simple checker for stress testing monadic code
 */
export const fuzzcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzcheck`,
  "A simple checker for stress testing monadic code",
);

/**
 * Filters a list based on a fuzzy string search
 */
export const fuzzy = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzy`,
  "Filters a list based on a fuzzy string search",
);

/**
 * Libary for parsing dates in strings in varied formats
 */
export const fuzzy_dates = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzy-dates`,
  "Libary for parsing dates in strings in varied formats",
);

/**
 * Tools for processing unstructured text data
 */
export const fuzzy_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzy-parse`,
  "Tools for processing unstructured text data",
);

export const fuzzy_time = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzy-time`,
  "",
);

export const fuzzy_time_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzy-time-gen`,
  "",
);

/**
 * A 'ten past six' style clock
 */
export const fuzzytime = mkPackage(
  nixRaw`pkgs.haskellPackages.fuzzytime`,
  "A 'ten past six' style clock",
);

/**
 * FWGL GLFW backend
 */
export const fwgl_glfw = mkPackage(
  nixRaw`pkgs.haskellPackages.fwgl-glfw`,
  "FWGL GLFW backend",
);

/**
 * FWGL GHCJS backend
 */
export const fwgl_javascript = mkPackage(
  nixRaw`pkgs.haskellPackages.fwgl-javascript`,
  "FWGL GHCJS backend",
);

/**
 * Horizontally composable effects
 */
export const fx = mkPackage(
  nixRaw`pkgs.haskellPackages.fx`,
  "Horizontally composable effects",
);

/**
 * Interface to the FXPak/FXPak Pro USB interface
 */
export const fxpak = mkPackage(
  nixRaw`pkgs.haskellPackages.fxpak`,
  "Interface to the FXPak/FXPak Pro USB interface",
);

/**
 * Haskell symbolic execution engine
 */
export const g2 = mkPackage(
  nixRaw`pkgs.haskellPackages.g2`,
  "Haskell symbolic execution engine",
);

/**
 * G2Q allows constraint programming, via writing Haskell predicates
 */
export const g2q = mkPackage(
  nixRaw`pkgs.haskellPackages.g2q`,
  "G2Q allows constraint programming, via writing Haskell predicates",
);

/**
 * Theorem prover for intuitionistic propositional logic using G4ip
 */
export const g4ip_prover = mkPackage(
  nixRaw`pkgs.haskellPackages.g4ip-prover`,
  "Theorem prover for intuitionistic propositional logic using G4ip",
);

/**
 * General Alignment Clustering Tool
 */
export const gact = mkPackage(
  nixRaw`pkgs.haskellPackages.gact`,
  "General Alignment Clustering Tool",
);

/**
 * FFTs over finite fields
 */
export const galois_fft = mkPackage(
  nixRaw`pkgs.haskellPackages.galois-fft`,
  "FFTs over finite fields",
);

/**
 * Galois field library
 */
export const galois_field = mkPackage(
  nixRaw`pkgs.haskellPackages.galois-field`,
  "Galois field library",
);

/**
 * Composable, streaming, and efficient left folds
 */
export const gambler = mkPackage(
  nixRaw`pkgs.haskellPackages.gambler`,
  "Composable, streaming, and efficient left folds",
);

/**
 * Conway's Game of Life
 */
export const game_of_life = mkPackage(
  nixRaw`pkgs.haskellPackages.game-of-life`,
  "Conway's Game of Life",
);

/**
 * Searching game trees with alpha-beta pruning
 */
export const game_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.game-tree`,
  "Searching game trees with alpha-beta pruning",
);

/**
 * Gamma function and related functions
 */
export const gamma = mkPackage(
  nixRaw`pkgs.haskellPackages.gamma`,
  "Gamma function and related functions",
);

/**
 * Non-deterministic parallelism with bags
 */
export const gang_of_threads = mkPackage(
  nixRaw`pkgs.haskellPackages.gang-of-threads`,
  "Non-deterministic parallelism with bags",
);

/**
 * TBA
 */
export const garfield = mkPackage(
  nixRaw`pkgs.haskellPackages.garfield`,
  "TBA",
);

/**
 * Manage PostgreSQL servers with gargoyle
 */
export const gargoyle_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.gargoyle-postgresql`,
  "Manage PostgreSQL servers with gargoyle",
);

/**
 * Connect to gargoyle-managed postgresql instances
 */
export const gargoyle_postgresql_connect = mkPackage(
  nixRaw`pkgs.haskellPackages.gargoyle-postgresql-connect`,
  "Connect to gargoyle-managed postgresql instances",
);

/**
 * Manage PostgreSQL servers with gargoyle and nix
 */
export const gargoyle_postgresql_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.gargoyle-postgresql-nix`,
  "Manage PostgreSQL servers with gargoyle and nix",
);

/**
 * A monad transformer for keeping track of where you've come from
 */
export const garlic_bread = mkPackage(
  nixRaw`pkgs.haskellPackages.garlic-bread`,
  "A monad transformer for keeping track of where you've come from",
);

/**
 * A Functional Implementation of the Garsia-Wachs Algorithm
 */
export const garsia_wachs = mkPackage(
  nixRaw`pkgs.haskellPackages.garsia-wachs`,
  "A Functional Implementation of the Garsia-Wachs Algorithm",
);

/**
 * A framework of algebraic classes
 */
export const gasp = mkPackage(
  nixRaw`pkgs.haskellPackages.gasp`,
  "A framework of algebraic classes",
);

/**
 * small framework for performance measurement and analysis
 */
export const gauge = mkPackage(
  nixRaw`pkgs.haskellPackages.gauge`,
  "small framework for performance measurement and analysis",
);

/**
 * A library for downloading data from a Great Black Swamp server
 */
export const gbs_downloader = mkPackage(
  nixRaw`pkgs.haskellPackages.gbs-downloader`,
  "A library for downloading data from a Great Black Swamp server",
);

/**
 * planar graph embedding into a plane
 */
export const gbu = mkPackage(
  nixRaw`pkgs.haskellPackages.gbu`,
  "planar graph embedding into a plane",
);

/**
 * Poor Richard's Memory Manager
 */
export const gc = mkPackage(
  nixRaw`pkgs.haskellPackages.gc`,
  "Poor Richard's Memory Manager",
);

/**
 * GCode processor
 */
export const gcodehs = mkPackage(
  nixRaw`pkgs.haskellPackages.gcodehs`,
  "GCode processor",
);

/**
 * A Haskell binding to a subset of the GD graphics library
 */
export const gd = mkPackage(
  nixRaw`pkgs.haskellPackages.gd`,
  "A Haskell binding to a subset of the GD graphics library",
);

/**
 * API Wrapping for Coinbase's GDAX exchange
 */
export const gdax = mkPackage(
  nixRaw`pkgs.haskellPackages.gdax`,
  "API Wrapping for Coinbase's GDAX exchange",
);

/**
 * GDELT V2 (Global Database of Events, Language, and Tone)
 */
export const gdelt = mkPackage(
  nixRaw`pkgs.haskellPackages.gdelt`,
  "GDELT V2 (Global Database of Events, Language, and Tone)",
);

/**
 * Generic diff and patch
 */
export const gdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.gdiff`,
  "Generic diff and patch",
);

/**
 * Generic diff for the instant-generics library
 */
export const gdiff_ig = mkPackage(
  nixRaw`pkgs.haskellPackages.gdiff-ig`,
  "Generic diff for the instant-generics library",
);

/**
 * recursive atomic build system
 */
export const gdo = mkPackage(
  nixRaw`pkgs.haskellPackages.gdo`,
  "recursive atomic build system",
);

/**
 * Reason about invariants and preconditions with ghosts of departed proofs
 */
export const gdp = mkPackage(
  nixRaw`pkgs.haskellPackages.gdp`,
  "Reason about invariants and preconditions with ghosts of departed proofs",
);

/**
 * zooming rotating fractal gears graphics demo
 */
export const gearbox = mkPackage(
  nixRaw`pkgs.haskellPackages.gearbox`,
  "zooming rotating fractal gears graphics demo",
);

/**
 * An implementation of Gear hash, a fast rolling hash algorithm
 */
export const gearhash = mkPackage(
  nixRaw`pkgs.haskellPackages.gearhash`,
  "An implementation of Gear hash, a fast rolling hash algorithm",
);

/**
 * Parser for the GEDCOM genealogy file format
 */
export const gedcom = mkPackage(
  nixRaw`pkgs.haskellPackages.gedcom`,
  "Parser for the GEDCOM genealogy file format",
);

/**
 * Geek blog engine
 */
export const geek = mkPackage(
  nixRaw`pkgs.haskellPackages.geek`,
  "Geek blog engine",
);

/**
 * Geek blog engine server
 */
export const geek_server = mkPackage(
  nixRaw`pkgs.haskellPackages.geek-server`,
  "Geek blog engine server",
);

/**
 * Haskell bindings to GEGL library
 */
export const gegl = mkPackage(
  nixRaw`pkgs.haskellPackages.gegl`,
  "Haskell bindings to GEGL library",
);

/**
 * FreeType2 based text rendering for the gelatin realtime rendering system
 */
export const gelatin_freetype2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gelatin-freetype2`,
  "FreeType2 based text rendering for the gelatin realtime rendering system",
);

/**
 * Gelatin's support for rendering TTF outlines, using FontyFruity
 */
export const gelatin_fruity = mkPackage(
  nixRaw`pkgs.haskellPackages.gelatin-fruity`,
  "Gelatin's support for rendering TTF outlines, using FontyFruity",
);

/**
 * OpenGL rendering routines for the gelatin-picture graphics EDSL
 */
export const gelatin_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.gelatin-gl`,
  "OpenGL rendering routines for the gelatin-picture graphics EDSL",
);

/**
 * An SDL2 backend for the gelatin renderer
 */
export const gelatin_sdl2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gelatin-sdl2`,
  "An SDL2 backend for the gelatin renderer",
);

/**
 * Gelatin's OpenGL shaders
 */
export const gelatin_shaders = mkPackage(
  nixRaw`pkgs.haskellPackages.gelatin-shaders`,
  "Gelatin's OpenGL shaders",
);

/**
 * Generate CSV Exports of Your Gemini Trades, Transfers, & Earn Transactions
 */
export const gemini_exports = mkPackage(
  nixRaw`pkgs.haskellPackages.gemini-exports`,
  "Generate CSV Exports of Your Gemini Trades, Transfers, & Earn Transactions",
);

/**
 * A simple Happstack-style Gemini router
 */
export const gemini_router = mkPackage(
  nixRaw`pkgs.haskellPackages.gemini-router`,
  "A simple Happstack-style Gemini router",
);

/**
 * A lightweight server for the Gemini protocol
 */
export const gemini_server = mkPackage(
  nixRaw`pkgs.haskellPackages.gemini-server`,
  "A lightweight server for the Gemini protocol",
);

/**
 * A barebones textboard for the Gemini protocol
 */
export const gemini_textboard = mkPackage(
  nixRaw`pkgs.haskellPackages.gemini-textboard`,
  "A barebones textboard for the Gemini protocol",
);

/**
 * A testing framework inspired by QuickCheck and SmallCheck
 */
export const gencheck = mkPackage(
  nixRaw`pkgs.haskellPackages.gencheck`,
  "A testing framework inspired by QuickCheck and SmallCheck",
);

/**
 * Library for generating interface documentation from types
 */
export const gendocs = mkPackage(
  nixRaw`pkgs.haskellPackages.gendocs`,
  "Library for generating interface documentation from types",
);

/**
 * Library supporting simulation of a number of games
 */
export const general_games = mkPackage(
  nixRaw`pkgs.haskellPackages.general-games`,
  "Library supporting simulation of a number of games",
);

/**
 * stringly-named getters for generic data
 */
export const generic_accessors = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-accessors`,
  "stringly-named getters for generic data",
);

/**
 * Generic implementation for QuickCheck's Arbitrary
 */
export const generic_arbitrary = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-arbitrary`,
  "Generic implementation for QuickCheck's Arbitrary",
);

/**
 * Constraints via Generic
 */
export const generic_constraints = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-constraints`,
  "Constraints via Generic",
);

/**
 * Deriving instances with GHC.Generics and related utilities
 */
export const generic_data = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-data`,
  "Deriving instances with GHC.Generics and related utilities",
);

/**
 * Familiar functions lifted to generic data types
 */
export const generic_data_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-data-functions`,
  "Familiar functions lifted to generic data types",
);

/**
 * Surgery for generic data types
 */
export const generic_data_surgery = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-data-surgery`,
  "Surgery for generic data types",
);

/**
 * Generic deep evaluation of data structures
 */
export const generic_deepseq = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-deepseq`,
  "Generic deep evaluation of data structures",
);

/**
 * Generic programming library for generalised deriving
 */
export const generic_deriving = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-deriving`,
  "Generic programming library for generalised deriving",
);

/**
 * Generic Environment Generator
 */
export const generic_env = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-env`,
  "Generic Environment Generator",
);

/**
 * Deriving generalized functors with GHC.Generics
 */
export const generic_functor = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-functor`,
  "Deriving generalized functors with GHC.Generics",
);

/**
 * Generically derive traversals, lenses and prisms
 */
export const generic_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-lens`,
  "Generically derive traversals, lenses and prisms",
);

/**
 * Generically derive traversals, lenses and prisms
 */
export const generic_lens_core = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-lens-core`,
  "Generically derive traversals, lenses and prisms",
);

/**
 * Monomorphic field lens like with generic-lens
 */
export const generic_lens_lite = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-lens-lite`,
  "Monomorphic field lens like with generic-lens",
);

/**
 * Derive Bounded and Enum for sum types and Enum for product types
 */
export const generic_lexicographic_order = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-lexicographic-order`,
  "Derive Bounded and Enum for sum types and Enum for product types",
);

/**
 * Derive monoid instances for product types
 */
export const generic_monoid = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-monoid`,
  "Derive monoid instances for product types",
);

/**
 * Generically derive traversals, lenses and prisms
 */
export const generic_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-optics`,
  "Generically derive traversals, lenses and prisms",
);

/**
 * Monomorphic field opics like with generic-lens
 */
export const generic_optics_lite = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-optics-lite`,
  "Monomorphic field opics like with generic-lens",
);

/**
 * Provides orphan instances necessary for integrating generic-override and aeson
 */
export const generic_override_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-override-aeson`,
  "Provides orphan instances necessary for integrating generic-override and aeson",
);

/**
 * Generic random generators for QuickCheck
 */
export const generic_random = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-random`,
  "Generic random generators for QuickCheck",
);

/**
 * A map, where the keys may be complex structured data
 */
export const generic_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-trie`,
  "A map, where the keys may be complex structured data",
);

/**
 * Marshalling Haskell values to/from XML
 */
export const generic_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.generic-xml`,
  "Marshalling Haskell values to/from XML",
);

/**
 * Generically newtype to use with DerivingVia
 */
export const generically = mkPackage(
  nixRaw`pkgs.haskellPackages.generically`,
  "Generically newtype to use with DerivingVia",
);

/**
 * A library for generic programming that aims to be easy to understand
 */
export const generics_eot = mkPackage(
  nixRaw`pkgs.haskellPackages.generics-eot`,
  "A library for generic programming that aims to be easy to understand",
);

/**
 * Reimplementation of the gdiff algorithm for generics-mrsop
 */
export const generics_mrsop_gdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.generics-mrsop-gdiff`,
  "Reimplementation of the gdiff algorithm for generics-mrsop",
);

/**
 * Generic Programming using True Sums of Products
 */
export const generics_sop = mkPackage(
  nixRaw`pkgs.haskellPackages.generics-sop`,
  "Generic Programming using True Sums of Products",
);

/**
 * Lenses for types in generics-sop
 */
export const generics_sop_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.generics-sop-lens`,
  "Lenses for types in generics-sop",
);

/**
 * Opinionated bootstrapping for Haskell web services
 */
export const genesis = mkPackage(
  nixRaw`pkgs.haskellPackages.genesis`,
  "Opinionated bootstrapping for Haskell web services",
);

/**
 * Opinionated bootstrapping for Haskell web services
 */
export const genesis_test = mkPackage(
  nixRaw`pkgs.haskellPackages.genesis-test`,
  "Opinionated bootstrapping for Haskell web services",
);

/**
 * GenI graphical user interface
 */
export const geni_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.geni-gui`,
  "GenI graphical user interface",
);

/**
 * Companion tools for use with the GenI surface realiser
 */
export const geni_util = mkPackage(
  nixRaw`pkgs.haskellPackages.geni-util`,
  "Companion tools for use with the GenI surface realiser",
);

/**
 * Conversion utility for the GenI generator
 */
export const geniconvert = mkPackage(
  nixRaw`pkgs.haskellPackages.geniconvert`,
  "Conversion utility for the GenI generator",
);

/**
 * Use Template Haskell to generate Uniplate-like functions
 */
export const geniplate_mirror = mkPackage(
  nixRaw`pkgs.haskellPackages.geniplate-mirror`,
  "Use Template Haskell to generate Uniplate-like functions",
);

/**
 * Simple HTTP server for GenI results
 */
export const geniserver = mkPackage(
  nixRaw`pkgs.haskellPackages.geniserver`,
  "Simple HTTP server for GenI results",
);

/**
 * Testing utilities for the validity library
 */
export const genvalidity = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity`,
  "Testing utilities for the validity library",
);

/**
 * GenValidity support for aeson
 */
export const genvalidity_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-aeson`,
  "GenValidity support for aeson",
);

export const genvalidity_appendful = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-appendful`,
  "",
);

/**
 * GenValidity support for ByteString
 */
export const genvalidity_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-bytestring`,
  "GenValidity support for ByteString",
);

/**
 * GenValidity support for case-insensitive
 */
export const genvalidity_case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-case-insensitive`,
  "GenValidity support for case-insensitive",
);

/**
 * GenValidity support for containers
 */
export const genvalidity_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-containers`,
  "GenValidity support for containers",
);

/**
 * Criterion benchmarks for generators
 */
export const genvalidity_criterion = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-criterion`,
  "Criterion benchmarks for generators",
);

/**
 * Generators for typed directory forests
 */
export const genvalidity_dirforest = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-dirforest`,
  "Generators for typed directory forests",
);

/**
 * Standard spec's for GenValidity instances
 */
export const genvalidity_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec`,
  "Standard spec's for GenValidity instances",
);

/**
 * Standard spec's for GenValidity instances
 */
export const genvalidity_hspec_1_0_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec_1_0_0_3`,
  "Standard spec's for GenValidity instances",
);

/**
 * Standard spec's for aeson-related instances
 */
export const genvalidity_hspec_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-aeson`,
  "Standard spec's for aeson-related instances",
);

/**
 * Standard spec's for binary-related Instances
 */
export const genvalidity_hspec_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-binary`,
  "Standard spec's for binary-related Instances",
);

/**
 * Standard spec's for cereal-related instances
 */
export const genvalidity_hspec_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-cereal`,
  "Standard spec's for cereal-related instances",
);

/**
 * Standard spec's for Hashable instances
 */
export const genvalidity_hspec_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-hashable`,
  "Standard spec's for Hashable instances",
);

/**
 * Standard spec's for Hashable instances
 */
export const genvalidity_hspec_hashable_1_0_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-hashable_1_0_0_1`,
  "Standard spec's for Hashable instances",
);

/**
 * Standard spec's for lens
 */
export const genvalidity_hspec_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-optics`,
  "Standard spec's for lens",
);

/**
 * Standard spec's for persistent-related instances
 */
export const genvalidity_hspec_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-hspec-persistent`,
  "Standard spec's for persistent-related instances",
);

export const genvalidity_mergeful = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-mergeful`,
  "",
);

export const genvalidity_mergeless = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-mergeless`,
  "",
);

/**
 * GenValidity support for URI
 */
export const genvalidity_network_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-network-uri`,
  "GenValidity support for URI",
);

/**
 * GenValidity support for Path
 */
export const genvalidity_path = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-path`,
  "GenValidity support for Path",
);

/**
 * GenValidity support for Persistent
 */
export const genvalidity_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-persistent`,
  "GenValidity support for Persistent",
);

/**
 * GenValidity support for Persistent
 */
export const genvalidity_persistent_1_0_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-persistent_1_0_0_2`,
  "GenValidity support for Persistent",
);

/**
 * Standard properties for functions on `Validity` types
 */
export const genvalidity_property = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-property`,
  "Standard properties for functions on `Validity` types",
);

/**
 * GenValidity support for Scientific
 */
export const genvalidity_scientific = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-scientific`,
  "GenValidity support for Scientific",
);

/**
 * Standard properties for functions on `Validity` types for the sydtest framework
 */
export const genvalidity_sydtest = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest`,
  "Standard properties for functions on `Validity` types for the sydtest framework",
);

/**
 * Standard spec's for aeson-related instances in sydtest
 */
export const genvalidity_sydtest_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest-aeson`,
  "Standard spec's for aeson-related instances in sydtest",
);

/**
 * Standard spec's for Hashable instances for sydtest
 */
export const genvalidity_sydtest_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest-hashable`,
  "Standard spec's for Hashable instances for sydtest",
);

/**
 * Standard spec's for Hashable instances for sydtest
 */
export const genvalidity_sydtest_hashable_1_0_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest-hashable_1_0_0_1`,
  "Standard spec's for Hashable instances for sydtest",
);

/**
 * Standard spec's for lens for sydtest
 */
export const genvalidity_sydtest_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest-lens`,
  "Standard spec's for lens for sydtest",
);

/**
 * Standard spec's for persistent-related instances for sydtest
 */
export const genvalidity_sydtest_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-sydtest-persistent`,
  "Standard spec's for persistent-related instances for sydtest",
);

/**
 * GenValidity support for Text
 */
export const genvalidity_text = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-text`,
  "GenValidity support for Text",
);

/**
 * GenValidity support for time
 */
export const genvalidity_time = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-time`,
  "GenValidity support for time",
);

/**
 * Generators for Phantom-Typed version of UUID
 */
export const genvalidity_typed_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-typed-uuid`,
  "Generators for Phantom-Typed version of UUID",
);

/**
 * GenValidity support for unordered-containers
 */
export const genvalidity_unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-unordered-containers`,
  "GenValidity support for unordered-containers",
);

/**
 * GenValidity support for unordered-containers
 */
export const genvalidity_unordered_containers_1_0_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-unordered-containers_1_0_0_1`,
  "GenValidity support for unordered-containers",
);

/**
 * GenValidity support for UUID
 */
export const genvalidity_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-uuid`,
  "GenValidity support for UUID",
);

/**
 * GenValidity support for vector
 */
export const genvalidity_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.genvalidity-vector`,
  "GenValidity support for vector",
);

/**
 * Libary for calculating distances between two coordinates in WSG84
 */
export const geocalc = mkPackage(
  nixRaw`pkgs.haskellPackages.geocalc`,
  "Libary for calculating distances between two coordinates in WSG84",
);

/**
 * Geodetic calculations
 */
export const geodetic = mkPackage(
  nixRaw`pkgs.haskellPackages.geodetic`,
  "Geodetic calculations",
);

/**
 * Terrestrial coordinate systems and geodetic calculations
 */
export const geodetics = mkPackage(
  nixRaw`pkgs.haskellPackages.geodetics`,
  "Terrestrial coordinate systems and geodetic calculations",
);

/**
 * Geohash latitudes and longitudes
 */
export const geohash = mkPackage(
  nixRaw`pkgs.haskellPackages.geohash`,
  "Geohash latitudes and longitudes",
);

/**
 * Pure haskell interface to MaxMind GeoIP database
 */
export const geoip2 = mkPackage(
  nixRaw`pkgs.haskellPackages.geoip2`,
  "Pure haskell interface to MaxMind GeoIP database",
);

/**
 * A thin GeoJSON Layer above the aeson library
 */
export const geojson = mkPackage(
  nixRaw`pkgs.haskellPackages.geojson`,
  "A thin GeoJSON Layer above the aeson library",
);

/**
 * Geolite CSV Parser
 */
export const geolite_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.geolite-csv`,
  "Geolite CSV Parser",
);

/**
 * Geometry and matrix manipulation
 */
export const geomancy = mkPackage(
  nixRaw`pkgs.haskellPackages.geomancy`,
  "Geometry and matrix manipulation",
);

/**
 * Geometry and matrix manipulation
 */
export const geomancy_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.geomancy-layout`,
  "Geometry and matrix manipulation",
);

/**
 * Fetch from emusic using .emx files
 */
export const getemx = mkPackage(
  nixRaw`pkgs.haskellPackages.getemx`,
  "Fetch from emusic using .emx files",
);

/**
 * Create command line interfaces with ease
 */
export const getopt_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.getopt-generics`,
  "Create command line interfaces with ease",
);

/**
 * A "System.Console.GetOpt" wrapper to make simple use case easy.
 */
export const getopt_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.getopt-simple`,
  "A \"System.Console.GetOpt\" wrapper to make simple use case easy.",
);

/**
 * gettext-th can internationalise a haskell program without runtime dependencies
 */
export const gettext_th = mkPackage(
  nixRaw`pkgs.haskellPackages.gettext-th`,
  "gettext-th can internationalise a haskell program without runtime dependencies",
);

/**
 * Script helpers for interacting with GitHub
 */
export const gh_pocket_knife = mkPackage(
  nixRaw`pkgs.haskellPackages.gh-pocket-knife`,
  "Script helpers for interacting with GitHub",
);

/**
 * The Glasgow Haskell Compiler
 */
export const ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc`,
  "The Glasgow Haskell Compiler",
);

/**
 * The GHC API
 */
export const ghc_9_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc_9_6_3`,
  "The GHC API",
);

/**
 * GHC BigNum library
 */
export const ghc_bignum_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-bignum_1_3`,
  "GHC BigNum library",
);

/**
 * Backwards-compatible orphan instances for ghc-bignum
 */
export const ghc_bignum_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-bignum-orphans`,
  "Backwards-compatible orphan instances for ghc-bignum",
);

/**
 * Shared functionality between GHC and its boot libraries
 */
export const ghc_boot_9_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-boot_9_6_3`,
  "Shared functionality between GHC and its boot libraries",
);

/**
 * Shared functionality between GHC and the @template-haskell@ library
 */
export const ghc_boot_th_9_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-boot-th_9_6_3`,
  "Shared functionality between GHC and the @template-haskell@ library",
);

/**
 * "GHC.ByteOrder" API Compatibility Layer
 */
export const ghc_byteorder = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-byteorder`,
  "\"GHC.ByteOrder\" API Compatibility Layer",
);

/**
 * Extra utilities for HasCallStack
 */
export const ghc_call_stack_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-call-stack-extras`,
  "Extra utilities for HasCallStack",
);

/**
 * detect mismatches between compile-time and run-time versions of the ghc api
 */
export const ghc_check = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-check`,
  "detect mismatches between compile-time and run-time versions of the ghc api",
);

/**
 * In memory storage of deeply evaluated data structure
 */
export const ghc_compact_0_1_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-compact_0_1_0_0`,
  "In memory storage of deeply evaluated data structure",
);

/**
 * Display GHC's core and assembly output in a pager
 */
export const ghc_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-core`,
  "Display GHC's core and assembly output in a pager",
);

/**
 * Core to HTML display
 */
export const ghc_core_html = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-core-html`,
  "Core to HTML display",
);

/**
 * A simple TUI using ghc-debug
 */
export const ghc_debug_brick = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-debug-brick`,
  "A simple TUI using ghc-debug",
);

/**
 * Useful functions for writing heap analysis tools which use ghc-debug
 */
export const ghc_debug_client = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-debug-client`,
  "Useful functions for writing heap analysis tools which use ghc-debug",
);

/**
 * Connect to a socket created by ghc-debug-stub and analyse the heap of the debuggee program
 */
export const ghc_debug_common = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-debug-common`,
  "Connect to a socket created by ghc-debug-stub and analyse the heap of the debuggee program",
);

/**
 * Definitions needed by ghc-debug-stub and ghc-debug-common
 */
export const ghc_debug_convention = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-debug-convention`,
  "Definitions needed by ghc-debug-stub and ghc-debug-common",
);

/**
 * Functions for instrumenting your application so the heap can be analysed with ghc-debug-common
 */
export const ghc_debug_stub = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-debug-stub`,
  "Functions for instrumenting your application so the heap can be analysed with ghc-debug-common",
);

/**
 * Handy tools for working with ghc-dump dumps
 */
export const ghc_dump_util = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-dump-util`,
  "Handy tools for working with ghc-dump dumps",
);

/**
 * Library and tool for parsing .eventlog files from GHC
 */
export const ghc_events = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-events`,
  "Library and tool for parsing .eventlog files from GHC",
);

/**
 * ExactPrint for GHC
 */
export const ghc_exactprint = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-exactprint`,
  "ExactPrint for GHC",
);

/**
 * ExactPrint for GHC
 */
export const ghc_exactprint_0_6_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-exactprint_0_6_4`,
  "ExactPrint for GHC",
);

/**
 * ExactPrint for GHC
 */
export const ghc_exactprint_1_5_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-exactprint_1_5_0`,
  "ExactPrint for GHC",
);

/**
 * ExactPrint for GHC
 */
export const ghc_exactprint_1_7_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-exactprint_1_7_0_1`,
  "ExactPrint for GHC",
);

/**
 * Graph performance of Haskell programs with different GC flags
 */
export const ghc_gc_tune = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-gc-tune`,
  "Graph performance of Haskell programs with different GC flags",
);

/**
 * Functions for walking GHC's heap
 */
export const ghc_heap_9_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-heap_9_6_3`,
  "Functions for walking GHC's heap",
);

/**
 * Extract the heap representation of Haskell values and thunks
 */
export const ghc_heap_view = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-heap-view`,
  "Extract the heap representation of Haskell values and thunks",
);

/**
 * Translate Haskell source to Template Haskell expression
 */
export const ghc_hs_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-hs-meta`,
  "Translate Haskell source to Template Haskell expression",
);

/**
 * Find the Haddock documentation for a symbol
 */
export const ghc_imported_from = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-imported-from`,
  "Find the Haddock documentation for a symbol",
);

/**
 * Easily import all instances contained in GHC distributed libraries
 */
export const ghc_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-instances`,
  "Easily import all instances contained in GHC distributed libraries",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_8_10_7_20220219 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib_8_10_7_20220219`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_9_2_8_20230729 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib_9_2_8_20230729`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_9_6_2_20230523 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib_9_6_2_20230523`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_parser_8_10_7_20220219 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser_8_10_7_20220219`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_parser_9_2_8_20230729 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser_9_2_8_20230729`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * The GHC API, decoupled from GHC versions
 */
export const ghc_lib_parser_9_6_2_20230523 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser_9_6_2_20230523`,
  "The GHC API, decoupled from GHC versions",
);

/**
 * Algorithms on GHC parse trees
 */
export const ghc_lib_parser_ex = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser-ex`,
  "Algorithms on GHC parse trees",
);

/**
 * Algorithms on GHC parse trees
 */
export const ghc_lib_parser_ex_8_10_0_24 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser-ex_8_10_0_24`,
  "Algorithms on GHC parse trees",
);

/**
 * Algorithms on GHC parse trees
 */
export const ghc_lib_parser_ex_9_2_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser-ex_9_2_1_1`,
  "Algorithms on GHC parse trees",
);

/**
 * Algorithms on GHC parse trees
 */
export const ghc_lib_parser_ex_9_6_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-lib-parser-ex_9_6_0_2`,
  "Algorithms on GHC parse trees",
);

/**
 * Accelerated version of ghc --make
 */
export const ghc_make = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-make`,
  "Accelerated version of ghc --make",
);

/**
 * Happy Haskell Hacking
 */
export const ghc_mod = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-mod`,
  "Happy Haskell Hacking",
);

/**
 * Haskell source parser from GHC
 */
export const ghc_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-parser`,
  "Haskell source parser from GHC",
);

/**
 * Knowledge of GHC's installation directories
 */
export const ghc_paths = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-paths`,
  "Knowledge of GHC's installation directories",
);

/**
 * Type checker plugins without the type checking
 */
export const ghc_plugs_out = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-plugs-out`,
  "Type checker plugins without the type checking",
);

/**
 * GHC primitives
 */
export const ghc_prim_0_10_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-prim_0_10_0`,
  "GHC primitives",
);

/**
 * Library for parsing GHC time and allocation profiling reports
 */
export const ghc_prof = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-prof`,
  "Library for parsing GHC time and allocation profiling reports",
);

/**
 * Parser for GHC's JSON profiling output
 */
export const ghc_prof_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-prof-aeson`,
  "Parser for GHC's JSON profiling output",
);

/**
 * Turn GHC `-pj` profiling output into FlameGraph format
 */
export const ghc_prof_aeson_flamegraph = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-prof-aeson-flamegraph`,
  "Turn GHC `-pj` profiling output into FlameGraph format",
);

/**
 * Generates flamegraphs from GHC .prof files.
 */
export const ghc_prof_flamegraph = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-prof-flamegraph`,
  "Generates flamegraphs from GHC .prof files.",
);

/**
 * None
 */
export const ghc_server = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-server`,
  "None",
);

/**
 * Simplified GHC API
 */
export const ghc_session = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-session`,
  "Simplified GHC API",
);

/**
 * Compile source code from the standard input
 */
export const ghc_stdin = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-stdin`,
  "Compile source code from the standard input",
);

/**
 * Symbol on term level
 */
export const ghc_symbol = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-symbol`,
  "Symbol on term level",
);

/**
 * Syntax highlighter for Haskell using the lexer of GHC
 */
export const ghc_syntax_highlighter = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-syntax-highlighter`,
  "Syntax highlighter for Haskell using the lexer of GHC",
);

/**
 * Syntax highlighter for Haskell using the lexer of GHC
 */
export const ghc_syntax_highlighter_0_0_10_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-syntax-highlighter_0_0_10_0`,
  "Syntax highlighter for Haskell using the lexer of GHC",
);

/**
 * Utility for generating ctags and etags with GHC API
 */
export const ghc_tags = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tags`,
  "Utility for generating ctags and etags with GHC API",
);

/**
 * Utility for generating ctags and etags with GHC API
 */
export const ghc_tags_1_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tags_1_5`,
  "Utility for generating ctags and etags with GHC API",
);

/**
 * Utility for generating ctags and etags with GHC API
 */
export const ghc_tags_1_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tags_1_6`,
  "Utility for generating ctags and etags with GHC API",
);

/**
 * CTags and ETags from Haskell syntax tree
 */
export const ghc_tags_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tags-core`,
  "CTags and ETags from Haskell syntax tree",
);

/**
 * Streaming interface for ghc-tags-core
 */
export const ghc_tags_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tags-pipes`,
  "Streaming interface for ghc-tags-core",
);

/**
 * An API for type-checker plugins
 */
export const ghc_tcplugin_api = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tcplugin-api`,
  "An API for type-checker plugins",
);

/**
 * Utilities for writing GHC type-checker plugins
 */
export const ghc_tcplugins_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-tcplugins-extra`,
  "Utilities for writing GHC type-checker plugins",
);

/**
 * Provides bindings to functions starting and stopping the RTS timers
 */
export const ghc_timers = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-timers`,
  "Provides bindings to functions starting and stopping the RTS timers",
);

/**
 * Faster traceEvent and traceMarker, and binary object logging for eventlog
 */
export const ghc_trace_events = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-trace-events`,
  "Faster traceEvent and traceMarker, and binary object logging for eventlog",
);

/**
 * Additional type-level operations on GHC.TypeLits.Nat
 */
export const ghc_typelits_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-typelits-extra`,
  "Additional type-level operations on GHC.TypeLits.Nat",
);

/**
 * Derive KnownNat constraints from other KnownNat constraints
 */
export const ghc_typelits_knownnat = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-typelits-knownnat`,
  "Derive KnownNat constraints from other KnownNat constraints",
);

/**
 * GHC typechecker plugin for types of kind GHC.TypeLits.Nat
 */
export const ghc_typelits_natnormalise = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-typelits-natnormalise`,
  "GHC typechecker plugin for types of kind GHC.TypeLits.Nat",
);

/**
 * Presburger Arithmetic Solver for GHC Type-level natural numbers
 */
export const ghc_typelits_presburger = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-typelits-presburger`,
  "Presburger Arithmetic Solver for GHC Type-level natural numbers",
);

/**
 * Live visualization of data structures in GHCi
 */
export const ghc_vis = mkPackage(
  nixRaw`pkgs.haskellPackages.ghc-vis`,
  "Live visualization of data structures in GHCi",
);

/**
 * Dump the ghc flags during compilation
 */
export const ghcflags = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcflags`,
  "Dump the ghc flags during compilation",
);

/**
 * The library supporting GHC's interactive interpreter
 */
export const ghci_8_10_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghci_8_10_2`,
  "The library supporting GHC's interactive interpreter",
);

/**
 * ghci-dap is a GHCi having DAP interface
 */
export const ghci_dap = mkPackage(
  nixRaw`pkgs.haskellPackages.ghci-dap`,
  "ghci-dap is a GHCi having DAP interface",
);

/**
 * GHCi as a Hex Calculator interactive
 */
export const ghci_hexcalc = mkPackage(
  nixRaw`pkgs.haskellPackages.ghci-hexcalc`,
  "GHCi as a Hex Calculator interactive",
);

/**
 * colored pretty-printing within ghci
 */
export const ghci_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.ghci-pretty`,
  "colored pretty-printing within ghci",
);

/**
 * A websocket server that survives GHCi reloads
 */
export const ghci_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.ghci-websockets`,
  "A websocket server that survives GHCi reloads",
);

/**
 * GHCi based bare bones IDE
 */
export const ghcid = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcid`,
  "GHCi based bare bones IDE",
);

/**
 * The core of an IDE
 */
export const ghcide = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcide`,
  "The core of an IDE",
);

/**
 * An LSP client for running performance experiments on HLS
 */
export const ghcide_bench = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcide-bench`,
  "An LSP client for running performance experiments on HLS",
);

/**
 * Crossbrowser AJAX Bindings for GHCJS
 */
export const ghcjs_ajax = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-ajax`,
  "Crossbrowser AJAX Bindings for GHCJS",
);

/**
 * base library for GHCJS
 */
export const ghcjs_base_0_2_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-base_0_2_1_0`,
  "base library for GHCJS",
);

/**
 * Allow GHCJS projects to compile under GHC and develop using intero
 */
export const ghcjs_base_stub = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-base-stub`,
  "Allow GHCJS projects to compile under GHC and develop using intero",
);

/**
 * Installs CodeMirror JavaScript files
 */
export const ghcjs_codemirror = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-codemirror`,
  "Installs CodeMirror JavaScript files",
);

/**
 * DOM library that supports both GHCJS and GHC
 */
export const ghcjs_dom = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-dom`,
  "DOM library that supports both GHCJS and GHC",
);

/**
 * GHCJS DOM Hello World, an example package
 */
export const ghcjs_dom_hello = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-dom-hello`,
  "GHCJS DOM Hello World, an example package",
);

/**
 * DOM library that supports both GHCJS and GHC using jsaddle
 */
export const ghcjs_dom_jsaddle = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-dom-jsaddle`,
  "DOM library that supports both GHCJS and GHC using jsaddle",
);

/**
 * DOM library that supports both GHCJS and WebKitGTK
 */
export const ghcjs_dom_webkit = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-dom-webkit`,
  "DOM library that supports both GHCJS and WebKitGTK",
);

/**
 * GHCJS bindings for the JavaScript Fetch API
 */
export const ghcjs_fetch = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-fetch`,
  "GHCJS bindings for the JavaScript Fetch API",
);

/**
 * Client-side web EDSL for transient nodes running in the web browser
 */
export const ghcjs_hplay = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-hplay`,
  "Client-side web EDSL for transient nodes running in the web browser",
);

/**
 * GHCJS version of Perch library
 */
export const ghcjs_perch = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-perch`,
  "GHCJS version of Perch library",
);

/**
 * Deprecated: use ghcjs-base's native websockets
 */
export const ghcjs_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcjs-websockets`,
  "Deprecated: use ghcjs-base's native websockets",
);

/**
 * GHC .prof files viewer
 */
export const ghcprofview = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcprofview`,
  "GHC .prof files viewer",
);

/**
 * ghc toolchain installer
 */
export const ghcup = mkPackage(
  nixRaw`pkgs.haskellPackages.ghcup`,
  "ghc toolchain installer",
);

/**
 * Decode Z-encoded strings from GHC
 */
export const ghczdecode = mkPackage(
  nixRaw`pkgs.haskellPackages.ghczdecode`,
  "Decode Z-encoded strings from GHC",
);

/**
 * Existential type utilites
 */
export const ghost_buster = mkPackage(
  nixRaw`pkgs.haskellPackages.ghost-buster`,
  "Existential type utilites",
);

/**
 * Let Ghostscript render pages in parallel
 */
export const ghostscript_parallel = mkPackage(
  nixRaw`pkgs.haskellPackages.ghostscript-parallel`,
  "Let Ghostscript render pages in parallel",
);

/**
 * Trivial routines for inspecting git repositories
 */
export const ght = mkPackage(
  nixRaw`pkgs.haskellPackages.ght`,
  "Trivial routines for inspecting git repositories",
);

/**
 * Adwaita bindings
 */
export const gi_adwaita = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-adwaita`,
  "Adwaita bindings",
);

/**
 * Atk bindings
 */
export const gi_atk = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-atk`,
  "Atk bindings",
);

/**
 * Cairo bindings
 */
export const gi_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-cairo`,
  "Cairo bindings",
);

/**
 * Bridge between packages gi-* and cairo-core
 */
export const gi_cairo_again = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-cairo-again`,
  "Bridge between packages gi-* and cairo-core",
);

/**
 * GI friendly Binding to the Cairo library
 */
export const gi_cairo_connector = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-cairo-connector`,
  "GI friendly Binding to the Cairo library",
);

/**
 * GI friendly Binding to the Cairo library
 */
export const gi_cairo_render = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-cairo-render`,
  "GI friendly Binding to the Cairo library",
);

/**
 * COGL GObject bindings
 */
export const gi_cogl = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-cogl`,
  "COGL GObject bindings",
);

/**
 * Dbusmenu bindings
 */
export const gi_dbusmenu = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-dbusmenu`,
  "Dbusmenu bindings",
);

/**
 * DbusmenuGtk bindings
 */
export const gi_dbusmenugtk3 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-dbusmenugtk3`,
  "DbusmenuGtk bindings",
);

/**
 * freetype2 bindings
 */
export const gi_freetype2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-freetype2`,
  "freetype2 bindings",
);

/**
 * Gdk bindings
 */
export const gi_gdk = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gdk`,
  "Gdk bindings",
);

/**
 * Gdk bindings
 */
export const gi_gdk_4_0_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gdk_4_0_7`,
  "Gdk bindings",
);

/**
 * GdkPixbuf bindings
 */
export const gi_gdkpixbuf = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gdkpixbuf`,
  "GdkPixbuf bindings",
);

/**
 * GdkX11 bindings
 */
export const gi_gdkx11 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gdkx11`,
  "GdkX11 bindings",
);

/**
 * GdkX11 bindings
 */
export const gi_gdkx11_4_0_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gdkx11_4_0_7`,
  "GdkX11 bindings",
);

/**
 * libges bindings
 */
export const gi_ges = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-ges`,
  "libges bindings",
);

/**
 * libgit2-glib bindings
 */
export const gi_ggit = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-ggit`,
  "libgit2-glib bindings",
);

/**
 * Gio bindings
 */
export const gi_gio = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gio`,
  "Gio bindings",
);

/**
 * GIRepository (gobject-introspection) bindings
 */
export const gi_girepository = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-girepository`,
  "GIRepository (gobject-introspection) bindings",
);

/**
 * GLib bindings
 */
export const gi_glib = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-glib`,
  "GLib bindings",
);

/**
 * GModule bindings
 */
export const gi_gmodule = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gmodule`,
  "GModule bindings",
);

/**
 * GObject bindings
 */
export const gi_gobject = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gobject`,
  "GObject bindings",
);

/**
 * Gsk bindings
 */
export const gi_gsk = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gsk`,
  "Gsk bindings",
);

/**
 * GStreamer bindings
 */
export const gi_gst = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gst`,
  "GStreamer bindings",
);

/**
 * GStreamerAudio bindings
 */
export const gi_gstaudio = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gstaudio`,
  "GStreamerAudio bindings",
);

/**
 * GStreamerBase bindings
 */
export const gi_gstbase = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gstbase`,
  "GStreamerBase bindings",
);

/**
 * GStreamer Plugins Base Utils bindings
 */
export const gi_gstpbutils = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gstpbutils`,
  "GStreamer Plugins Base Utils bindings",
);

/**
 * GStreamerVideo bindings
 */
export const gi_gstvideo = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gstvideo`,
  "GStreamerVideo bindings",
);

/**
 * Gtk bindings
 */
export const gi_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtk`,
  "Gtk bindings",
);

/**
 * Gtk bindings
 */
export const gi_gtk_4_0_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtk_4_0_8`,
  "Gtk bindings",
);

/**
 * Declarative GTK+ programming in Haskell in the style of Pux
 */
export const gi_gtk_declarative_app_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtk-declarative-app-simple`,
  "Declarative GTK+ programming in Haskell in the style of Pux",
);

/**
 * A wrapper for gi-gtk, adding a few more idiomatic API parts on top
 */
export const gi_gtk_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtk-hs`,
  "A wrapper for gi-gtk, adding a few more idiomatic API parts on top",
);

/**
 * gtk-layer-shell bindings
 */
export const gi_gtk_layer_shell = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtk-layer-shell`,
  "gtk-layer-shell bindings",
);

/**
 * GtkosxApplication bindings
 */
export const gi_gtkosxapplication = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-gtkosxapplication`,
  "GtkosxApplication bindings",
);

/**
 * libhandy bindings
 */
export const gi_handy = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-handy`,
  "libhandy bindings",
);

/**
 * HarfBuzz bindings
 */
export const gi_harfbuzz = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-harfbuzz`,
  "HarfBuzz bindings",
);

/**
 * JavaScriptCore bindings
 */
export const gi_javascriptcore = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-javascriptcore`,
  "JavaScriptCore bindings",
);

/**
 * JavaScriptCore bindings
 */
export const gi_javascriptcore_6_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-javascriptcore_6_0_3`,
  "JavaScriptCore bindings",
);

/**
 * JSON GObject bindings
 */
export const gi_json = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-json`,
  "JSON GObject bindings",
);

/**
 * Libnotify bindings
 */
export const gi_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-notify`,
  "Libnotify bindings",
);

/**
 * OSTree bindings
 */
export const gi_ostree = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-ostree`,
  "OSTree bindings",
);

/**
 * Pango bindings
 */
export const gi_pango = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-pango`,
  "Pango bindings",
);

/**
 * PangoCairo bindings
 */
export const gi_pangocairo = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-pangocairo`,
  "PangoCairo bindings",
);

/**
 * Poppler bindings
 */
export const gi_poppler = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-poppler`,
  "Poppler bindings",
);

/**
 * librsvg bindings
 */
export const gi_rsvg = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-rsvg`,
  "librsvg bindings",
);

/**
 * Libsecret bindings
 */
export const gi_secret = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-secret`,
  "Libsecret bindings",
);

/**
 * Libsoup bindings
 */
export const gi_soup = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-soup`,
  "Libsoup bindings",
);

/**
 * Libsoup bindings
 */
export const gi_soup_3_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-soup_3_0_2`,
  "Libsoup bindings",
);

/**
 * libvips GObject bindings
 */
export const gi_vips = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-vips`,
  "libvips GObject bindings",
);

/**
 * Vte bindings
 */
export const gi_vte = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-vte`,
  "Vte bindings",
);

/**
 * WebKit bindings
 */
export const gi_webkit = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-webkit`,
  "WebKit bindings",
);

/**
 * WebKit2 bindings
 */
export const gi_webkit2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-webkit2`,
  "WebKit2 bindings",
);

/**
 * WebKit2-WebExtension bindings
 */
export const gi_webkit2webextension = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-webkit2webextension`,
  "WebKit2-WebExtension bindings",
);

/**
 * Wnck bindings
 */
export const gi_wnck = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-wnck`,
  "Wnck bindings",
);

/**
 * xlib bindings
 */
export const gi_xlib = mkPackage(
  nixRaw`pkgs.haskellPackages.gi-xlib`,
  "xlib bindings",
);

/**
 * A compiler for operating on serialized trees
 */
export const gibbon = mkPackage(
  nixRaw`pkgs.haskellPackages.gibbon`,
  "A compiler for operating on serialized trees",
);

/**
 * Haskell parser for GIML
 */
export const gimlh = mkPackage(
  nixRaw`pkgs.haskellPackages.gimlh`,
  "Haskell parser for GIML",
);

/**
 * An implementation of the Jinja2 template language in Haskell
 */
export const ginger = mkPackage(
  nixRaw`pkgs.haskellPackages.ginger`,
  "An implementation of the Jinja2 template language in Haskell",
);

/**
 * Binding to GIO
 */
export const gio = mkPackage(
  nixRaw`pkgs.haskellPackages.gio`,
  "Binding to GIO",
);

/**
 * manage files with git, without checking their contents into git
 */
export const git_annex = mkPackage(
  nixRaw`pkgs.haskellPackages.git-annex`,
  "manage files with git, without checking their contents into git",
);

/**
 * A simple parser for Git configuration files
 */
export const git_config = mkPackage(
  nixRaw`pkgs.haskellPackages.git-config`,
  "A simple parser for Git configuration files",
);

/**
 * Use TH to embed Git repo information
 */
export const git_embed = mkPackage(
  nixRaw`pkgs.haskellPackages.git-embed`,
  "Use TH to embed Git repo information",
);

/**
 * Custom git command for formatting code
 */
export const git_fmt = mkPackage(
  nixRaw`pkgs.haskellPackages.git-fmt`,
  "Custom git command for formatting code",
);

/**
 * A Git subcommand to show total addition, deletion per file
 */
export const git_freq = mkPackage(
  nixRaw`pkgs.haskellPackages.git-freq`,
  "A Git subcommand to show total addition, deletion per file",
);

/**
 * More intelligent push-to-GitHub utility
 */
export const git_gpush = mkPackage(
  nixRaw`pkgs.haskellPackages.git-gpush`,
  "More intelligent push-to-GitHub utility",
);

/**
 * git-lfs protocol
 */
export const git_lfs = mkPackage(
  nixRaw`pkgs.haskellPackages.git-lfs`,
  "git-lfs protocol",
);

/**
 * Tool to help resolving git conflicts
 */
export const git_mediate = mkPackage(
  nixRaw`pkgs.haskellPackages.git-mediate`,
  "Tool to help resolving git conflicts",
);

/**
 * Passively snapshots working tree changes efficiently
 */
export const git_monitor = mkPackage(
  nixRaw`pkgs.haskellPackages.git-monitor`,
  "Passively snapshots working tree changes efficiently",
);

/**
 * Git object and its parser
 */
export const git_object = mkPackage(
  nixRaw`pkgs.haskellPackages.git-object`,
  "Git object and its parser",
);

/**
 * Git remote helper to store git objects on IPFS
 */
export const git_remote_ipfs = mkPackage(
  nixRaw`pkgs.haskellPackages.git-remote-ipfs`,
  "Git remote helper to store git objects on IPFS",
);

/**
 * A sanity checker for your git history
 */
export const git_sanity = mkPackage(
  nixRaw`pkgs.haskellPackages.git-sanity`,
  "A sanity checker for your git history",
);

/**
 * Simple git utility to use and manage clone cache
 */
export const gitcache = mkPackage(
  nixRaw`pkgs.haskellPackages.gitcache`,
  "Simple git utility to use and manage clone cache",
);

/**
 * Create Github issues out of TODO comments in code
 */
export const gitdo = mkPackage(
  nixRaw`pkgs.haskellPackages.gitdo`,
  "Create Github issues out of TODO comments in code",
);

/**
 * Compile git revision info into Haskell projects
 */
export const githash = mkPackage(
  nixRaw`pkgs.haskellPackages.githash`,
  "Compile git revision info into Haskell projects",
);

/**
 * Access to the GitHub API, v3
 */
export const github = mkPackage(
  nixRaw`pkgs.haskellPackages.github`,
  "Access to the GitHub API, v3",
);

/**
 * Access to the GitHub API, v3
 */
export const github_0_29 = mkPackage(
  nixRaw`pkgs.haskellPackages.github_0_29`,
  "Access to the GitHub API, v3",
);

/**
 * Access to the GitHub API, v3
 */
export const github_data = mkPackage(
  nixRaw`pkgs.haskellPackages.github-data`,
  "Access to the GitHub API, v3",
);

/**
 * Upload files to GitHub releases
 */
export const github_release = mkPackage(
  nixRaw`pkgs.haskellPackages.github-release`,
  "Upload files to GitHub releases",
);

/**
 * Query the GitHub REST API programmatically
 */
export const github_rest = mkPackage(
  nixRaw`pkgs.haskellPackages.github-rest`,
  "Query the GitHub REST API programmatically",
);

/**
 * Type definitions for objects used by the GitHub v3 API
 */
export const github_types = mkPackage(
  nixRaw`pkgs.haskellPackages.github-types`,
  "Type definitions for objects used by the GitHub v3 API",
);

/**
 * GitHub WebHook Handler implementation for Snap
 */
export const github_webhook_handler_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.github-webhook-handler-snap`,
  "GitHub WebHook Handler implementation for Snap",
);

/**
 * Aeson instances for GitHub Webhook payloads
 */
export const github_webhooks = mkPackage(
  nixRaw`pkgs.haskellPackages.github-webhooks`,
  "Aeson instances for GitHub Webhook payloads",
);

/**
 * Wiki using happstack, git or darcs, and pandoc
 */
export const gitit = mkPackage(
  nixRaw`pkgs.haskellPackages.gitit`,
  "Wiki using happstack, git or darcs, and pandoc",
);

/**
 * API library for working with Git repositories
 */
export const gitlib = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib`,
  "API library for working with Git repositories",
);

/**
 * Run tests between repositories
 */
export const gitlib_cross = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib-cross`,
  "Run tests between repositories",
);

/**
 * Libgit2 backend for gitlib
 */
export const gitlib_libgit2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib-libgit2`,
  "Libgit2 backend for gitlib",
);

/**
 * Gitlib repository backend for storing Git objects in Amazon S3
 */
export const gitlib_s3 = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib-s3`,
  "Gitlib repository backend for storing Git objects in Amazon S3",
);

/**
 * Sample backend for gitlib showing the basic structure for any backend
 */
export const gitlib_sample = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib-sample`,
  "Sample backend for gitlib showing the basic structure for any backend",
);

/**
 * Test library for confirming gitlib backend compliance
 */
export const gitlib_test = mkPackage(
  nixRaw`pkgs.haskellPackages.gitlib-test`,
  "Test library for confirming gitlib backend compliance",
);

/**
 * Compile git revision info into Haskell projects
 */
export const gitrev = mkPackage(
  nixRaw`pkgs.haskellPackages.gitrev`,
  "Compile git revision info into Haskell projects",
);

/**
 * A document store library for Git + JSON
 */
export const gitson = mkPackage(
  nixRaw`pkgs.haskellPackages.gitson`,
  "A document store library for Git + JSON",
);

/**
 * CLI Giphy search tool with previews in iTerm 2
 */
export const givegif = mkPackage(
  nixRaw`pkgs.haskellPackages.givegif`,
  "CLI Giphy search tool with previews in iTerm 2",
);

/**
 * Gilbert-Johnson-Keerthi (GJK) collision detection algorithm
 */
export const gjk = mkPackage(
  nixRaw`pkgs.haskellPackages.gjk`,
  "Gilbert-Johnson-Keerthi (GJK) collision detection algorithm",
);

export const gjk2d = mkPackage(
  nixRaw`pkgs.haskellPackages.gjk2d`,
  "",
);

/**
 * Complete OpenGL raw bindings
 */
export const gl = mkPackage(
  nixRaw`pkgs.haskellPackages.gl`,
  "Complete OpenGL raw bindings",
);

/**
 * Haskell bindings for the gl3w library
 */
export const gl3w = mkPackage(
  nixRaw`pkgs.haskellPackages.gl3w`,
  "Haskell bindings for the gl3w library",
);

/**
 * OpenGL standard memory layouts
 */
export const gl_block = mkPackage(
  nixRaw`pkgs.haskellPackages.gl-block`,
  "OpenGL standard memory layouts",
);

/**
 * simple image capture from OpenGL
 */
export const gl_capture = mkPackage(
  nixRaw`pkgs.haskellPackages.gl-capture`,
  "simple image capture from OpenGL",
);

/**
 * A template DSL library
 */
export const glabrous = mkPackage(
  nixRaw`pkgs.haskellPackages.glabrous`,
  "A template DSL library",
);

/**
 * Automagically declares getters for widget handles in specified interface file
 */
export const gladexml_accessor = mkPackage(
  nixRaw`pkgs.haskellPackages.gladexml-accessor`,
  "Automagically declares getters for widget handles in specified interface file",
);

/**
 * A simply typed lambda calculus interpreter, written with GADTs
 */
export const glambda = mkPackage(
  nixRaw`pkgs.haskellPackages.glambda`,
  "A simply typed lambda calculus interpreter, written with GADTs",
);

/**
 * Graphical Lasso algorithm
 */
export const glasso = mkPackage(
  nixRaw`pkgs.haskellPackages.glasso`,
  "Graphical Lasso algorithm",
);

/**
 * Extensible effects using ContT, State and variants
 */
export const glazier = mkPackage(
  nixRaw`pkgs.haskellPackages.glazier`,
  "Extensible effects using ContT, State and variants",
);

/**
 * A threaded rendering framework using glaizer and pipes
 */
export const glazier_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.glazier-pipes`,
  "A threaded rendering framework using glaizer and pipes",
);

/**
 * ReactJS binding using Glazier.Command.
 */
export const glazier_react = mkPackage(
  nixRaw`pkgs.haskellPackages.glazier-react`,
  "ReactJS binding using Glazier.Command.",
);

/**
 * Examples of using glazier-react
 */
export const glazier_react_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.glazier-react-examples`,
  "Examples of using glazier-react",
);

/**
 * Generic widget library using glazier-react
 */
export const glazier_react_widget = mkPackage(
  nixRaw`pkgs.haskellPackages.glazier-react-widget`,
  "Generic widget library using glazier-react",
);

/**
 * Binding to the GLIB library for Gtk2Hs
 */
export const glib = mkPackage(
  nixRaw`pkgs.haskellPackages.glib`,
  "Binding to the GLIB library for Gtk2Hs",
);

/**
 * A simple ray tracer in an early stage of development
 */
export const glintcollider = mkPackage(
  nixRaw`pkgs.haskellPackages.glintcollider`,
  "A simple ray tracer in an early stage of development",
);

/**
 * Console IRC client
 */
export const glirc = mkPackage(
  nixRaw`pkgs.haskellPackages.glirc`,
  "Console IRC client",
);

/**
 * GLL parser with simple combinator interface
 */
export const gll = mkPackage(
  nixRaw`pkgs.haskellPackages.gll`,
  "GLL parser with simple combinator interface",
);

/**
 * Library enabling unique top-level declarations
 */
export const global = mkPackage(
  nixRaw`pkgs.haskellPackages.global`,
  "Library enabling unique top-level declarations",
);

/**
 * Global mutable configuration
 */
export const global_config = mkPackage(
  nixRaw`pkgs.haskellPackages.global-config`,
  "Global mutable configuration",
);

/**
 * A global lock implemented without unsafePerformIO
 */
export const global_lock = mkPackage(
  nixRaw`pkgs.haskellPackages.global-lock`,
  "A global lock implemented without unsafePerformIO",
);

/**
 * ray tracer
 */
export const glome_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.glome-hs`,
  "ray tracer",
);

/**
 * Painless 2D vector graphics, animations and simulations
 */
export const gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss`,
  "Painless 2D vector graphics, animations and simulations",
);

/**
 * Extras to interface Gloss and Accelerate
 */
export const gloss_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-accelerate`,
  "Extras to interface Gloss and Accelerate",
);

/**
 * Data structures and algorithms for working with 2D graphics
 */
export const gloss_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-algorithms`,
  "Data structures and algorithms for working with 2D graphics",
);

/**
 * Display images in Gloss using libdevil for decoding
 */
export const gloss_devil = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-devil`,
  "Display images in Gloss using libdevil for decoding",
);

/**
 * Examples using the gloss library
 */
export const gloss_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-examples`,
  "Examples using the gloss library",
);

/**
 * Load any image supported by Juicy.Pixels in your gloss application
 */
export const gloss_juicy = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-juicy`,
  "Load any image supported by Juicy.Pixels in your gloss application",
);

/**
 * Parallel rendering of raster images
 */
export const gloss_raster = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-raster`,
  "Parallel rendering of raster images",
);

/**
 * Parallel rendering of raster images using Accelerate
 */
export const gloss_raster_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-raster-accelerate`,
  "Parallel rendering of raster images using Accelerate",
);

/**
 * Massiv-based alternative for gloss-raster
 */
export const gloss_raster_massiv = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-raster-massiv`,
  "Massiv-based alternative for gloss-raster",
);

/**
 * Gloss picture data types and rendering functions
 */
export const gloss_rendering = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-rendering`,
  "Gloss picture data types and rendering functions",
);

/**
 * A Sodium interface to the Gloss drawing package
 */
export const gloss_sodium = mkPackage(
  nixRaw`pkgs.haskellPackages.gloss-sodium`,
  "A Sodium interface to the Gloss drawing package",
);

/**
 * Low-level Haskell bindings to the GLPK library
 */
export const glpk_headers = mkPackage(
  nixRaw`pkgs.haskellPackages.glpk-headers`,
  "Low-level Haskell bindings to the GLPK library",
);

/**
 * Comprehensive GLPK linear programming bindings
 */
export const glpk_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.glpk-hs`,
  "Comprehensive GLPK linear programming bindings",
);

/**
 * High level GlTF loader
 */
export const gltf_loader = mkPackage(
  nixRaw`pkgs.haskellPackages.gltf-loader`,
  "High level GlTF loader",
);

/**
 * Attempts to fix your syntax erroring Lua files
 */
export const glualint = mkPackage(
  nixRaw`pkgs.haskellPackages.glualint`,
  "Attempts to fix your syntax erroring Lua files",
);

/**
 * Make better services and clients
 */
export const glue_common = mkPackage(
  nixRaw`pkgs.haskellPackages.glue-common`,
  "Make better services and clients",
);

/**
 * Make better services and clients
 */
export const glue_core = mkPackage(
  nixRaw`pkgs.haskellPackages.glue-core`,
  "Make better services and clients",
);

/**
 * Make better services and clients
 */
export const glue_ekg = mkPackage(
  nixRaw`pkgs.haskellPackages.glue-ekg`,
  "Make better services and clients",
);

/**
 * Make better services and clients
 */
export const glue_example = mkPackage(
  nixRaw`pkgs.haskellPackages.glue-example`,
  "Make better services and clients",
);

/**
 * turtle like LOGO with glut
 */
export const gluturtle = mkPackage(
  nixRaw`pkgs.haskellPackages.gluturtle`,
  "turtle like LOGO with glut",
);

/**
 * Simple library for Google Mail (GMail)
 */
export const gmail_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.gmail-simple`,
  "Simple library for Google Mail (GMail)",
);

/**
 * Composable maps and generic tries
 */
export const gmap = mkPackage(
  nixRaw`pkgs.haskellPackages.gmap`,
  "Composable maps and generic tries",
);

/**
 * Mandelbrot Set explorer using GTK
 */
export const gmndl = mkPackage(
  nixRaw`pkgs.haskellPackages.gmndl`,
  "Mandelbrot Set explorer using GTK",
);

/**
 * GMP integer conversions
 */
export const gmpint = mkPackage(
  nixRaw`pkgs.haskellPackages.gmpint`,
  "GMP integer conversions",
);

/**
 * Randomly set a picture as the GNOME desktop background
 */
export const gnome_desktop = mkPackage(
  nixRaw`pkgs.haskellPackages.gnome-desktop`,
  "Randomly set a picture as the GNOME desktop background",
);

/**
 * Bindings for libgnome-keyring
 */
export const gnome_keyring = mkPackage(
  nixRaw`pkgs.haskellPackages.gnome-keyring`,
  "Bindings for libgnome-keyring",
);

/**
 * Binding to the GNOME Virtual File System library
 */
export const gnomevfs = mkPackage(
  nixRaw`pkgs.haskellPackages.gnomevfs`,
  "Binding to the GNOME Virtual File System library",
);

/**
 * GNSS Converters
 */
export const gnss_converters = mkPackage(
  nixRaw`pkgs.haskellPackages.gnss-converters`,
  "GNSS Converters",
);

/**
 * Bindings for GNU IDN
 */
export const gnuidn = mkPackage(
  nixRaw`pkgs.haskellPackages.gnuidn`,
  "Bindings for GNU IDN",
);

/**
 * 2D and 3D plots using gnuplot
 */
export const gnuplot = mkPackage(
  nixRaw`pkgs.haskellPackages.gnuplot`,
  "2D and 3D plots using gnuplot",
);

/**
 * Bindings for GNU libgnutls
 */
export const gnutls = mkPackage(
  nixRaw`pkgs.haskellPackages.gnutls`,
  "Bindings for GNU libgnutls",
);

/**
 * The basic geometric type system of Goal
 */
export const goal_geometry = mkPackage(
  nixRaw`pkgs.haskellPackages.goal-geometry`,
  "The basic geometric type system of Goal",
);

/**
 * Optimization of latent variable and dynamical models with Goal
 */
export const goal_graphical = mkPackage(
  nixRaw`pkgs.haskellPackages.goal-graphical`,
  "Optimization of latent variable and dynamical models with Goal",
);

/**
 * Optimization on manifolds of probability distributions with Goal
 */
export const goal_probability = mkPackage(
  nixRaw`pkgs.haskellPackages.goal-probability`,
  "Optimization on manifolds of probability distributions with Goal",
);

/**
 * Mealy based simulation tools
 */
export const goal_simulation = mkPackage(
  nixRaw`pkgs.haskellPackages.goal-simulation`,
  "Mealy based simulation tools",
);

/**
 * Time Series Compression
 */
export const goat = mkPackage(
  nixRaw`pkgs.haskellPackages.goat`,
  "Time Series Compression",
);

/**
 * A monadic take on a 2,500-year-old board game - GTK+ UI
 */
export const goatee_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.goatee-gtk`,
  "A monadic take on a 2,500-year-old board game - GTK+ UI",
);

/**
 * Extensible interface to Web APIs
 */
export const goggles = mkPackage(
  nixRaw`pkgs.haskellPackages.goggles`,
  "Extensible interface to Web APIs",
);

/**
 * `goggles` interface to Google Cloud Storage
 */
export const goggles_gcs = mkPackage(
  nixRaw`pkgs.haskellPackages.goggles-gcs`,
  "`goggles` interface to Google Cloud Storage",
);

/**
 * Comprehensive Google Services SDK
 */
export const gogol = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol`,
  "Comprehensive Google Services SDK",
);

/**
 * Google Abusive Experience Report SDK
 */
export const gogol_abusiveexperiencereport = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-abusiveexperiencereport`,
  "Google Abusive Experience Report SDK",
);

/**
 * Google Accelerated Mobile Pages (AMP) URL SDK
 */
export const gogol_acceleratedmobilepageurl = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-acceleratedmobilepageurl`,
  "Google Accelerated Mobile Pages (AMP) URL SDK",
);

/**
 * Google Access Approval SDK
 */
export const gogol_accessapproval = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-accessapproval`,
  "Google Access Approval SDK",
);

/**
 * Google Access Context Manager SDK
 */
export const gogol_accesscontextmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-accesscontextmanager`,
  "Google Access Context Manager SDK",
);

/**
 * Google Ad Exchange Buyer SDK
 */
export const gogol_adexchange_buyer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adexchange-buyer`,
  "Google Ad Exchange Buyer SDK",
);

/**
 * Google Ad Exchange Seller SDK
 */
export const gogol_adexchange_seller = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adexchange-seller`,
  "Google Ad Exchange Seller SDK",
);

/**
 * Google Ad Exchange Buyer API II SDK
 */
export const gogol_adexchangebuyer2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adexchangebuyer2`,
  "Google Ad Exchange Buyer API II SDK",
);

/**
 * Google Ad Experience Report SDK
 */
export const gogol_adexperiencereport = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adexperiencereport`,
  "Google Ad Experience Report SDK",
);

/**
 * Google Admin Data Transfer SDK
 */
export const gogol_admin_datatransfer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-admin-datatransfer`,
  "Google Admin Data Transfer SDK",
);

/**
 * Google Admin Directory SDK
 */
export const gogol_admin_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-admin-directory`,
  "Google Admin Directory SDK",
);

/**
 * Google Email Migration API v2 SDK
 */
export const gogol_admin_emailmigration = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-admin-emailmigration`,
  "Google Email Migration API v2 SDK",
);

/**
 * Google Admin Reports SDK
 */
export const gogol_admin_reports = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-admin-reports`,
  "Google Admin Reports SDK",
);

/**
 * Google AdSense Management SDK
 */
export const gogol_adsense = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adsense`,
  "Google AdSense Management SDK",
);

/**
 * Google AdSense Host SDK
 */
export const gogol_adsense_host = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-adsense-host`,
  "Google AdSense Host SDK",
);

/**
 * Google Affiliate Network SDK
 */
export const gogol_affiliates = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-affiliates`,
  "Google Affiliate Network SDK",
);

/**
 * Google G Suite Alert Center SDK
 */
export const gogol_alertcenter = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-alertcenter`,
  "Google G Suite Alert Center SDK",
);

/**
 * Google Analytics SDK
 */
export const gogol_analytics = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-analytics`,
  "Google Analytics SDK",
);

/**
 * Google Analytics Reporting SDK
 */
export const gogol_analyticsreporting = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-analyticsreporting`,
  "Google Analytics Reporting SDK",
);

/**
 * Google Play EMM SDK
 */
export const gogol_android_enterprise = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-android-enterprise`,
  "Google Play EMM SDK",
);

/**
 * Google Play Developer SDK
 */
export const gogol_android_publisher = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-android-publisher`,
  "Google Play Developer SDK",
);

/**
 * Google Android Device Provisioning Partner SDK
 */
export const gogol_androiddeviceprovisioning = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-androiddeviceprovisioning`,
  "Google Android Device Provisioning Partner SDK",
);

/**
 * Google Android Management SDK
 */
export const gogol_androidmanagement = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-androidmanagement`,
  "Google Android Management SDK",
);

/**
 * Google App Engine Admin SDK
 */
export const gogol_appengine = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-appengine`,
  "Google App Engine Admin SDK",
);

/**
 * Google Drive Activity SDK
 */
export const gogol_apps_activity = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-apps-activity`,
  "Google Drive Activity SDK",
);

/**
 * Google Calendar SDK
 */
export const gogol_apps_calendar = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-apps-calendar`,
  "Google Calendar SDK",
);

/**
 * Google Enterprise License Manager SDK
 */
export const gogol_apps_licensing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-apps-licensing`,
  "Google Enterprise License Manager SDK",
);

/**
 * Google Enterprise Apps Reseller SDK
 */
export const gogol_apps_reseller = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-apps-reseller`,
  "Google Enterprise Apps Reseller SDK",
);

/**
 * Google Tasks SDK
 */
export const gogol_apps_tasks = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-apps-tasks`,
  "Google Tasks SDK",
);

/**
 * Google App State SDK
 */
export const gogol_appstate = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-appstate`,
  "Google App State SDK",
);

/**
 * Google Compute Engine Autoscaler SDK
 */
export const gogol_autoscaler = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-autoscaler`,
  "Google Compute Engine Autoscaler SDK",
);

/**
 * Google BigQuery SDK
 */
export const gogol_bigquery = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-bigquery`,
  "Google BigQuery SDK",
);

/**
 * Google BigQuery Data Transfer SDK
 */
export const gogol_bigquerydatatransfer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-bigquerydatatransfer`,
  "Google BigQuery Data Transfer SDK",
);

/**
 * Google Cloud Bigtable Admin SDK
 */
export const gogol_bigtableadmin = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-bigtableadmin`,
  "Google Cloud Bigtable Admin SDK",
);

/**
 * Google Cloud Billing SDK
 */
export const gogol_billing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-billing`,
  "Google Cloud Billing SDK",
);

/**
 * Google Binary Authorization SDK
 */
export const gogol_binaryauthorization = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-binaryauthorization`,
  "Google Binary Authorization SDK",
);

/**
 * Google Blogger SDK
 */
export const gogol_blogger = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-blogger`,
  "Google Blogger SDK",
);

/**
 * Google Books SDK
 */
export const gogol_books = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-books`,
  "Google Books SDK",
);

/**
 * Google Hangouts Chat SDK
 */
export const gogol_chat = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-chat`,
  "Google Hangouts Chat SDK",
);

/**
 * Google Civic Information SDK
 */
export const gogol_civicinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-civicinfo`,
  "Google Civic Information SDK",
);

/**
 * Google Classroom SDK
 */
export const gogol_classroom = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-classroom`,
  "Google Classroom SDK",
);

/**
 * Google Cloud Asset SDK
 */
export const gogol_cloudasset = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudasset`,
  "Google Cloud Asset SDK",
);

/**
 * Google Stackdriver Error Reporting SDK
 */
export const gogol_clouderrorreporting = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-clouderrorreporting`,
  "Google Stackdriver Error Reporting SDK",
);

/**
 * Google Cloud Functions SDK
 */
export const gogol_cloudfunctions = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudfunctions`,
  "Google Cloud Functions SDK",
);

/**
 * Google Cloud Identity SDK
 */
export const gogol_cloudidentity = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudidentity`,
  "Google Cloud Identity SDK",
);

/**
 * Google Cloud IoT SDK
 */
export const gogol_cloudiot = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudiot`,
  "Google Cloud IoT SDK",
);

/**
 * Google Cloud Key Management Service (KMS) SDK
 */
export const gogol_cloudkms = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudkms`,
  "Google Cloud Key Management Service (KMS) SDK",
);

/**
 * Google Cloud Monitoring SDK
 */
export const gogol_cloudmonitoring = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudmonitoring`,
  "Google Cloud Monitoring SDK",
);

/**
 * Google Cloud Private Catalog SDK
 */
export const gogol_cloudprivatecatalog = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudprivatecatalog`,
  "Google Cloud Private Catalog SDK",
);

/**
 * Google Cloud Private Catalog Producer SDK
 */
export const gogol_cloudprivatecatalogproducer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudprivatecatalogproducer`,
  "Google Cloud Private Catalog Producer SDK",
);

/**
 * Google Stackdriver Profiler SDK
 */
export const gogol_cloudprofiler = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudprofiler`,
  "Google Stackdriver Profiler SDK",
);

/**
 * Google Cloud Scheduler SDK
 */
export const gogol_cloudscheduler = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudscheduler`,
  "Google Cloud Scheduler SDK",
);

/**
 * Google Cloud Search SDK
 */
export const gogol_cloudsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudsearch`,
  "Google Cloud Search SDK",
);

/**
 * Google Cloud Shell SDK
 */
export const gogol_cloudshell = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudshell`,
  "Google Cloud Shell SDK",
);

/**
 * Google Cloud Tasks SDK
 */
export const gogol_cloudtasks = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudtasks`,
  "Google Cloud Tasks SDK",
);

/**
 * Google Stackdriver Trace SDK
 */
export const gogol_cloudtrace = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-cloudtrace`,
  "Google Stackdriver Trace SDK",
);

/**
 * Google Perspective Comment Analyzer SDK
 */
export const gogol_commentanalyzer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-commentanalyzer`,
  "Google Perspective Comment Analyzer SDK",
);

/**
 * Google Cloud Composer SDK
 */
export const gogol_composer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-composer`,
  "Google Cloud Composer SDK",
);

/**
 * Google Compute Engine SDK
 */
export const gogol_compute = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-compute`,
  "Google Compute Engine SDK",
);

/**
 * Google Consumer Surveys SDK
 */
export const gogol_consumersurveys = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-consumersurveys`,
  "Google Consumer Surveys SDK",
);

/**
 * Google Kubernetes Engine SDK
 */
export const gogol_container = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-container`,
  "Google Kubernetes Engine SDK",
);

/**
 * Google Container Analysis SDK
 */
export const gogol_containeranalysis = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-containeranalysis`,
  "Google Container Analysis SDK",
);

/**
 * Google Cloud Build SDK
 */
export const gogol_containerbuilder = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-containerbuilder`,
  "Google Cloud Build SDK",
);

/**
 * Google CustomSearch SDK
 */
export const gogol_customsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-customsearch`,
  "Google CustomSearch SDK",
);

/**
 * Google Dataflow SDK
 */
export const gogol_dataflow = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dataflow`,
  "Google Dataflow SDK",
);

/**
 * Google Cloud Data Fusion SDK
 */
export const gogol_datafusion = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-datafusion`,
  "Google Cloud Data Fusion SDK",
);

/**
 * Google Cloud Dataproc SDK
 */
export const gogol_dataproc = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dataproc`,
  "Google Cloud Dataproc SDK",
);

/**
 * Google Cloud Datastore SDK
 */
export const gogol_datastore = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-datastore`,
  "Google Cloud Datastore SDK",
);

/**
 * Google Stackdriver Debugger SDK
 */
export const gogol_debugger = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-debugger`,
  "Google Stackdriver Debugger SDK",
);

/**
 * Google Cloud Deployment Manager SDK
 */
export const gogol_deploymentmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-deploymentmanager`,
  "Google Cloud Deployment Manager SDK",
);

/**
 * Google DCM/DFA Reporting And Trafficking SDK
 */
export const gogol_dfareporting = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dfareporting`,
  "Google DCM/DFA Reporting And Trafficking SDK",
);

/**
 * Google Dialogflow SDK
 */
export const gogol_dialogflow = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dialogflow`,
  "Google Dialogflow SDK",
);

/**
 * Google Digital Asset Links SDK
 */
export const gogol_digitalassetlinks = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-digitalassetlinks`,
  "Google Digital Asset Links SDK",
);

/**
 * Google API Discovery Service SDK
 */
export const gogol_discovery = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-discovery`,
  "Google API Discovery Service SDK",
);

/**
 * Google Cloud Data Loss Prevention (DLP) SDK
 */
export const gogol_dlp = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dlp`,
  "Google Cloud Data Loss Prevention (DLP) SDK",
);

/**
 * Google Cloud DNS SDK
 */
export const gogol_dns = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-dns`,
  "Google Cloud DNS SDK",
);

/**
 * Google Docs SDK
 */
export const gogol_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-docs`,
  "Google Docs SDK",
);

/**
 * Google DoubleClick Bid Manager SDK
 */
export const gogol_doubleclick_bids = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-doubleclick-bids`,
  "Google DoubleClick Bid Manager SDK",
);

/**
 * Google DoubleClick Search SDK
 */
export const gogol_doubleclick_search = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-doubleclick-search`,
  "Google DoubleClick Search SDK",
);

/**
 * Google Drive SDK
 */
export const gogol_drive = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-drive`,
  "Google Drive SDK",
);

/**
 * Google Drive Activity SDK
 */
export const gogol_driveactivity = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-driveactivity`,
  "Google Drive Activity SDK",
);

/**
 * Google Fact Check Tools SDK
 */
export const gogol_factchecktools = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-factchecktools`,
  "Google Fact Check Tools SDK",
);

/**
 * Google Cloud Filestore SDK
 */
export const gogol_file = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-file`,
  "Google Cloud Filestore SDK",
);

/**
 * Google Firebase Dynamic Links SDK
 */
export const gogol_firebase_dynamiclinks = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-firebase-dynamiclinks`,
  "Google Firebase Dynamic Links SDK",
);

/**
 * Google Firebase Rules SDK
 */
export const gogol_firebase_rules = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-firebase-rules`,
  "Google Firebase Rules SDK",
);

/**
 * Google Firebase Hosting SDK
 */
export const gogol_firebasehosting = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-firebasehosting`,
  "Google Firebase Hosting SDK",
);

/**
 * Google Firebase Remote Config SDK
 */
export const gogol_firebaseremoteconfig = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-firebaseremoteconfig`,
  "Google Firebase Remote Config SDK",
);

/**
 * Google Cloud Firestore SDK
 */
export const gogol_firestore = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-firestore`,
  "Google Cloud Firestore SDK",
);

/**
 * Google Fitness SDK
 */
export const gogol_fitness = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-fitness`,
  "Google Fitness SDK",
);

/**
 * Google Fonts Developer SDK
 */
export const gogol_fonts = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-fonts`,
  "Google Fonts Developer SDK",
);

/**
 * Google Freebase Search SDK
 */
export const gogol_freebasesearch = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-freebasesearch`,
  "Google Freebase Search SDK",
);

/**
 * Google Fusion Tables SDK
 */
export const gogol_fusiontables = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-fusiontables`,
  "Google Fusion Tables SDK",
);

/**
 * Google Play Game Services SDK
 */
export const gogol_games = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-games`,
  "Google Play Game Services SDK",
);

/**
 * Google Play Game Services Publishing SDK
 */
export const gogol_games_configuration = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-games-configuration`,
  "Google Play Game Services Publishing SDK",
);

/**
 * Google Play Game Services Management SDK
 */
export const gogol_games_management = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-games-management`,
  "Google Play Game Services Management SDK",
);

/**
 * Google Genomics SDK
 */
export const gogol_genomics = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-genomics`,
  "Google Genomics SDK",
);

/**
 * Google Gmail SDK
 */
export const gogol_gmail = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-gmail`,
  "Google Gmail SDK",
);

/**
 * Google Groups Migration SDK
 */
export const gogol_groups_migration = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-groups-migration`,
  "Google Groups Migration SDK",
);

/**
 * Google Groups Settings SDK
 */
export const gogol_groups_settings = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-groups-settings`,
  "Google Groups Settings SDK",
);

/**
 * Google Cloud Healthcare SDK
 */
export const gogol_healthcare = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-healthcare`,
  "Google Cloud Healthcare SDK",
);

/**
 * Google Identity and Access Management (IAM) SDK
 */
export const gogol_iam = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-iam`,
  "Google Identity and Access Management (IAM) SDK",
);

/**
 * Google IAM Service Account Credentials SDK
 */
export const gogol_iamcredentials = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-iamcredentials`,
  "Google IAM Service Account Credentials SDK",
);

/**
 * Google Cloud Identity-Aware Proxy SDK
 */
export const gogol_iap = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-iap`,
  "Google Cloud Identity-Aware Proxy SDK",
);

/**
 * Google Identity Toolkit SDK
 */
export const gogol_identity_toolkit = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-identity-toolkit`,
  "Google Identity Toolkit SDK",
);

/**
 * Google Indexing SDK
 */
export const gogol_indexing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-indexing`,
  "Google Indexing SDK",
);

/**
 * Google Cloud Talent Solution SDK
 */
export const gogol_jobs = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-jobs`,
  "Google Cloud Talent Solution SDK",
);

/**
 * Google Knowledge Graph Search SDK
 */
export const gogol_kgsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-kgsearch`,
  "Google Knowledge Graph Search SDK",
);

/**
 * Google Cloud Natural Language SDK
 */
export const gogol_language = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-language`,
  "Google Cloud Natural Language SDK",
);

/**
 * Google Cloud Network Performance Monitoring SDK
 */
export const gogol_latencytest = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-latencytest`,
  "Google Cloud Network Performance Monitoring SDK",
);

/**
 * Google Library Agent SDK
 */
export const gogol_libraryagent = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-libraryagent`,
  "Google Library Agent SDK",
);

/**
 * Google Stackdriver Logging SDK
 */
export const gogol_logging = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-logging`,
  "Google Stackdriver Logging SDK",
);

/**
 * Google Manufacturer Center SDK
 */
export const gogol_manufacturers = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-manufacturers`,
  "Google Manufacturer Center SDK",
);

/**
 * Google Maps Coordinate SDK
 */
export const gogol_maps_coordinate = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-maps-coordinate`,
  "Google Maps Coordinate SDK",
);

/**
 * Google Maps Engine SDK
 */
export const gogol_maps_engine = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-maps-engine`,
  "Google Maps Engine SDK",
);

/**
 * Google Mirror SDK
 */
export const gogol_mirror = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-mirror`,
  "Google Mirror SDK",
);

/**
 * Google Cloud Machine Learning Engine SDK
 */
export const gogol_ml = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-ml`,
  "Google Cloud Machine Learning Engine SDK",
);

/**
 * Google Stackdriver Monitoring SDK
 */
export const gogol_monitoring = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-monitoring`,
  "Google Stackdriver Monitoring SDK",
);

/**
 * Google OAuth2 SDK
 */
export const gogol_oauth2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-oauth2`,
  "Google OAuth2 SDK",
);

/**
 * Google Cloud OS Login SDK
 */
export const gogol_oslogin = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-oslogin`,
  "Google Cloud OS Login SDK",
);

/**
 * Google PageSpeed Insights SDK
 */
export const gogol_pagespeed = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-pagespeed`,
  "Google PageSpeed Insights SDK",
);

/**
 * Google Partners SDK
 */
export const gogol_partners = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-partners`,
  "Google Partners SDK",
);

/**
 * Google People SDK
 */
export const gogol_people = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-people`,
  "Google People SDK",
);

/**
 * Google Photos Library SDK
 */
export const gogol_photoslibrary = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-photoslibrary`,
  "Google Photos Library SDK",
);

/**
 * Google Play Movies Partner SDK
 */
export const gogol_play_moviespartner = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-play-moviespartner`,
  "Google Play Movies Partner SDK",
);

/**
 * Google Play Custom App Publishing SDK
 */
export const gogol_playcustomapp = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-playcustomapp`,
  "Google Play Custom App Publishing SDK",
);

/**
 * Google + SDK
 */
export const gogol_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-plus`,
  "Google + SDK",
);

/**
 * Google + Domains SDK
 */
export const gogol_plus_domains = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-plus-domains`,
  "Google + Domains SDK",
);

/**
 * Google Poly SDK
 */
export const gogol_poly = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-poly`,
  "Google Poly SDK",
);

/**
 * Google Prediction SDK
 */
export const gogol_prediction = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-prediction`,
  "Google Prediction SDK",
);

/**
 * Google Proximity Beacon SDK
 */
export const gogol_proximitybeacon = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-proximitybeacon`,
  "Google Proximity Beacon SDK",
);

/**
 * Google Cloud Pub/Sub SDK
 */
export const gogol_pubsub = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-pubsub`,
  "Google Cloud Pub/Sub SDK",
);

/**
 * Google QPX Express SDK
 */
export const gogol_qpxexpress = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-qpxexpress`,
  "Google QPX Express SDK",
);

/**
 * Google Cloud Memorystore for Redis SDK
 */
export const gogol_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-redis`,
  "Google Cloud Memorystore for Redis SDK",
);

/**
 * Google Remote Build Execution SDK
 */
export const gogol_remotebuildexecution = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-remotebuildexecution`,
  "Google Remote Build Execution SDK",
);

/**
 * Google Replica Pool SDK
 */
export const gogol_replicapool = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-replicapool`,
  "Google Replica Pool SDK",
);

/**
 * Google Compute Engine Instance Group Updater SDK
 */
export const gogol_replicapool_updater = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-replicapool-updater`,
  "Google Compute Engine Instance Group Updater SDK",
);

/**
 * Google Cloud Resource Manager SDK
 */
export const gogol_resourcemanager = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-resourcemanager`,
  "Google Cloud Resource Manager SDK",
);

/**
 * Google Compute Engine Instance Groups SDK
 */
export const gogol_resourceviews = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-resourceviews`,
  "Google Compute Engine Instance Groups SDK",
);

/**
 * Google Cloud Run SDK
 */
export const gogol_run = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-run`,
  "Google Cloud Run SDK",
);

/**
 * Google Cloud Runtime Configuration SDK
 */
export const gogol_runtimeconfig = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-runtimeconfig`,
  "Google Cloud Runtime Configuration SDK",
);

/**
 * Google Safe Browsing SDK
 */
export const gogol_safebrowsing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-safebrowsing`,
  "Google Safe Browsing SDK",
);

/**
 * Google Apps Script SDK
 */
export const gogol_script = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-script`,
  "Google Apps Script SDK",
);

/**
 * Google Search Console URL Testing Tools SDK
 */
export const gogol_searchconsole = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-searchconsole`,
  "Google Search Console URL Testing Tools SDK",
);

/**
 * Google Cloud Security Command Center SDK
 */
export const gogol_securitycenter = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-securitycenter`,
  "Google Cloud Security Command Center SDK",
);

/**
 * Google Service Broker SDK
 */
export const gogol_servicebroker = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-servicebroker`,
  "Google Service Broker SDK",
);

/**
 * Google Service Consumer Management SDK
 */
export const gogol_serviceconsumermanagement = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-serviceconsumermanagement`,
  "Google Service Consumer Management SDK",
);

/**
 * Google Service Control SDK
 */
export const gogol_servicecontrol = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-servicecontrol`,
  "Google Service Control SDK",
);

/**
 * Google Service Management SDK
 */
export const gogol_servicemanagement = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-servicemanagement`,
  "Google Service Management SDK",
);

/**
 * Google Service Networking SDK
 */
export const gogol_servicenetworking = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-servicenetworking`,
  "Google Service Networking SDK",
);

/**
 * Google Service Usage SDK
 */
export const gogol_serviceusage = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-serviceusage`,
  "Google Service Usage SDK",
);

/**
 * Google Service User SDK
 */
export const gogol_serviceuser = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-serviceuser`,
  "Google Service User SDK",
);

/**
 * Google Sheets SDK
 */
export const gogol_sheets = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-sheets`,
  "Google Sheets SDK",
);

/**
 * Google Content API for Shopping SDK
 */
export const gogol_shopping_content = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-shopping-content`,
  "Google Content API for Shopping SDK",
);

/**
 * Google Site Verification SDK
 */
export const gogol_siteverification = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-siteverification`,
  "Google Site Verification SDK",
);

/**
 * Google Slides SDK
 */
export const gogol_slides = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-slides`,
  "Google Slides SDK",
);

/**
 * Google Cloud Source Repositories SDK
 */
export const gogol_sourcerepo = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-sourcerepo`,
  "Google Cloud Source Repositories SDK",
);

/**
 * Google Cloud Spanner SDK
 */
export const gogol_spanner = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-spanner`,
  "Google Cloud Spanner SDK",
);

/**
 * Google Spectrum Database SDK
 */
export const gogol_spectrum = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-spectrum`,
  "Google Spectrum Database SDK",
);

/**
 * Google Cloud Speech-to-Text SDK
 */
export const gogol_speech = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-speech`,
  "Google Cloud Speech-to-Text SDK",
);

/**
 * Google Cloud SQL Admin SDK
 */
export const gogol_sqladmin = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-sqladmin`,
  "Google Cloud SQL Admin SDK",
);

/**
 * Google Cloud Storage JSON SDK
 */
export const gogol_storage = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-storage`,
  "Google Cloud Storage JSON SDK",
);

/**
 * Google Storage Transfer SDK
 */
export const gogol_storage_transfer = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-storage-transfer`,
  "Google Storage Transfer SDK",
);

/**
 * Google Street View Publish SDK
 */
export const gogol_streetviewpublish = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-streetviewpublish`,
  "Google Street View Publish SDK",
);

/**
 * Google Surveys SDK
 */
export const gogol_surveys = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-surveys`,
  "Google Surveys SDK",
);

/**
 * Google Tag Manager SDK
 */
export const gogol_tagmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-tagmanager`,
  "Google Tag Manager SDK",
);

/**
 * Google TaskQueue SDK
 */
export const gogol_taskqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-taskqueue`,
  "Google TaskQueue SDK",
);

/**
 * Google Cloud Testing SDK
 */
export const gogol_testing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-testing`,
  "Google Cloud Testing SDK",
);

/**
 * Google Cloud Text-to-Speech SDK
 */
export const gogol_texttospeech = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-texttospeech`,
  "Google Cloud Text-to-Speech SDK",
);

/**
 * Google Cloud Tool Results SDK
 */
export const gogol_toolresults = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-toolresults`,
  "Google Cloud Tool Results SDK",
);

/**
 * Google Cloud TPU SDK
 */
export const gogol_tpu = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-tpu`,
  "Google Cloud TPU SDK",
);

/**
 * Google Tracing SDK
 */
export const gogol_tracing = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-tracing`,
  "Google Tracing SDK",
);

/**
 * Google Cloud Translation SDK
 */
export const gogol_translate = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-translate`,
  "Google Cloud Translation SDK",
);

/**
 * Google URL Shortener SDK
 */
export const gogol_urlshortener = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-urlshortener`,
  "Google URL Shortener SDK",
);

/**
 * Google Cloud User Accounts SDK
 */
export const gogol_useraccounts = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-useraccounts`,
  "Google Cloud User Accounts SDK",
);

/**
 * Google G Suite Vault SDK
 */
export const gogol_vault = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-vault`,
  "Google G Suite Vault SDK",
);

/**
 * Google Cloud Video Intelligence SDK
 */
export const gogol_videointelligence = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-videointelligence`,
  "Google Cloud Video Intelligence SDK",
);

/**
 * Google Cloud Vision SDK
 */
export const gogol_vision = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-vision`,
  "Google Cloud Vision SDK",
);

/**
 * Google Search Console SDK
 */
export const gogol_webmaster_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-webmaster-tools`,
  "Google Search Console SDK",
);

/**
 * Google Web Security Scanner SDK
 */
export const gogol_websecurityscanner = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-websecurityscanner`,
  "Google Web Security Scanner SDK",
);

/**
 * Google YouTube Data SDK
 */
export const gogol_youtube = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-youtube`,
  "Google YouTube Data SDK",
);

/**
 * Google YouTube Analytics SDK
 */
export const gogol_youtube_analytics = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-youtube-analytics`,
  "Google YouTube Analytics SDK",
);

/**
 * Google YouTube Reporting SDK
 */
export const gogol_youtube_reporting = mkPackage(
  nixRaw`pkgs.haskellPackages.gogol-youtube-reporting`,
  "Google YouTube Reporting SDK",
);

/**
 * A lightweight golden test runner
 */
export const goldplate = mkPackage(
  nixRaw`pkgs.haskellPackages.goldplate`,
  "A lightweight golden test runner",
);

/**
 * Simple interface to the google.com/dictionary API
 */
export const google_dictionary = mkPackage(
  nixRaw`pkgs.haskellPackages.google-dictionary`,
  "Simple interface to the google.com/dictionary API",
);

/**
 * Google Drive API access
 */
export const google_drive = mkPackage(
  nixRaw`pkgs.haskellPackages.google-drive`,
  "Google Drive API access",
);

export const google_isbn = mkPackage(
  nixRaw`pkgs.haskellPackages.google-isbn`,
  "",
);

/**
 * Write GMail filters and output to importable XML
 */
export const google_mail_filters = mkPackage(
  nixRaw`pkgs.haskellPackages.google-mail-filters`,
  "Write GMail filters and output to importable XML",
);

/**
 * Bindings to the Google Geocoding API (formerly Maps Geocoding API)
 */
export const google_maps_geocoding = mkPackage(
  nixRaw`pkgs.haskellPackages.google-maps-geocoding`,
  "Bindings to the Google Geocoding API (formerly Maps Geocoding API)",
);

/**
 * Get Google OAuth2 token for CLI tools
 */
export const google_oauth2_for_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.google-oauth2-for-cli`,
  "Get Google OAuth2 token for CLI tools",
);

/**
 * Bindings to the Google Maps Static API (formerly Static Maps API)
 */
export const google_static_maps = mkPackage(
  nixRaw`pkgs.haskellPackages.google-static-maps`,
  "Bindings to the Google Maps Static API (formerly Static Maps API)",
);

/**
 * Haskell implementation of the Google+ API v1
 */
export const googleplus = mkPackage(
  nixRaw`pkgs.haskellPackages.googleplus`,
  "Haskell implementation of the Google+ API v1",
);

/**
 * proxy gopher over http
 */
export const gopher_proxy = mkPackage(
  nixRaw`pkgs.haskellPackages.gopher-proxy`,
  "proxy gopher over http",
);

/**
 * Gore&Ash engine extension that implements actor style of programming
 */
export const gore_and_ash_actor = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-actor`,
  "Gore&Ash engine extension that implements actor style of programming",
);

/**
 * Core module for Gore&Ash engine that embeds async IO actions into game loop
 */
export const gore_and_ash_async = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-async`,
  "Core module for Gore&Ash engine that embeds async IO actions into game loop",
);

/**
 * Demonstration game for Gore&Ash game engine
 */
export const gore_and_ash_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-demo`,
  "Demonstration game for Gore&Ash game engine",
);

/**
 * Core module for Gore&Ash engine for GLFW input events
 */
export const gore_and_ash_glfw = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-glfw`,
  "Core module for Gore&Ash engine for GLFW input events",
);

/**
 * Core module for Gore&Ash engine that do something
 */
export const gore_and_ash_lambdacube = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-lambdacube`,
  "Core module for Gore&Ash engine that do something",
);

/**
 * Core module for gore-and-ash with logging utilities
 */
export const gore_and_ash_logging = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-logging`,
  "Core module for gore-and-ash with logging utilities",
);

/**
 * Core module for Gore&Ash engine with low level network API
 */
export const gore_and_ash_network = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-network`,
  "Core module for Gore&Ash engine with low level network API",
);

/**
 * Gore&Ash core module for integration with SDL library
 */
export const gore_and_ash_sdl = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-sdl`,
  "Gore&Ash core module for integration with SDL library",
);

/**
 * Gore&Ash module for high level network synchronization
 */
export const gore_and_ash_sync = mkPackage(
  nixRaw`pkgs.haskellPackages.gore-and-ash-sync`,
  "Gore&Ash module for high level network synchronization",
);

/**
 * Generalized Pitch Class Sets for Haskell
 */
export const gpcsets = mkPackage(
  nixRaw`pkgs.haskellPackages.gpcsets`,
  "Generalized Pitch Class Sets for Haskell",
);

/**
 * Haskell GPIO interface, designed specifically for the RaspberryPi
 */
export const gpio = mkPackage(
  nixRaw`pkgs.haskellPackages.gpio`,
  "Haskell GPIO interface, designed specifically for the RaspberryPi",
);

/**
 * Pure module for encoding/decoding Google Polyline
 */
export const gpolyline = mkPackage(
  nixRaw`pkgs.haskellPackages.gpolyline`,
  "Pure module for encoding/decoding Google Polyline",
);

/**
 * For manipulating GPS coordinates and trails
 */
export const gps = mkPackage(
  nixRaw`pkgs.haskellPackages.gps`,
  "For manipulating GPS coordinates and trails",
);

/**
 * GPS to HTML Summary Report
 */
export const gps2htmlReport = mkPackage(
  nixRaw`pkgs.haskellPackages.gps2htmlReport`,
  "GPS to HTML Summary Report",
);

/**
 * Applicative non-linear consumption
 */
export const grab = mkPackage(
  nixRaw`pkgs.haskellPackages.grab`,
  "Applicative non-linear consumption",
);

/**
 * Applicative parsers for form parameter lists
 */
export const grab_form = mkPackage(
  nixRaw`pkgs.haskellPackages.grab-form`,
  "Applicative parsers for form parameter lists",
);

/**
 * Configure grafana dashboards from Dhall expression
 */
export const grafdhall = mkPackage(
  nixRaw`pkgs.haskellPackages.grafdhall`,
  "Configure grafana dashboards from Dhall expression",
);

/**
 * Monadic correlated log events
 */
export const graflog = mkPackage(
  nixRaw`pkgs.haskellPackages.graflog`,
  "Monadic correlated log events",
);

/**
 * A parsing library of context-free grammar combinators
 */
export const grammar_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.grammar-combinators`,
  "A parsing library of context-free grammar combinators",
);

/**
 * Examples using the Grapefruit library
 */
export const grapefruit_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.grapefruit-examples`,
  "Examples using the Grapefruit library",
);

/**
 * Functional Reactive Programming core
 */
export const grapefruit_frp = mkPackage(
  nixRaw`pkgs.haskellPackages.grapefruit-frp`,
  "Functional Reactive Programming core",
);

/**
 * A record system for Functional Reactive Programming
 */
export const grapefruit_records = mkPackage(
  nixRaw`pkgs.haskellPackages.grapefruit-records`,
  "A record system for Functional Reactive Programming",
);

/**
 * Declarative user interface programming
 */
export const grapefruit_ui = mkPackage(
  nixRaw`pkgs.haskellPackages.grapefruit-ui`,
  "Declarative user interface programming",
);

/**
 * GTK+-based backend for declarative user interface programming
 */
export const grapefruit_ui_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.grapefruit-ui-gtk`,
  "GTK+-based backend for declarative user interface programming",
);

/**
 * Class of graphs
 */
export const graph = mkPackage(
  nixRaw`pkgs.haskellPackages.graph`,
  "Class of graphs",
);

/**
 * Fast, memory efficient and persistent graph implementation
 */
export const graph_core = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-core`,
  "Fast, memory efficient and persistent graph implementation",
);

/**
 * Functions for generating structured or random FGL graphs
 */
export const graph_generators = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-generators`,
  "Functions for generating structured or random FGL graphs",
);

/**
 * Interactive graph rewriting system implementing various well-known combinators
 */
export const graph_rewriting_cl = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-cl`,
  "Interactive graph rewriting system implementing various well-known combinators",
);

/**
 * OpenGL interface for interactive port graph rewriting
 */
export const graph_rewriting_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-gl`,
  "OpenGL interface for interactive port graph rewriting",
);

/**
 * Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system
 */
export const graph_rewriting_lambdascope = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-lambdascope`,
  "Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system",
);

/**
 * Force-directed node placement intended for incremental graph drawing
 */
export const graph_rewriting_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-layout`,
  "Force-directed node placement intended for incremental graph drawing",
);

/**
 * Two evalutors of the SKI combinator calculus as interactive graph rewrite systems
 */
export const graph_rewriting_ski = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-ski`,
  "Two evalutors of the SKI combinator calculus as interactive graph rewrite systems",
);

/**
 * Evaluation strategies for port-graph rewriting systems
 */
export const graph_rewriting_strategies = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-strategies`,
  "Evaluation strategies for port-graph rewriting systems",
);

/**
 * Evaluate first-order applicative term rewrite systems interactively using graph reduction
 */
export const graph_rewriting_trs = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-trs`,
  "Evaluate first-order applicative term rewrite systems interactively using graph reduction",
);

/**
 * Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing
 */
export const graph_rewriting_ww = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-rewriting-ww`,
  "Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing",
);

/**
 * Trace the call graph of a program
 */
export const graph_trace = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-trace`,
  "Trace the call graph of a program",
);

/**
 * Converts a graph-trace log into a DOT file for use with Graphviz
 */
export const graph_trace_dot = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-trace-dot`,
  "Converts a graph-trace log into a DOT file for use with Graphviz",
);

/**
 * Converts a graph-trace log into an HTML document
 */
export const graph_trace_viz = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-trace-viz`,
  "Converts a graph-trace log into an HTML document",
);

/**
 * Graph walk abstraction
 */
export const graph_visit = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-visit`,
  "Graph walk abstraction",
);

/**
 * A wrapper around the standard Data.Graph with a less awkward interface
 */
export const graph_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.graph-wrapper`,
  "A wrapper around the standard Data.Graph with a less awkward interface",
);

/**
 * Classes for renderable objects
 */
export const graphicsFormats = mkPackage(
  nixRaw`pkgs.haskellPackages.graphicsFormats`,
  "Classes for renderable objects",
);

/**
 * Tools for creating graphical UIs, based on wxHaskell
 */
export const graphicstools = mkPackage(
  nixRaw`pkgs.haskellPackages.graphicstools`,
  "Tools for creating graphical UIs, based on wxHaskell",
);

/**
 * Graphs and networks library
 */
export const graphite = mkPackage(
  nixRaw`pkgs.haskellPackages.graphite`,
  "Graphs and networks library",
);

/**
 * Present the module dependencies of a program as a "dot" graph
 */
export const graphmod = mkPackage(
  nixRaw`pkgs.haskellPackages.graphmod`,
  "Present the module dependencies of a program as a \"dot\" graph",
);

/**
 * Haskell GraphQL implementation
 */
export const graphql = mkPackage(
  nixRaw`pkgs.haskellPackages.graphql`,
  "Haskell GraphQL implementation",
);

/**
 * A client for Haskell programs to query a GraphQL API
 */
export const graphql_client = mkPackage(
  nixRaw`pkgs.haskellPackages.graphql-client`,
  "A client for Haskell programs to query a GraphQL API",
);

/**
 * GraphQL with batteries
 */
export const graphql_spice = mkPackage(
  nixRaw`pkgs.haskellPackages.graphql-spice`,
  "GraphQL with batteries",
);

/**
 * A simple monadic graph library
 */
export const graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.graphs`,
  "A simple monadic graph library",
);

/**
 * A simple tool to illustrate dependencies between Haskell types
 */
export const graphtype = mkPackage(
  nixRaw`pkgs.haskellPackages.graphtype`,
  "A simple tool to illustrate dependencies between Haskell types",
);

/**
 * A simple interface for generating persistent data and linking its dependencies
 */
export const graphula = mkPackage(
  nixRaw`pkgs.haskellPackages.graphula`,
  "A simple interface for generating persistent data and linking its dependencies",
);

/**
 * Bindings to Graphviz for graph visualisation
 */
export const graphviz = mkPackage(
  nixRaw`pkgs.haskellPackages.graphviz`,
  "Bindings to Graphviz for graph visualisation",
);

/**
 * Generate Gravatar image URLs
 */
export const gravatar = mkPackage(
  nixRaw`pkgs.haskellPackages.gravatar`,
  "Generate Gravatar image URLs",
);

/**
 * Gray encoding schemes
 */
export const gray_extended = mkPackage(
  nixRaw`pkgs.haskellPackages.gray-extended`,
  "Gray encoding schemes",
);

/**
 * A foreign function interface pre-processor library for Haskell
 */
export const greencard_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.greencard-lib`,
  "A foreign function interface pre-processor library for Haskell",
);

/**
 * Simple clipboard manager to be integrated with rofi
 */
export const greenclip = mkPackage(
  nixRaw`pkgs.haskellPackages.greenclip`,
  "Simple clipboard manager to be integrated with rofi",
);

/**
 * Practical Deep Learning in Haskell
 */
export const grenade = mkPackage(
  nixRaw`pkgs.haskellPackages.grenade`,
  "Practical Deep Learning in Haskell",
);

/**
 * Haskell binding for Gremlin graph query language
 */
export const greskell = mkPackage(
  nixRaw`pkgs.haskellPackages.greskell`,
  "Haskell binding for Gremlin graph query language",
);

/**
 * Haskell client for Gremlin Server using WebSocket serializer
 */
export const greskell_websocket = mkPackage(
  nixRaw`pkgs.haskellPackages.greskell-websocket`,
  "Haskell client for Gremlin Server using WebSocket serializer",
);

/**
 * Tools for working with regular grids (graphs, lattices)
 */
export const grid = mkPackage(
  nixRaw`pkgs.haskellPackages.grid`,
  "Tools for working with regular grids (graphs, lattices)",
);

/**
 * Game engine for Prototyping on a Grid
 */
export const grid_proto = mkPackage(
  nixRaw`pkgs.haskellPackages.grid-proto`,
  "Game engine for Prototyping on a Grid",
);

/**
 * Collision detection for GridBox
 */
export const gridbounds = mkPackage(
  nixRaw`pkgs.haskellPackages.gridbounds`,
  "Collision detection for GridBox",
);

/**
 * A grid box model
 */
export const gridbox = mkPackage(
  nixRaw`pkgs.haskellPackages.gridbox`,
  "A grid box model",
);

/**
 * Grid-based multimedia engine
 */
export const gridland = mkPackage(
  nixRaw`pkgs.haskellPackages.gridland`,
  "Grid-based multimedia engine",
);

/**
 * Parser for reStructuredText-style grid tables
 */
export const gridtables = mkPackage(
  nixRaw`pkgs.haskellPackages.gridtables`,
  "Parser for reStructuredText-style grid tables",
);

/**
 * Symbolic evaluation as a library
 */
export const grisette = mkPackage(
  nixRaw`pkgs.haskellPackages.grisette`,
  "Symbolic evaluation as a library",
);

/**
 * Support for monad-coroutine package with Grisette
 */
export const grisette_monad_coroutine = mkPackage(
  nixRaw`pkgs.haskellPackages.grisette-monad-coroutine`,
  "Support for monad-coroutine package with Grisette",
);

/**
 * Pretty printing for well-behaved Show instances
 */
export const groom = mkPackage(
  nixRaw`pkgs.haskellPackages.groom`,
  "Pretty printing for well-behaved Show instances",
);

/**
 * A spoof on gloss for terminal animation
 */
export const gross = mkPackage(
  nixRaw`pkgs.haskellPackages.gross`,
  "A spoof on gloss for terminal animation",
);

/**
 * Extended Converter Library for groundhog embedded types
 */
export const groundhog_converters = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-converters`,
  "Extended Converter Library for groundhog embedded types",
);

/**
 * Type-safe datatype-database mapping library
 */
export const groundhog_inspector = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-inspector`,
  "Type-safe datatype-database mapping library",
);

/**
 * MySQL backend for the groundhog library
 */
export const groundhog_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-mysql`,
  "MySQL backend for the groundhog library",
);

/**
 * PostgreSQL backend for the groundhog library
 */
export const groundhog_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-postgresql`,
  "PostgreSQL backend for the groundhog library",
);

/**
 * Sqlite3 backend for the groundhog library
 */
export const groundhog_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-sqlite`,
  "Sqlite3 backend for the groundhog library",
);

/**
 * Type-safe datatype-database mapping library
 */
export const groundhog_th = mkPackage(
  nixRaw`pkgs.haskellPackages.groundhog-th`,
  "Type-safe datatype-database mapping library",
);

/**
 * Replacement definition of Data.List.GroupBy
 */
export const groupBy = mkPackage(
  nixRaw`pkgs.haskellPackages.groupBy`,
  "Replacement definition of Data.List.GroupBy",
);

/**
 * Shell command for grouping files by dates into folders
 */
export const group_by_date = mkPackage(
  nixRaw`pkgs.haskellPackages.group-by-date`,
  "Shell command for grouping files by dates into folders",
);

/**
 * A Groupoid class
 */
export const groupoid = mkPackage(
  nixRaw`pkgs.haskellPackages.groupoid`,
  "A Groupoid class",
);

/**
 * This package has been absorbed into semigroupoids 4.0
 */
export const groupoids = mkPackage(
  nixRaw`pkgs.haskellPackages.groupoids`,
  "This package has been absorbed into semigroupoids 4.0",
);

/**
 * Groups
 */
export const groups = mkPackage(
  nixRaw`pkgs.haskellPackages.groups`,
  "Groups",
);

/**
 * Generically derive Group instances
 */
export const groups_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.groups-generic`,
  "Generically derive Group instances",
);

/**
 * gRPC client for etcd
 */
export const grpc_etcd_client = mkPackage(
  nixRaw`pkgs.haskellPackages.grpc-etcd-client`,
  "gRPC client for etcd",
);

/**
 * Haskell implementation of gRPC layered on shared C library
 */
export const grpc_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.grpc-haskell`,
  "Haskell implementation of gRPC layered on shared C library",
);

/**
 * Haskell implementation of gRPC layered on shared C library
 */
export const grpc_haskell_core = mkPackage(
  nixRaw`pkgs.haskellPackages.grpc-haskell-core`,
  "Haskell implementation of gRPC layered on shared C library",
);

/**
 * fractal explorer GUI using the ruff library
 */
export const gruff = mkPackage(
  nixRaw`pkgs.haskellPackages.gruff`,
  "fractal explorer GUI using the ruff library",
);

/**
 * Mandelbrot Set examples using ruff and gruff
 */
export const gruff_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.gruff-examples`,
  "Mandelbrot Set examples using ruff and gruff",
);

/**
 * Bindings for GNU libgsasl
 */
export const gsasl = mkPackage(
  nixRaw`pkgs.haskellPackages.gsasl`,
  "Bindings for GNU libgsasl",
);

/**
 * Generic implementation of Gerstein/Sonnhammer/Chothia weighting
 */
export const gsc_weighting = mkPackage(
  nixRaw`pkgs.haskellPackages.gsc-weighting`,
  "Generic implementation of Gerstein/Sonnhammer/Chothia weighting",
);

/**
 * scrapes google scholar, provides RSS feed
 */
export const gscholar_rss = mkPackage(
  nixRaw`pkgs.haskellPackages.gscholar-rss`,
  "scrapes google scholar, provides RSS feed",
);

/**
 * Instances for using gsl-random with random-fu
 */
export const gsl_random_fu = mkPackage(
  nixRaw`pkgs.haskellPackages.gsl-random-fu`,
  "Instances for using gsl-random with random-fu",
);

/**
 * A visual generic menu
 */
export const gsmenu = mkPackage(
  nixRaw`pkgs.haskellPackages.gsmenu`,
  "A visual generic menu",
);

/**
 * libgssapi and libkrb5 bindings for haskell
 */
export const gssapi = mkPackage(
  nixRaw`pkgs.haskellPackages.gssapi`,
  "libgssapi and libkrb5 bindings for haskell",
);

/**
 * WAI Middleware for SPNEGO authentiaction
 */
export const gssapi_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.gssapi-wai`,
  "WAI Middleware for SPNEGO authentiaction",
);

/**
 * Generic implementation of Storable
 */
export const gstorable = mkPackage(
  nixRaw`pkgs.haskellPackages.gstorable`,
  "Generic implementation of Storable",
);

/**
 * Console and GUI interface for Google Translate service
 */
export const gt_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.gt-tools`,
  "Console and GUI interface for Google Translate service",
);

/**
 * The General Transit Feed Specification format
 */
export const gtfs = mkPackage(
  nixRaw`pkgs.haskellPackages.gtfs`,
  "The General Transit Feed Specification format",
);

/**
 * GTFS RealTime protobafs library (autogenerated from .proto file)
 */
export const gtfs_realtime = mkPackage(
  nixRaw`pkgs.haskellPackages.gtfs-realtime`,
  "GTFS RealTime protobafs library (autogenerated from .proto file)",
);

/**
 * Binding to the Gtk+ graphical user interface library
 */
export const gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk`,
  "Binding to the Gtk+ graphical user interface library",
);

/**
 * Tools to build the Gtk2Hs suite of User Interface libraries
 */
export const gtk2hs_buildtools = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-buildtools`,
  "Tools to build the Gtk2Hs suite of User Interface libraries",
);

/**
 * A type class for cast functions of Gtk2hs: glade package
 */
export const gtk2hs_cast_glade = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-glade`,
  "A type class for cast functions of Gtk2hs: glade package",
);

/**
 * A type class for cast functions of Gtk2hs: glib package
 */
export const gtk2hs_cast_glib = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-glib`,
  "A type class for cast functions of Gtk2hs: glib package",
);

/**
 * A type class for cast functions of Gtk2hs: gnomevfs package
 */
export const gtk2hs_cast_gnomevfs = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-gnomevfs`,
  "A type class for cast functions of Gtk2hs: gnomevfs package",
);

/**
 * A type class for cast functions of Gtk2hs: gtk package
 */
export const gtk2hs_cast_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-gtk`,
  "A type class for cast functions of Gtk2hs: gtk package",
);

/**
 * A type class for cast functions of Gtk2hs: gtkglext package
 */
export const gtk2hs_cast_gtkglext = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-gtkglext`,
  "A type class for cast functions of Gtk2hs: gtkglext package",
);

/**
 * A type class for cast functions of Gtk2hs: gtksourceview2 package
 */
export const gtk2hs_cast_gtksourceview2 = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk2hs-cast-gtksourceview2`,
  "A type class for cast functions of Gtk2hs: gtksourceview2 package",
);

/**
 * Binding to the Gtk+ 3 graphical user interface library
 */
export const gtk3 = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk3`,
  "Binding to the Gtk+ 3 graphical user interface library",
);

/**
 * Bindings for the Gtk/OS X integration library
 */
export const gtk3_mac_integration = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk3-mac-integration`,
  "Bindings for the Gtk/OS X integration library",
);

/**
 * A simple custom form widget for gtk which allows inputing of JSON values
 */
export const gtk_jsinput = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-jsinput`,
  "A simple custom form widget for gtk which allows inputing of JSON values",
);

/**
 * Large TreeStore support for gtk2hs
 */
export const gtk_largeTreeStore = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-largeTreeStore`,
  "Large TreeStore support for gtk2hs",
);

/**
 * Bindings for the Gtk/OS X integration library
 */
export const gtk_mac_integration = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-mac-integration`,
  "Bindings for the Gtk/OS X integration library",
);

/**
 * GTK+ Serialized event
 */
export const gtk_serialized_event = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-serialized-event`,
  "GTK+ Serialized event",
);

/**
 * A simple custom form widget for gtk which allows single LOC creation/updating of list views
 */
export const gtk_simple_list_view = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-simple-list-view`,
  "A simple custom form widget for gtk which allows single LOC creation/updating of list views",
);

/**
 * A standalone StatusNotifierItem/AppIndicator tray
 */
export const gtk_sni_tray = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-sni-tray`,
  "A standalone StatusNotifierItem/AppIndicator tray",
);

/**
 * Library for creating strut windows with gi-gtk
 */
export const gtk_strut = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-strut`,
  "Library for creating strut windows with gi-gtk",
);

/**
 * A simple custom form widget for gtk which allows single LOC creation/updating of toggle button lists
 */
export const gtk_toggle_button_list = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-toggle-button-list`,
  "A simple custom form widget for gtk which allows single LOC creation/updating of toggle button lists",
);

/**
 * A wrapper around the eggtraymanager library for Linux system trays
 */
export const gtk_traymanager = mkPackage(
  nixRaw`pkgs.haskellPackages.gtk-traymanager`,
  "A wrapper around the eggtraymanager library for Linux system trays",
);

/**
 * Binding to the GtkImageView library
 */
export const gtkimageview = mkPackage(
  nixRaw`pkgs.haskellPackages.gtkimageview`,
  "Binding to the GtkImageView library",
);

/**
 * Gnome rsync progress display
 */
export const gtkrsync = mkPackage(
  nixRaw`pkgs.haskellPackages.gtkrsync`,
  "Gnome rsync progress display",
);

/**
 * Memory allocation with added stress tests and integrity checks
 */
export const guarded_allocation = mkPackage(
  nixRaw`pkgs.haskellPackages.guarded-allocation`,
  "Memory allocation with added stress tests and integrity checks",
);

/**
 * Datatype-generic rewriting with preconditions
 */
export const guarded_rewriting = mkPackage(
  nixRaw`pkgs.haskellPackages.guarded-rewriting`,
  "Datatype-generic rewriting with preconditions",
);

/**
 * Generate simple combinators given their type
 */
export const guess_combinator = mkPackage(
  nixRaw`pkgs.haskellPackages.guess-combinator`,
  "Generate simple combinators given their type",
);

/**
 * A simple wrapper around uuid
 */
export const guid = mkPackage(
  nixRaw`pkgs.haskellPackages.guid`,
  "A simple wrapper around uuid",
);

/**
 * The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project
 */
export const gutenberg_fibonaccis = mkPackage(
  nixRaw`pkgs.haskellPackages.gutenberg-fibonaccis`,
  "The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project",
);

/**
 * GraphViz Tabular Interface
 */
export const gvti = mkPackage(
  nixRaw`pkgs.haskellPackages.gvti`,
  "GraphViz Tabular Interface",
);

/**
 * Control your Arduino board from Haskell
 */
export const hArduino = mkPackage(
  nixRaw`pkgs.haskellPackages.hArduino`,
  "Control your Arduino board from Haskell",
);

/**
 * An abstraction layer for BDD libraries
 */
export const hBDD = mkPackage(
  nixRaw`pkgs.haskellPackages.hBDD`,
  "An abstraction layer for BDD libraries",
);

/**
 * Conceptual modelling support for Haskell
 */
export const hCM = mkPackage(
  nixRaw`pkgs.haskellPackages.hCM`,
  "Conceptual modelling support for Haskell",
);

/**
 * The tool to transform the OFF to other image format
 */
export const hOff_display = mkPackage(
  nixRaw`pkgs.haskellPackages.hOff-display`,
  "The tool to transform the OFF to other image format",
);

/**
 * The parser to parser the OFF(Object File Format, Princeton ModelNet)
 */
export const hOff_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.hOff-parser`,
  "The parser to parser the OFF(Object File Format, Princeton ModelNet)",
);

/**
 * native Haskell implementation of OpenPGP (RFC4880)
 */
export const hOpenPGP = mkPackage(
  nixRaw`pkgs.haskellPackages.hOpenPGP`,
  "native Haskell implementation of OpenPGP (RFC4880)",
);

/**
 * Protein Databank file format library
 */
export const hPDB = mkPackage(
  nixRaw`pkgs.haskellPackages.hPDB`,
  "Protein Databank file format library",
);

/**
 * Examples for hPDB library
 */
export const hPDB_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.hPDB-examples`,
  "Examples for hPDB library",
);

/**
 * Interface to Amazon's Simple Storage Service (S3)
 */
export const hS3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hS3`,
  "Interface to Amazon's Simple Storage Service (S3)",
);

/**
 * A Gtk mixer GUI application for FreeBSD
 */
export const hXmixer = mkPackage(
  nixRaw`pkgs.haskellPackages.hXmixer`,
  "A Gtk mixer GUI application for FreeBSD",
);

/**
 * Haskell message bot framework
 */
export const habit = mkPackage(
  nixRaw`pkgs.haskellPackages.habit`,
  "Haskell message bot framework",
);

/**
 * customizable pretty printer library for tables
 */
export const hable = mkPackage(
  nixRaw`pkgs.haskellPackages.hable`,
  "customizable pretty printer library for tables",
);

/**
 * A minimalist static blog generator
 */
export const hablo = mkPackage(
  nixRaw`pkgs.haskellPackages.hablo`,
  "A minimalist static blog generator",
);

/**
 * A blog system
 */
export const hablog = mkPackage(
  nixRaw`pkgs.haskellPackages.hablog`,
  "A blog system",
);

/**
 * Template Haskell framework for automatic FFI code generation
 */
export const hacanon_light = mkPackage(
  nixRaw`pkgs.haskellPackages.hacanon-light`,
  "Template Haskell framework for automatic FFI code generation",
);

/**
 * a Haskell Webserver Interface
 */
export const hack = mkPackage(
  nixRaw`pkgs.haskellPackages.hack`,
  "a Haskell Webserver Interface",
);

/**
 * a Haskell Webserver Interface (V2)
 */
export const hack2 = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2`,
  "a Haskell Webserver Interface (V2)",
);

/**
 * Hack2 contrib extra
 */
export const hack2_contrib_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2-contrib-extra`,
  "Hack2 contrib extra",
);

/**
 * Hack2 Happstack server handler
 */
export const hack2_handler_happstack_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2-handler-happstack-server`,
  "Hack2 Happstack server handler",
);

/**
 * Hack2 Mongrel2 HTTP handler
 */
export const hack2_handler_mongrel2_http = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2-handler-mongrel2-http`,
  "Hack2 Mongrel2 HTTP handler",
);

/**
 * Hack2 Snap server handler
 */
export const hack2_handler_snap_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2-handler-snap-server`,
  "Hack2 Snap server handler",
);

/**
 * Hack2 interface to WAI
 */
export const hack2_interface_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.hack2-interface-wai`,
  "Hack2 interface to WAI",
);

/**
 * Hack contrib
 */
export const hack_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-contrib`,
  "Hack contrib",
);

/**
 * Hack helper that renders Press templates
 */
export const hack_contrib_press = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-contrib-press`,
  "Hack helper that renders Press templates",
);

/**
 * Allows programs written against MonadCGI to run with any hack handler. (deprecated)
 */
export const hack_frontend_monadcgi = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-frontend-monadcgi`,
  "Allows programs written against MonadCGI to run with any hack handler. (deprecated)",
);

/**
 * hack handler implementation using epoll
 */
export const hack_handler_epoll = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-handler-epoll`,
  "hack handler implementation using epoll",
);

/**
 * Hack EvHTTP (libevent) Handler
 */
export const hack_handler_evhttp = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-handler-evhttp`,
  "Hack EvHTTP (libevent) Handler",
);

/**
 * Hack handler direct to fastcgi (deprecated)
 */
export const hack_handler_fastcgi = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-handler-fastcgi`,
  "Hack handler direct to fastcgi (deprecated)",
);

/**
 * Hyena hack handler
 */
export const hack_handler_hyena = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-handler-hyena`,
  "Hyena hack handler",
);

/**
 * A simplistic HTTP server handler for Hack. (deprecated)
 */
export const hack_handler_simpleserver = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-handler-simpleserver`,
  "A simplistic HTTP server handler for Hack. (deprecated)",
);

/**
 * Applies some basic redirect rules to get cleaner paths. (deprecated)
 */
export const hack_middleware_cleanpath = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-middleware-cleanpath`,
  "Applies some basic redirect rules to get cleaner paths. (deprecated)",
);

/**
 * Middleware for easily keeping session data in client cookies. (deprecated)
 */
export const hack_middleware_clientsession = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-middleware-clientsession`,
  "Middleware for easily keeping session data in client cookies. (deprecated)",
);

/**
 * Automatic gzip compression of responses. (deprecated)
 */
export const hack_middleware_gzip = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-middleware-gzip`,
  "Automatic gzip compression of responses. (deprecated)",
);

/**
 * Automatic wrapping of JSON responses to convert into JSONP. (deprecated)
 */
export const hack_middleware_jsonp = mkPackage(
  nixRaw`pkgs.haskellPackages.hack-middleware-jsonp`,
  "Automatic wrapping of JSON responses to convert into JSONP. (deprecated)",
);

/**
 * Send new Hackage releases to Twitter
 */
export const hackage2twitter = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage2twitter`,
  "Send new Hackage releases to Twitter",
);

/**
 * CLI tool for Hackage
 */
export const hackage_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-cli`,
  "CLI tool for Hackage",
);

/**
 * Access cabal-install's Hackage database via Data.Map
 */
export const hackage_db = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-db`,
  "Access cabal-install's Hackage database via Data.Map",
);

/**
 * Generate cumulative graphs of hackage uploads
 */
export const hackage_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-plot`,
  "Generate cumulative graphs of hackage uploads",
);

/**
 * Manage secure file-based package repositories
 */
export const hackage_repo_tool = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-repo-tool`,
  "Manage secure file-based package repositories",
);

/**
 * Hackage security library
 */
export const hackage_security = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-security`,
  "Hackage security library",
);

/**
 * Hackage security bindings against the HTTP library
 */
export const hackage_security_HTTP = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-security-HTTP`,
  "Hackage security bindings against the HTTP library",
);

/**
 * Generate sparkline graphs of hackage statistics
 */
export const hackage_sparks = mkPackage(
  nixRaw`pkgs.haskellPackages.hackage-sparks`,
  "Generate sparkline graphs of hackage statistics",
);

/**
 * "Hack" like a programmer in movies and games!
 */
export const hackertyper = mkPackage(
  nixRaw`pkgs.haskellPackages.hackertyper`,
  "\"Hack\" like a programmer in movies and games!",
);

/**
 * Generate useful files for Haskell projects
 */
export const hackmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.hackmanager`,
  "Generate useful files for Haskell projects",
);

/**
 * Hackage and Portage integration tool
 */
export const hackport = mkPackage(
  nixRaw`pkgs.haskellPackages.hackport`,
  "Hackage and Portage integration tool",
);

/**
 * A documentation-generation tool for Haskell libraries
 */
export const haddock = mkPackage(
  nixRaw`pkgs.haskellPackages.haddock`,
  "A documentation-generation tool for Haskell libraries",
);

/**
 * A documentation-generation tool for Haskell libraries
 */
export const haddock_2_23_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.haddock_2_23_1`,
  "A documentation-generation tool for Haskell libraries",
);

/**
 * A documentation-only package exemplifying haddock markup features
 */
export const haddock_cheatsheet = mkPackage(
  nixRaw`pkgs.haskellPackages.haddock-cheatsheet`,
  "A documentation-only package exemplifying haddock markup features",
);

/**
 * Library exposing some functionality of Haddock
 */
export const haddock_library = mkPackage(
  nixRaw`pkgs.haskellPackages.haddock-library`,
  "Library exposing some functionality of Haddock",
);

/**
 * Library exposing some functionality of Haddock
 */
export const haddock_library_1_7_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.haddock-library_1_7_0`,
  "Library exposing some functionality of Haddock",
);

/**
 * Generate docset of Dash by Haddock haskell documentation tool
 */
export const haddocset = mkPackage(
  nixRaw`pkgs.haskellPackages.haddocset`,
  "Generate docset of Dash by Haddock haskell documentation tool",
);

/**
 * Dockerfile Linter JavaScript API
 */
export const hadolint = mkPackage(
  nixRaw`pkgs.haskellPackages.hadolint`,
  "Dockerfile Linter JavaScript API",
);

/**
 * Fast command line tools for working with Hadoop
 */
export const hadoop_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.hadoop-tools`,
  "Fast command line tools for working with Hadoop",
);

/**
 * Confirm delegation of NS and MX records
 */
export const haeredes = mkPackage(
  nixRaw`pkgs.haskellPackages.haeredes`,
  "Confirm delegation of NS and MX records",
);

/**
 * A static site generator with blogging/comments support
 */
export const haggis = mkPackage(
  nixRaw`pkgs.haskellPackages.haggis`,
  "A static site generator with blogging/comments support",
);

/**
 * A simple library for creating animated ascii art on ANSI terminals
 */
export const haha = mkPackage(
  nixRaw`pkgs.haskellPackages.haha`,
  "A simple library for creating animated ascii art on ANSI terminals",
);

/**
 * A program to send emails throught the Mailgun api
 */
export const hailgun_send = mkPackage(
  nixRaw`pkgs.haskellPackages.hailgun-send`,
  "A program to send emails throught the Mailgun api",
);

/**
 * Easy-to-use wrapper for the hailgun package
 */
export const hailgun_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.hailgun-simple`,
  "Easy-to-use wrapper for the hailgun package",
);

/**
 * Dynamic launcher of Hails applications
 */
export const hails_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.hails-bin`,
  "Dynamic launcher of Hails applications",
);

/**
 * make tool. ruby : rake = haskell : hake
 */
export const hake = mkPackage(
  nixRaw`pkgs.haskellPackages.hake`,
  "make tool. ruby : rake = haskell : hake",
);

/**
 * A static website compiler library
 */
export const hakyll = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll`,
  "A static website compiler library",
);

/**
 * Hakyll extension for rendering Coq code using Alectryon
 */
export const hakyll_alectryon = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-alectryon`,
  "Hakyll extension for rendering Coq code using Alectryon",
);

/**
 * automatic hyphenation for Hakyll
 */
export const hakyll_contrib_hyphenation = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-contrib-hyphenation`,
  "automatic hyphenation for Hakyll",
);

/**
 * Convert from other blog engines to Hakyll
 */
export const hakyll_convert = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-convert`,
  "Convert from other blog engines to Hakyll",
);

/**
 * Hakyll wrapper for the Elm compiler
 */
export const hakyll_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-elm`,
  "Hakyll wrapper for the Elm compiler",
);

export const hakyll_favicon = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-favicon`,
  "",
);

/**
 * FileStore utilities for Hakyll
 */
export const hakyll_filestore = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-filestore`,
  "FileStore utilities for Hakyll",
);

/**
 * Hakyll utilities to work with images
 */
export const hakyll_images = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-images`,
  "Hakyll utilities to work with images",
);

/**
 * Integrate ogmarkup document with Hakyll
 */
export const hakyll_ogmarkup = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-ogmarkup`,
  "Integrate ogmarkup document with Hakyll",
);

/**
 * Hakyll compiler for arbitrary external processes
 */
export const hakyll_process = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-process`,
  "Hakyll compiler for arbitrary external processes",
);

/**
 * Hakyll SASS compiler over hsass
 */
export const hakyll_sass = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-sass`,
  "Hakyll SASS compiler over hsass",
);

/**
 * Hakyll Hamlet compiler
 */
export const hakyll_shakespeare = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-shakespeare`,
  "Hakyll Hamlet compiler",
);

/**
 * Use shortcut-links in markdown file for Hakyll
 */
export const hakyll_shortcut_links = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyll-shortcut-links`,
  "Use shortcut-links in markdown file for Hakyll",
);

/**
 * A Hakyll compiler for Handlebars-like templates
 */
export const hakyllbars = mkPackage(
  nixRaw`pkgs.haskellPackages.hakyllbars`,
  "A Hakyll compiler for Handlebars-like templates",
);

/**
 * A tool to generate missing import statements for Haskell modules
 */
export const halberd = mkPackage(
  nixRaw`pkgs.haskellPackages.halberd`,
  "A tool to generate missing import statements for Haskell modules",
);

/**
 * Half-precision floating-point
 */
export const half = mkPackage(
  nixRaw`pkgs.haskellPackages.half`,
  "Half-precision floating-point",
);

/**
 * Additive monoids generalising vector spaces
 */
export const half_space = mkPackage(
  nixRaw`pkgs.haskellPackages.half-space`,
  "Additive monoids generalising vector spaces",
);

/**
 * A library to provide special kind of two-column terminal output for Phladiprelio
 */
export const halfsplit = mkPackage(
  nixRaw`pkgs.haskellPackages.halfsplit`,
  "A library to provide special kind of two-column terminal output for Phladiprelio",
);

/**
 * Integration between Halide and JuicyPixels
 */
export const halide_JuicyPixels = mkPackage(
  nixRaw`pkgs.haskellPackages.halide-JuicyPixels`,
  "Integration between Halide and JuicyPixels",
);

/**
 * Integration between Halide and ArrayFire
 */
export const halide_arrayfire = mkPackage(
  nixRaw`pkgs.haskellPackages.halide-arrayfire`,
  "Integration between Halide and ArrayFire",
);

/**
 * Symmetry operations generater of Hall Symbols
 */
export const hall_symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.hall-symbols`,
  "Symmetry operations generater of Hall Symbols",
);

/**
 * GTK application for playing Halma
 */
export const halma_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.halma-gui`,
  "GTK application for playing Halma",
);

/**
 * Telegram bot for playing Halma
 */
export const halma_telegram_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.halma-telegram-bot`,
  "Telegram bot for playing Halma",
);

/**
 * looks for functions given a set of example input/outputs
 */
export const haltavista = mkPackage(
  nixRaw`pkgs.haskellPackages.haltavista`,
  "looks for functions given a set of example input/outputs",
);

export const ham = mkPackage(
  nixRaw`pkgs.haskellPackages.ham`,
  "",
);

/**
 * Binding to the OS level Midi services (fork of system-midi)
 */
export const hamid = mkPackage(
  nixRaw`pkgs.haskellPackages.hamid`,
  "Binding to the OS level Midi services (fork of system-midi)",
);

/**
 * Physics on generalized coordinate systems using Hamiltonian Mechanics and AD
 */
export const hamilton = mkPackage(
  nixRaw`pkgs.haskellPackages.hamilton`,
  "Physics on generalized coordinate systems using Hamiltonian Mechanics and AD",
);

/**
 * Haml-like template files that are compile-time checked (deprecated)
 */
export const hamlet = mkPackage(
  nixRaw`pkgs.haskellPackages.hamlet`,
  "Haml-like template files that are compile-time checked (deprecated)",
);

/**
 * Intel AMT serial-over-lan (SOL) client
 */
export const hamtsolo = mkPackage(
  nixRaw`pkgs.haskellPackages.hamtsolo`,
  "Intel AMT serial-over-lan (SOL) client",
);

/**
 * Library to handle abstract music
 */
export const hamusic = mkPackage(
  nixRaw`pkgs.haskellPackages.hamusic`,
  "Library to handle abstract music",
);

/**
 * Convert Halfwidth Katakana to Fullwidth Katakana
 */
export const han2zen = mkPackage(
  nixRaw`pkgs.haskellPackages.han2zen`,
  "Convert Halfwidth Katakana to Fullwidth Katakana",
);

/**
 * This package is deprecated. It formerly contained Haskell utilities for data structures and data manipulation.
 */
export const handa_data = mkPackage(
  nixRaw`pkgs.haskellPackages.handa-data`,
  "This package is deprecated. It formerly contained Haskell utilities for data structures and data manipulation.",
);

/**
 * Geographic and Geometric Data
 */
export const handa_geodata = mkPackage(
  nixRaw`pkgs.haskellPackages.handa-geodata`,
  "Geographic and Geometric Data",
);

/**
 * Utility functions for OpenGL and GLUT
 */
export const handa_opengl = mkPackage(
  nixRaw`pkgs.haskellPackages.handa-opengl`,
  "Utility functions for OpenGL and GLUT",
);

/**
 * API Client for the handwriting.io API.
 */
export const handwriting = mkPackage(
  nixRaw`pkgs.haskellPackages.handwriting`,
  "API Client for the handwriting.io API.",
);

/**
 * Hangman implementation in Haskell written in two hours
 */
export const hangman = mkPackage(
  nixRaw`pkgs.haskellPackages.hangman`,
  "Hangman implementation in Haskell written in two hours",
);

/**
 * Driver for real ethernet devices for HaNS
 */
export const hans_pcap = mkPackage(
  nixRaw`pkgs.haskellPackages.hans-pcap`,
  "Driver for real ethernet devices for HaNS",
);

/**
 * The "Haskell Applets" Gtk+ ver. 2 back-end for "happlets".
 */
export const happlets_lib_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.happlets-lib-gtk`,
  "The \"Haskell Applets\" Gtk+ ver. 2 back-end for \"happlets\".",
);

export const happs_hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.happs-hsp`,
  "",
);

/**
 * Utilities for using HSP templates in HAppS applications
 */
export const happs_hsp_template = mkPackage(
  nixRaw`pkgs.haskellPackages.happs-hsp-template`,
  "Utilities for using HSP templates in HAppS applications",
);

/**
 * A Happstack Tutorial that is its own web 2.0-type demo.
 */
export const happs_tutorial = mkPackage(
  nixRaw`pkgs.haskellPackages.happs-tutorial`,
  "A Happstack Tutorial that is its own web 2.0-type demo.",
);

/**
 * A Happstack Authentication Suite
 */
export const happstack_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-auth`,
  "A Happstack Authentication Suite",
);

/**
 * Happstack Authentication Library
 */
export const happstack_authenticate = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-authenticate`,
  "Happstack Authentication Library",
);

/**
 * Web related tools and services
 */
export const happstack_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-contrib`,
  "Web related tools and services",
);

/**
 * Happstack data manipulation libraries
 */
export const happstack_data = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-data`,
  "Happstack data manipulation libraries",
);

/**
 * Cross-request user interactions for Happstack
 */
export const happstack_dlg = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-dlg`,
  "Cross-request user interactions for Happstack",
);

/**
 * A package for building Facebook applications using Happstack
 */
export const happstack_facebook = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-facebook`,
  "A package for building Facebook applications using Happstack",
);

/**
 * Happstack extension for use with FastCGI
 */
export const happstack_fastcgi = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-fastcgi`,
  "Happstack extension for use with FastCGI",
);

/**
 * Support for using Fay with Happstack
 */
export const happstack_fay = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-fay`,
  "Support for using Fay with Happstack",
);

/**
 * Support for using Fay with Happstack
 */
export const happstack_fay_ajax = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-fay-ajax`,
  "Support for using Fay with Happstack",
);

/**
 * Glue code for using Happstack with acid-state, web-routes, reform, and HSP
 */
export const happstack_foundation = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-foundation`,
  "Glue code for using Happstack with acid-state, web-routes, reform, and HSP",
);

/**
 * Support for using Heist templates in Happstack
 */
export const happstack_heist = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-heist`,
  "Support for using Heist templates in Happstack",
);

/**
 * Convenience functions for Happstack
 */
export const happstack_helpers = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-helpers`,
  "Convenience functions for Happstack",
);

/**
 * Support for using HSP templates in Happstack
 */
export const happstack_hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-hsp`,
  "Support for using HSP templates in Happstack",
);

/**
 * Efficient relational queries on Haskell sets
 */
export const happstack_ixset = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-ixset`,
  "Efficient relational queries on Haskell sets",
);

/**
 * Support for using JMacro with Happstack
 */
export const happstack_jmacro = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-jmacro`,
  "Support for using JMacro with Happstack",
);

/**
 * The haskell application server stack + reload
 */
export const happstack_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-plugins`,
  "The haskell application server stack + reload",
);

/**
 * Web related tools and services
 */
export const happstack_server = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-server`,
  "Web related tools and services",
);

/**
 * extend happstack-server with https:// support (TLS/SSL)
 */
export const happstack_server_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-server-tls`,
  "extend happstack-server with https:// support (TLS/SSL)",
);

/**
 * Event-based distributed state
 */
export const happstack_state = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-state`,
  "Event-based distributed state",
);

/**
 * Support for static URL routing with overlap detection for Happstack
 */
export const happstack_static_routing = mkPackage(
  nixRaw`pkgs.haskellPackages.happstack-static-routing`,
  "Support for static URL routing with overlap detection for Happstack",
);

/**
 * Happy is a parser generator for Haskell
 */
export const happy = mkPackage(
  nixRaw`pkgs.haskellPackages.happy`,
  "Happy is a parser generator for Haskell",
);

/**
 * Happy is a parser generator for Haskell
 */
export const happy_1_19_12 = mkPackage(
  nixRaw`pkgs.haskellPackages.happy_1_19_12`,
  "Happy is a parser generator for Haskell",
);

/**
 * Parser for dot made with happy
 */
export const happy_dot = mkPackage(
  nixRaw`pkgs.haskellPackages.happy-dot`,
  "Parser for dot made with happy",
);

/**
 * Generate simple okay-looking bar plots without much effort
 */
export const happy_hour = mkPackage(
  nixRaw`pkgs.haskellPackages.happy-hour`,
  "Generate simple okay-looking bar plots without much effort",
);

/**
 * Quasi-quoter for Happy parsers
 */
export const happy_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.happy-meta`,
  "Quasi-quoter for Happy parsers",
);

/**
 * WebKit Happybara driver
 */
export const happybara_webkit = mkPackage(
  nixRaw`pkgs.haskellPackages.happybara-webkit`,
  "WebKit Happybara driver",
);

/**
 * A Haskell implementation of the Quil instruction set for quantum computing
 */
export const haquil = mkPackage(
  nixRaw`pkgs.haskellPackages.haquil`,
  "A Haskell implementation of the Quil instruction set for quantum computing",
);

/**
 * HAR spec in Haskell
 */
export const har = mkPackage(
  nixRaw`pkgs.haskellPackages.har`,
  "HAR spec in Haskell",
);

/**
 * Deep embedding of hardware descriptions with code generation
 */
export const hardware_edsl = mkPackage(
  nixRaw`pkgs.haskellPackages.hardware-edsl`,
  "Deep embedding of hardware descriptions with code generation",
);

/**
 * A Gentoo package query tool
 */
export const hark = mkPackage(
  nixRaw`pkgs.haskellPackages.hark`,
  "A Gentoo package query tool",
);

/**
 * A web service specification compiler that generates implementation and tests
 */
export const harmony = mkPackage(
  nixRaw`pkgs.haskellPackages.harmony`,
  "A web service specification compiler that generates implementation and tests",
);

/**
 * Yet another Groonga http server
 */
export const haroonga_httpd = mkPackage(
  nixRaw`pkgs.haskellPackages.haroonga-httpd`,
  "Yet another Groonga http server",
);

/**
 * HaRP allows pattern-matching with regular expressions
 */
export const harp = mkPackage(
  nixRaw`pkgs.haskellPackages.harp`,
  "HaRP allows pattern-matching with regular expressions",
);

/**
 * Template Haskell function for Has records
 */
export const has_th = mkPackage(
  nixRaw`pkgs.haskellPackages.has-th`,
  "Template Haskell function for Has records",
);

/**
 * This library 'Has' transformers
 */
export const has_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.has-transformers`,
  "This library 'Has' transformers",
);

/**
 * Haskell driver for Neo4j 3+ (BOLT protocol)
 */
export const hasbolt = mkPackage(
  nixRaw`pkgs.haskellPackages.hasbolt`,
  "Haskell driver for Neo4j 3+ (BOLT protocol)",
);

/**
 * tiny calculator library and command-line program
 */
export const hascal = mkPackage(
  nixRaw`pkgs.haskellPackages.hascal`,
  "tiny calculator library and command-line program",
);

/**
 * Hascat Web Server
 */
export const hascat = mkPackage(
  nixRaw`pkgs.haskellPackages.hascat`,
  "Hascat Web Server",
);

/**
 * Hascat Package
 */
export const hascat_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.hascat-lib`,
  "Hascat Package",
);

/**
 * Hascat Installation helper
 */
export const hascat_setup = mkPackage(
  nixRaw`pkgs.haskellPackages.hascat-setup`,
  "Hascat Installation helper",
);

/**
 * Hascat System Package
 */
export const hascat_system = mkPackage(
  nixRaw`pkgs.haskellPackages.hascat-system`,
  "Hascat System Package",
);

/**
 * Hash-addressed file storage
 */
export const hash_addressed = mkPackage(
  nixRaw`pkgs.haskellPackages.hash-addressed`,
  "Hash-addressed file storage",
);

/**
 * Hash-addressed file storage app
 */
export const hash_addressed_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hash-addressed-cli`,
  "Hash-addressed file storage app",
);

/**
 * Hash as cache
 */
export const hash_store = mkPackage(
  nixRaw`pkgs.haskellPackages.hash-store`,
  "Hash as cache",
);

/**
 * Merkle Hash Tree
 */
export const hash_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.hash-tree`,
  "Merkle Hash Tree",
);

/**
 * A class for types that can be converted to a hash value
 */
export const hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.hashable`,
  "A class for types that can be converted to a hash value",
);

/**
 * A class for types which can be converted into a hash value
 */
export const hashable_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.hashable-accelerate`,
  "A class for types which can be converted into a hash value",
);

/**
 * Provides instances missing from Hashable
 */
export const hashable_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.hashable-orphans`,
  "Provides instances missing from Hashable",
);

/**
 * Hashable instances for Data.Time
 */
export const hashable_time = mkPackage(
  nixRaw`pkgs.haskellPackages.hashable-time`,
  "Hashable instances for Data.Time",
);

/**
 * Hash digests for files and directories
 */
export const hasherize = mkPackage(
  nixRaw`pkgs.haskellPackages.hasherize`,
  "Hash digests for files and directories",
);

/**
 * Hash functions
 */
export const hashes = mkPackage(
  nixRaw`pkgs.haskellPackages.hashes`,
  "Hash functions",
);

/**
 * A library for working with HashFlare.io contracts and hashrates
 */
export const hashflare = mkPackage(
  nixRaw`pkgs.haskellPackages.hashflare`,
  "A library for working with HashFlare.io contracts and hashrates",
);

/**
 * Hashids generates short, unique, non-sequential ids from numbers
 */
export const hashids = mkPackage(
  nixRaw`pkgs.haskellPackages.hashids`,
  "Hashids generates short, unique, non-sequential ids from numbers",
);

/**
 * A pure haskell library implements several hash algorithms
 */
export const hashing = mkPackage(
  nixRaw`pkgs.haskellPackages.hashing`,
  "A pure haskell library implements several hash algorithms",
);

/**
 * Persistent containers Map and Set based on hashing
 */
export const hashmap = mkPackage(
  nixRaw`pkgs.haskellPackages.hashmap`,
  "Persistent containers Map and Set based on hashing",
);

/**
 * A Hashmap on io monad
 */
export const hashmap_io = mkPackage(
  nixRaw`pkgs.haskellPackages.hashmap-io`,
  "A Hashmap on io monad",
);

/**
 * Throw behaviour for hashmap lookup
 */
export const hashmap_throw = mkPackage(
  nixRaw`pkgs.haskellPackages.hashmap-throw`,
  "Throw behaviour for hashmap lookup",
);

/**
 * Rename every file in a directory with his SHA1 hash
 */
export const hashrename = mkPackage(
  nixRaw`pkgs.haskellPackages.hashrename`,
  "Rename every file in a directory with his SHA1 hash",
);

/**
 * Benchmark of hash table implementations
 */
export const hashtable_benchmark = mkPackage(
  nixRaw`pkgs.haskellPackages.hashtable-benchmark`,
  "Benchmark of hash table implementations",
);

/**
 * Mutable hash tables in the ST monad
 */
export const hashtables = mkPackage(
  nixRaw`pkgs.haskellPackages.hashtables`,
  "Mutable hash tables in the ST monad",
);

/**
 * Generate homepages for cabal packages
 */
export const hask_home = mkPackage(
  nixRaw`pkgs.haskellPackages.hask-home`,
  "Generate homepages for cabal packages",
);

/**
 * Kafka bindings for Haskell
 */
export const haskakafka = mkPackage(
  nixRaw`pkgs.haskellPackages.haskakafka`,
  "Kafka bindings for Haskell",
);

/**
 * A breakout game written in Yampa using SDL
 */
export const haskanoid = mkPackage(
  nixRaw`pkgs.haskellPackages.haskanoid`,
  "A breakout game written in Yampa using SDL",
);

/**
 * Computes and audits file hashes
 */
export const haskdeep = mkPackage(
  nixRaw`pkgs.haskellPackages.haskdeep`,
  "Computes and audits file hashes",
);

/**
 * Generate tags file for Haskell project and its nearest deps
 */
export const haskdogs = mkPackage(
  nixRaw`pkgs.haskellPackages.haskdogs`,
  "Generate tags file for Haskell project and its nearest deps",
);

/**
 * A small scheme interpreter
 */
export const haskeem = mkPackage(
  nixRaw`pkgs.haskellPackages.haskeem`,
  "A small scheme interpreter",
);

/**
 * A command-line interface for user input, written in Haskell
 */
export const haskeline_0_8_2_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskeline_0_8_2_1`,
  "A command-line interface for user input, written in Haskell",
);

export const haskeline_repl = mkPackage(
  nixRaw`pkgs.haskellPackages.haskeline-repl`,
  "",
);

/**
 * Haskell Application BlockChain Interface (ABCI) Server Library
 */
export const haskell_abci = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-abci`,
  "Haskell Application BlockChain Interface (ABCI) Server Library",
);

/**
 * Remote Management Platform for Haskell Applications
 */
export const haskell_admin = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-admin`,
  "Remote Management Platform for Haskell Applications",
);

/**
 * Application Health Component for Haskell Admin
 */
export const haskell_admin_health = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-admin-health`,
  "Application Health Component for Haskell Admin",
);

/**
 * Managed Functions integration for Haskell Admin
 */
export const haskell_admin_managed_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-admin-managed-functions`,
  "Managed Functions integration for Haskell Admin",
);

/**
 * haskell client of aliyun service
 */
export const haskell_aliyun = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-aliyun`,
  "haskell client of aliyun service",
);

/**
 * Complete BitMEX Client
 */
export const haskell_bitmex_client = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-bitmex-client`,
  "Complete BitMEX Client",
);

/**
 * Cabal package script generator for Travis-CI
 */
export const haskell_ci = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-ci`,
  "Cabal package script generator for Travis-CI",
);

/**
 * Simple CoffeeScript API
 */
export const haskell_coffee = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-coffee`,
  "Simple CoffeeScript API",
);

/**
 * Haskell implementation of the DAP interface data
 */
export const haskell_dap = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-dap`,
  "Haskell implementation of the DAP interface data",
);

/**
 * Haskell Debug Adapter
 */
export const haskell_debug_adapter = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-debug-adapter`,
  "Haskell Debug Adapter",
);

/**
 * A program to find and display the docs and type of a name
 */
export const haskell_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-docs`,
  "A program to find and display the docs and type of a name",
);

/**
 * Search Hoogle and navigate Hackage from the command line
 */
export const haskell_docs_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-docs-cli`,
  "Search Hoogle and navigate Hackage from the command line",
);

/**
 * Some utility functions for haskell-eigen library
 */
export const haskell_eigen_util = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-eigen-util`,
  "Some utility functions for haskell-eigen library",
);

/**
 * Simple parser parser from Haskell to TemplateHaskell expressions
 */
export const haskell_exp_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-exp-parser`,
  "Simple parser parser from Haskell to TemplateHaskell expressions",
);

/**
 * Simple library for retrieving current user agent strings
 */
export const haskell_fake_user_agent = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-fake-user-agent`,
  "Simple library for retrieving current user agent strings",
);

/**
 * A Haskell ftp server with configurable backend
 */
export const haskell_ftp = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-ftp`,
  "A Haskell ftp server with configurable backend",
);

/**
 * GetText runtime library implementation in pure Haskell
 */
export const haskell_gettext = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-gettext`,
  "GetText runtime library implementation in pure Haskell",
);

/**
 * Generate Haskell bindings for GObject Introspection capable libraries
 */
export const haskell_gi = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-gi`,
  "Generate Haskell bindings for GObject Introspection capable libraries",
);

/**
 * Foundation for libraries generated by haskell-gi
 */
export const haskell_gi_base = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-gi-base`,
  "Foundation for libraries generated by haskell-gi",
);

/**
 * Overloading support for haskell-gi
 */
export const haskell_gi_overloading = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-gi-overloading`,
  "Overloading support for haskell-gi",
);

/**
 * Simple library for accessing Google Trends
 */
export const haskell_google_trends = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-google-trends`,
  "Simple library for accessing Google Trends",
);

/**
 * LSP server for GHC
 */
export const haskell_language_server = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-language-server`,
  "LSP server for GHC",
);

/**
 * A fully compliant Haskell 98 lexer
 */
export const haskell_lexer = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-lexer`,
  "A fully compliant Haskell 98 lexer",
);

/**
 * Haskell library for the Microsoft Language Server Protocol
 */
export const haskell_lsp = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-lsp`,
  "Haskell library for the Microsoft Language Server Protocol",
);

/**
 * A haskell package to build your own Language Server client
 */
export const haskell_lsp_client = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-lsp-client`,
  "A haskell package to build your own Language Server client",
);

/**
 * A simple menu system for Haskell programs
 */
export const haskell_menu = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-menu`,
  "A simple menu system for Haskell programs",
);

/**
 * A cereal-based parser for the Modbus protocol
 */
export const haskell_modbus = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-modbus`,
  "A cereal-based parser for the Modbus protocol",
);

/**
 * Distributed parallel programming in Haskell using MPI
 */
export const haskell_mpi = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-mpi`,
  "Distributed parallel programming in Haskell using MPI",
);

/**
 * Tool for presenting PDF-based presentations
 */
export const haskell_pdf_presenter = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-pdf-presenter`,
  "Tool for presenting PDF-based presentations",
);

/**
 * A test system for the Haskell Platform environment
 */
export const haskell_platform_test = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-platform-test`,
  "A test system for the Haskell Platform environment",
);

/**
 * Simple library for retrieving proxy servers info from https://proxy-list.org
 */
export const haskell_proxy_list = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-proxy-list`,
  "Simple library for retrieving proxy servers info from https://proxy-list.org",
);

/**
 * Haskell bindings for libqrencode
 */
export const haskell_qrencode = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-qrencode`,
  "Haskell bindings for libqrencode",
);

/**
 * Reflect Haskell types
 */
export const haskell_reflect = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-reflect`,
  "Reflect Haskell types",
);

/**
 * Let the Haskell logo talk to your users!
 */
export const haskell_say = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-say`,
  "Let the Haskell logo talk to your users!",
);

/**
 * Snake game implemetation in Haskell using SDL2
 */
export const haskell_snake = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-snake`,
  "Snake game implemetation in Haskell using SDL2",
);

/**
 * Support for manipulating Haskell source code
 */
export const haskell_src = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src`,
  "Support for manipulating Haskell source code",
);

/**
 * Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer
 */
export const haskell_src_exts = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src-exts`,
  "Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer",
);

/**
 * Observable orphan instances for haskell-src-exts
 */
export const haskell_src_exts_observe = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src-exts-observe`,
  "Observable orphan instances for haskell-src-exts",
);

/**
 * A simplified view on the haskell-src-exts AST
 */
export const haskell_src_exts_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src-exts-simple`,
  "A simplified view on the haskell-src-exts AST",
);

/**
 * Helper functions for working with haskell-src-exts trees
 */
export const haskell_src_exts_util = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src-exts-util`,
  "Helper functions for working with haskell-src-exts trees",
);

/**
 * Parse source to template-haskell abstract syntax
 */
export const haskell_src_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-src-meta`,
  "Parse source to template-haskell abstract syntax",
);

/**
 * Some useful wrappers and functions for building time ranges
 */
export const haskell_time_range = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-time-range`,
  "Some useful wrappers and functions for building time ranges",
);

/**
 * Utilities to tie up tokens to an AST
 */
export const haskell_token_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-token-utils`,
  "Utilities to tie up tokens to an AST",
);

/**
 * Haskell AST for efficient tooling
 */
export const haskell_tools_ast = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-ast`,
  "Haskell AST for efficient tooling",
);

/**
 * Creating the Haskell-Tools AST from GHC's representations
 */
export const haskell_tools_ast_fromghc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-ast-fromghc`,
  "Creating the Haskell-Tools AST from GHC's representations",
);

/**
 * Facilities for generating new parts of the Haskell-Tools AST
 */
export const haskell_tools_ast_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-ast-gen`,
  "Facilities for generating new parts of the Haskell-Tools AST",
);

/**
 * Conversions on Haskell-Tools AST to prepare for refactorings
 */
export const haskell_tools_ast_trf = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-ast-trf`,
  "Conversions on Haskell-Tools AST to prepare for refactorings",
);

/**
 * Creating the Haskell-Tools AST from GHC's representations
 */
export const haskell_tools_backend_ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-backend-ghc`,
  "Creating the Haskell-Tools AST from GHC's representations",
);

/**
 * Refactoring Tool for Haskell
 */
export const haskell_tools_builtin_refactorings = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-builtin-refactorings`,
  "Refactoring Tool for Haskell",
);

/**
 * Command-line frontend for Haskell-tools Refact
 */
export const haskell_tools_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-cli`,
  "Command-line frontend for Haskell-tools Refact",
);

/**
 * Background process for Haskell-tools that editors can connect to
 */
export const haskell_tools_daemon = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-daemon`,
  "Background process for Haskell-tools that editors can connect to",
);

/**
 * Debugging Tools for Haskell-tools
 */
export const haskell_tools_debug = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-debug`,
  "Debugging Tools for Haskell-tools",
);

/**
 * A web-based demo for Haskell-tools Refactor
 */
export const haskell_tools_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-demo`,
  "A web-based demo for Haskell-tools Refactor",
);

/**
 * Refactoring Tool for Haskell
 */
export const haskell_tools_experimental_refactorings = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-experimental-refactorings`,
  "Refactoring Tool for Haskell",
);

/**
 * Pretty printing of Haskell-Tools AST
 */
export const haskell_tools_prettyprint = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-prettyprint`,
  "Pretty printing of Haskell-Tools AST",
);

/**
 * Refactoring Tool for Haskell
 */
export const haskell_tools_refactor = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-refactor`,
  "Refactoring Tool for Haskell",
);

/**
 * Facilities for generating new parts of the Haskell-Tools AST
 */
export const haskell_tools_rewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tools-rewrite`,
  "Facilities for generating new parts of the Haskell-Tools AST",
);

/**
 * A Haskell Tor Node
 */
export const haskell_tor = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-tor`,
  "A Haskell Tor Node",
);

/**
 * Rebuild Haskell dependencies in Gentoo
 */
export const haskell_updater = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-updater`,
  "Rebuild Haskell dependencies in Gentoo",
);

/**
 * Haskell XMPP (eXtensible Message Passing Protocol, a.k.a. Jabber) library
 */
export const haskell_xmpp = mkPackage(
  nixRaw`pkgs.haskellPackages.haskell-xmpp`,
  "Haskell XMPP (eXtensible Message Passing Protocol, a.k.a. Jabber) library",
);

/**
 * Bracketed HDBC session for HaskellDB
 */
export const haskelldb_connect_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-connect-hdbc`,
  "Bracketed HDBC session for HaskellDB",
);

/**
 * Bracketed HaskellDB HDBC session using MonadCatchIO-mtl
 */
export const haskelldb_connect_hdbc_catchio_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-connect-hdbc-catchio-mtl`,
  "Bracketed HaskellDB HDBC session using MonadCatchIO-mtl",
);

/**
 * Bracketed HaskellDB HDBC session using MonadCatchIO-transformers
 */
export const haskelldb_connect_hdbc_catchio_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-connect-hdbc-catchio-tf`,
  "Bracketed HaskellDB HDBC session using MonadCatchIO-transformers",
);

/**
 * Bracketed HaskellDB HDBC session using MonadCatchIO-transformers
 */
export const haskelldb_connect_hdbc_catchio_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-connect-hdbc-catchio-transformers`,
  "Bracketed HaskellDB HDBC session using MonadCatchIO-transformers",
);

/**
 * Bracketed HaskellDB HDBC session using lifted-base
 */
export const haskelldb_connect_hdbc_lifted = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-connect-hdbc-lifted`,
  "Bracketed HaskellDB HDBC session using lifted-base",
);

/**
 * HaskellDB support for the dynamically loaded drivers
 */
export const haskelldb_dynamic = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-dynamic`,
  "HaskellDB support for the dynamically loaded drivers",
);

/**
 * An experimental HaskellDB back-end in pure Haskell (no SQL)
 */
export const haskelldb_flat = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-flat`,
  "An experimental HaskellDB back-end in pure Haskell (no SQL)",
);

/**
 * HaskellDB support for HDBC
 */
export const haskelldb_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hdbc`,
  "HaskellDB support for HDBC",
);

/**
 * HaskellDB support for the HDBC MySQL driver
 */
export const haskelldb_hdbc_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hdbc-mysql`,
  "HaskellDB support for the HDBC MySQL driver",
);

/**
 * HaskellDB support for the HDBC ODBC driver
 */
export const haskelldb_hdbc_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hdbc-odbc`,
  "HaskellDB support for the HDBC ODBC driver",
);

/**
 * HaskellDB support for the HDBC PostgreSQL driver
 */
export const haskelldb_hdbc_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hdbc-postgresql`,
  "HaskellDB support for the HDBC PostgreSQL driver",
);

/**
 * HaskellDB support for the HDBC SQLite driver
 */
export const haskelldb_hdbc_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hdbc-sqlite3`,
  "HaskellDB support for the HDBC SQLite driver",
);

/**
 * HaskellDB support for HSQL
 */
export const haskelldb_hsql = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hsql`,
  "HaskellDB support for HSQL",
);

/**
 * HaskellDB support for the HSQL MySQL driver
 */
export const haskelldb_hsql_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hsql-mysql`,
  "HaskellDB support for the HSQL MySQL driver",
);

/**
 * HaskellDB support for the HSQL ODBC driver
 */
export const haskelldb_hsql_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hsql-odbc`,
  "HaskellDB support for the HSQL ODBC driver",
);

/**
 * HaskellDB support for the HSQL PostgreSQL driver
 */
export const haskelldb_hsql_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hsql-postgresql`,
  "HaskellDB support for the HSQL PostgreSQL driver",
);

/**
 * HaskellDB support for the HSQL SQLite3 driver
 */
export const haskelldb_hsql_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-hsql-sqlite3`,
  "HaskellDB support for the HSQL SQLite3 driver",
);

/**
 * Template Haskell utilities for HaskellDB
 */
export const haskelldb_th = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelldb-th`,
  "Template Haskell utilities for HaskellDB",
);

/**
 * For parsing Haskell-ish languages
 */
export const haskellish = mkPackage(
  nixRaw`pkgs.haskellPackages.haskellish`,
  "For parsing Haskell-ish languages",
);

/**
 * Elm to Haskell translation
 */
export const haskelm = mkPackage(
  nixRaw`pkgs.haskellPackages.haskelm`,
  "Elm to Haskell translation",
);

/**
 * A transactional, ACID compliant, embeddable key-value store
 */
export const haskey = mkPackage(
  nixRaw`pkgs.haskellPackages.haskey`,
  "A transactional, ACID compliant, embeddable key-value store",
);

/**
 * A monad transformer supporting Haskey transactions
 */
export const haskey_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.haskey-mtl`,
  "A monad transformer supporting Haskey transactions",
);

/**
 * Haskell game library
 */
export const haskgame = mkPackage(
  nixRaw`pkgs.haskellPackages.haskgame`,
  "Haskell game library",
);

/**
 * embedded DSL for defining epidemiologic cohorts
 */
export const hasklepias = mkPackage(
  nixRaw`pkgs.haskellPackages.hasklepias`,
  "embedded DSL for defining epidemiologic cohorts",
);

/**
 * An adapter for haskoin to network-bitcoin
 */
export const haskoin_bitcoind = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-bitcoind`,
  "An adapter for haskoin to network-bitcoin",
);

/**
 * Bitcoin & Bitcoin Cash library for Haskell
 */
export const haskoin_core = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-core`,
  "Bitcoin & Bitcoin Cash library for Haskell",
);

/**
 * Bitcoin & Bitcoin Cash library for Haskell
 */
export const haskoin_core_1_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-core_1_0_2`,
  "Bitcoin & Bitcoin Cash library for Haskell",
);

/**
 * Implementation of Bitcoin cryptographic primitives
 */
export const haskoin_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-crypto`,
  "Implementation of Bitcoin cryptographic primitives",
);

/**
 * P2P library for Bitcoin and Bitcoin Cash
 */
export const haskoin_node = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-node`,
  "P2P library for Bitcoin and Bitcoin Cash",
);

/**
 * P2P library for Bitcoin and Bitcoin Cash
 */
export const haskoin_node_1_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-node_1_0_1`,
  "P2P library for Bitcoin and Bitcoin Cash",
);

/**
 * Implementation of the Bitcoin network protocol messages
 */
export const haskoin_protocol = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-protocol`,
  "Implementation of the Bitcoin network protocol messages",
);

/**
 * Implementation of Bitcoin script parsing and evaluation
 */
export const haskoin_script = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-script`,
  "Implementation of Bitcoin script parsing and evaluation",
);

/**
 * Data for Haskoin Store
 */
export const haskoin_store_data = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-store-data`,
  "Data for Haskoin Store",
);

/**
 * Data for Haskoin Store
 */
export const haskoin_store_data_1_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoin-store-data_1_2_0`,
  "Data for Haskoin Store",
);

/**
 * Web Application Abstraction
 */
export const haskoon = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoon`,
  "Web Application Abstraction",
);

/**
 * Integrating HttpSpec with Haskoon
 */
export const haskoon_httpspec = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoon-httpspec`,
  "Integrating HttpSpec with Haskoon",
);

/**
 * Integrating HttpSpec with Haskoon
 */
export const haskoon_salvia = mkPackage(
  nixRaw`pkgs.haskellPackages.haskoon-salvia`,
  "Integrating HttpSpec with Haskoon",
);

/**
 * Routines for realtime playback of Haskore songs
 */
export const haskore_realtime = mkPackage(
  nixRaw`pkgs.haskellPackages.haskore-realtime`,
  "Routines for realtime playback of Haskore songs",
);

/**
 * Haskore back-end for SuperCollider
 */
export const haskore_supercollider = mkPackage(
  nixRaw`pkgs.haskellPackages.haskore-supercollider`,
  "Haskore back-end for SuperCollider",
);

/**
 * Music rendering coded in Haskell
 */
export const haskore_synthesizer = mkPackage(
  nixRaw`pkgs.haskellPackages.haskore-synthesizer`,
  "Music rendering coded in Haskell",
);

/**
 * Simple unsupervised segmentation model
 */
export const haskseg = mkPackage(
  nixRaw`pkgs.haskellPackages.haskseg`,
  "Simple unsupervised segmentation model",
);

/**
 * Produces ctags "tags" and etags "TAGS" files for Haskell programs
 */
export const hasktags = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktags`,
  "Produces ctags \"tags\" and etags \"TAGS\" files for Haskell programs",
);

/**
 * Produces ctags "tags" and etags "TAGS" files for Haskell programs
 */
export const hasktags_0_73_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktags_0_73_0`,
  "Produces ctags \"tags\" and etags \"TAGS\" files for Haskell programs",
);

/**
 * Torch for tensors and neural networks in Haskell
 */
export const hasktorch = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch`,
  "Torch for tensors and neural networks in Haskell",
);

/**
 * Testing library for Hasktorch's FFI bindings
 */
export const hasktorch_ffi_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-ffi-tests`,
  "Testing library for Hasktorch's FFI bindings",
);

/**
 * Bindings to Cutorch
 */
export const hasktorch_ffi_thc = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-ffi-thc`,
  "Bindings to Cutorch",
);

/**
 * Core Hasktorch abstractions wrapping FFI bindings
 */
export const hasktorch_indef = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-indef`,
  "Core Hasktorch abstractions wrapping FFI bindings",
);

/**
 * Backpack signatures for Tensor operations
 */
export const hasktorch_signatures = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-signatures`,
  "Backpack signatures for Tensor operations",
);

/**
 * Core types for Hasktorch backpack signatures
 */
export const hasktorch_signatures_types = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-signatures-types`,
  "Core types for Hasktorch backpack signatures",
);

/**
 * C-types for Torch
 */
export const hasktorch_types_th = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-types-th`,
  "C-types for Torch",
);

/**
 * C-types for Cutorch
 */
export const hasktorch_types_thc = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-types-thc`,
  "C-types for Cutorch",
);

/**
 * Neural architectures in hasktorch
 */
export const hasktorch_zoo = mkPackage(
  nixRaw`pkgs.haskellPackages.hasktorch-zoo`,
  "Neural architectures in hasktorch",
);

/**
 * Haskus binary format manipulation
 */
export const haskus_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-binary`,
  "Haskus binary format manipulation",
);

/**
 * Haskus system build tool
 */
export const haskus_system_build = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-system-build`,
  "Haskus system build tool",
);

/**
 * Haskus utility modules
 */
export const haskus_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-utils`,
  "Haskus utility modules",
);

/**
 * Compatibility modules with other external packages (ByteString, etc.)
 */
export const haskus_utils_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-utils-compat`,
  "Compatibility modules with other external packages (ByteString, etc.)",
);

/**
 * Haskus data utility modules
 */
export const haskus_utils_data = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-utils-data`,
  "Haskus data utility modules",
);

/**
 * Haskus types utility modules
 */
export const haskus_utils_types = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-utils-types`,
  "Haskus types utility modules",
);

/**
 * Haskus web
 */
export const haskus_web = mkPackage(
  nixRaw`pkgs.haskellPackages.haskus-web`,
  "Haskus web",
);

/**
 * Loan calculator engine
 */
export const haslo = mkPackage(
  nixRaw`pkgs.haskellPackages.haslo`,
  "Loan calculator engine",
);

/**
 * Loan calculator Gtk GUI. Based on haslo (Haskell Loan) library.
 */
export const hasloGUI = mkPackage(
  nixRaw`pkgs.haskellPackages.hasloGUI`,
  "Loan calculator Gtk GUI. Based on haslo (Haskell Loan) library.",
);

/**
 * Haskell bindings to aspell
 */
export const haspell = mkPackage(
  nixRaw`pkgs.haskellPackages.haspell`,
  "Haskell bindings to aspell",
);

/**
 * An efficient PostgreSQL driver with a flexible mapping API
 */
export const hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql`,
  "An efficient PostgreSQL driver with a flexible mapping API",
);

/**
 * A declarative abstraction over PostgreSQL Cursor
 */
export const hasql_cursor_query = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-cursor-query`,
  "A declarative abstraction over PostgreSQL Cursor",
);

/**
 * Toolkit for constructing Hasql statements dynamically
 */
export const hasql_dynamic_statements = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-dynamic-statements`,
  "Toolkit for constructing Hasql statements dynamically",
);

/**
 * Implicit definitions for Hasql, such as default codecs for standard types
 */
export const hasql_implicits = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-implicits`,
  "Implicit definitions for Hasql, such as default codecs for standard types",
);

/**
 * QuasiQuoter that supports expression interpolation for hasql
 */
export const hasql_interpolate = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-interpolate`,
  "QuasiQuoter that supports expression interpolation for hasql",
);

/**
 * QuasiQuoter that supports expression interpolation for hasql
 */
export const hasql_interpolate_0_2_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-interpolate_0_2_1_0`,
  "QuasiQuoter that supports expression interpolation for hasql",
);

/**
 * LISTEN/NOTIFY with hasql
 */
export const hasql_listen_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-listen-notify`,
  "LISTEN/NOTIFY with hasql",
);

/**
 * PostgreSQL Schema Migrations
 */
export const hasql_migration = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-migration`,
  "PostgreSQL Schema Migrations",
);

/**
 * LISTEN/NOTIFY support for Hasql
 */
export const hasql_notifications = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-notifications`,
  "LISTEN/NOTIFY support for Hasql",
);

/**
 * "optparse-applicative" parsers for "hasql"
 */
export const hasql_optparse_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-optparse-applicative`,
  "\"optparse-applicative\" parsers for \"hasql\"",
);

/**
 * "optparse-applicative" parsers for "hasql"
 */
export const hasql_optparse_applicative_0_7_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-optparse-applicative_0_7_1_1`,
  "\"optparse-applicative\" parsers for \"hasql\"",
);

/**
 * A pipe to stream a postgres database cursor in the hasql ecosystem
 */
export const hasql_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-pipes`,
  "A pipe to stream a postgres database cursor in the hasql ecosystem",
);

/**
 * Pool of connections for Hasql
 */
export const hasql_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-pool`,
  "Pool of connections for Hasql",
);

/**
 * Pool of connections for Hasql
 */
export const hasql_pool_0_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-pool_0_10`,
  "Pool of connections for Hasql",
);

/**
 * A "PostgreSQL" backend for the "hasql" library
 */
export const hasql_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-postgres`,
  "A \"PostgreSQL\" backend for the \"hasql\" library",
);

/**
 * An "optparse-applicative" parser for "hasql-postgres"
 */
export const hasql_postgres_options = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-postgres-options`,
  "An \"optparse-applicative\" parser for \"hasql-postgres\"",
);

/**
 * A PostgreSQL backed queue
 */
export const hasql_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-queue`,
  "A PostgreSQL backed queue",
);

/**
 * Stream Hasql queries with Conduit
 */
export const hasql_streams_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-conduit`,
  "Stream Hasql queries with Conduit",
);

/**
 * Stream Hasql queries
 */
export const hasql_streams_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-core`,
  "Stream Hasql queries",
);

/**
 * An example program that shows how to use Hasql streams with Rel8
 */
export const hasql_streams_example = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-example`,
  "An example program that shows how to use Hasql streams with Rel8",
);

/**
 * Stream Hasql queries with Pipes
 */
export const hasql_streams_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-pipes`,
  "Stream Hasql queries with Pipes",
);

/**
 * Stream Hasql queries with Streaming
 */
export const hasql_streams_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-streaming`,
  "Stream Hasql queries with Streaming",
);

/**
 * Stream Hasql queries with Streamly
 */
export const hasql_streams_streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-streams-streamly`,
  "Stream Hasql queries with Streamly",
);

/**
 * Template Haskell utilities for Hasql
 */
export const hasql_th = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-th`,
  "Template Haskell utilities for Hasql",
);

/**
 * Composable abstraction over retryable transactions for Hasql
 */
export const hasql_transaction = mkPackage(
  nixRaw`pkgs.haskellPackages.hasql-transaction`,
  "Composable abstraction over retryable transactions for Hasql",
);

/**
 * composable SQL generation
 */
export const hasqlator_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.hasqlator-mysql`,
  "composable SQL generation",
);

/**
 * composable SQL generation
 */
export const hasqly_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.hasqly-mysql`,
  "composable SQL generation",
);

/**
 * render hastache templates using aeson values
 */
export const hastache_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.hastache-aeson`,
  "render hastache templates using aeson values",
);

/**
 * Framework for type-safe, distributed web applications
 */
export const haste_app = mkPackage(
  nixRaw`pkgs.haskellPackages.haste-app`,
  "Framework for type-safe, distributed web applications",
);

/**
 * Google API bindings for the Haste compiler
 */
export const haste_gapi = mkPackage(
  nixRaw`pkgs.haskellPackages.haste-gapi`,
  "Google API bindings for the Haste compiler",
);

/**
 * Base libraries for haste-compiler
 */
export const haste_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.haste-lib`,
  "Base libraries for haste-compiler",
);

/**
 * A port of blaze-markup and blaze-html to Haste
 */
export const haste_markup = mkPackage(
  nixRaw`pkgs.haskellPackages.haste-markup`,
  "A port of blaze-markup and blaze-html to Haste",
);

/**
 * Create, navigate and modify the DOM tree with composable syntax, with the haste compiler
 */
export const haste_perch = mkPackage(
  nixRaw`pkgs.haskellPackages.haste-perch`,
  "Create, navigate and modify the DOM tree with composable syntax, with the haste compiler",
);

/**
 * A program to download subtitle files
 */
export const hastily = mkPackage(
  nixRaw`pkgs.haskellPackages.hastily`,
  "A program to download subtitle files",
);

/**
 * Speedy traversal through parameter space
 */
export const hasty_hamiltonian = mkPackage(
  nixRaw`pkgs.haskellPackages.hasty-hamiltonian`,
  "Speedy traversal through parameter space",
);

/**
 * A high-performance striped resource pooling implementation
 */
export const hasura_resource_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.hasura-resource-pool`,
  "A high-performance striped resource pooling implementation",
);

/**
 * XMPP client with 9P and (optionally) GTK interfaces
 */
export const hatexmpp3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hatexmpp3`,
  "XMPP client with 9P and (optionally) GTK interfaces",
);

/**
 * Hath manipulates network blocks in CIDR notation
 */
export const hath = mkPackage(
  nixRaw`pkgs.haskellPackages.hath`,
  "Hath manipulates network blocks in CIDR notation",
);

/**
 * A twitter client for GTK+. Beta version.
 */
export const hawitter = mkPackage(
  nixRaw`pkgs.haskellPackages.hawitter`,
  "A twitter client for GTK+. Beta version.",
);

/**
 * Haxl data source for accessing AWS services through amazonka
 */
export const haxl_amazonka = mkPackage(
  nixRaw`pkgs.haskellPackages.haxl-amazonka`,
  "Haxl data source for accessing AWS services through amazonka",
);

/**
 * An example Haxl data source for accessing the Facebook Graph API
 */
export const haxl_facebook = mkPackage(
  nixRaw`pkgs.haskellPackages.haxl-facebook`,
  "An example Haxl data source for accessing the Facebook Graph API",
);

/**
 * XML-RPC client and server library
 */
export const haxr = mkPackage(
  nixRaw`pkgs.haskellPackages.haxr`,
  "XML-RPC client and server library",
);

/**
 * A simple HTTP proxy server library
 */
export const haxy = mkPackage(
  nixRaw`pkgs.haskellPackages.haxy`,
  "A simple HTTP proxy server library",
);

/**
 * A command line tool to compute BLAKE3 hashes
 */
export const hb3sum = mkPackage(
  nixRaw`pkgs.haskellPackages.hb3sum`,
  "A command line tool to compute BLAKE3 hashes",
);

/**
 * N-back memory game
 */
export const hback = mkPackage(
  nixRaw`pkgs.haskellPackages.hback`,
  "N-back memory game",
);

/**
 * Bayesian Networks
 */
export const hbayes = mkPackage(
  nixRaw`pkgs.haskellPackages.hbayes`,
  "Bayesian Networks",
);

/**
 * Haskell Busy Bee, a backend for text editors
 */
export const hbb = mkPackage(
  nixRaw`pkgs.haskellPackages.hbb`,
  "Haskell Busy Bee, a backend for text editors",
);

/**
 * Packed binary-coded decimal (BCD) serialization
 */
export const hbcd = mkPackage(
  nixRaw`pkgs.haskellPackages.hbcd`,
  "Packed binary-coded decimal (BCD) serialization",
);

/**
 * An optimizing Brainfuck compiler and evaluator
 */
export const hbf = mkPackage(
  nixRaw`pkgs.haskellPackages.hbf`,
  "An optimizing Brainfuck compiler and evaluator",
);

/**
 * Minimal extensible web-browser
 */
export const hbro = mkPackage(
  nixRaw`pkgs.haskellPackages.hbro`,
  "Minimal extensible web-browser",
);

/**
 * Third-party extensions to hbro
 */
export const hbro_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.hbro-contrib`,
  "Third-party extensions to hbro",
);

/**
 * 2d Delaunay triangulation
 */
export const hcdt = mkPackage(
  nixRaw`pkgs.haskellPackages.hcdt`,
  "2d Delaunay triangulation",
);

/**
 * haskell cg (minus) (cairo rendering)
 */
export const hcg_minus_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.hcg-minus-cairo`,
  "haskell cg (minus) (cairo rendering)",
);

/**
 * A collection of code cheatsheet
 */
export const hcheat = mkPackage(
  nixRaw`pkgs.haskellPackages.hcheat`,
  "A collection of code cheatsheet",
);

/**
 * Implementation of checkers ("draughts") board game - server application
 */
export const hcheckers = mkPackage(
  nixRaw`pkgs.haskellPackages.hcheckers`,
  "Implementation of checkers (\"draughts\") board game - server application",
);

/**
 * Easily convert between latitude/longitude, UTM and OSGB
 */
export const hcoord = mkPackage(
  nixRaw`pkgs.haskellPackages.hcoord`,
  "Easily convert between latitude/longitude, UTM and OSGB",
);

/**
 * Haskell name counts
 */
export const hcount = mkPackage(
  nixRaw`pkgs.haskellPackages.hcount`,
  "Haskell name counts",
);

/**
 * Virtual Rubik's cube of arbitrary size
 */
export const hcube = mkPackage(
  nixRaw`pkgs.haskellPackages.hcube`,
  "Virtual Rubik's cube of arbitrary size",
);

/**
 * Library to interface with the wiimote
 */
export const hcwiid = mkPackage(
  nixRaw`pkgs.haskellPackages.hcwiid`,
  "Library to interface with the wiimote",
);

/**
 * Library to handle the details of writing daemons for UNIX
 */
export const hdaemonize = mkPackage(
  nixRaw`pkgs.haskellPackages.hdaemonize`,
  "Library to handle the details of writing daemons for UNIX",
);

/**
 * Type save tuples for HDBC
 */
export const hdbc_tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbc-tuple`,
  "Type save tuples for HDBC",
);

/**
 * Haskell Database Independent interface
 */
export const hdbi = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbi`,
  "Haskell Database Independent interface",
);

/**
 * Conduit glue for HDBI
 */
export const hdbi_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbi-conduit`,
  "Conduit glue for HDBI",
);

/**
 * PostgreSQL driver for hdbi
 */
export const hdbi_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbi-postgresql`,
  "PostgreSQL driver for hdbi",
);

/**
 * SQlite driver for HDBI
 */
export const hdbi_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbi-sqlite`,
  "SQlite driver for HDBI",
);

/**
 * test suite for testing HDBI
 */
export const hdbi_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.hdbi-tests`,
  "test suite for testing HDBI",
);

/**
 * High-level bindings to the HDF5 "lite" interface
 */
export const hdf5_lite = mkPackage(
  nixRaw`pkgs.haskellPackages.hdf5-lite`,
  "High-level bindings to the HDF5 \"lite\" interface",
);

/**
 * Pattern-Expression-based differencing of arbitrary types
 */
export const hdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.hdiff`,
  "Pattern-Expression-based differencing of arbitrary types",
);

/**
 * An IDL compiler for Haskell
 */
export const hdirect = mkPackage(
  nixRaw`pkgs.haskellPackages.hdirect`,
  "An IDL compiler for Haskell",
);

/**
 * Haskell docs tool
 */
export const hdocs = mkPackage(
  nixRaw`pkgs.haskellPackages.hdocs`,
  "Haskell docs tool",
);

/**
 * Haskell distributed parallel Haskell
 */
export const hdph = mkPackage(
  nixRaw`pkgs.haskellPackages.hdph`,
  "Haskell distributed parallel Haskell",
);

/**
 * More informative parser
 */
export const headed_megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.headed-megaparsec`,
  "More informative parser",
);

/**
 * License Header Manager
 */
export const headroom = mkPackage(
  nixRaw`pkgs.haskellPackages.headroom`,
  "License Header Manager",
);

/**
 * Heaps in Haskell
 */
export const heap = mkPackage(
  nixRaw`pkgs.haskellPackages.heap`,
  "Heaps in Haskell",
);

/**
 * Asymptotically optimal Brodal/Okasaki heaps
 */
export const heaps = mkPackage(
  nixRaw`pkgs.haskellPackages.heaps`,
  "Asymptotically optimal Brodal/Okasaki heaps",
);

/**
 * Determine the size of runtime data structures
 */
export const heapsize = mkPackage(
  nixRaw`pkgs.haskellPackages.heapsize`,
  "Determine the size of runtime data structures",
);

/**
 * An opinionated app prelude and framework in the UnliftIO style
 */
export const heart_app = mkPackage(
  nixRaw`pkgs.haskellPackages.heart-app`,
  "An opinionated app prelude and framework in the UnliftIO style",
);

/**
 * Find and annotate ITDs
 */
export const heatitup = mkPackage(
  nixRaw`pkgs.haskellPackages.heatitup`,
  "Find and annotate ITDs",
);

/**
 * Compression and decompression using heatshrink
 */
export const heatshrink = mkPackage(
  nixRaw`pkgs.haskellPackages.heatshrink`,
  "Compression and decompression using heatshrink",
);

/**
 * Simle api for heavy logger
 */
export const heavy_log_shortcuts = mkPackage(
  nixRaw`pkgs.haskellPackages.heavy-log-shortcuts`,
  "Simle api for heavy logger",
);

/**
 * Full-weight logging based on fast-logger
 */
export const heavy_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.heavy-logger`,
  "Full-weight logging based on fast-logger",
);

/**
 * heavy-logger compatibility with amazonka-core logging
 */
export const heavy_logger_amazon = mkPackage(
  nixRaw`pkgs.haskellPackages.heavy-logger-amazon`,
  "heavy-logger compatibility with amazonka-core logging",
);

/**
 * Orphan instances for data types in heavy-logger package
 */
export const heavy_logger_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.heavy-logger-instances`,
  "Orphan instances for data types in heavy-logger package",
);

/**
 * Elliptic Curve Cryptography for Haskell
 */
export const hecc = mkPackage(
  nixRaw`pkgs.haskellPackages.hecc`,
  "Elliptic Curve Cryptography for Haskell",
);

/**
 * Oh heck, it's a heckin' case conversion library
 */
export const heckin = mkPackage(
  nixRaw`pkgs.haskellPackages.heckin`,
  "Oh heck, it's a heckin' case conversion library",
);

/**
 * Release with confidence
 */
export const hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog`,
  "Release with confidence",
);

/**
 * Release with confidence
 */
export const hedgehog_1_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog_1_4`,
  "Release with confidence",
);

export const hedgehog_checkers_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-checkers-lens`,
  "",
);

/**
 * Hedgehog will eat your typeclass bugs
 */
export const hedgehog_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-classes`,
  "Hedgehog will eat your typeclass bugs",
);

/**
 * hedgehog-corpus
 */
export const hedgehog_corpus = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-corpus`,
  "hedgehog-corpus",
);

/**
 * Supplemental library for hedgehog
 */
export const hedgehog_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-extras`,
  "Supplemental library for hedgehog",
);

/**
 * Use 'fakedata' with 'hedgehog'
 */
export const hedgehog_fakedata = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-fakedata`,
  "Use 'fakedata' with 'hedgehog'",
);

/**
 * Function generation for `hedgehog`
 */
export const hedgehog_fn = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-fn`,
  "Function generation for `hedgehog`",
);

/**
 * JSON generators for Hedgehog
 */
export const hedgehog_gen_json = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-gen-json`,
  "JSON generators for Hedgehog",
);

/**
 * Hedgehog properties for optics laws
 */
export const hedgehog_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-optics`,
  "Hedgehog properties for optics laws",
);

/**
 * Use QuickCheck generators in Hedgehog and vice versa
 */
export const hedgehog_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.hedgehog-quickcheck`,
  "Use QuickCheck generators in Hedgehog and vice versa",
);

/**
 * Client library for the Redis datastore: supports full command set, pipelining
 */
export const hedis = mkPackage(
  nixRaw`pkgs.haskellPackages.hedis`,
  "Client library for the Redis datastore: supports full command set, pipelining",
);

export const hedis_envy = mkPackage(
  nixRaw`pkgs.haskellPackages.hedis-envy`,
  "",
);

/**
 * A la MonadReader for Redis connection
 */
export const hedis_monadic = mkPackage(
  nixRaw`pkgs.haskellPackages.hedis-monadic`,
  "A la MonadReader for Redis connection",
);

/**
 * Caching mandatory data with Redis
 */
export const hedis_pile = mkPackage(
  nixRaw`pkgs.haskellPackages.hedis-pile`,
  "Caching mandatory data with Redis",
);

/**
 * EDN parsing and encoding
 */
export const hedn = mkPackage(
  nixRaw`pkgs.haskellPackages.hedn`,
  "EDN parsing and encoding",
);

/**
 * Base functor for EDN AST
 */
export const hedn_functor = mkPackage(
  nixRaw`pkgs.haskellPackages.hedn-functor`,
  "Base functor for EDN AST",
);

/**
 * Higher-order version of Freer
 */
export const heftia = mkPackage(
  nixRaw`pkgs.haskellPackages.heftia`,
  "Higher-order version of Freer",
);

/**
 * Handlers for standard effects using Heftia
 */
export const heftia_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.heftia-effects`,
  "Handlers for standard effects using Heftia",
);

/**
 * Fast equality saturation in Haskell
 */
export const hegg = mkPackage(
  nixRaw`pkgs.haskellPackages.hegg`,
  "Fast equality saturation in Haskell",
);

/**
 * Use JSON directly from Heist templates
 */
export const heist_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.heist-aeson`,
  "Use JSON directly from Heist templates",
);

/**
 * Adding support for asynchronous updates ("AJAX") with heist
 */
export const heist_async = mkPackage(
  nixRaw`pkgs.haskellPackages.heist-async`,
  "Adding support for asynchronous updates (\"AJAX\") with heist",
);

/**
 * Extra heist functionality
 */
export const heist_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.heist-extra`,
  "Extra heist functionality",
);

/**
 * Typechecking terms of the Edinburgh Logical Framework (LF)
 */
export const helf = mkPackage(
  nixRaw`pkgs.haskellPackages.helf`,
  "Typechecking terms of the Edinburgh Logical Framework (LF)",
);

/**
 * Clipboard Manager
 */
export const helic = mkPackage(
  nixRaw`pkgs.haskellPackages.helic`,
  "Clipboard Manager",
);

/**
 * New Relic agent SDK wrapper for Haskell
 */
export const helics = mkPackage(
  nixRaw`pkgs.haskellPackages.helics`,
  "New Relic agent SDK wrapper for Haskell",
);

/**
 * New Relic agent SDK wrapper for wai
 */
export const helics_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.helics-wai`,
  "New Relic agent SDK wrapper for wai",
);

/**
 * The Helium Compiler
 */
export const helium = mkPackage(
  nixRaw`pkgs.haskellPackages.helium`,
  "The Helium Compiler",
);

/**
 * A backwards-compatible, modern replacement for the Prelude
 */
export const helium_overture = mkPackage(
  nixRaw`pkgs.haskellPackages.helium-overture`,
  "A backwards-compatible, modern replacement for the Prelude",
);

/**
 * A Haskell shell based on shell-conduit
 */
export const hell = mkPackage(
  nixRaw`pkgs.haskellPackages.hell`,
  "A Haskell shell based on shell-conduit",
);

/**
 * Distributed hackage mirror
 */
export const hellage = mkPackage(
  nixRaw`pkgs.haskellPackages.hellage`,
  "Distributed hackage mirror",
);

/**
 * Simple, distributed, anonymous data sharing network
 */
export const hellnet = mkPackage(
  nixRaw`pkgs.haskellPackages.hellnet`,
  "Simple, distributed, anonymous data sharing network",
);

/**
 * Hello World, an example package
 */
export const hello = mkPackage(
  nixRaw`pkgs.haskellPackages.hello`,
  "Hello World, an example package",
);

/**
 * A device independent module music mixer
 */
export const hemkay_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hemkay-core`,
  "A device independent module music mixer",
);

/**
 * Haskell port of the Emokit EEG project
 */
export const hemokit = mkPackage(
  nixRaw`pkgs.haskellPackages.hemokit`,
  "Haskell port of the Emokit EEG project",
);

/**
 * Haskell bindings to Xen hypervisor interface
 */
export const hen = mkPackage(
  nixRaw`pkgs.haskellPackages.hen`,
  "Haskell bindings to Xen hypervisor interface",
);

/**
 * Bindings and high level interface for to ENet v1.3.9
 */
export const henet = mkPackage(
  nixRaw`pkgs.haskellPackages.henet`,
  "Bindings and high level interface for to ENet v1.3.9",
);

/**
 * HEPEVT parser
 */
export const hepevt = mkPackage(
  nixRaw`pkgs.haskellPackages.hepevt`,
  "HEPEVT parser",
);

/**
 * A lexer for Haskell source code
 */
export const her_lexer = mkPackage(
  nixRaw`pkgs.haskellPackages.her-lexer`,
  "A lexer for Haskell source code",
);

/**
 * Runs Continuous Integration tasks on your machines
 */
export const hercules_ci_agent = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-agent`,
  "Runs Continuous Integration tasks on your machines",
);

/**
 * Hercules CI API definition with Servant
 */
export const hercules_ci_api = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-api`,
  "Hercules CI API definition with Servant",
);

/**
 * API definition for Hercules CI Agent to talk to hercules-ci.com or Hercules CI Enterprise
 */
export const hercules_ci_api_agent = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-api-agent`,
  "API definition for Hercules CI Agent to talk to hercules-ci.com or Hercules CI Enterprise",
);

/**
 * Types and convenience modules use across Hercules CI API packages
 */
export const hercules_ci_api_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-api-core`,
  "Types and convenience modules use across Hercules CI API packages",
);

/**
 * The hci command for working with Hercules CI
 */
export const hercules_ci_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-cli`,
  "The hci command for working with Hercules CI",
);

/**
 * Bindings for the Nix evaluator
 */
export const hercules_ci_cnix_expr = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-cnix-expr`,
  "Bindings for the Nix evaluator",
);

/**
 * Haskell bindings for Nix's libstore
 */
export const hercules_ci_cnix_store = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-cnix-store`,
  "Haskell bindings for Nix's libstore",
);

/**
 * Utilities and combinators for parsing command line options (fork)
 */
export const hercules_ci_optparse_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.hercules-ci-optparse-applicative`,
  "Utilities and combinators for parsing command line options (fork)",
);

/**
 * Here docs & interpolated strings via quasiquotation
 */
export const here = mkPackage(
  nixRaw`pkgs.haskellPackages.here`,
  "Here docs & interpolated strings via quasiquotation",
);

/**
 * multi-line string / here document using QuasiQuotes
 */
export const heredoc = mkPackage(
  nixRaw`pkgs.haskellPackages.heredoc`,
  "multi-line string / here document using QuasiQuotes",
);

/**
 * haskell time manipulation in a 'kerf like' style
 */
export const herf_time = mkPackage(
  nixRaw`pkgs.haskellPackages.herf-time`,
  "haskell time manipulation in a 'kerf like' style",
);

/**
 * Fast JSON decoding via simdjson C++ bindings
 */
export const hermes_json = mkPackage(
  nixRaw`pkgs.haskellPackages.hermes-json`,
  "Fast JSON decoding via simdjson C++ bindings",
);

/**
 * Haskell Equational Reasoning Model-to-Implementation Tunnel
 */
export const hermit = mkPackage(
  nixRaw`pkgs.haskellPackages.hermit`,
  "Haskell Equational Reasoning Model-to-Implementation Tunnel",
);

/**
 * HERMIT plugin for optimizing Scrap-Your-Boilerplate traversals
 */
export const hermit_syb = mkPackage(
  nixRaw`pkgs.haskellPackages.hermit-syb`,
  "HERMIT plugin for optimizing Scrap-Your-Boilerplate traversals",
);

/**
 * Think back of the five tenets of hero club
 */
export const hero_club_five_tenets = mkPackage(
  nixRaw`pkgs.haskellPackages.hero-club-five-tenets`,
  "Think back of the five tenets of hero club",
);

/**
 * helpers for deploying to Heroku
 */
export const heroku = mkPackage(
  nixRaw`pkgs.haskellPackages.heroku`,
  "helpers for deploying to Heroku",
);

/**
 * A library for compiling and serving static web assets
 */
export const herringbone = mkPackage(
  nixRaw`pkgs.haskellPackages.herringbone`,
  "A library for compiling and serving static web assets",
);

/**
 * Embed preprocessed web assets in your executable with Template Haskell
 */
export const herringbone_embed = mkPackage(
  nixRaw`pkgs.haskellPackages.herringbone-embed`,
  "Embed preprocessed web assets in your executable with Template Haskell",
);

/**
 * Wai adapter for the Herringbone web asset preprocessor
 */
export const herringbone_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.herringbone-wai`,
  "Wai adapter for the Herringbone web asset preprocessor",
);

/**
 * the Haskell Extensible Shell: Haskell for Bash-style scripts
 */
export const hesh = mkPackage(
  nixRaw`pkgs.haskellPackages.hesh`,
  "the Haskell Extensible Shell: Haskell for Bash-style scripts",
);

/**
 * Haskell's embedded SQL
 */
export const hesql = mkPackage(
  nixRaw`pkgs.haskellPackages.hesql`,
  "Haskell's embedded SQL",
);

/**
 * Pure heterogeneous maps
 */
export const hetero_map = mkPackage(
  nixRaw`pkgs.haskellPackages.hetero-map`,
  "Pure heterogeneous maps",
);

/**
 * A type-safe template engine for working with front end development tools
 */
export const heterocephalus = mkPackage(
  nixRaw`pkgs.haskellPackages.heterocephalus`,
  "A type-safe template engine for working with front end development tools",
);

/**
 * A heterogeneous list type
 */
export const heterolist = mkPackage(
  nixRaw`pkgs.haskellPackages.heterolist`,
  "A heterogeneous list type",
);

/**
 * Hetzner Cloud and DNS library
 */
export const hetzner = mkPackage(
  nixRaw`pkgs.haskellPackages.hetzner`,
  "Hetzner Cloud and DNS library",
);

/**
 * Hetzner Cloud and DNS library
 */
export const hetzner_0_4_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.hetzner_0_4_0_1`,
  "Hetzner Cloud and DNS library",
);

/**
 * Ethereum virtual machine evaluator
 */
export const hevm = mkPackage(
  nixRaw`pkgs.haskellPackages.hevm`,
  "Ethereum virtual machine evaluator",
);

/**
 * Genetic Mona Lisa problem in Haskell
 */
export const hevolisa = mkPackage(
  nixRaw`pkgs.haskellPackages.hevolisa`,
  "Genetic Mona Lisa problem in Haskell",
);

/**
 * Genetic Mona Lisa problem in Haskell - using Data Parallel Haskell
 */
export const hevolisa_dph = mkPackage(
  nixRaw`pkgs.haskellPackages.hevolisa-dph`,
  "Genetic Mona Lisa problem in Haskell - using Data Parallel Haskell",
);

/**
 * Convert strings into hexadecimal and back
 */
export const hex = mkPackage(
  nixRaw`pkgs.haskellPackages.hex`,
  "Convert strings into hexadecimal and back",
);

/**
 * ByteString-Text hexidecimal conversions
 */
export const hex_text = mkPackage(
  nixRaw`pkgs.haskellPackages.hex-text`,
  "ByteString-Text hexidecimal conversions",
);

/**
 * A library for forming hexdumps
 */
export const hexdump = mkPackage(
  nixRaw`pkgs.haskellPackages.hexdump`,
  "A library for forming hexdumps",
);

/**
 * XML subset DOM parser
 */
export const hexml = mkPackage(
  nixRaw`pkgs.haskellPackages.hexml`,
  "XML subset DOM parser",
);

/**
 * XML parser/formatter based on expat
 */
export const hexpat = mkPackage(
  nixRaw`pkgs.haskellPackages.hexpat`,
  "XML parser/formatter based on expat",
);

export const hexpat_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hexpat-conduit`,
  "",
);

/**
 * Chunked XML parsing using iteratees
 */
export const hexpat_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.hexpat-iteratee`,
  "Chunked XML parsing using iteratees",
);

/**
 * XML picklers based on hexpat, source-code-similar to those of the HXT package
 */
export const hexpat_pickle = mkPackage(
  nixRaw`pkgs.haskellPackages.hexpat-pickle`,
  "XML picklers based on hexpat, source-code-similar to those of the HXT package",
);

/**
 * Parse (possibly malformed) HTML to hexpat tree
 */
export const hexpat_tagsoup = mkPackage(
  nixRaw`pkgs.haskellPackages.hexpat-tagsoup`,
  "Parse (possibly malformed) HTML to hexpat tree",
);

/**
 * Streaming-friendly XML parsers
 */
export const hextream = mkPackage(
  nixRaw`pkgs.haskellPackages.hextream`,
  "Streaming-friendly XML parsers",
);

/**
 * Haskell bindings for the Keystone assembler framework
 */
export const heystone = mkPackage(
  nixRaw`pkgs.haskellPackages.heystone`,
  "Haskell bindings for the Keystone assembler framework",
);

/**
 * Flash debugger
 */
export const hfd = mkPackage(
  nixRaw`pkgs.haskellPackages.hfd`,
  "Flash debugger",
);

/**
 * Four in a Row in Haskell!!
 */
export const hfiar = mkPackage(
  nixRaw`pkgs.haskellPackages.hfiar`,
  "Four in a Row in Haskell!!",
);

/**
 * Command line flag parser, very similar to Google's gflags
 */
export const hflags = mkPackage(
  nixRaw`pkgs.haskellPackages.hflags`,
  "Command line flag parser, very similar to Google's gflags",
);

/**
 * Simple Haskell formatting
 */
export const hformat = mkPackage(
  nixRaw`pkgs.haskellPackages.hformat`,
  "Simple Haskell formatting",
);

/**
 * OpenGL fractal renderer
 */
export const hfractal = mkPackage(
  nixRaw`pkgs.haskellPackages.hfractal`,
  "OpenGL fractal renderer",
);

/**
 * File/folder watching for OS X
 */
export const hfsevents = mkPackage(
  nixRaw`pkgs.haskellPackages.hfsevents`,
  "File/folder watching for OS X",
);

/**
 * library for computation automorphism group and canonical labelling of a graph
 */
export const hgal = mkPackage(
  nixRaw`pkgs.haskellPackages.hgal`,
  "library for computation automorphism group and canonical labelling of a graph",
);

/**
 * Haskell Genetic Algorithm Library
 */
export const hgalib = mkPackage(
  nixRaw`pkgs.haskellPackages.hgalib`,
  "Haskell Genetic Algorithm Library",
);

/**
 * Haskell binding to the GDAL library
 */
export const hgdal = mkPackage(
  nixRaw`pkgs.haskellPackages.hgdal`,
  "Haskell binding to the GDAL library",
);

/**
 * Random generation of modal and hybrid logic formulas
 */
export const hgen = mkPackage(
  nixRaw`pkgs.haskellPackages.hgen`,
  "Random generation of modal and hybrid logic formulas",
);

/**
 * Geometric Algorithms, Data structures, and Data types
 */
export const hgeometry = mkPackage(
  nixRaw`pkgs.haskellPackages.hgeometry`,
  "Geometric Algorithms, Data structures, and Data types",
);

/**
 * Data structures, and Data types
 */
export const hgeometry_combinatorial = mkPackage(
  nixRaw`pkgs.haskellPackages.hgeometry-combinatorial`,
  "Data structures, and Data types",
);

/**
 * Reading and Writing ipe7 files
 */
export const hgeometry_ipe = mkPackage(
  nixRaw`pkgs.haskellPackages.hgeometry-ipe`,
  "Reading and Writing ipe7 files",
);

/**
 * Writing geometric primitives from HGeometry as SVG Files
 */
export const hgeometry_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.hgeometry-svg`,
  "Writing geometric primitives from HGeometry as SVG Files",
);

/**
 * Simple Haskell bindings to GEOS C API
 */
export const hgeos = mkPackage(
  nixRaw`pkgs.haskellPackages.hgeos`,
  "Simple Haskell bindings to GEOS C API",
);

/**
 * Bindings to libintl.h (gettext, bindtextdomain)
 */
export const hgettext = mkPackage(
  nixRaw`pkgs.haskellPackages.hgettext`,
  "Bindings to libintl.h (gettext, bindtextdomain)",
);

/**
 * Haskell bindings to the GitHub API
 */
export const hgithub = mkPackage(
  nixRaw`pkgs.haskellPackages.hgithub`,
  "Haskell bindings to the GitHub API",
);

/**
 * Haskell interface to GMP
 */
export const hgmp = mkPackage(
  nixRaw`pkgs.haskellPackages.hgmp`,
  "Haskell interface to GMP",
);

/**
 * Tools for working on (di)graphs
 */
export const hgraph = mkPackage(
  nixRaw`pkgs.haskellPackages.hgraph`,
  "Tools for working on (di)graphs",
);

/**
 * Generate scaffold for cabal project
 */
export const hi = mkPackage(
  nixRaw`pkgs.haskellPackages.hi`,
  "Generate scaffold for cabal project",
);

/**
 * Parser for GHC's hi files
 */
export const hi_file_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.hi-file-parser`,
  "Parser for GHC's hi files",
);

/**
 * Relatively efficient Tcl interpreter with support for basic operations
 */
export const hiccup = mkPackage(
  nixRaw`pkgs.haskellPackages.hiccup`,
  "Relatively efficient Tcl interpreter with support for basic operations",
);

/**
 * Haskell bindings to HIDAPI
 */
export const hidapi = mkPackage(
  nixRaw`pkgs.haskellPackages.hidapi`,
  "Haskell bindings to HIDAPI",
);

/**
 * Set up a GHC API session
 */
export const hie_bios = mkPackage(
  nixRaw`pkgs.haskellPackages.hie-bios`,
  "Set up a GHC API session",
);

/**
 * Set up a GHC API session
 */
export const hie_bios_0_13_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hie-bios_0_13_0`,
  "Set up a GHC API session",
);

/**
 * HIE files for GHC 8.8 and other HIE file backports
 */
export const hie_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.hie-compat`,
  "HIE files for GHC 8.8 and other HIE file backports",
);

/**
 * The core of an IDE
 */
export const hie_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hie-core`,
  "The core of an IDE",
);

/**
 * Generates a references DB from .hie files
 */
export const hiedb = mkPackage(
  nixRaw`pkgs.haskellPackages.hiedb`,
  "Generates a references DB from .hie files",
);

/**
 * Draw diagrams of dendrograms made by hierarchical-clustering
 */
export const hierarchical_clustering_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.hierarchical-clustering-diagrams`,
  "Draw diagrams of dendrograms made by hierarchical-clustering",
);

/**
 * hierarchical environments for dependency injection
 */
export const hierarchical_env = mkPackage(
  nixRaw`pkgs.haskellPackages.hierarchical-env`,
  "hierarchical environments for dependency injection",
);

/**
 * Hierarchical spectral clustering of a graph
 */
export const hierarchical_spectral_clustering = mkPackage(
  nixRaw`pkgs.haskellPackages.hierarchical-spectral-clustering`,
  "Hierarchical spectral clustering of a graph",
);

/**
 * Partial types as a type constructor
 */
export const higgledy = mkPackage(
  nixRaw`pkgs.haskellPackages.higgledy`,
  "Partial types as a type constructor",
);

/**
 * Derive swagger instances from highjson specs
 */
export const highjson_swagger = mkPackage(
  nixRaw`pkgs.haskellPackages.highjson-swagger`,
  "Derive swagger instances from highjson specs",
);

/**
 * Template Haskell helpers for highjson specs
 */
export const highjson_th = mkPackage(
  nixRaw`pkgs.haskellPackages.highjson-th`,
  "Template Haskell helpers for highjson specs",
);

/**
 * Command line tool for highlighting parts of files matching a regex
 */
export const highlight = mkPackage(
  nixRaw`pkgs.haskellPackages.highlight`,
  "Command line tool for highlighting parts of files matching a regex",
);

/**
 * source code highlighting
 */
export const highlighter = mkPackage(
  nixRaw`pkgs.haskellPackages.highlighter`,
  "source code highlighting",
);

/**
 * source code highlighting
 */
export const highlighter2 = mkPackage(
  nixRaw`pkgs.haskellPackages.highlighter2`,
  "source code highlighting",
);

/**
 * Syntax highlighting
 */
export const highlighting_kate = mkPackage(
  nixRaw`pkgs.haskellPackages.highlighting-kate`,
  "Syntax highlighting",
);

/**
 * multithreaded snmp poller for riemann
 */
export const himpy = mkPackage(
  nixRaw`pkgs.haskellPackages.himpy`,
  "multithreaded snmp poller for riemann",
);

/**
 * Extensible Haskell pretty printer
 */
export const hindent = mkPackage(
  nixRaw`pkgs.haskellPackages.hindent`,
  "Extensible Haskell pretty printer",
);

/**
 * Extensible Haskell pretty printer
 */
export const hindent_6_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hindent_6_1_0`,
  "Extensible Haskell pretty printer",
);

/**
 * Apriori algorithm for association rule mining
 */
export const hinduce_associations_apriori = mkPackage(
  nixRaw`pkgs.haskellPackages.hinduce-associations-apriori`,
  "Apriori algorithm for association rule mining",
);

/**
 * Interface and utilities for classifiers
 */
export const hinduce_classifier = mkPackage(
  nixRaw`pkgs.haskellPackages.hinduce-classifier`,
  "Interface and utilities for classifiers",
);

/**
 * Decision Tree Classifiers for hInduce
 */
export const hinduce_classifier_decisiontree = mkPackage(
  nixRaw`pkgs.haskellPackages.hinduce-classifier-decisiontree`,
  "Decision Tree Classifiers for hInduce",
);

/**
 * Example data for hInduce
 */
export const hinduce_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.hinduce-examples`,
  "Example data for hInduce",
);

/**
 * Utility functions
 */
export const hinduce_missingh = mkPackage(
  nixRaw`pkgs.haskellPackages.hinduce-missingh`,
  "Utility functions",
);

/**
 * Command Line App With Info on your Haskell App
 */
export const hinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.hinfo`,
  "Command Line App With Info on your Haskell App",
);

/**
 * Generic project initialization tool
 */
export const hinit = mkPackage(
  nixRaw`pkgs.haskellPackages.hinit`,
  "Generic project initialization tool",
);

/**
 * Haskell binding to inotify
 */
export const hinotify = mkPackage(
  nixRaw`pkgs.haskellPackages.hinotify`,
  "Haskell binding to inotify",
);

/**
 * Haskell binding to inotify
 */
export const hinotify_0_3_9 = mkPackage(
  nixRaw`pkgs.haskellPackages.hinotify_0_3_9`,
  "Haskell binding to inotify",
);

/**
 * Haskell binding to inotify, using ByteString filepaths
 */
export const hinotify_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.hinotify-bytestring`,
  "Haskell binding to inotify, using ByteString filepaths",
);

/**
 * inotify conduit sources
 */
export const hinotify_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hinotify-conduit`,
  "inotify conduit sources",
);

/**
 * A Haskell interpreter built on top of the GHC API
 */
export const hint = mkPackage(
  nixRaw`pkgs.haskellPackages.hint`,
  "A Haskell interpreter built on top of the GHC API",
);

/**
 * Space Invaders
 */
export const hinvaders = mkPackage(
  nixRaw`pkgs.haskellPackages.hinvaders`,
  "Space Invaders",
);

/**
 * Streams and Unique Fixed Points
 */
export const hinze_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.hinze-streams`,
  "Streams and Unique Fixed Points",
);

/**
 * Haskell Image Processing (HIP) Library
 */
export const hip = mkPackage(
  nixRaw`pkgs.haskellPackages.hip`,
  "Haskell Image Processing (HIP) Library",
);

/**
 * A library for building HipChat Bots
 */
export const hipbot = mkPackage(
  nixRaw`pkgs.haskellPackages.hipbot`,
  "A library for building HipChat Bots",
);

/**
 * Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)
 */
export const hipe = mkPackage(
  nixRaw`pkgs.haskellPackages.hipe`,
  "Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)",
);

/**
 * an IPS patcher
 */
export const hips = mkPackage(
  nixRaw`pkgs.haskellPackages.hips`,
  "an IPS patcher",
);

export const hipsql_client = mkPackage(
  nixRaw`pkgs.haskellPackages.hipsql-client`,
  "",
);

export const hipsql_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.hipsql-monad`,
  "",
);

export const hipsql_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hipsql-server`,
  "",
);

export const hipsql_tx_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.hipsql-tx-simple`,
  "",
);

/**
 * Calculates IRT 2PL and 3PL models
 */
export const hirt = mkPackage(
  nixRaw`pkgs.haskellPackages.hirt`,
  "Calculates IRT 2PL and 3PL models",
);

/**
 * Umbrella package for the historical dictionary of Polish
 */
export const hist_pl = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl`,
  "Umbrella package for the historical dictionary of Polish",
);

/**
 * A generic, DAWG-based dictionary
 */
export const hist_pl_dawg = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl-dawg`,
  "A generic, DAWG-based dictionary",
);

/**
 * Merging historical dictionary with PoliMorf
 */
export const hist_pl_fusion = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl-fusion`,
  "Merging historical dictionary with PoliMorf",
);

/**
 * A binary representation of the historical dictionary of Polish
 */
export const hist_pl_lexicon = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl-lexicon`,
  "A binary representation of the historical dictionary of Polish",
);

/**
 * LMF parsing for the historical dictionary of Polish
 */
export const hist_pl_lmf = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl-lmf`,
  "LMF parsing for the historical dictionary of Polish",
);

/**
 * A simple EDSL for transliteration rules
 */
export const hist_pl_transliter = mkPackage(
  nixRaw`pkgs.haskellPackages.hist-pl-transliter`,
  "A simple EDSL for transliteration rules",
);

/**
 * Library for histograms creation
 */
export const histogram_fill = mkPackage(
  nixRaw`pkgs.haskellPackages.histogram-fill`,
  "Library for histograms creation",
);

/**
 * Binary instances for histogram-fill package
 */
export const histogram_fill_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.histogram-fill-binary`,
  "Binary instances for histogram-fill package",
);

/**
 * Binary instances for histogram-fill package
 */
export const histogram_fill_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.histogram-fill-cereal`,
  "Binary instances for histogram-fill package",
);

/**
 * Simple Data.Map-based histogram
 */
export const histogram_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.histogram-simple`,
  "Simple Data.Map-based histogram",
);

/**
 * Git like program in haskell
 */
export const hit = mkPackage(
  nixRaw`pkgs.haskellPackages.hit`,
  "Git like program in haskell",
);

/**
 * Use graph algorithms to access and manipulate Git repos
 */
export const hit_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.hit-graph`,
  "Use graph algorithms to access and manipulate Git repos",
);

/**
 * Haskell/Nix development build tools
 */
export const hix = mkPackage(
  nixRaw`pkgs.haskellPackages.hix`,
  "Haskell/Nix development build tools",
);

/**
 * XPath-like syntax for querying JSON
 */
export const hjpath = mkPackage(
  nixRaw`pkgs.haskellPackages.hjpath`,
  "XPath-like syntax for querying JSON",
);

/**
 * Haskell implementation of a javascript minifier
 */
export const hjsmin = mkPackage(
  nixRaw`pkgs.haskellPackages.hjsmin`,
  "Haskell implementation of a javascript minifier",
);

/**
 * JSON parsing library
 */
export const hjson = mkPackage(
  nixRaw`pkgs.haskellPackages.hjson`,
  "JSON parsing library",
);

/**
 * JSON Schema library
 */
export const hjsonschema = mkPackage(
  nixRaw`pkgs.haskellPackages.hjsonschema`,
  "JSON Schema library",
);

/**
 * Majority Judgment
 */
export const hjugement = mkPackage(
  nixRaw`pkgs.haskellPackages.hjugement`,
  "Majority Judgment",
);

/**
 * Majority Judgment and Helios-C command line tool
 */
export const hjugement_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hjugement-cli`,
  "Majority Judgment and Helios-C command line tool",
);

/**
 * "higher-kinded data"
 */
export const hkd = mkPackage(
  nixRaw`pkgs.haskellPackages.hkd`,
  "\"higher-kinded data\"",
);

/**
 * Apply default value for optional field of HKD
 */
export const hkd_default = mkPackage(
  nixRaw`pkgs.haskellPackages.hkd-default`,
  "Apply default value for optional field of HKD",
);

/**
 * Implementation of HKDF (RFC 5869)
 */
export const hkdf = mkPackage(
  nixRaw`pkgs.haskellPackages.hkdf`,
  "Implementation of HKDF (RFC 5869)",
);

/**
 * Simple Hackage release workflow for package maintainers
 */
export const hkgr = mkPackage(
  nixRaw`pkgs.haskellPackages.hkgr`,
  "Simple Hackage release workflow for package maintainers",
);

/**
 * A library to build valid LaTeX files
 */
export const hlatex = mkPackage(
  nixRaw`pkgs.haskellPackages.hlatex`,
  "A library to build valid LaTeX files",
);

/**
 * Fast algorithm for mining closed frequent itemsets
 */
export const hlcm = mkPackage(
  nixRaw`pkgs.haskellPackages.hlcm`,
  "Fast algorithm for mining closed frequent itemsets",
);

/**
 * Command-line interface for the hledger accounting system
 */
export const hledger = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger`,
  "Command-line interface for the hledger accounting system",
);

/**
 * Command-line interface for the hledger accounting system
 */
export const hledger_1_31 = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger_1_31`,
  "Command-line interface for the hledger accounting system",
);

/**
 * Web API server for the hledger accounting tool
 */
export const hledger_api = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-api`,
  "Web API server for the hledger accounting tool",
);

/**
 * computes interest for a given account
 */
export const hledger_interest = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-interest`,
  "computes interest for a given account",
);

/**
 * A reusable library providing the core functionality of hledger
 */
export const hledger_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-lib`,
  "A reusable library providing the core functionality of hledger",
);

/**
 * A reusable library providing the core functionality of hledger
 */
export const hledger_lib_1_31 = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-lib_1_31`,
  "A reusable library providing the core functionality of hledger",
);

/**
 * Generate HLedger Price Directives From Daily Stock Quotes
 */
export const hledger_stockquotes = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-stockquotes`,
  "Generate HLedger Price Directives From Daily Stock Quotes",
);

/**
 * Curses-style terminal interface for the hledger accounting system
 */
export const hledger_ui = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-ui`,
  "Curses-style terminal interface for the hledger accounting system",
);

/**
 * Curses-style terminal interface for the hledger accounting system
 */
export const hledger_ui_1_31 = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-ui_1_31`,
  "Curses-style terminal interface for the hledger accounting system",
);

/**
 * Web-based user interface for the hledger accounting system
 */
export const hledger_web = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-web`,
  "Web-based user interface for the hledger accounting system",
);

/**
 * Web-based user interface for the hledger accounting system
 */
export const hledger_web_1_31 = mkPackage(
  nixRaw`pkgs.haskellPackages.hledger-web_1_31`,
  "Web-based user interface for the hledger accounting system",
);

/**
 * Simple Lexer Creation
 */
export const hlex = mkPackage(
  nixRaw`pkgs.haskellPackages.hlex`,
  "Simple Lexer Creation",
);

/**
 * Bindings to https://github.com/anrieff/libcpuid
 */
export const hlibcpuid = mkPackage(
  nixRaw`pkgs.haskellPackages.hlibcpuid`,
  "Bindings to https://github.com/anrieff/libcpuid",
);

/**
 * Low-level bindings to libgit2
 */
export const hlibgit2 = mkPackage(
  nixRaw`pkgs.haskellPackages.hlibgit2`,
  "Low-level bindings to libgit2",
);

/**
 * Low-level bindings to Libsass
 */
export const hlibsass = mkPackage(
  nixRaw`pkgs.haskellPackages.hlibsass`,
  "Low-level bindings to Libsass",
);

/**
 * Source code suggestions
 */
export const hlint = mkPackage(
  nixRaw`pkgs.haskellPackages.hlint`,
  "Source code suggestions",
);

/**
 * Source code suggestions
 */
export const hlint_3_2_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.hlint_3_2_8`,
  "Source code suggestions",
);

/**
 * Source code suggestions
 */
export const hlint_3_4_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.hlint_3_4_1`,
  "Source code suggestions",
);

/**
 * Source code suggestions
 */
export const hlint_3_6_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.hlint_3_6_1`,
  "Source code suggestions",
);

/**
 * Run hlint in test suite
 */
export const hlint_test = mkPackage(
  nixRaw`pkgs.haskellPackages.hlint-test`,
  "Run hlint in test suite",
);

/**
 * Heterogeneous list
 */
export const hlist = mkPackage(
  nixRaw`pkgs.haskellPackages.hlist`,
  "Heterogeneous list",
);

/**
 * High-level Redis Database
 */
export const hlrdb = mkPackage(
  nixRaw`pkgs.haskellPackages.hlrdb`,
  "High-level Redis Database",
);

/**
 * High-level Redis Database Core API
 */
export const hlrdb_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hlrdb-core`,
  "High-level Redis Database Core API",
);

/**
 * Haskell Lindenmayer Systems
 */
export const hls = mkPackage(
  nixRaw`pkgs.haskellPackages.hls`,
  "Haskell Lindenmayer Systems",
);

/**
 * Provide Alternate Number Formats plugin for Haskell Language Server
 */
export const hls_alternate_number_format_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-alternate-number-format-plugin`,
  "Provide Alternate Number Formats plugin for Haskell Language Server",
);

/**
 * Integration with the cabal-fmt code formatter
 */
export const hls_cabal_fmt_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-cabal-fmt-plugin`,
  "Integration with the cabal-fmt code formatter",
);

/**
 * Cabal integration plugin with Haskell Language Server
 */
export const hls_cabal_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-cabal-plugin`,
  "Cabal integration plugin with Haskell Language Server",
);

/**
 * Call hierarchy plugin for Haskell Language Server
 */
export const hls_call_hierarchy_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-call-hierarchy-plugin`,
  "Call hierarchy plugin for Haskell Language Server",
);

/**
 * Change a declarations type signature with a Code Action
 */
export const hls_change_type_signature_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-change-type-signature-plugin`,
  "Change a declarations type signature with a Code Action",
);

/**
 * Class/instance management plugin for Haskell Language Server
 */
export const hls_class_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-class-plugin`,
  "Class/instance management plugin for Haskell Language Server",
);

/**
 * HLS Plugin to support smart selection range and Folding range
 */
export const hls_code_range_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-code-range-plugin`,
  "HLS Plugin to support smart selection range and Folding range",
);

/**
 * Eval plugin for Haskell Language Server
 */
export const hls_eval_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-eval-plugin`,
  "Eval plugin for Haskell Language Server",
);

/**
 * Common utilities to interaction between ghc-exactprint and HLS plugins
 */
export const hls_exactprint_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-exactprint-utils`,
  "Common utilities to interaction between ghc-exactprint and HLS plugins",
);

/**
 * Show fixity explicitly while hovering
 */
export const hls_explicit_fixity_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-explicit-fixity-plugin`,
  "Show fixity explicitly while hovering",
);

/**
 * Explicit imports plugin for Haskell Language Server
 */
export const hls_explicit_imports_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-explicit-imports-plugin`,
  "Explicit imports plugin for Haskell Language Server",
);

/**
 * Explicit record fields plugin for Haskell Language Server
 */
export const hls_explicit_record_fields_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-explicit-record-fields-plugin`,
  "Explicit record fields plugin for Haskell Language Server",
);

/**
 * Integration with the Floskell code formatter
 */
export const hls_floskell_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-floskell-plugin`,
  "Integration with the Floskell code formatter",
);

/**
 * Integration with the Fourmolu code formatter
 */
export const hls_fourmolu_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-fourmolu-plugin`,
  "Integration with the Fourmolu code formatter",
);

/**
 * Convert to GADT syntax plugin
 */
export const hls_gadt_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-gadt-plugin`,
  "Convert to GADT syntax plugin",
);

/**
 * Haskell Language Server internal graph API
 */
export const hls_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-graph`,
  "Haskell Language Server internal graph API",
);

/**
 * Hlint integration plugin with Haskell Language Server
 */
export const hls_hlint_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-hlint-plugin`,
  "Hlint integration plugin with Haskell Language Server",
);

/**
 * Module name plugin for Haskell Language Server
 */
export const hls_module_name_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-module-name-plugin`,
  "Module name plugin for Haskell Language Server",
);

/**
 * Integration with the Ormolu code formatter
 */
export const hls_ormolu_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-ormolu-plugin`,
  "Integration with the Ormolu code formatter",
);

/**
 * Overloaded record dot plugin for Haskell Language Server
 */
export const hls_overloaded_record_dot_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-overloaded-record-dot-plugin`,
  "Overloaded record dot plugin for Haskell Language Server",
);

/**
 * Haskell Language Server API for plugin communication
 */
export const hls_plugin_api = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-plugin-api`,
  "Haskell Language Server API for plugin communication",
);

/**
 * Pragmas plugin for Haskell Language Server
 */
export const hls_pragmas_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-pragmas-plugin`,
  "Pragmas plugin for Haskell Language Server",
);

/**
 * A Haskell Language Server plugin that qualifies imported names
 */
export const hls_qualify_imported_names_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-qualify-imported-names-plugin`,
  "A Haskell Language Server plugin that qualifies imported names",
);

/**
 * Exactprint refactorings for Haskell Language Server
 */
export const hls_refactor_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-refactor-plugin`,
  "Exactprint refactorings for Haskell Language Server",
);

/**
 * Rename plugin for Haskell Language Server
 */
export const hls_rename_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-rename-plugin`,
  "Rename plugin for Haskell Language Server",
);

/**
 * Retrie integration plugin for Haskell Language Server
 */
export const hls_retrie_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-retrie-plugin`,
  "Retrie integration plugin for Haskell Language Server",
);

/**
 * HLS Plugin to expand TemplateHaskell Splices and QuasiQuotes
 */
export const hls_splice_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-splice-plugin`,
  "HLS Plugin to expand TemplateHaskell Splices and QuasiQuotes",
);

/**
 * Integration with the Stylish Haskell code formatter
 */
export const hls_stylish_haskell_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-stylish-haskell-plugin`,
  "Integration with the Stylish Haskell code formatter",
);

/**
 * Utilities used in the tests of Haskell Language Server
 */
export const hls_test_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.hls-test-utils`,
  "Utilities used in the tests of Haskell Language Server",
);

/**
 * A tool and library for Markov chains based text generation
 */
export const hmark = mkPackage(
  nixRaw`pkgs.haskellPackages.hmark`,
  "A tool and library for Markov chains based text generation",
);

/**
 * Numeric Linear Algebra
 */
export const hmatrix = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix`,
  "Numeric Linear Algebra",
);

/**
 * hmatrix operations lifted for backprop
 */
export const hmatrix_backprop = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-backprop`,
  "hmatrix operations lifted for backprop",
);

/**
 * CSV encoding and decoding for hmatrix
 */
export const hmatrix_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-csv`,
  "CSV encoding and decoding for hmatrix",
);

/**
 * Linear Programming based on GLPK
 */
export const hmatrix_glpk = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-glpk`,
  "Linear Programming based on GLPK",
);

/**
 * Numerical computation
 */
export const hmatrix_gsl = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-gsl`,
  "Numerical computation",
);

/**
 * GSL Statistics interface
 */
export const hmatrix_gsl_stats = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-gsl-stats`,
  "GSL Statistics interface",
);

/**
 * Low-level machine learning auxiliary functions
 */
export const hmatrix_morpheus = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-morpheus`,
  "Low-level machine learning auxiliary functions",
);

/**
 * Interface HMatrix with the NLOPT minimizer
 */
export const hmatrix_nlopt = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-nlopt`,
  "Interface HMatrix with the NLOPT minimizer",
);

/**
 * Bindings to the QuadProg++ quadratic programming library
 */
export const hmatrix_quadprogpp = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-quadprogpp`,
  "Bindings to the QuadProg++ quadratic programming library",
);

/**
 * Adaptors for interoperability between hmatrix and repa
 */
export const hmatrix_repa = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-repa`,
  "Adaptors for interoperability between hmatrix and repa",
);

/**
 * Interface to GSL special functions
 */
export const hmatrix_special = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-special`,
  "Interface to GSL special functions",
);

/**
 * hmatrix interface to sundials
 */
export const hmatrix_sundials = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-sundials`,
  "hmatrix interface to sundials",
);

/**
 * Conversions between hmatrix and vector-sized types
 */
export const hmatrix_vector_sized = mkPackage(
  nixRaw`pkgs.haskellPackages.hmatrix-vector-sized`,
  "Conversions between hmatrix and vector-sized types",
);

/**
 * Haskell Meapsoft Parser
 */
export const hmeap = mkPackage(
  nixRaw`pkgs.haskellPackages.hmeap`,
  "Haskell Meapsoft Parser",
);

/**
 * Haskell Meapsoft Parser Utilities
 */
export const hmeap_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.hmeap-utils`,
  "Haskell Meapsoft Parser Utilities",
);

/**
 * In-memory relational database
 */
export const hmemdb = mkPackage(
  nixRaw`pkgs.haskellPackages.hmemdb`,
  "In-memory relational database",
);

/**
 * HMEP Multi Expression Programming  a genetic programming variant
 */
export const hmep = mkPackage(
  nixRaw`pkgs.haskellPackages.hmep`,
  "HMEP Multi Expression Programming  a genetic programming variant",
);

/**
 * Binding to the OS level MIDI services
 */
export const hmidi = mkPackage(
  nixRaw`pkgs.haskellPackages.hmidi`,
  "Binding to the OS level MIDI services",
);

/**
 * Hidden Markov Models using LAPACK primitives
 */
export const hmm_lapack = mkPackage(
  nixRaw`pkgs.haskellPackages.hmm-lapack`,
  "Hidden Markov Models using LAPACK primitives",
);

/**
 * A 2019 fork of an ncurses mp3 player written in Haskell
 */
export const hmp3_ng = mkPackage(
  nixRaw`pkgs.haskellPackages.hmp3-ng`,
  "A 2019 fork of an ncurses mp3 player written in Haskell",
);

/**
 * Haskell binding to the MPFR library
 */
export const hmpfr = mkPackage(
  nixRaw`pkgs.haskellPackages.hmpfr`,
  "Haskell binding to the MPFR library",
);

/**
 * Haskell Music Theory
 */
export const hmt = mkPackage(
  nixRaw`pkgs.haskellPackages.hmt`,
  "Haskell Music Theory",
);

/**
 * Haskell Music Theory Base
 */
export const hmt_base = mkPackage(
  nixRaw`pkgs.haskellPackages.hmt-base`,
  "Haskell Music Theory Base",
);

/**
 * Haskell Music Theory Diagrams
 */
export const hmt_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.hmt-diagrams`,
  "Haskell Music Theory Diagrams",
);

/**
 * Haskell NetCDF library
 */
export const hnetcdf = mkPackage(
  nixRaw`pkgs.haskellPackages.hnetcdf`,
  "Haskell NetCDF library",
);

/**
 * Haskell implementation of the Nix language
 */
export const hnix = mkPackage(
  nixRaw`pkgs.haskellPackages.hnix`,
  "Haskell implementation of the Nix language",
);

/**
 * Core effects for interacting with the Nix store
 */
export const hnix_store_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hnix-store-core`,
  "Core effects for interacting with the Nix store",
);

/**
 * Core effects for interacting with the Nix store
 */
export const hnix_store_core_0_6_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hnix-store-core_0_6_1_0`,
  "Core effects for interacting with the Nix store",
);

/**
 * Remote hnix store
 */
export const hnix_store_remote = mkPackage(
  nixRaw`pkgs.haskellPackages.hnix-store-remote`,
  "Remote hnix store",
);

/**
 * Remote hnix store
 */
export const hnix_store_remote_0_6_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hnix-store-remote_0_6_0_0`,
  "Remote hnix store",
);

/**
 * Log message normalisation tool producing structured JSON messages
 */
export const hnormalise = mkPackage(
  nixRaw`pkgs.haskellPackages.hnormalise`,
  "Log message normalisation tool producing structured JSON messages",
);

/**
 * Haskell OAuth2 authentication client
 */
export const hoauth2 = mkPackage(
  nixRaw`pkgs.haskellPackages.hoauth2`,
  "Haskell OAuth2 authentication client",
);

/**
 * Haskell OAuth2 authentication client
 */
export const hoauth2_2_8_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.hoauth2_2_8_1`,
  "Haskell OAuth2 authentication client",
);

/**
 * hoauth2 demo application
 */
export const hoauth2_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.hoauth2-demo`,
  "hoauth2 demo application",
);

/**
 * tutorial for hoauth2-providers module
 */
export const hoauth2_providers_tutorial = mkPackage(
  nixRaw`pkgs.haskellPackages.hoauth2-providers-tutorial`,
  "tutorial for hoauth2-providers module",
);

/**
 * A source code editor aiming for the convenience of use
 */
export const hob = mkPackage(
  nixRaw`pkgs.haskellPackages.hob`,
  "A source code editor aiming for the convenience of use",
);

/**
 * Haskell binding to a subset of OGRE
 */
export const hogre = mkPackage(
  nixRaw`pkgs.haskellPackages.hogre`,
  "Haskell binding to a subset of OGRE",
);

/**
 * Examples for using Hogre
 */
export const hogre_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.hogre-examples`,
  "Examples for using Hogre",
);

/**
 * Some convenience facilities for hoisting errors into a monad
 */
export const hoist_error = mkPackage(
  nixRaw`pkgs.haskellPackages.hoist-error`,
  "Some convenience facilities for hoisting errors into a monad",
);

/**
 * Higher order logic
 */
export const hol = mkPackage(
  nixRaw`pkgs.haskellPackages.hol`,
  "Higher order logic",
);

/**
 * None
 */
export const holey_format = mkPackage(
  nixRaw`pkgs.haskellPackages.holey-format`,
  "None",
);

/**
 * Start your Haskell project with cabal, git and tests
 */
export const holy_project = mkPackage(
  nixRaw`pkgs.haskellPackages.holy-project`,
  "Start your Haskell project with cabal, git and tests",
);

/**
 * Haskell Offline Music Manipulation And Generation EDSL
 */
export const hommage = mkPackage(
  nixRaw`pkgs.haskellPackages.hommage`,
  "Haskell Offline Music Manipulation And Generation EDSL",
);

/**
 * DirectSound extension (Windows) for the Hommage sound library
 */
export const hommage_ds = mkPackage(
  nixRaw`pkgs.haskellPackages.hommage-ds`,
  "DirectSound extension (Windows) for the Hommage sound library",
);

/**
 * Homotuple, all whose elements are the same type
 */
export const homotuple = mkPackage(
  nixRaw`pkgs.haskellPackages.homotuple`,
  "Homotuple, all whose elements are the same type",
);

export const homura_stopwatch = mkPackage(
  nixRaw`pkgs.haskellPackages.homura-stopwatch`,
  "",
);

export const honeycomb = mkPackage(
  nixRaw`pkgs.haskellPackages.honeycomb`,
  "",
);

/**
 * Cross-platform interface to the PC speaker
 */
export const honk = mkPackage(
  nixRaw`pkgs.haskellPackages.honk`,
  "Cross-platform interface to the PC speaker",
);

/**
 * Debugging by observing in place
 */
export const hood = mkPackage(
  nixRaw`pkgs.haskellPackages.hood`,
  "Debugging by observing in place",
);

/**
 * A small, toy roguelike
 */
export const hoodie = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodie`,
  "A small, toy roguelike",
);

/**
 * Executable for hoodle
 */
export const hoodle = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle`,
  "Executable for hoodle",
);

/**
 * text builder for hoodle file format
 */
export const hoodle_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-builder`,
  "text builder for hoodle file format",
);

/**
 * Core library for hoodle
 */
export const hoodle_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-core`,
  "Core library for hoodle",
);

/**
 * extra hoodle tools
 */
export const hoodle_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-extra`,
  "extra hoodle tools",
);

/**
 * Hoodle file parser
 */
export const hoodle_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-parser`,
  "Hoodle file parser",
);

/**
 * publish hoodle files as a static web site
 */
export const hoodle_publish = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-publish`,
  "publish hoodle files as a static web site",
);

/**
 * Hoodle file renderer
 */
export const hoodle_render = mkPackage(
  nixRaw`pkgs.haskellPackages.hoodle-render`,
  "Hoodle file renderer",
);

/**
 * Haskell API Search
 */
export const hoogle = mkPackage(
  nixRaw`pkgs.haskellPackages.hoogle`,
  "Haskell API Search",
);

/**
 * Abstraction over creating network connections with SOCKS5 and TLS
 */
export const hookup = mkPackage(
  nixRaw`pkgs.haskellPackages.hookup`,
  "Abstraction over creating network connections with SOCKS5 and TLS",
);

/**
 * Haskell Media Server
 */
export const hoovie = mkPackage(
  nixRaw`pkgs.haskellPackages.hoovie`,
  "Haskell Media Server",
);

/**
 * FFI Bindings to OpenSSL's EVP Digest Interface
 */
export const hopenssl = mkPackage(
  nixRaw`pkgs.haskellPackages.hopenssl`,
  "FFI Bindings to OpenSSL's EVP Digest Interface",
);

/**
 * Hopfield Networks for unsupervised learning in Haskell
 */
export const hopfield_networks = mkPackage(
  nixRaw`pkgs.haskellPackages.hopfield-networks`,
  "Hopfield Networks for unsupervised learning in Haskell",
);

/**
 * Bidings to Google's Zopfli compression library
 */
export const hopfli = mkPackage(
  nixRaw`pkgs.haskellPackages.hopfli`,
  "Bidings to Google's Zopfli compression library",
);

/**
 * C++ FFI generator - Documentation
 */
export const hoppy_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.hoppy-docs`,
  "C++ FFI generator - Documentation",
);

/**
 * C++ FFI generator - Runtime support
 */
export const hoppy_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.hoppy-runtime`,
  "C++ FFI generator - Runtime support",
);

/**
 * C++ FFI generator - Standard library bindings
 */
export const hoppy_std = mkPackage(
  nixRaw`pkgs.haskellPackages.hoppy-std`,
  "C++ FFI generator - Standard library bindings",
);

/**
 * date time
 */
export const hora = mkPackage(
  nixRaw`pkgs.haskellPackages.hora`,
  "date time",
);

/**
 * Horizon Stable Package Set Type Definitions
 */
export const horizon_spec = mkPackage(
  nixRaw`pkgs.haskellPackages.horizon-spec`,
  "Horizon Stable Package Set Type Definitions",
);

/**
 * horizontal rule for the terminal
 */
export const horizontal_rule = mkPackage(
  nixRaw`pkgs.haskellPackages.horizontal-rule`,
  "horizontal rule for the terminal",
);

/**
 * Haskell Open Sound Control
 */
export const hosc = mkPackage(
  nixRaw`pkgs.haskellPackages.hosc`,
  "Haskell Open Sound Control",
);

/**
 * Network Host Addresses
 */
export const hostaddress = mkPackage(
  nixRaw`pkgs.haskellPackages.hostaddress`,
  "Network Host Addresses",
);

/**
 * A very simple package providing a cross-platform means of determining the hostname
 */
export const hostname = mkPackage(
  nixRaw`pkgs.haskellPackages.hostname`,
  "A very simple package providing a cross-platform means of determining the hostname",
);

/**
 * Validate hostnames e.g. localhost or foo.co.uk.
 */
export const hostname_validate = mkPackage(
  nixRaw`pkgs.haskellPackages.hostname-validate`,
  "Validate hostnames e.g. localhost or foo.co.uk.",
);

export const hotel_california = mkPackage(
  nixRaw`pkgs.haskellPackages.hotel-california`,
  "",
);

/**
 * Simple code hotswapping
 */
export const hotswap = mkPackage(
  nixRaw`pkgs.haskellPackages.hotswap`,
  "Simple code hotswapping",
);

/**
 * simple performant time related library
 */
export const hourglass = mkPackage(
  nixRaw`pkgs.haskellPackages.hourglass`,
  "simple performant time related library",
);

/**
 * Orphan Aeson instances to hourglass
 */
export const hourglass_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.hourglass-orphans`,
  "Orphan Aeson instances to hourglass",
);

/**
 * Non-interactive proof assistant monad for first-order logic
 */
export const hout = mkPackage(
  nixRaw`pkgs.haskellPackages.hout`,
  "Non-interactive proof assistant monad for first-order logic",
);

/**
 * Real-time heap graphing utility and profile stream server with a reusable graphing module
 */
export const hp2any_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.hp2any-graph`,
  "Real-time heap graphing utility and profile stream server with a reusable graphing module",
);

/**
 * A utility to visualise and compare heap profiles
 */
export const hp2any_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.hp2any-manager`,
  "A utility to visualise and compare heap profiles",
);

/**
 * A tool for converting GHC heap-profiles to HTML
 */
export const hp2html = mkPackage(
  nixRaw`pkgs.haskellPackages.hp2html`,
  "A tool for converting GHC heap-profiles to HTML",
);

/**
 * generate pretty graphs from heap profiles
 */
export const hp2pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.hp2pretty`,
  "generate pretty graphs from heap profiles",
);

/**
 * A modern format for Haskell packages
 */
export const hpack = mkPackage(
  nixRaw`pkgs.haskellPackages.hpack`,
  "A modern format for Haskell packages",
);

/**
 * A modern format for Haskell packages
 */
export const hpack_0_36_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hpack_0_36_0`,
  "A modern format for Haskell packages",
);

/**
 * Modular template compiler
 */
export const hpaco = mkPackage(
  nixRaw`pkgs.haskellPackages.hpaco`,
  "Modular template compiler",
);

/**
 * Modular template compiler library
 */
export const hpaco_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.hpaco-lib`,
  "Modular template compiler library",
);

/**
 * A scrapbook for Haskell developers
 */
export const hpage = mkPackage(
  nixRaw`pkgs.haskellPackages.hpage`,
  "A scrapbook for Haskell developers",
);

/**
 * Haskell paste web site
 */
export const hpaste = mkPackage(
  nixRaw`pkgs.haskellPackages.hpaste`,
  "Haskell paste web site",
);

/**
 * Support for well-typed paths
 */
export const hpath = mkPackage(
  nixRaw`pkgs.haskellPackages.hpath`,
  "Support for well-typed paths",
);

/**
 * Alternative to 'directory' package with ByteString based filepaths
 */
export const hpath_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.hpath-directory`,
  "Alternative to 'directory' package with ByteString based filepaths",
);

/**
 * ByteString based filepath manipulation
 */
export const hpath_filepath = mkPackage(
  nixRaw`pkgs.haskellPackages.hpath-filepath`,
  "ByteString based filepath manipulation",
);

/**
 * High-level IO operations on files/directories
 */
export const hpath_io = mkPackage(
  nixRaw`pkgs.haskellPackages.hpath-io`,
  "High-level IO operations on files/directories",
);

/**
 * Some low-level POSIX glue code, that is not in 'unix'
 */
export const hpath_posix = mkPackage(
  nixRaw`pkgs.haskellPackages.hpath-posix`,
  "Some low-level POSIX glue code, that is not in 'unix'",
);

/**
 * Code Coverage Library for Haskell
 */
export const hpc_0_7_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc_0_7_0_0`,
  "Code Coverage Library for Haskell",
);

/**
 * Generate codecov report from hpc data
 */
export const hpc_codecov = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-codecov`,
  "Generate codecov report from hpc data",
);

/**
 * Generate codecov report from hpc data
 */
export const hpc_codecov_0_4_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-codecov_0_4_1_0`,
  "Generate codecov report from hpc data",
);

/**
 * Convert HPC output into LCOV format
 */
export const hpc_lcov = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-lcov`,
  "Convert HPC output into LCOV format",
);

/**
 * Hpc-generated strobes for a running Haskell program
 */
export const hpc_strobe = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-strobe`,
  "Hpc-generated strobes for a running Haskell program",
);

/**
 * Ensure the code coverage is above configured thresholds
 */
export const hpc_threshold = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-threshold`,
  "Ensure the code coverage is above configured thresholds",
);

/**
 * Tracer with AJAX interface
 */
export const hpc_tracer = mkPackage(
  nixRaw`pkgs.haskellPackages.hpc-tracer`,
  "Tracer with AJAX interface",
);

/**
 * monadic, reactive Formlets running in the Web browser
 */
export const hplayground = mkPackage(
  nixRaw`pkgs.haskellPackages.hplayground`,
  "monadic, reactive Formlets running in the Web browser",
);

/**
 * A Haskell pre-processor
 */
export const hpp = mkPackage(
  nixRaw`pkgs.haskellPackages.hpp`,
  "A Haskell pre-processor",
);

/**
 * Adaptation of the hpqtypes library for the effectful ecosystem
 */
export const hpqtypes_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.hpqtypes-effectful`,
  "Adaptation of the hpqtypes library for the effectful ecosystem",
);

/**
 * Extra utilities for hpqtypes library
 */
export const hpqtypes_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.hpqtypes-extras`,
  "Extra utilities for hpqtypes library",
);

/**
 * Parse Google Protocol Buffer specifications
 */
export const hprotoc = mkPackage(
  nixRaw`pkgs.haskellPackages.hprotoc`,
  "Parse Google Protocol Buffer specifications",
);

/**
 * Parse Google Protocol Buffer specifications
 */
export const hprotoc_fork = mkPackage(
  nixRaw`pkgs.haskellPackages.hprotoc-fork`,
  "Parse Google Protocol Buffer specifications",
);

/**
 * a lightweight HTTP proxy server, and more
 */
export const hprox = mkPackage(
  nixRaw`pkgs.haskellPackages.hprox`,
  "a lightweight HTTP proxy server, and more",
);

/**
 * Haskell Postscript
 */
export const hps = mkPackage(
  nixRaw`pkgs.haskellPackages.hps`,
  "Haskell Postscript",
);

/**
 * Cairo rendering for the haskell postscript library
 */
export const hps_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.hps-cairo`,
  "Cairo rendering for the haskell postscript library",
);

/**
 * Haskell bindings for libpuz
 */
export const hpuz = mkPackage(
  nixRaw`pkgs.haskellPackages.hpuz`,
  "Haskell bindings for libpuz",
);

/**
 * Python language tools
 */
export const hpython = mkPackage(
  nixRaw`pkgs.haskellPackages.hpython`,
  "Python language tools",
);

/**
 * Quantitative Library
 */
export const hq = mkPackage(
  nixRaw`pkgs.haskellPackages.hq`,
  "Quantitative Library",
);

/**
 * HQuantLib is a port of essencial parts of QuantLib to Haskell
 */
export const hquantlib = mkPackage(
  nixRaw`pkgs.haskellPackages.hquantlib`,
  "HQuantLib is a port of essencial parts of QuantLib to Haskell",
);

/**
 * Basic utility for ranking a list of items
 */
export const hranker = mkPackage(
  nixRaw`pkgs.haskellPackages.hranker`,
  "Basic utility for ranking a list of items",
);

/**
 * Generalization of MonadReader and ReaderT using hset
 */
export const hreader = mkPackage(
  nixRaw`pkgs.haskellPackages.hreader`,
  "Generalization of MonadReader and ReaderT using hset",
);

/**
 * Optics for hreader package
 */
export const hreader_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.hreader-lens`,
  "Optics for hreader package",
);

/**
 * A Type dependent Highlevel HTTP client library
 */
export const hreq_client = mkPackage(
  nixRaw`pkgs.haskellPackages.hreq-client`,
  "A Type dependent Highlevel HTTP client library",
);

/**
 * Conduit streaming support for Hreq
 */
export const hreq_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hreq-conduit`,
  "Conduit streaming support for Hreq",
);

/**
 * File size in human readable format
 */
export const hrfsize = mkPackage(
  nixRaw`pkgs.haskellPackages.hrfsize`,
  "File size in human readable format",
);

/**
 * A Riemann Client for Haskell
 */
export const hriemann = mkPackage(
  nixRaw`pkgs.haskellPackages.hriemann`,
  "A Riemann Client for Haskell",
);

/**
 * GHC-toolchain installer broker
 */
export const hs = mkPackage(
  nixRaw`pkgs.haskellPackages.hs`,
  "GHC-toolchain installer broker",
);

/**
 * A 2048 clone in Haskell
 */
export const hs2048 = mkPackage(
  nixRaw`pkgs.haskellPackages.hs2048`,
  "A 2048 clone in Haskell",
);

/**
 * Create ATS types from Haskell types
 */
export const hs2ats = mkPackage(
  nixRaw`pkgs.haskellPackages.hs2ats`,
  "Create ATS types from Haskell types",
);

/**
 * Generate graphviz-code from Haskell-code
 */
export const hs2dot = mkPackage(
  nixRaw`pkgs.haskellPackages.hs2dot`,
  "Generate graphviz-code from Haskell-code",
);

/**
 * By using this package, you can make application configurable
 */
export const hsConfigure = mkPackage(
  nixRaw`pkgs.haskellPackages.hsConfigure`,
  "By using this package, you can make application configurable",
);

/**
 * PID control loop
 */
export const hsPID = mkPackage(
  nixRaw`pkgs.haskellPackages.hsPID`,
  "PID control loop",
);

/**
 * Haskell bindings to the MaxMind GeoIPCity database via the C library
 */
export const hs_GeoIP = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-GeoIP`,
  "Haskell bindings to the MaxMind GeoIPCity database via the C library",
);

/**
 * A modern and easy-to-use wrapper for Docker-based Lambda implementations. Now with API Gateway support!
 */
export const hs_aws_lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-aws-lambda`,
  "A modern and easy-to-use wrapper for Docker-based Lambda implementations. Now with API Gateway support!",
);

/**
 * Haskell bindings to bibutils, the bibliography conversion utilities
 */
export const hs_bibutils = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-bibutils`,
  "Haskell bindings to bibutils, the bibliography conversion utilities",
);

/**
 * A cryptohash-inspired library for blake2
 */
export const hs_blake2 = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-blake2`,
  "A cryptohash-inspired library for blake2",
);

/**
 * Generate images suitable for use as CAPTCHAs in online web-form security
 */
export const hs_captcha = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-captcha`,
  "Generate images suitable for use as CAPTCHAs in online web-form security",
);

/**
 * A Haskell framework for parallel monte carlo simulations
 */
export const hs_carbon = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-carbon`,
  "A Haskell framework for parallel monte carlo simulations",
);

/**
 * A library for reading CDB (Constant Database) files
 */
export const hs_cdb = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-cdb`,
  "A library for reading CDB (Constant Database) files",
);

/**
 * Conllu validating parser and utils
 */
export const hs_conllu = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-conllu`,
  "Conllu validating parser and utils",
);

/**
 * Bindings to FFMPEG library
 */
export const hs_ffmpeg = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-ffmpeg`,
  "Bindings to FFMPEG library",
);

/**
 * Functors from products of Haskell and its dual to Haskell
 */
export const hs_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-functors`,
  "Functors from products of Haskell and its dual to Haskell",
);

/**
 * Haskell wrapper for the Google Chart API
 */
export const hs_gchart = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-gchart`,
  "Haskell wrapper for the Google Chart API",
);

/**
 * Utility to generate haskell-names interface files
 */
export const hs_gen_iface = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-gen-iface`,
  "Utility to generate haskell-names interface files",
);

/**
 * Haskell source code analyzer
 */
export const hs_inspector = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-inspector`,
  "Haskell source code analyzer",
);

/**
 * Indexed applicative functors and monads
 */
export const hs_ix = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-ix`,
  "Indexed applicative functors and monads",
);

export const hs_mesos = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-mesos`,
  "",
);

/**
 * The OpenMoji emoji dataset
 */
export const hs_openmoji_data = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-openmoji-data`,
  "The OpenMoji emoji dataset",
);

/**
 * OpenTelemetry API for use by libraries for direct instrumentation or wrapper packages
 */
export const hs_opentelemetry_api = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-api`,
  "OpenTelemetry API for use by libraries for direct instrumentation or wrapper packages",
);

/**
 * [synopsis]
 */
export const hs_opentelemetry_awsxray = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-awsxray`,
  "[synopsis]",
);

export const hs_opentelemetry_exporter_handle = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-exporter-handle`,
  "",
);

export const hs_opentelemetry_exporter_in_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-exporter-in-memory`,
  "",
);

/**
 * OpenTelemetry exporter supporting the standard OTLP protocol
 */
export const hs_opentelemetry_exporter_otlp = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-exporter-otlp`,
  "OpenTelemetry exporter supporting the standard OTLP protocol",
);

export const hs_opentelemetry_instrumentation_cloudflare = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-cloudflare`,
  "",
);

export const hs_opentelemetry_instrumentation_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-conduit`,
  "",
);

export const hs_opentelemetry_instrumentation_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-hspec`,
  "",
);

export const hs_opentelemetry_instrumentation_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-http-client`,
  "",
);

export const hs_opentelemetry_instrumentation_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-persistent`,
  "",
);

export const hs_opentelemetry_instrumentation_postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-postgresql-simple`,
  "",
);

/**
 * WAI instrumentation middleware for OpenTelemetry
 */
export const hs_opentelemetry_instrumentation_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-wai`,
  "WAI instrumentation middleware for OpenTelemetry",
);

/**
 * Yesod middleware for providing OpenTelemetry instrumentation
 */
export const hs_opentelemetry_instrumentation_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-instrumentation-yesod`,
  "Yesod middleware for providing OpenTelemetry instrumentation",
);

/**
 * OpenTelemetry protocol buffer modules generated for the OTLP protocol by the proto-lens package
 */
export const hs_opentelemetry_otlp = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-otlp`,
  "OpenTelemetry protocol buffer modules generated for the OTLP protocol by the proto-lens package",
);

/**
 * Trace propagation via HTTP headers following the b3 tracestate spec
 */
export const hs_opentelemetry_propagator_b3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-propagator-b3`,
  "Trace propagation via HTTP headers following the b3 tracestate spec",
);

/**
 * Trace propagation via HTTP headers following the w3c tracestate spec
 */
export const hs_opentelemetry_propagator_w3c = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-propagator-w3c`,
  "Trace propagation via HTTP headers following the w3c tracestate spec",
);

/**
 * OpenTelemetry SDK for use in applications
 */
export const hs_opentelemetry_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-sdk`,
  "OpenTelemetry SDK for use in applications",
);

export const hs_opentelemetry_utils_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-utils-exceptions`,
  "",
);

/**
 * Optional OpenTelemetry integration for Honeycomb
 */
export const hs_opentelemetry_vendor_honeycomb = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-opentelemetry-vendor-honeycomb`,
  "Optional OpenTelemetry integration for Honeycomb",
);

/**
 * PHP session and values serialization
 */
export const hs_php_session = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-php-session`,
  "PHP session and values serialization",
);

/**
 * A library for Passbook pass creation & signing
 */
export const hs_pkpass = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-pkpass`,
  "A library for Passbook pass creation & signing",
);

/**
 * Bindings to C pipe functions
 */
export const hs_popen = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-popen`,
  "Bindings to C pipe functions",
);

/**
 * Profunctors from Haskell to Haskell
 */
export const hs_profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-profunctors`,
  "Profunctors from Haskell to Haskell",
);

/**
 * Terminal Emulator written in Haskell, SDL2 Backend
 */
export const hs_sdl_term_emulator = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-sdl-term-emulator`,
  "Terminal Emulator written in Haskell, SDL2 Backend",
);

/**
 * Write a server supporting Server::Starter's protocol in Haskell
 */
export const hs_server_starter = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-server-starter`,
  "Write a server supporting Server::Starter's protocol in Haskell",
);

/**
 * Convert an eventlog into the speedscope json format
 */
export const hs_speedscope = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-speedscope`,
  "Convert an eventlog into the speedscope json format",
);

/**
 * Data.HashTable.Class instance definition for Data.HashTable.ST.Swiss
 */
export const hs_swisstable_hashtables_class = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-swisstable-hashtables-class`,
  "Data.HashTable.Class instance definition for Data.HashTable.ST.Swiss",
);

/**
 * Haskell bindings to the Zstandard compression algorithm
 */
export const hs_zstd = mkPackage(
  nixRaw`pkgs.haskellPackages.hs-zstd`,
  "Haskell bindings to the Zstandard compression algorithm",
);

/**
 * Akamai API(Edgegrid and Netstorage)
 */
export const hsakamai = mkPackage(
  nixRaw`pkgs.haskellPackages.hsakamai`,
  "Akamai API(Edgegrid and Netstorage)",
);

/**
 * Integrating Sass into Haskell applications
 */
export const hsass = mkPackage(
  nixRaw`pkgs.haskellPackages.hsass`,
  "Integrating Sass into Haskell applications",
);

/**
 * Haskell bindings for PyAutoGUI, a library for automating user interaction
 */
export const hsautogui = mkPackage(
  nixRaw`pkgs.haskellPackages.hsautogui`,
  "Haskell bindings for PyAutoGUI, a library for automating user interaction",
);

/**
 * Preprocesses a file, adding blobs from files as string literals
 */
export const hsb2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.hsb2hs`,
  "Preprocesses a file, adding blobs from files as string literals",
);

/**
 * simple utility for rolling filesystem backups
 */
export const hsbackup = mkPackage(
  nixRaw`pkgs.haskellPackages.hsbackup`,
  "simple utility for rolling filesystem backups",
);

/**
 * Backend for uploading benchmark data to CodeSpeed
 */
export const hsbencher_codespeed = mkPackage(
  nixRaw`pkgs.haskellPackages.hsbencher-codespeed`,
  "Backend for uploading benchmark data to CodeSpeed",
);

/**
 * Backend for uploading benchmark data to Google Fusion Tables
 */
export const hsbencher_fusion = mkPackage(
  nixRaw`pkgs.haskellPackages.hsbencher-fusion`,
  "Backend for uploading benchmark data to Google Fusion Tables",
);

/**
 * Haskell bindings to BLST
 */
export const hsblst = mkPackage(
  nixRaw`pkgs.haskellPackages.hsblst`,
  "Haskell bindings to BLST",
);

/**
 * A preprocessor that helps with writing Haskell bindings to C code
 */
export const hsc2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc2hs`,
  "A preprocessor that helps with writing Haskell bindings to C code",
);

/**
 * Haskell SuperCollider
 */
export const hsc3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3`,
  "Haskell SuperCollider",
);

/**
 * Haskell SuperCollider Auditor
 */
export const hsc3_auditor = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-auditor`,
  "Haskell SuperCollider Auditor",
);

/**
 * haskell supercollider data
 */
export const hsc3_data = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-data`,
  "haskell supercollider data",
);

/**
 * FORTH SUPERCOLLIDER
 */
export const hsc3_forth = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-forth`,
  "FORTH SUPERCOLLIDER",
);

/**
 * Haskell SuperCollider Graphs
 */
export const hsc3_graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-graphs`,
  "Haskell SuperCollider Graphs",
);

/**
 * LISP SUPERCOLLIDER
 */
export const hsc3_lisp = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-lisp`,
  "LISP SUPERCOLLIDER",
);

/**
 * Haskell SuperCollider Plotting
 */
export const hsc3_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-plot`,
  "Haskell SuperCollider Plotting",
);

/**
 * SuperCollider server resource management and synchronization
 */
export const hsc3_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-server`,
  "SuperCollider server resource management and synchronization",
);

/**
 * Haskell SuperCollider SoundFile
 */
export const hsc3_sf_hsndfile = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-sf-hsndfile`,
  "Haskell SuperCollider SoundFile",
);

/**
 * Haskell SuperCollider Utilities
 */
export const hsc3_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.hsc3-utils`,
  "Haskell SuperCollider Utilities",
);

/**
 * cassandra database interface
 */
export const hscassandra = mkPackage(
  nixRaw`pkgs.haskellPackages.hscassandra`,
  "cassandra database interface",
);

/**
 * minimal ncurses-like library
 */
export const hscharm = mkPackage(
  nixRaw`pkgs.haskellPackages.hscharm`,
  "minimal ncurses-like library",
);

/**
 * Describe schemas for your Haskell data types
 */
export const hschema = mkPackage(
  nixRaw`pkgs.haskellPackages.hschema`,
  "Describe schemas for your Haskell data types",
);

/**
 * Describe schemas for your Haskell data types
 */
export const hschema_prettyprinter = mkPackage(
  nixRaw`pkgs.haskellPackages.hschema-prettyprinter`,
  "Describe schemas for your Haskell data types",
);

/**
 * Describe schemas for your Haskell data types
 */
export const hschema_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.hschema-quickcheck`,
  "Describe schemas for your Haskell data types",
);

/**
 * Colourise Haskell code
 */
export const hscolour = mkPackage(
  nixRaw`pkgs.haskellPackages.hscolour`,
  "Colourise Haskell code",
);

/**
 * Colourise Haskell code
 */
export const hscolour_1_25 = mkPackage(
  nixRaw`pkgs.haskellPackages.hscolour_1_25`,
  "Colourise Haskell code",
);

/**
 * cscope like browser for Haskell code
 */
export const hscope = mkPackage(
  nixRaw`pkgs.haskellPackages.hscope`,
  "cscope like browser for Haskell code",
);

/**
 * Haskell shell script templates
 */
export const hscrtmpl = mkPackage(
  nixRaw`pkgs.haskellPackages.hscrtmpl`,
  "Haskell shell script templates",
);

/**
 * NCurses bindings for Haskell
 */
export const hscurses = mkPackage(
  nixRaw`pkgs.haskellPackages.hscurses`,
  "NCurses bindings for Haskell",
);

/**
 * hscurses swimming fish example
 */
export const hscurses_fish_ex = mkPackage(
  nixRaw`pkgs.haskellPackages.hscurses-fish-ex`,
  "hscurses swimming fish example",
);

/**
 * Haskell development library
 */
export const hsdev = mkPackage(
  nixRaw`pkgs.haskellPackages.hsdev`,
  "Haskell development library",
);

/**
 * Asynchronous DNS Resolver
 */
export const hsdns = mkPackage(
  nixRaw`pkgs.haskellPackages.hsdns`,
  "Asynchronous DNS Resolver",
);

/**
 * Preprocess+parse haskell code
 */
export const hse_cpp = mkPackage(
  nixRaw`pkgs.haskellPackages.hse-cpp`,
  "Preprocess+parse haskell code",
);

/**
 * Parsec parsers for the Internet Message format (e-mail)
 */
export const hsemail = mkPackage(
  nixRaw`pkgs.haskellPackages.hsemail`,
  "Parsec parsers for the Internet Message format (e-mail)",
);

/**
 * Internet Message Parsers
 */
export const hsemail_ns = mkPackage(
  nixRaw`pkgs.haskellPackages.hsemail-ns`,
  "Internet Message Parsers",
);

/**
 * sendxmpp clone, sending XMPP messages via CLI
 */
export const hsendxmpp = mkPackage(
  nixRaw`pkgs.haskellPackages.hsendxmpp`,
  "sendxmpp clone, sending XMPP messages via CLI",
);

/**
 * Simple http server in haskell
 */
export const hserv = mkPackage(
  nixRaw`pkgs.haskellPackages.hserv`,
  "Simple http server in haskell",
);

/**
 * Primitive list with elements of unique types
 */
export const hset = mkPackage(
  nixRaw`pkgs.haskellPackages.hset`,
  "Primitive list with elements of unique types",
);

/**
 * EXIF handling library in pure Haskell
 */
export const hsexif = mkPackage(
  nixRaw`pkgs.haskellPackages.hsexif`,
  "EXIF handling library in pure Haskell",
);

/**
 * A small and ugly library that emulates the output of the puppet facter program
 */
export const hsfacter = mkPackage(
  nixRaw`pkgs.haskellPackages.hsfacter`,
  "A small and ugly library that emulates the output of the puppet facter program",
);

/**
 * Console-based gettings-things-done application
 */
export const hsgtd = mkPackage(
  nixRaw`pkgs.haskellPackages.hsgtd`,
  "Console-based gettings-things-done application",
);

/**
 * Haskell SHARC bindings
 */
export const hsharc = mkPackage(
  nixRaw`pkgs.haskellPackages.hsharc`,
  "Haskell SHARC bindings",
);

/**
 * Signal processing and EEG data analysis
 */
export const hsignal = mkPackage(
  nixRaw`pkgs.haskellPackages.hsignal`,
  "Signal processing and EEG data analysis",
);

/**
 * RPN calculator
 */
export const hsilop = mkPackage(
  nixRaw`pkgs.haskellPackages.hsilop`,
  "RPN calculator",
);

/**
 * ini configuration files
 */
export const hsini = mkPackage(
  nixRaw`pkgs.haskellPackages.hsini`,
  "ini configuration files",
);

/**
 * Inspect Haskell source files
 */
export const hsinspect = mkPackage(
  nixRaw`pkgs.haskellPackages.hsinspect`,
  "Inspect Haskell source files",
);

/**
 * LSP interface over the hsinspect binary
 */
export const hsinspect_lsp = mkPackage(
  nixRaw`pkgs.haskellPackages.hsinspect-lsp`,
  "LSP interface over the hsinspect binary",
);

/**
 * Install Haskell software
 */
export const hsinstall = mkPackage(
  nixRaw`pkgs.haskellPackages.hsinstall`,
  "Install Haskell software",
);

/**
 * Versatile logging framework
 */
export const hslogger = mkPackage(
  nixRaw`pkgs.haskellPackages.hslogger`,
  "Versatile logging framework",
);

/**
 * DEPRECATED hslogger handlers for log4j's XMLLayout
 */
export const hslogger4j = mkPackage(
  nixRaw`pkgs.haskellPackages.hslogger4j`,
  "DEPRECATED hslogger handlers for log4j's XMLLayout",
);

/**
 * A library to work with, or as, a logstash server
 */
export const hslogstash = mkPackage(
  nixRaw`pkgs.haskellPackages.hslogstash`,
  "A library to work with, or as, a logstash server",
);

/**
 * Bindings to Lua, an embeddable scripting language
 */
export const hslua = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua`,
  "Bindings to Lua, an embeddable scripting language",
);

/**
 * Allow aeson data types to be used with Lua
 */
export const hslua_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-aeson`,
  "Allow aeson data types to be used with Lua",
);

/**
 * Type classes for HsLua
 */
export const hslua_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-classes`,
  "Type classes for HsLua",
);

/**
 * Command-line interface for Lua
 */
export const hslua_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-cli`,
  "Command-line interface for Lua",
);

/**
 * Bindings to Lua, an embeddable scripting language
 */
export const hslua_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-core`,
  "Bindings to Lua, an embeddable scripting language",
);

/**
 * Examples of how to combine Haskell and Lua
 */
export const hslua_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-examples`,
  "Examples of how to combine Haskell and Lua",
);

/**
 * Opinionated, but extensible Lua list type
 */
export const hslua_list = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-list`,
  "Opinionated, but extensible Lua list type",
);

/**
 * Marshalling of values between Haskell and Lua
 */
export const hslua_marshalling = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-marshalling`,
  "Marshalling of values between Haskell and Lua",
);

/**
 * Lua module wrapping Text.DocLayout.
 */
export const hslua_module_doclayout = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-doclayout`,
  "Lua module wrapping Text.DocLayout.",
);

/**
 * Lua module to work with file paths
 */
export const hslua_module_path = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-path`,
  "Lua module to work with file paths",
);

/**
 * Lua module wrapper around Haskell's System module
 */
export const hslua_module_system = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-system`,
  "Lua module wrapper around Haskell's System module",
);

/**
 * Lua module for text
 */
export const hslua_module_text = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-text`,
  "Lua module for text",
);

/**
 * Lua module to work with version specifiers
 */
export const hslua_module_version = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-version`,
  "Lua module to work with version specifiers",
);

/**
 * Lua module to work with file zips
 */
export const hslua_module_zip = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-module-zip`,
  "Lua module to work with file zips",
);

/**
 * Object orientation tools for HsLua
 */
export const hslua_objectorientation = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-objectorientation`,
  "Object orientation tools for HsLua",
);

/**
 * Utilities to build Lua modules
 */
export const hslua_packaging = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-packaging`,
  "Utilities to build Lua modules",
);

/**
 * Isocline-based Lua REPL
 */
export const hslua_repl = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-repl`,
  "Isocline-based Lua REPL",
);

/**
 * Type specifiers for Lua
 */
export const hslua_typing = mkPackage(
  nixRaw`pkgs.haskellPackages.hslua-typing`,
  "Type specifiers for Lua",
);

/**
 * A collection of miscellaneous modules
 */
export const hsmisc = mkPackage(
  nixRaw`pkgs.haskellPackages.hsmisc`,
  "A collection of miscellaneous modules",
);

/**
 * Haskell bindings for libsndfile
 */
export const hsndfile = mkPackage(
  nixRaw`pkgs.haskellPackages.hsndfile`,
  "Haskell bindings for libsndfile",
);

/**
 * Haskell bindings for libsndfile (Data.StorableVector interface)
 */
export const hsndfile_storablevector = mkPackage(
  nixRaw`pkgs.haskellPackages.hsndfile-storablevector`,
  "Haskell bindings for libsndfile (Data.StorableVector interface)",
);

/**
 * Haskell bindings for libsndfile (Data.Vector interface)
 */
export const hsndfile_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.hsndfile-vector`,
  "Haskell bindings for libsndfile (Data.Vector interface)",
);

/**
 * A coherent 3d noise library
 */
export const hsnoise = mkPackage(
  nixRaw`pkgs.haskellPackages.hsnoise`,
  "A coherent 3d noise library",
);

/**
 * Haskell Server Pages is a library for writing dynamic server-side web pages
 */
export const hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.hsp`,
  "Haskell Server Pages is a library for writing dynamic server-side web pages",
);

/**
 * Sparklines for Haskell
 */
export const hsparklines = mkPackage(
  nixRaw`pkgs.haskellPackages.hsparklines`,
  "Sparklines for Haskell",
);

/**
 * A SPARQL query generator and DSL, and a client to query a SPARQL server
 */
export const hsparql = mkPackage(
  nixRaw`pkgs.haskellPackages.hsparql`,
  "A SPARQL query generator and DSL, and a client to query a SPARQL server",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec`,
  "A Testing Framework for Haskell",
);

/**
 * Spec for testing properties
 */
export const hspecVariant = mkPackage(
  nixRaw`pkgs.haskellPackages.hspecVariant`,
  "Spec for testing properties",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec_2_11_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec_2_11_5`,
  "A Testing Framework for Haskell",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec_2_7_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec_2_7_10`,
  "A Testing Framework for Haskell",
);

/**
 * Utility functions for testing your attoparsec parsers with hspec
 */
export const hspec_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-attoparsec`,
  "Utility functions for testing your attoparsec parsers with hspec",
);

/**
 * The bracket definitions for Hspec
 */
export const hspec_bracket = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-bracket`,
  "The bracket definitions for Hspec",
);

/**
 * Allows to use checkers properties from hspec
 */
export const hspec_checkers = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-checkers`,
  "Allows to use checkers properties from hspec",
);

/**
 * Contributed functionality for Hspec
 */
export const hspec_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-contrib`,
  "Contributed functionality for Hspec",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec_core = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-core`,
  "A Testing Framework for Haskell",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec_core_2_11_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-core_2_11_5`,
  "A Testing Framework for Haskell",
);

/**
 * A Testing Framework for Haskell
 */
export const hspec_core_2_7_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-core_2_7_10`,
  "A Testing Framework for Haskell",
);

/**
 * Helper functions to simplify adding integration tests
 */
export const hspec_dirstream = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-dirstream`,
  "Helper functions to simplify adding integration tests",
);

/**
 * Automatically discover and run Hspec tests
 */
export const hspec_discover = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-discover`,
  "Automatically discover and run Hspec tests",
);

/**
 * Automatically discover and run Hspec tests
 */
export const hspec_discover_2_11_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-discover_2_11_5`,
  "Automatically discover and run Hspec tests",
);

/**
 * Automatically discover and run Hspec tests
 */
export const hspec_discover_2_7_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-discover_2_7_10`,
  "Automatically discover and run Hspec tests",
);

/**
 * Catchy combinators for HUnit
 */
export const hspec_expectations = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations`,
  "Catchy combinators for HUnit",
);

/**
 * Catchy combinators for HUnit
 */
export const hspec_expectations_0_8_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations_0_8_4`,
  "Catchy combinators for HUnit",
);

/**
 * Hspec expectations for JSON Values
 */
export const hspec_expectations_json = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations-json`,
  "Hspec expectations for JSON Values",
);

/**
 * Hspec expectations for the lens stuff
 */
export const hspec_expectations_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations-lens`,
  "Hspec expectations for the lens stuff",
);

/**
 * A version of hspec-expectations generalized to MonadIO
 */
export const hspec_expectations_lifted = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations-lifted`,
  "A version of hspec-expectations generalized to MonadIO",
);

/**
 * hspec-expectations with pretty printing on failure
 */
export const hspec_expectations_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations-pretty`,
  "hspec-expectations with pretty printing on failure",
);

/**
 * Catchy combinators for HUnit
 */
export const hspec_expectations_pretty_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-expectations-pretty-diff`,
  "Catchy combinators for HUnit",
);

/**
 * Golden tests for hspec
 */
export const hspec_golden = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-golden`,
  "Golden tests for hspec",
);

/**
 * Golden tests for hspec
 */
export const hspec_golden_0_1_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-golden_0_1_0_3`,
  "Golden tests for hspec",
);

/**
 * Use tests to monitor changes in Aeson serialization
 */
export const hspec_golden_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-golden-aeson`,
  "Use tests to monitor changes in Aeson serialization",
);

/**
 * Initial project template from stack
 */
export const hspec_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-hashable`,
  "Initial project template from stack",
);

/**
 * Integrate Hedgehog and Hspec!
 */
export const hspec_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-hedgehog`,
  "Integrate Hedgehog and Hspec!",
);

/**
 * Integrate Hedgehog and Hspec!
 */
export const hspec_hedgehog_0_1_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-hedgehog_0_1_0_0`,
  "Integrate Hedgehog and Hspec!",
);

/**
 * Document and test laws for standard type classes
 */
export const hspec_laws = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-laws`,
  "Document and test laws for standard type classes",
);

/**
 * LeanCheck support for the Hspec test framework
 */
export const hspec_leancheck = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-leancheck`,
  "LeanCheck support for the Hspec test framework",
);

/**
 * Utility functions for testing Megaparsec parsers with Hspec
 */
export const hspec_megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-megaparsec`,
  "Utility functions for testing Megaparsec parsers with Hspec",
);

/**
 * A version of Hspec which is used to test Hspec itself
 */
export const hspec_meta = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-meta`,
  "A version of Hspec which is used to test Hspec itself",
);

/**
 * A version of Hspec which is used to test Hspec itself
 */
export const hspec_meta_2_11_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-meta_2_11_5`,
  "A version of Hspec which is used to test Hspec itself",
);

/**
 * A version of Hspec which is used to test Hspec itself
 */
export const hspec_meta_2_7_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-meta_2_7_8`,
  "A version of Hspec which is used to test Hspec itself",
);

/**
 * A testing framework for Haskell using Hspec
 */
export const hspec_multicheck = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-multicheck`,
  "A testing framework for Haskell using Hspec",
);

/**
 * Hspec expectations for testing Parsec parsers
 */
export const hspec_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-parsec`,
  "Hspec expectations for testing Parsec parsers",
);

/**
 * Helpers for creating database tests with hspec and pg-transact
 */
export const hspec_pg_transact = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-pg-transact`,
  "Helpers for creating database tests with hspec and pg-transact",
);

/**
 * Test Framework for checking server's status
 */
export const hspec_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-server`,
  "Test Framework for checking server's status",
);

/**
 * Add an hspec test-suite in one command
 */
export const hspec_setup = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-setup`,
  "Add an hspec test-suite in one command",
);

/**
 * Convenience wrapper and utilities for hspec
 */
export const hspec_shouldbe = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-shouldbe`,
  "Convenience wrapper and utilities for hspec",
);

/**
 * SmallCheck support for the Hspec testing framework
 */
export const hspec_smallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-smallcheck`,
  "SmallCheck support for the Hspec testing framework",
);

/**
 * A library for testing with Hspec and the Snap Web Framework
 */
export const hspec_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-snap`,
  "A library for testing with Hspec and the Snap Web Framework",
);

/**
 * Simple project template from stack
 */
export const hspec_stack_rerun = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-stack-rerun`,
  "Simple project template from stack",
);

/**
 * Run test-framework tests with Hspec
 */
export const hspec_test_framework = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-test-framework`,
  "Run test-framework tests with Hspec",
);

/**
 * Run test-framework tests with Hspec
 */
export const hspec_test_framework_th = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-test-framework-th`,
  "Run test-framework tests with Hspec",
);

/**
 * Hspec convenience functions for use with test-sandbox
 */
export const hspec_test_sandbox = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-test-sandbox`,
  "Hspec convenience functions for use with test-sandbox",
);

/**
 * Simplify use of tmp-proc from hspec tests
 */
export const hspec_tmp_proc = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-tmp-proc`,
  "Simplify use of tmp-proc from hspec tests",
);

/**
 * Simplify use of tmp-proc from hspec tests
 */
export const hspec_tmp_proc_0_5_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-tmp-proc_0_5_2_0`,
  "Simplify use of tmp-proc from hspec tests",
);

/**
 * Experimental Hspec support for testing WAI applications
 */
export const hspec_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-wai`,
  "Experimental Hspec support for testing WAI applications",
);

/**
 * Testing JSON APIs with hspec-wai
 */
export const hspec_wai_json = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-wai-json`,
  "Testing JSON APIs with hspec-wai",
);

/**
 * Write end2end web application tests using webdriver and hspec
 */
export const hspec_webdriver = mkPackage(
  nixRaw`pkgs.haskellPackages.hspec-webdriver`,
  "Write end2end web application tests using webdriver and hspec",
);

/**
 * Session handler for HSP
 */
export const hspr_sh = mkPackage(
  nixRaw`pkgs.haskellPackages.hspr-sh`,
  "Session handler for HSP",
);

/**
 * Multivariate polynomials
 */
export const hspray = mkPackage(
  nixRaw`pkgs.haskellPackages.hspray`,
  "Multivariate polynomials",
);

/**
 * The Haskell Stream Processor command line utility
 */
export const hsprocess = mkPackage(
  nixRaw`pkgs.haskellPackages.hsprocess`,
  "The Haskell Stream Processor command line utility",
);

/**
 * MySQL driver for HSQL
 */
export const hsql_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.hsql-mysql`,
  "MySQL driver for HSQL",
);

/**
 * A Haskell Interface to ODBC
 */
export const hsql_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.hsql-odbc`,
  "A Haskell Interface to ODBC",
);

/**
 * A Haskell Interface to PostgreSQL via the PQ library
 */
export const hsql_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.hsql-postgresql`,
  "A Haskell Interface to PostgreSQL via the PQ library",
);

/**
 * SQLite3 driver for HSQL
 */
export const hsql_sqlite3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hsql-sqlite3`,
  "SQLite3 driver for HSQL",
);

/**
 * Haskell binding for Qt Quick
 */
export const hsqml = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml`,
  "Haskell binding for Qt Quick",
);

/**
 * HsQML (Qt5) data model
 */
export const hsqml_datamodel = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-datamodel`,
  "HsQML (Qt5) data model",
);

/**
 * HsQML DataModel instances for Vinyl Rec
 */
export const hsqml_datamodel_vinyl = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-datamodel-vinyl`,
  "HsQML DataModel instances for Vinyl Rec",
);

/**
 * HsQML-based clone of Pipe Mania
 */
export const hsqml_demo_manic = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-demo-manic`,
  "HsQML-based clone of Pipe Mania",
);

/**
 * HsQML-based implementation of Nine Men's Morris
 */
export const hsqml_demo_morris = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-demo-morris`,
  "HsQML-based implementation of Nine Men's Morris",
);

/**
 * Sticky notes example program implemented in HsQML
 */
export const hsqml_demo_notes = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-demo-notes`,
  "Sticky notes example program implemented in HsQML",
);

/**
 * HsQML sample programs
 */
export const hsqml_demo_samples = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-demo-samples`,
  "HsQML sample programs",
);

/**
 * HsQML-based implementation of Nine Men's Morris
 */
export const hsqml_morris = mkPackage(
  nixRaw`pkgs.haskellPackages.hsqml-morris`,
  "HsQML-based implementation of Nine Men's Morris",
);

/**
 * Access to the Readability API
 */
export const hsreadability = mkPackage(
  nixRaw`pkgs.haskellPackages.hsreadability`,
  "Access to the Readability API",
);

/**
 * SSH protocol implementation
 */
export const hssh = mkPackage(
  nixRaw`pkgs.haskellPackages.hssh`,
  "SSH protocol implementation",
);

/**
 * get haskell source code info
 */
export const hssourceinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.hssourceinfo`,
  "get haskell source code info",
);

/**
 * hssqlppp extras which need template-haskell
 */
export const hssqlppp_th = mkPackage(
  nixRaw`pkgs.haskellPackages.hssqlppp-th`,
  "hssqlppp extras which need template-haskell",
);

/**
 * Haskell version of tar CLI utility
 */
export const hstar = mkPackage(
  nixRaw`pkgs.haskellPackages.hstar`,
  "Haskell version of tar CLI utility",
);

/**
 * Statistics
 */
export const hstatistics = mkPackage(
  nixRaw`pkgs.haskellPackages.hstatistics`,
  "Statistics",
);

/**
 * Distributed instant messaging over Tor
 */
export const hstorchat = mkPackage(
  nixRaw`pkgs.haskellPackages.hstorchat`,
  "Distributed instant messaging over Tor",
);

/**
 * A Tox protocol implementation in Haskell
 */
export const hstox = mkPackage(
  nixRaw`pkgs.haskellPackages.hstox`,
  "A Tox protocol implementation in Haskell",
);

/**
 * Tradeking API bindings for Haskell
 */
export const hstradeking = mkPackage(
  nixRaw`pkgs.haskellPackages.hstradeking`,
  "Tradeking API bindings for Haskell",
);

/**
 * A two player abstract strategy game
 */
export const hstzaar = mkPackage(
  nixRaw`pkgs.haskellPackages.hstzaar`,
  "A two player abstract strategy game",
);

/**
 * One-time, faithful conversion of Subversion repositories to Git
 */
export const hsubconvert = mkPackage(
  nixRaw`pkgs.haskellPackages.hsubconvert`,
  "One-time, faithful conversion of Subversion repositories to Git",
);

/**
 * Synthesizable Verilog DSL supporting for multiple clock and reset
 */
export const hsverilog = mkPackage(
  nixRaw`pkgs.haskellPackages.hsverilog`,
  "Synthesizable Verilog DSL supporting for multiple clock and reset",
);

/**
 * embedding prolog in haskell
 */
export const hswip = mkPackage(
  nixRaw`pkgs.haskellPackages.hswip`,
  "embedding prolog in haskell",
);

/**
 * HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code
 */
export const hsx2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.hsx2hs`,
  "HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code",
);

/**
 * hsp+jmacro support
 */
export const hsx_jmacro = mkPackage(
  nixRaw`pkgs.haskellPackages.hsx-jmacro`,
  "hsp+jmacro support",
);

/**
 * XHTML utilities to use together with HSX
 */
export const hsx_xhtml = mkPackage(
  nixRaw`pkgs.haskellPackages.hsx-xhtml`,
  "XHTML utilities to use together with HSX",
);

/**
 * FFI interface to syslog(3) from POSIX.1-2001
 */
export const hsyslog = mkPackage(
  nixRaw`pkgs.haskellPackages.hsyslog`,
  "FFI interface to syslog(3) from POSIX.1-2001",
);

/**
 * syslog over TCP
 */
export const hsyslog_tcp = mkPackage(
  nixRaw`pkgs.haskellPackages.hsyslog-tcp`,
  "syslog over TCP",
);

/**
 * Bindings to TagLib, audio meta-data library
 */
export const htaglib = mkPackage(
  nixRaw`pkgs.haskellPackages.htaglib`,
  "Bindings to TagLib, audio meta-data library",
);

/**
 * A Haskell98 parsing tags program similar to ctags
 */
export const htags = mkPackage(
  nixRaw`pkgs.haskellPackages.htags`,
  "A Haskell98 parsing tags program similar to ctags",
);

/**
 * Talk across TLS
 */
export const htalkat = mkPackage(
  nixRaw`pkgs.haskellPackages.htalkat`,
  "Talk across TLS",
);

/**
 * Tautology Proving Logic in Haskell
 */
export const htaut = mkPackage(
  nixRaw`pkgs.haskellPackages.htaut`,
  "Tautology Proving Logic in Haskell",
);

/**
 * Timing utility for the command line
 */
export const htime = mkPackage(
  nixRaw`pkgs.haskellPackages.htime`,
  "Timing utility for the command line",
);

/**
 * Equiprobable draw from publicly verifiable random data
 */
export const htirage = mkPackage(
  nixRaw`pkgs.haskellPackages.htirage`,
  "Equiprobable draw from publicly verifiable random data",
);

/**
 * HTML combinator library
 */
export const html = mkPackage(
  nixRaw`pkgs.haskellPackages.html`,
  "HTML combinator library",
);

/**
 * HTML to Hamlet converter
 */
export const html2hamlet = mkPackage(
  nixRaw`pkgs.haskellPackages.html2hamlet`,
  "HTML to Hamlet converter",
);

/**
 * A library for looking up and validating HTML5 entities
 */
export const html5_entity = mkPackage(
  nixRaw`pkgs.haskellPackages.html5-entity`,
  "A library for looking up and validating HTML5 entities",
);

/**
 * Determine character encoding of HTML documents/fragments
 */
export const html_charset = mkPackage(
  nixRaw`pkgs.haskellPackages.html-charset`,
  "Determine character encoding of HTML documents/fragments",
);

/**
 * Parse HTML documents using xml-conduit datatypes
 */
export const html_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.html-conduit`,
  "Parse HTML documents using xml-conduit datatypes",
);

/**
 * Validating an email address against HTML standard
 */
export const html_email_validate = mkPackage(
  nixRaw`pkgs.haskellPackages.html-email-validate`,
  "Validating an email address against HTML standard",
);

/**
 * A codec library for HTML-escaped text and HTML-entities
 */
export const html_entities = mkPackage(
  nixRaw`pkgs.haskellPackages.html-entities`,
  "A codec library for HTML-escaped text and HTML-entities",
);

/**
 * HTML entity decoding and encoding for Text
 */
export const html_entity = mkPackage(
  nixRaw`pkgs.haskellPackages.html-entity`,
  "HTML entity decoding and encoding for Text",
);

/**
 * Map from HTML5 entity names to the corresponding Unicode text
 */
export const html_entity_map = mkPackage(
  nixRaw`pkgs.haskellPackages.html-entity-map`,
  "Map from HTML5 entity names to the corresponding Unicode text",
);

/**
 * HTML rewrite engine, using KURE
 */
export const html_kure = mkPackage(
  nixRaw`pkgs.haskellPackages.html-kure`,
  "HTML rewrite engine, using KURE",
);

/**
 * Minimalist haskell html library
 */
export const html_minimalist = mkPackage(
  nixRaw`pkgs.haskellPackages.html-minimalist`,
  "Minimalist haskell html library",
);

/**
 * Utility functions for working with html-parse
 */
export const html_parse_util = mkPackage(
  nixRaw`pkgs.haskellPackages.html-parse-util`,
  "Utility functions for working with html-parse",
);

/**
 * Simple tool to create html presentation for text
 */
export const html_presentation_text = mkPackage(
  nixRaw`pkgs.haskellPackages.html-presentation-text`,
  "Simple tool to create html presentation for text",
);

/**
 * A HTML truncator
 */
export const html_truncate = mkPackage(
  nixRaw`pkgs.haskellPackages.html-truncate`,
  "A HTML truncator",
);

/**
 * A command-line interface for https://validator.w3.org/
 */
export const html_validator_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.html-validator-cli`,
  "A command-line interface for https://validator.w3.org/",
);

/**
 * resolver using htn algorithm
 */
export const htn = mkPackage(
  nixRaw`pkgs.haskellPackages.htn`,
  "resolver using htn algorithm",
);

/**
 * A todo application
 */
export const htodo = mkPackage(
  nixRaw`pkgs.haskellPackages.htodo`,
  "A todo application",
);

/**
 * Parse TOML values produced by htoml-megaparsec package
 */
export const htoml_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.htoml-parse`,
  "Parse TOML values produced by htoml-megaparsec package",
);

/**
 * Hierarchical tracing for debugging of lazy evaluation
 */
export const htrace = mkPackage(
  nixRaw`pkgs.haskellPackages.htrace`,
  "Hierarchical tracing for debugging of lazy evaluation",
);

/**
 * Display/logging facilities used by both htsn and htsn-import
 */
export const htsn_common = mkPackage(
  nixRaw`pkgs.haskellPackages.htsn-common`,
  "Display/logging facilities used by both htsn and htsn-import",
);

/**
 * Import XML files from The Sports Network into an RDBMS
 */
export const htsn_import = mkPackage(
  nixRaw`pkgs.haskellPackages.htsn-import`,
  "Import XML files from The Sports Network into an RDBMS",
);

/**
 * HTTP/2 library
 */
export const http2 = mkPackage(
  nixRaw`pkgs.haskellPackages.http2`,
  "HTTP/2 library",
);

/**
 * HTTP/2 library
 */
export const http2_3_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.http2_3_0_3`,
  "HTTP/2 library",
);

/**
 * HTTP/2 library
 */
export const http2_4_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.http2_4_2_0`,
  "HTTP/2 library",
);

/**
 * A command-line http2 client
 */
export const http2_client_exe = mkPackage(
  nixRaw`pkgs.haskellPackages.http2-client-exe`,
  "A command-line http2 client",
);

/**
 * Implement gRPC-over-HTTP2 clients
 */
export const http2_client_grpc = mkPackage(
  nixRaw`pkgs.haskellPackages.http2-client-grpc`,
  "Implement gRPC-over-HTTP2 clients",
);

/**
 * Encoders based on `proto3-wire` for gRPC over HTTP2
 */
export const http2_grpc_proto3_wire = mkPackage(
  nixRaw`pkgs.haskellPackages.http2-grpc-proto3-wire`,
  "Encoders based on `proto3-wire` for gRPC over HTTP2",
);

/**
 * Encoders based on `proto-lens` for gRPC over HTTP2
 */
export const http2_grpc_proto_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.http2-grpc-proto-lens`,
  "Encoders based on `proto-lens` for gRPC over HTTP2",
);

/**
 * HTTP/3 library
 */
export const http3 = mkPackage(
  nixRaw`pkgs.haskellPackages.http3`,
  "HTTP/3 library",
);

/**
 * Functions for working with HTTP Accept headers
 */
export const http_accept = mkPackage(
  nixRaw`pkgs.haskellPackages.http-accept`,
  "Functions for working with HTTP Accept headers",
);

/**
 * Converting to/from HTTP API data like URL pieces, headers and query parameters
 */
export const http_api_data = mkPackage(
  nixRaw`pkgs.haskellPackages.http-api-data`,
  "Converting to/from HTTP API data like URL pieces, headers and query parameters",
);

/**
 * Converting to/from HTTP API data like URL pieces, headers and query parameters
 */
export const http_api_data_0_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.http-api-data_0_6`,
  "Converting to/from HTTP API data like URL pieces, headers and query parameters",
);

/**
 * Quasiquoter for building URLs with ToHttpApiData types
 */
export const http_api_data_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.http-api-data-qq`,
  "Quasiquoter for building URLs with ToHttpApiData types",
);

/**
 * An HTTP client engine
 */
export const http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client`,
  "An HTTP client engine",
);

/**
 * HTTP authorization (both basic and digest) done right
 */
export const http_client_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-auth`,
  "HTTP authorization (both basic and digest) done right",
);

/**
 * Http client with time-limited brRead
 */
export const http_client_brread_timeout = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-brread-timeout`,
  "Http client with time-limited brRead",
);

/**
 * Frontend support for using http-client with conduit (deprecated)
 */
export const http_client_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-conduit`,
  "Frontend support for using http-client with conduit (deprecated)",
);

/**
 * wrapper for http-client exposing cookies
 */
export const http_client_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-extra`,
  "wrapper for http-client exposing cookies",
);

/**
 * Generate multipart uploads for http-client. (deprecated)
 */
export const http_client_multipart = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-multipart`,
  "Generate multipart uploads for http-client. (deprecated)",
);

/**
 * http-client backend using the OpenSSL library
 */
export const http_client_openssl = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-openssl`,
  "http-client backend using the OpenSSL library",
);

/**
 * HTTP client overrides
 */
export const http_client_overrides = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-overrides`,
  "HTTP client overrides",
);

/**
 * restricting the servers that http-client will use
 */
export const http_client_restricted = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-restricted`,
  "restricting the servers that http-client will use",
);

/**
 * restricting the servers that http-client will use
 */
export const http_client_restricted_0_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-restricted_0_1_0`,
  "restricting the servers that http-client will use",
);

/**
 * http-client TLS backend using Rustls
 */
export const http_client_rustls = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-rustls`,
  "http-client TLS backend using Rustls",
);

/**
 * http-client backend using the connection package and tls library
 */
export const http_client_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-tls`,
  "http-client backend using the connection package and tls library",
);

/**
 * http-client backend using the connection package and tls library
 */
export const http_client_tls_0_3_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-tls_0_3_6_3`,
  "http-client backend using the connection package and tls library",
);

/**
 * Glue code for http-client and websockets
 */
export const http_client_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.http-client-websockets`,
  "Glue code for http-client and websockets",
);

/**
 * Common types for HTTP clients and servers
 */
export const http_common = mkPackage(
  nixRaw`pkgs.haskellPackages.http-common`,
  "Common types for HTTP clients and servers",
);

/**
 * HTTP client package with conduit interface and HTTPS support
 */
export const http_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.http-conduit`,
  "HTTP client package with conduit interface and HTTPS support",
);

/**
 * HTTP client package with conduit interface and HTTPS support
 */
export const http_conduit_2_3_8_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.http-conduit_2_3_8_3`,
  "HTTP client package with conduit interface and HTTPS support",
);

/**
 * HTTP Date parser/formatter
 */
export const http_date = mkPackage(
  nixRaw`pkgs.haskellPackages.http-date`,
  "HTTP Date parser/formatter",
);

/**
 * Verified downloads with retries
 */
export const http_download = mkPackage(
  nixRaw`pkgs.haskellPackages.http-download`,
  "Verified downloads with retries",
);

/**
 * Verified downloads with retries
 */
export const http_download_0_2_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.http-download_0_2_1_0`,
  "Verified downloads with retries",
);

/**
 * HTTP client package with enumerator interface and HTTPS support. (deprecated)
 */
export const http_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.http-enumerator`,
  "HTTP client package with enumerator interface and HTTPS support. (deprecated)",
);

/**
 * Perform HTTP Requests
 */
export const http_exchange = mkPackage(
  nixRaw`pkgs.haskellPackages.http-exchange`,
  "Perform HTTP Requests",
);

/**
 * Instantiations of http-exchange
 */
export const http_exchange_instantiations = mkPackage(
  nixRaw`pkgs.haskellPackages.http-exchange-instantiations`,
  "Instantiations of http-exchange",
);

/**
 * HTTP and WebSocket client based on io-streams
 */
export const http_io_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.http-io-streams`,
  "HTTP and WebSocket client based on io-streams",
);

/**
 * HTTP Link header parser/writer
 */
export const http_link_header = mkPackage(
  nixRaw`pkgs.haskellPackages.http-link-header`,
  "HTTP Link header parser/writer",
);

/**
 * Processing HTTP Content-Type and Accept headers
 */
export const http_media = mkPackage(
  nixRaw`pkgs.haskellPackages.http-media`,
  "Processing HTTP Content-Type and Accept headers",
);

/**
 * HTTP mocking and expectations library for Haskell
 */
export const http_mock = mkPackage(
  nixRaw`pkgs.haskellPackages.http-mock`,
  "HTTP mocking and expectations library for Haskell",
);

/**
 * Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation
 */
export const http_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.http-monad`,
  "Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation",
);

/**
 * Tag http headers as case insensitive
 */
export const http_pony_transformer_case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.http-pony-transformer-case-insensitive`,
  "Tag http headers as case insensitive",
);

/**
 * Transform raw TCP stream to a basic HTTP type
 */
export const http_pony_transformer_http = mkPackage(
  nixRaw`pkgs.haskellPackages.http-pony-transformer-http`,
  "Transform raw TCP stream to a basic HTTP type",
);

/**
 * transform HTTP startlines to tuples
 */
export const http_pony_transformer_startline = mkPackage(
  nixRaw`pkgs.haskellPackages.http-pony-transformer-startline`,
  "transform HTTP startlines to tuples",
);

/**
 * Simple http queries
 */
export const http_query = mkPackage(
  nixRaw`pkgs.haskellPackages.http-query`,
  "Simple http queries",
);

/**
 * Declarative DSL for parsing an HTTP response
 */
export const http_response_decoder = mkPackage(
  nixRaw`pkgs.haskellPackages.http-response-decoder`,
  "Declarative DSL for parsing an HTTP response",
);

/**
 * Reverse proxy HTTP requests, either over raw sockets or with WAI
 */
export const http_reverse_proxy = mkPackage(
  nixRaw`pkgs.haskellPackages.http-reverse-proxy`,
  "Reverse proxy HTTP requests, either over raw sockets or with WAI",
);

/**
 * An HTTP client using io-streams
 */
export const http_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.http-streams`,
  "An HTTP client using io-streams",
);

/**
 * Test framework for HTTP APIs
 */
export const http_test = mkPackage(
  nixRaw`pkgs.haskellPackages.http-test`,
  "Test framework for HTTP APIs",
);

/**
 * Tracking http redirects
 */
export const http_trace = mkPackage(
  nixRaw`pkgs.haskellPackages.http-trace`,
  "Tracking http redirects",
);

/**
 * Generic HTTP types for Haskell (for both client and server code)
 */
export const http_types = mkPackage(
  nixRaw`pkgs.haskellPackages.http-types`,
  "Generic HTTP types for Haskell (for both client and server code)",
);

/**
 * A simple web-server with an interact style API
 */
export const httpd_shed = mkPackage(
  nixRaw`pkgs.haskellPackages.httpd-shed`,
  "A simple web-server with an interact style API",
);

/**
 * High-level access to HTTPS Everywhere rulesets
 */
export const https_everywhere_rules = mkPackage(
  nixRaw`pkgs.haskellPackages.https-everywhere-rules`,
  "High-level access to HTTPS Everywhere rulesets",
);

/**
 * Low-level (i.e. XML) access to HTTPS Everywhere rulesets.
 */
export const https_everywhere_rules_raw = mkPackage(
  nixRaw`pkgs.haskellPackages.https-everywhere-rules-raw`,
  "Low-level (i.e. XML) access to HTTPS Everywhere rulesets.",
);

/**
 * Specification of HTTP request/response generators and parsers
 */
export const httpspec = mkPackage(
  nixRaw`pkgs.haskellPackages.httpspec`,
  "Specification of HTTP request/response generators and parsers",
);

/**
 * For multiplexing GHC installations and providing development sandboxes
 */
export const hub = mkPackage(
  nixRaw`pkgs.haskellPackages.hub`,
  "For multiplexing GHC installations and providing development sandboxes",
);

/**
 * A haskell wrap for Ubigraph
 */
export const hubigraph = mkPackage(
  nixRaw`pkgs.haskellPackages.hubigraph`,
  "A haskell wrap for Ubigraph",
);

/**
 * Support library for Hubris, the Ruby <=> Haskell bridge
 */
export const hubris = mkPackage(
  nixRaw`pkgs.haskellPackages.hubris`,
  "Support library for Hubris, the Ruby <=> Haskell bridge",
);

/**
 * Haskell IOT on Intel Edison and other Linux computers
 */
export const huckleberry = mkPackage(
  nixRaw`pkgs.haskellPackages.huckleberry`,
  "Haskell IOT on Intel Edison and other Linux computers",
);

/**
 * Hugs Front-end to Yhc Core
 */
export const hugs2yc = mkPackage(
  nixRaw`pkgs.haskellPackages.hugs2yc`,
  "Hugs Front-end to Yhc Core",
);

/**
 * IRC server written in Haskell
 */
export const hulk = mkPackage(
  nixRaw`pkgs.haskellPackages.hulk`,
  "IRC server written in Haskell",
);

/**
 * Provide duration helper
 */
export const human_readable_duration = mkPackage(
  nixRaw`pkgs.haskellPackages.human-readable-duration`,
  "Provide duration helper",
);

/**
 * Deja Fu support for the HUnit test framework
 */
export const hunit_dejafu = mkPackage(
  nixRaw`pkgs.haskellPackages.hunit-dejafu`,
  "Deja Fu support for the HUnit test framework",
);

/**
 * A GUI testrunner for HUnit
 */
export const hunit_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.hunit-gui`,
  "A GUI testrunner for HUnit",
);

/**
 * An HUnit Testable instance for Parsec parser unit tests
 */
export const hunit_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.hunit-parsec`,
  "An HUnit Testable instance for Parsec parser unit tests",
);

/**
 * Unpacker tool with DWIM
 */
export const hunp = mkPackage(
  nixRaw`pkgs.haskellPackages.hunp`,
  "Unpacker tool with DWIM",
);

/**
 * Hunspell thread-safe FFI bindings for spell checking
 */
export const hunspell_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.hunspell-hs`,
  "Hunspell thread-safe FFI bindings for spell checking",
);

/**
 * A search and indexing engine
 */
export const hunt_searchengine = mkPackage(
  nixRaw`pkgs.haskellPackages.hunt-searchengine`,
  "A search and indexing engine",
);

/**
 * A search and indexing engine server
 */
export const hunt_server = mkPackage(
  nixRaw`pkgs.haskellPackages.hunt-server`,
  "A search and indexing engine server",
);

/**
 * Extract function names from Windows DLLs
 */
export const hurdle = mkPackage(
  nixRaw`pkgs.haskellPackages.hurdle`,
  "Extract function names from Windows DLLs",
);

/**
 * Haskell URL resolver
 */
export const hurl = mkPackage(
  nixRaw`pkgs.haskellPackages.hurl`,
  "Haskell URL resolver",
);

/**
 * Fetch parsed XML & possibly CSS for a URL based on MIMEtype
 */
export const hurl_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.hurl-xml`,
  "Fetch parsed XML & possibly CSS for a URL based on MIMEtype",
);

/**
 * R5RS Scheme interpreter, compiler, and library
 */
export const husk_scheme = mkPackage(
  nixRaw`pkgs.haskellPackages.husk-scheme`,
  "R5RS Scheme interpreter, compiler, and library",
);

/**
 * Extra libraries for the husk Scheme platform
 */
export const husk_scheme_libs = mkPackage(
  nixRaw`pkgs.haskellPackages.husk-scheme-libs`,
  "Extra libraries for the husk Scheme platform",
);

/**
 * Fuzzy logic library with support for T1, IT2, GT2
 */
export const huzzy = mkPackage(
  nixRaw`pkgs.haskellPackages.huzzy`,
  "Fuzzy logic library with support for T1, IT2, GT2",
);

/**
 * Simple strict heterogeneous lists
 */
export const hvect = mkPackage(
  nixRaw`pkgs.haskellPackages.hvect`,
  "Simple strict heterogeneous lists",
);

/**
 * Create Vega-Lite visualizations (version 4) in Haskell
 */
export const hvega = mkPackage(
  nixRaw`pkgs.haskellPackages.hvega`,
  "Create Vega-Lite visualizations (version 4) in Haskell",
);

/**
 * Theme for hvega
 */
export const hvega_theme = mkPackage(
  nixRaw`pkgs.haskellPackages.hvega-theme`,
  "Theme for hvega",
);

/**
 * Convenience functions for Aeson
 */
export const hw_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-aeson`,
  "Convenience functions for Aeson",
);

/**
 * Demo library
 */
export const hw_all = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-all`,
  "Demo library",
);

/**
 * Balanced parentheses
 */
export const hw_balancedparens = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-balancedparens`,
  "Balanced parentheses",
);

/**
 * Bit manipulation
 */
export const hw_bits = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-bits`,
  "Bit manipulation",
);

/**
 * Conduits for tokenizing streams
 */
export const hw_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-conduit`,
  "Conduits for tokenizing streams",
);

/**
 * Additional merges and joins for Conduit
 */
export const hw_conduit_merges = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-conduit-merges`,
  "Additional merges and joins for Conduit",
);

/**
 * Diagnostics library
 */
export const hw_diagnostics = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-diagnostics`,
  "Diagnostics library",
);

/**
 * Elias-Fano
 */
export const hw_eliasfano = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-eliasfano`,
  "Elias-Fano",
);

/**
 * Excess
 */
export const hw_excess = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-excess`,
  "Excess",
);

/**
 * Generic finger-tree structure, with example instances
 */
export const hw_fingertree = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-fingertree`,
  "Generic finger-tree structure, with example instances",
);

/**
 * Generic strict finger-tree structure
 */
export const hw_fingertree_strict = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-fingertree-strict`,
  "Generic strict finger-tree structure",
);

/**
 * Extra hedgehog functionality
 */
export const hw_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-hedgehog`,
  "Extra hedgehog functionality",
);

/**
 * Interoperability between hspec and hedgehog
 */
export const hw_hspec_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-hspec-hedgehog`,
  "Interoperability between hspec and hedgehog",
);

/**
 * Additional facilities for Integers
 */
export const hw_int = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-int`,
  "Additional facilities for Integers",
);

/**
 * Library for manipulating IP addresses and CIDR blocks
 */
export const hw_ip = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-ip`,
  "Library for manipulating IP addresses and CIDR blocks",
);

/**
 * Memory efficient JSON parser
 */
export const hw_json = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-json`,
  "Memory efficient JSON parser",
);

/**
 * Memory efficient JSON parser
 */
export const hw_json_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-json-demo`,
  "Memory efficient JSON parser",
);

/**
 * Lens for hw-json
 */
export const hw_json_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-json-lens`,
  "Lens for hw-json",
);

/**
 * Memory efficient JSON parser
 */
export const hw_json_simple_cursor = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-json-simple-cursor`,
  "Memory efficient JSON parser",
);

/**
 * Memory efficient JSON parser
 */
export const hw_json_standard_cursor = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-json-standard-cursor`,
  "Memory efficient JSON parser",
);

/**
 * Avro support for Kafka infrastructure
 */
export const hw_kafka_avro = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-kafka-avro`,
  "Avro support for Kafka infrastructure",
);

/**
 * Kafka bindings for Haskell
 */
export const hw_kafka_client = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-kafka-client`,
  "Kafka bindings for Haskell",
);

/**
 * Kafka bindings for Haskell
 */
export const hw_kafka_client_5_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-kafka-client_5_3_0`,
  "Kafka bindings for Haskell",
);

/**
 * Conduit bindings for hw-kafka-client
 */
export const hw_kafka_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-kafka-conduit`,
  "Conduit bindings for hw-kafka-client",
);

/**
 * Combinators for lazy IO
 */
export const hw_lazy = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-lazy`,
  "Combinators for lazy IO",
);

/**
 * Monadic query DSL
 */
export const hw_mquery = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-mquery`,
  "Monadic query DSL",
);

/**
 * Packed Vector
 */
export const hw_packed_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-packed-vector`,
  "Packed Vector",
);

/**
 * Simple parser support
 */
export const hw_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-parser`,
  "Simple parser support",
);

/**
 * Primitive functions and data types
 */
export const hw_prim = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-prim`,
  "Primitive functions and data types",
);

/**
 * Rank-select
 */
export const hw_rankselect = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-rankselect`,
  "Rank-select",
);

/**
 * Rank-select base
 */
export const hw_rankselect_base = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-rankselect-base`,
  "Rank-select base",
);

/**
 * SIMD library
 */
export const hw_simd = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-simd`,
  "SIMD library",
);

/**
 * String parser
 */
export const hw_string_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-string-parse`,
  "String parser",
);

/**
 * Succint datastructures
 */
export const hw_succinct = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-succinct`,
  "Succint datastructures",
);

/**
 * Supports IO on URIs
 */
export const hw_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-uri`,
  "Supports IO on URIs",
);

/**
 * Vector type with convenient typeclass instances
 */
export const hw_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.hw-vector`,
  "Vector type with convenient typeclass instances",
);

/**
 * Commandline text processing with Haskell functions
 */
export const hwk = mkPackage(
  nixRaw`pkgs.haskellPackages.hwk`,
  "Commandline text processing with Haskell functions",
);

/**
 * Library for sending email with Amazon's SES and hworker
 */
export const hworker_ses = mkPackage(
  nixRaw`pkgs.haskellPackages.hworker-ses`,
  "Library for sending email with Amazon's SES and hworker",
);

/**
 * magic-wormhole client
 */
export const hwormhole = mkPackage(
  nixRaw`pkgs.haskellPackages.hwormhole`,
  "magic-wormhole client",
);

/**
 * Simple Haskell Web Server
 */
export const hws = mkPackage(
  nixRaw`pkgs.haskellPackages.hws`,
  "Simple Haskell Web Server",
);

/**
 * A hashed byte-vector based on algebraic hashes and finger trees
 */
export const hwsl2_bytevector = mkPackage(
  nixRaw`pkgs.haskellPackages.hwsl2-bytevector`,
  "A hashed byte-vector based on algebraic hashes and finger trees",
);

/**
 * Semigroup and Reducer instances for Data.Hash.SL2
 */
export const hwsl2_reducers = mkPackage(
  nixRaw`pkgs.haskellPackages.hwsl2-reducers`,
  "Semigroup and Reducer instances for Data.Hash.SL2",
);

/**
 * A pen notetaking program written in haskell
 */
export const hxournal = mkPackage(
  nixRaw`pkgs.haskellPackages.hxournal`,
  "A pen notetaking program written in haskell",
);

/**
 * A collection of tools for processing XML with Haskell
 */
export const hxt = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt`,
  "A collection of tools for processing XML with Haskell",
);

/**
 * Serialisation and deserialisation of HXT XmlTrees
 */
export const hxt_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-binary`,
  "Serialisation and deserialisation of HXT XmlTrees",
);

/**
 * Cache for HXT XML Documents and other binary data
 */
export const hxt_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-cache`,
  "Cache for HXT XML Documents and other binary data",
);

/**
 * Character properties and classes for XML and Unicode
 */
export const hxt_charproperties = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-charproperties`,
  "Character properties and classes for XML and Unicode",
);

/**
 * CSS selectors for HXT
 */
export const hxt_css = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-css`,
  "CSS selectors for HXT",
);

/**
 * LibCurl interface for HXT
 */
export const hxt_curl = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-curl`,
  "LibCurl interface for HXT",
);

/**
 * Expat parser for HXT
 */
export const hxt_expat = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-expat`,
  "Expat parser for HXT",
);

/**
 * Extra functions for HXT
 */
export const hxt_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-extras`,
  "Extra functions for HXT",
);

/**
 * A collection of tools for processing XML with Haskell (Filter variant)
 */
export const hxt_filter = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-filter`,
  "A collection of tools for processing XML with Haskell (Filter variant)",
);

/**
 * Interface to native Haskell HTTP package HTTP
 */
export const hxt_http = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-http`,
  "Interface to native Haskell HTTP package HTTP",
);

/**
 * A regular expression library for W3C XML Schema regular expressions
 */
export const hxt_regex_xmlschema = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-regex-xmlschema`,
  "A regular expression library for W3C XML Schema regular expressions",
);

/**
 * The HXT RelaxNG validator
 */
export const hxt_relaxng = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-relaxng`,
  "The HXT RelaxNG validator",
);

/**
 * TagSoup parser for HXT
 */
export const hxt_tagsoup = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-tagsoup`,
  "TagSoup parser for HXT",
);

/**
 * Unicode en-/decoding functions for utf8, iso-latin-* and other encodings
 */
export const hxt_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-unicode`,
  "Unicode en-/decoding functions for utf8, iso-latin-* and other encodings",
);

/**
 * The XPath modules for HXT
 */
export const hxt_xpath = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-xpath`,
  "The XPath modules for HXT",
);

/**
 * The XSLT modules for HXT
 */
export const hxt_xslt = mkPackage(
  nixRaw`pkgs.haskellPackages.hxt-xslt`,
  "The XSLT modules for HXT",
);

/**
 * Helper functions for HXT
 */
export const hxthelper = mkPackage(
  nixRaw`pkgs.haskellPackages.hxthelper`,
  "Helper functions for HXT",
);

/**
 * Minimal webframework using fastcgi, libxml2 and libxslt
 */
export const hxweb = mkPackage(
  nixRaw`pkgs.haskellPackages.hxweb`,
  "Minimal webframework using fastcgi, libxml2 and libxslt",
);

/**
 * A Yahtzee game implementation in Haskell
 */
export const hyahtzee = mkPackage(
  nixRaw`pkgs.haskellPackages.hyahtzee`,
  "A Yahtzee game implementation in Haskell",
);

/**
 * A implementation of a type-checker for Lambda-H
 */
export const hybrid = mkPackage(
  nixRaw`pkgs.haskellPackages.hybrid`,
  "A implementation of a type-checker for Lambda-H",
);

/**
 * Hybrid vectors e.g. Mixed Boxed/Unboxed vectors
 */
export const hybrid_vectors = mkPackage(
  nixRaw`pkgs.haskellPackages.hybrid-vectors`,
  "Hybrid vectors e.g. Mixed Boxed/Unboxed vectors",
);

/**
 * NCurses interface to view multiple ByteString streams in parallel
 */
export const hydra_print = mkPackage(
  nixRaw`pkgs.haskellPackages.hydra-print`,
  "NCurses interface to view multiple ByteString streams in parallel",
);

/**
 * Hydrogen Data
 */
export const hydrogen_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-cli`,
  "Hydrogen Data",
);

/**
 * Hydrogen Command Line Arguments Parser
 */
export const hydrogen_cli_args = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-cli-args`,
  "Hydrogen Command Line Arguments Parser",
);

/**
 * Hydrogen Data
 */
export const hydrogen_data = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-data`,
  "Hydrogen Data",
);

/**
 * Hydrogen Parsing Utilities
 */
export const hydrogen_parsing = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-parsing`,
  "Hydrogen Parsing Utilities",
);

/**
 * Hydrogen Prelude
 */
export const hydrogen_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-prelude`,
  "Hydrogen Prelude",
);

/**
 * Hydrogen Prelude /w Parsec
 */
export const hydrogen_prelude_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-prelude-parsec`,
  "Hydrogen Prelude /w Parsec",
);

/**
 * Hydrogen Syntax
 */
export const hydrogen_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-syntax`,
  "Hydrogen Syntax",
);

/**
 * Hydrogen Tools
 */
export const hydrogen_util = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-util`,
  "Hydrogen Tools",
);

/**
 * Hydrogen Version Type
 */
export const hydrogen_version = mkPackage(
  nixRaw`pkgs.haskellPackages.hydrogen-version`,
  "Hydrogen Version Type",
);

/**
 * Simple web application server
 */
export const hyena = mkPackage(
  nixRaw`pkgs.haskellPackages.hyena`,
  "Simple web application server",
);

/**
 * GLSL embedded in Haskell
 */
export const hylogen = mkPackage(
  nixRaw`pkgs.haskellPackages.hylogen`,
  "GLSL embedded in Haskell",
);

/**
 * Tableau based theorem prover for hybrid logics
 */
export const hylotab = mkPackage(
  nixRaw`pkgs.haskellPackages.hylotab`,
  "Tableau based theorem prover for hybrid logics",
);

/**
 * Very small programs for hybrid logics
 */
export const hyloutils = mkPackage(
  nixRaw`pkgs.haskellPackages.hyloutils`,
  "Very small programs for hybrid logics",
);

/**
 * Display class for the HyperHaskell graphical Haskell interpreter
 */
export const hyper = mkPackage(
  nixRaw`pkgs.haskellPackages.hyper`,
  "Display class for the HyperHaskell graphical Haskell interpreter",
);

/**
 * Hypergeometric function of a matrix argument
 */
export const hypergeomatrix = mkPackage(
  nixRaw`pkgs.haskellPackages.hypergeomatrix`,
  "Hypergeometric function of a matrix argument",
);

/**
 * Hypergeometric functions
 */
export const hypergeometric = mkPackage(
  nixRaw`pkgs.haskellPackages.hypergeometric`,
  "Hypergeometric functions",
);

/**
 * An approximate streaming (constant space) unique object counter
 */
export const hyperloglog = mkPackage(
  nixRaw`pkgs.haskellPackages.hyperloglog`,
  "An approximate streaming (constant space) unique object counter",
);

/**
 * A thin wrapper for the Hyperpublic API
 */
export const hyperpublic = mkPackage(
  nixRaw`pkgs.haskellPackages.hyperpublic`,
  "A thin wrapper for the Hyperpublic API",
);

/**
 * Typed ASTs
 */
export const hypertypes = mkPackage(
  nixRaw`pkgs.haskellPackages.hypertypes`,
  "Typed ASTs",
);

/**
 * Text hyphenation algorithm
 */
export const hyphenate = mkPackage(
  nixRaw`pkgs.haskellPackages.hyphenate`,
  "Text hyphenation algorithm",
);

/**
 * Configurable Knuth-Liang hyphenation
 */
export const hyphenation = mkPackage(
  nixRaw`pkgs.haskellPackages.hyphenation`,
  "Configurable Knuth-Liang hyphenation",
);

/**
 * Bindings for the Z3 Theorem Prover
 */
export const hz3 = mkPackage(
  nixRaw`pkgs.haskellPackages.hz3`,
  "Bindings for the Z3 Theorem Prover",
);

/**
 * This package is Zaif Exchange Api wrapper
 */
export const hzaif = mkPackage(
  nixRaw`pkgs.haskellPackages.hzaif`,
  "This package is Zaif Exchange Api wrapper",
);

/**
 * Zenhan library for Haskell
 */
export const hzenhan = mkPackage(
  nixRaw`pkgs.haskellPackages.hzenhan`,
  "Zenhan library for Haskell",
);

/**
 * Haskell interface to Zenity dialogs
 */
export const hzenity = mkPackage(
  nixRaw`pkgs.haskellPackages.hzenity`,
  "Haskell interface to Zenity dialogs",
);

/**
 * Haskell client library for Apache Zookeeper
 */
export const hzk = mkPackage(
  nixRaw`pkgs.haskellPackages.hzk`,
  "Haskell client library for Apache Zookeeper",
);

/**
 * Haskell interval types. Bounds checking.
 */
export const i = mkPackage(
  nixRaw`pkgs.haskellPackages.i`,
  "Haskell interval types. Bounds checking.",
);

/**
 * iCalendar data types, parser, and printer
 */
export const iCalendar = mkPackage(
  nixRaw`pkgs.haskellPackages.iCalendar`,
  "iCalendar data types, parser, and printer",
);

/**
 * Version of Control.Exception using InterleavableIO.
 */
export const iException = mkPackage(
  nixRaw`pkgs.haskellPackages.iException`,
  "Version of Control.Exception using InterleavableIO.",
);

/**
 * A simple uncomplete ibus api
 */
export const ibus_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.ibus-hs`,
  "A simple uncomplete ibus api",
);

/**
 * Lattice iCE40 Primitive IP
 */
export const ice40_prim = mkPackage(
  nixRaw`pkgs.haskellPackages.ice40-prim`,
  "Lattice iCE40 Primitive IP",
);

/**
 * Package for handling icon fonts in Haskell
 */
export const icon_fonts = mkPackage(
  nixRaw`pkgs.haskellPackages.icon-fonts`,
  "Package for handling icon fonts in Haskell",
);

/**
 * String encoding conversion
 */
export const iconv = mkPackage(
  nixRaw`pkgs.haskellPackages.iconv`,
  "String encoding conversion",
);

/**
 * An IDE backend library
 */
export const ide_backend = mkPackage(
  nixRaw`pkgs.haskellPackages.ide-backend`,
  "An IDE backend library",
);

/**
 * RTS for the IDE backend
 */
export const ide_backend_rts = mkPackage(
  nixRaw`pkgs.haskellPackages.ide-backend-rts`,
  "RTS for the IDE backend",
);

/**
 * An IDE backend server
 */
export const ide_backend_server = mkPackage(
  nixRaw`pkgs.haskellPackages.ide-backend-server`,
  "An IDE backend server",
);

/**
 * Interactive domain reasoner for logic and mathematics
 */
export const ideas_math = mkPackage(
  nixRaw`pkgs.haskellPackages.ideas-math`,
  "Interactive domain reasoner for logic and mathematics",
);

/**
 * Common types for mathematical domain reasoners
 */
export const ideas_math_types = mkPackage(
  nixRaw`pkgs.haskellPackages.ideas-math-types`,
  "Common types for mathematical domain reasoners",
);

/**
 * Interactive domain reasoner for statistics
 */
export const ideas_statistics = mkPackage(
  nixRaw`pkgs.haskellPackages.ideas-statistics`,
  "Interactive domain reasoner for statistics",
);

/**
 * Flexible generation of identicons
 */
export const identicon = mkPackage(
  nixRaw`pkgs.haskellPackages.identicon`,
  "Flexible generation of identicons",
);

/**
 * Squares style for the identicon package
 */
export const identicon_style_squares = mkPackage(
  nixRaw`pkgs.haskellPackages.identicon-style-squares`,
  "Squares style for the identicon package",
);

/**
 * Deriving Applicative for sum types.. Idiomatically.
 */
export const idiomatic = mkPackage(
  nixRaw`pkgs.haskellPackages.idiomatic`,
  "Deriving Applicative for sum types.. Idiomatically.",
);

/**
 * Implements IDNA (RFC 3490)
 */
export const idna = mkPackage(
  nixRaw`pkgs.haskellPackages.idna`,
  "Implements IDNA (RFC 3490)",
);

/**
 * A project manage tool for Idris
 */
export const idringen = mkPackage(
  nixRaw`pkgs.haskellPackages.idringen`,
  "A project manage tool for Idris",
);

/**
 * Functional Programming Language with Dependent Types
 */
export const idris = mkPackage(
  nixRaw`pkgs.haskellPackages.idris`,
  "Functional Programming Language with Dependent Types",
);

/**
 * Utilities for dealing with IEEE floating point numbers
 */
export const ieee = mkPackage(
  nixRaw`pkgs.haskellPackages.ieee`,
  "Utilities for dealing with IEEE floating point numbers",
);

/**
 * Utilities for dealing with IEEE floating point numbers
 */
export const ieee754 = mkPackage(
  nixRaw`pkgs.haskellPackages.ieee754`,
  "Utilities for dealing with IEEE floating point numbers",
);

export const ieee754_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.ieee754-parser`,
  "",
);

/**
 * ieee-utils
 */
export const ieee_utils_tempfix = mkPackage(
  nixRaw`pkgs.haskellPackages.ieee-utils-tempfix`,
  "ieee-utils",
);

/**
 * (?) and (?>) conditional operator
 */
export const if_ = mkPackage(
  nixRaw`pkgs.haskellPackages.if`,
  "(?) and (?>) conditional operator",
);

/**
 * Branch on whether a constraint is satisfied
 */
export const if_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.if-instance`,
  "Branch on whether a constraint is satisfied",
);

/**
 * Constructing and dissecting IFF files
 */
export const iff = mkPackage(
  nixRaw`pkgs.haskellPackages.iff`,
  "Constructing and dissecting IFF files",
);

/**
 * An inductive-form set constraint solver
 */
export const ifscs = mkPackage(
  nixRaw`pkgs.haskellPackages.ifscs`,
  "An inductive-form set constraint solver",
);

/**
 * Bindings for the Gtk/OS X integration library
 */
export const ige_mac_integration = mkPackage(
  nixRaw`pkgs.haskellPackages.ige-mac-integration`,
  "Bindings for the Gtk/OS X integration library",
);

/**
 * International Geomagnetic Reference Field
 */
export const igrf = mkPackage(
  nixRaw`pkgs.haskellPackages.igrf`,
  "International Geomagnetic Reference Field",
);

/**
 * A Haskell backend kernel for the Jupyter project
 */
export const ihaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell`,
  "A Haskell backend kernel for the Jupyter project",
);

/**
 * IHaskell display instances for Aeson
 */
export const ihaskell_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-aeson`,
  "IHaskell display instances for Aeson",
);

/**
 * IHaskell display instances for basic types
 */
export const ihaskell_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-basic`,
  "IHaskell display instances for basic types",
);

/**
 * IHaskell display instances for blaze-html types
 */
export const ihaskell_blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-blaze`,
  "IHaskell display instances for blaze-html types",
);

/**
 * IHaskell display instances for basic types
 */
export const ihaskell_display = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-display`,
  "IHaskell display instances for basic types",
);

/**
 * IHaskell display instances for hatex
 */
export const ihaskell_hatex = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-hatex`,
  "IHaskell display instances for hatex",
);

/**
 * IHaskell display instance for hvega types
 */
export const ihaskell_hvega = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-hvega`,
  "IHaskell display instance for hvega types",
);

/**
 * Embed R quasiquotes and plots in IHaskell notebooks
 */
export const ihaskell_inline_r = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-inline-r`,
  "Embed R quasiquotes and plots in IHaskell notebooks",
);

/**
 * IHaskell - IHaskellDisplay instances of the image types of the JuicyPixels package
 */
export const ihaskell_juicypixels = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-juicypixels`,
  "IHaskell - IHaskellDisplay instances of the image types of the JuicyPixels package",
);

/**
 * IHaskell display instances for bytestrings
 */
export const ihaskell_magic = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-magic`,
  "IHaskell display instances for bytestrings",
);

/**
 * a rDisp quasiquote to show plots from Rlang-QQ in IHaskell
 */
export const ihaskell_rlangqq = mkPackage(
  nixRaw`pkgs.haskellPackages.ihaskell-rlangqq`,
  "a rDisp quasiquote to show plots from Rlang-QQ in IHaskell",
);

/**
 * Interpolated Haskell
 */
export const ihs = mkPackage(
  nixRaw`pkgs.haskellPackages.ihs`,
  "Interpolated Haskell",
);

/**
 * Incremental HTTP iteratee
 */
export const ihttp = mkPackage(
  nixRaw`pkgs.haskellPackages.ihttp`,
  "Incremental HTTP iteratee",
);

/**
 * Optimised list functions for doing index-related things
 */
export const ilist = mkPackage(
  nixRaw`pkgs.haskellPackages.ilist`,
  "Optimised list functions for doing index-related things",
);

/**
 * Image Filters (contrast, brightness, gaussian blur, etc)
 */
export const imagefilters = mkPackage(
  nixRaw`pkgs.haskellPackages.imagefilters`,
  "Image Filters (contrast, brightness, gaussian blur, etc)",
);

/**
 * Determine the size of some common image formats
 */
export const imagesize_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.imagesize-conduit`,
  "Determine the size of some common image formats",
);

/**
 * An efficient IMAP client library, with SSL and streaming
 */
export const imap = mkPackage(
  nixRaw`pkgs.haskellPackages.imap`,
  "An efficient IMAP client library, with SSL and streaming",
);

/**
 * Minimalistic reference manager
 */
export const imbib = mkPackage(
  nixRaw`pkgs.haskellPackages.imbib`,
  "Minimalistic reference manager",
);

/**
 * Uploader for Imgur
 */
export const imgurder = mkPackage(
  nixRaw`pkgs.haskellPackages.imgurder`,
  "Uploader for Imgur",
);

/**
 * Animation Framework
 */
export const imj_animation = mkPackage(
  nixRaw`pkgs.haskellPackages.imj-animation`,
  "Animation Framework",
);

/**
 * Game engine with geometry, easing, animated text, delta rendering
 */
export const imj_base = mkPackage(
  nixRaw`pkgs.haskellPackages.imj-base`,
  "Game engine with geometry, easing, animated text, delta rendering",
);

/**
 * A game with flying numbers and 8-bit color animations
 */
export const imj_game_hamazed = mkPackage(
  nixRaw`pkgs.haskellPackages.imj-game-hamazed`,
  "A game with flying numbers and 8-bit color animations",
);

/**
 * An application to determine the maximum capacity of stdout buffer
 */
export const imj_measure_stdout = mkPackage(
  nixRaw`pkgs.haskellPackages.imj-measure-stdout`,
  "An application to determine the maximum capacity of stdout buffer",
);

/**
 * Spawn threads that never die (unless told to do so)
 */
export const immortal = mkPackage(
  nixRaw`pkgs.haskellPackages.immortal`,
  "Spawn threads that never die (unless told to do so)",
);

/**
 * Spawn threads that never die (unless told to do so)
 */
export const immortal_0_2_2_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.immortal_0_2_2_1`,
  "Spawn threads that never die (unless told to do so)",
);

/**
 * Build a pool of queue-processing worker threads
 */
export const immortal_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.immortal-queue`,
  "Build a pool of queue-processing worker threads",
);

/**
 * Multi-platform parser analyzer and generator
 */
export const imparse = mkPackage(
  nixRaw`pkgs.haskellPackages.imparse`,
  "Multi-platform parser analyzer and generator",
);

/**
 * Deep embedding of imperative programs with code generation
 */
export const imperative_edsl = mkPackage(
  nixRaw`pkgs.haskellPackages.imperative-edsl`,
  "Deep embedding of imperative programs with code generation",
);

/**
 * Deep embedding of VHDL programs with code generation
 */
export const imperative_edsl_vhdl = mkPackage(
  nixRaw`pkgs.haskellPackages.imperative-edsl-vhdl`,
  "Deep embedding of VHDL programs with code generation",
);

/**
 * A math-inspired programmatic 2D & 3D CAD system
 */
export const implicit = mkPackage(
  nixRaw`pkgs.haskellPackages.implicit`,
  "A math-inspired programmatic 2D & 3D CAD system",
);

/**
 * Auto generate hie-bios cradles & hie.yaml
 */
export const implicit_hie = mkPackage(
  nixRaw`pkgs.haskellPackages.implicit-hie`,
  "Auto generate hie-bios cradles & hie.yaml",
);

/**
 * Auto generate hie-bios cradles & hie.yaml
 */
export const implicit_hie_0_1_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.implicit-hie_0_1_4_0`,
  "Auto generate hie-bios cradles & hie.yaml",
);

/**
 * Auto generate hie-bios cradles
 */
export const implicit_hie_cradle = mkPackage(
  nixRaw`pkgs.haskellPackages.implicit-hie-cradle`,
  "Auto generate hie-bios cradles",
);

/**
 * Tool for haskell imports refactoring
 */
export const importify = mkPackage(
  nixRaw`pkgs.haskellPackages.importify`,
  "Tool for haskell imports refactoring",
);

/**
 * Imprevu support for Happstack
 */
export const imprevu_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.imprevu-happstack`,
  "Imprevu support for Happstack",
);

/**
 * An imperative, verifiable programming language for high assurance applications
 */
export const improve = mkPackage(
  nixRaw`pkgs.haskellPackages.improve`,
  "An imperative, verifiable programming language for high assurance applications",
);

/**
 * A higher-order effect system where the sky's the limit
 */
export const in_other_words = mkPackage(
  nixRaw`pkgs.haskellPackages.in-other-words`,
  "A higher-order effect system where the sky's the limit",
);

/**
 * Inbox for asychronous messages
 */
export const inbox = mkPackage(
  nixRaw`pkgs.haskellPackages.inbox`,
  "Inbox for asychronous messages",
);

/**
 * A STM reference useful for incremental computing
 */
export const inc_ref = mkPackage(
  nixRaw`pkgs.haskellPackages.inc-ref`,
  "A STM reference useful for incremental computing",
);

/**
 * A type-checker for Haskell with integer constraints
 */
export const inch = mkPackage(
  nixRaw`pkgs.haskellPackages.inch`,
  "A type-checker for Haskell with integer constraints",
);

/**
 * A Prelude for Polysemy
 */
export const incipit = mkPackage(
  nixRaw`pkgs.haskellPackages.incipit`,
  "A Prelude for Polysemy",
);

/**
 * A Prelude for Polysemy  Base Reexports
 */
export const incipit_base = mkPackage(
  nixRaw`pkgs.haskellPackages.incipit-base`,
  "A Prelude for Polysemy  Base Reexports",
);

/**
 * A Prelude for Polysemy
 */
export const incipit_core = mkPackage(
  nixRaw`pkgs.haskellPackages.incipit-core`,
  "A Prelude for Polysemy",
);

/**
 * Include the value of an environment variable at compile time
 */
export const include_env = mkPackage(
  nixRaw`pkgs.haskellPackages.include-env`,
  "Include the value of an environment variable at compile time",
);

/**
 * Inclusion of files in executables at compile-time
 */
export const include_file = mkPackage(
  nixRaw`pkgs.haskellPackages.include-file`,
  "Inclusion of files in executables at compile-time",
);

/**
 * incremental update library
 */
export const incremental = mkPackage(
  nixRaw`pkgs.haskellPackages.incremental`,
  "incremental update library",
);

/**
 * Incremental computing
 */
export const incremental_computing = mkPackage(
  nixRaw`pkgs.haskellPackages.incremental-computing`,
  "Incremental computing",
);

/**
 * Package for doing incremental computations on maps
 */
export const incremental_maps = mkPackage(
  nixRaw`pkgs.haskellPackages.incremental-maps`,
  "Package for doing incremental computations on maps",
);

/**
 * Generic parser library capable of providing partial results from partial input
 */
export const incremental_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.incremental-parser`,
  "Generic parser library capable of providing partial results from partial input",
);

/**
 * Simple, Incremental SAT Solving as a Library
 */
export const incremental_sat_solver = mkPackage(
  nixRaw`pkgs.haskellPackages.incremental-sat-solver`,
  "Simple, Incremental SAT Solving as a Library",
);

/**
 * type classes for incremental updates to data
 */
export const increments = mkPackage(
  nixRaw`pkgs.haskellPackages.increments`,
  "type classes for incremental updates to data",
);

/**
 * Fix your indentation
 */
export const indent = mkPackage(
  nixRaw`pkgs.haskellPackages.indent`,
  "Fix your indentation",
);

/**
 * Indentation sensitive parsing combinators for Parsec and Trifecta
 */
export const indentation = mkPackage(
  nixRaw`pkgs.haskellPackages.indentation`,
  "Indentation sensitive parsing combinators for Parsec and Trifecta",
);

/**
 * Indentation sensitive parsing combinators for Parsec
 */
export const indentation_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.indentation-parsec`,
  "Indentation sensitive parsing combinators for Parsec",
);

/**
 * Indentation sensitive parsing combinators for Trifecta
 */
export const indentation_trifecta = mkPackage(
  nixRaw`pkgs.haskellPackages.indentation-trifecta`,
  "Indentation sensitive parsing combinators for Trifecta",
);

/**
 * A parser for indentation based structures
 */
export const indentparser = mkPackage(
  nixRaw`pkgs.haskellPackages.indentparser`,
  "A parser for indentation based structures",
);

/**
 * indentation sensitive parser-combinators for parsec
 */
export const indents = mkPackage(
  nixRaw`pkgs.haskellPackages.indents`,
  "indentation sensitive parser-combinators for parsec",
);

/**
 * Tools for entity indexation
 */
export const indexation = mkPackage(
  nixRaw`pkgs.haskellPackages.indexation`,
  "Tools for entity indexation",
);

/**
 * Haskell98 indexed functors, monads, comonads
 */
export const indexed = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed`,
  "Haskell98 indexed functors, monads, comonads",
);

/**
 * Indexed functors, monads and comonads that require extensions to Haskell98
 */
export const indexed_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-extras`,
  "Indexed functors, monads and comonads that require extensions to Haskell98",
);

/**
 * indexed monads for free
 */
export const indexed_free = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-free`,
  "indexed monads for free",
);

/**
 * Type safe indexed list literals
 */
export const indexed_list_literals = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-list-literals`,
  "Type safe indexed list literals",
);

/**
 * Utilities for indexed profunctors
 */
export const indexed_profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-profunctors`,
  "Utilities for indexed profunctors",
);

/**
 * FunctorWithIndex, FoldableWithIndex, TraversableWithIndex
 */
export const indexed_traversable = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-traversable`,
  "FunctorWithIndex, FoldableWithIndex, TraversableWithIndex",
);

/**
 * FunctorWithIndex, FoldableWithIndex, TraversableWithIndex
 */
export const indexed_traversable_0_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-traversable_0_1_3`,
  "FunctorWithIndex, FoldableWithIndex, TraversableWithIndex",
);

/**
 * More instances of FunctorWithIndex, FoldableWithIndex, TraversableWithIndex
 */
export const indexed_traversable_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.indexed-traversable-instances`,
  "More instances of FunctorWithIndex, FoldableWithIndex, TraversableWithIndex",
);

/**
 * Indian Language Font Converter
 */
export const indian_language_font_converter = mkPackage(
  nixRaw`pkgs.haskellPackages.indian-language-font-converter`,
  "Indian Language Font Converter",
);

/**
 * A collection of implementations of IndieWeb algorithms
 */
export const indieweb_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.indieweb-algorithms`,
  "A collection of implementations of IndieWeb algorithms",
);

/**
 * Convenient imperative eDSL over Lorentz
 */
export const indigo = mkPackage(
  nixRaw`pkgs.haskellPackages.indigo`,
  "Convenient imperative eDSL over Lorentz",
);

/**
 * Automatic differentiation and backpropagation
 */
export const inf_backprop = mkPackage(
  nixRaw`pkgs.haskellPackages.inf-backprop`,
  "Automatic differentiation and backpropagation",
);

/**
 * Infer software license from a given license file
 */
export const infer_license = mkPackage(
  nixRaw`pkgs.haskellPackages.infer-license`,
  "Infer software license from a given license file",
);

/**
 * A statically-typed functional scripting language
 */
export const inferno_core = mkPackage(
  nixRaw`pkgs.haskellPackages.inferno-core`,
  "A statically-typed functional scripting language",
);

/**
 * LSP for Inferno
 */
export const inferno_lsp = mkPackage(
  nixRaw`pkgs.haskellPackages.inferno-lsp`,
  "LSP for Inferno",
);

/**
 * Version control server for Inferno
 */
export const inferno_vc = mkPackage(
  nixRaw`pkgs.haskellPackages.inferno-vc`,
  "Version control server for Inferno",
);

/**
 * Infinite lists
 */
export const infinite_list = mkPackage(
  nixRaw`pkgs.haskellPackages.infinite-list`,
  "Infinite lists",
);

/**
 * Exhaustively searchable infinite sets
 */
export const infinite_search = mkPackage(
  nixRaw`pkgs.haskellPackages.infinite-search`,
  "Exhaustively searchable infinite sets",
);

export const infinity = mkPackage(
  nixRaw`pkgs.haskellPackages.infinity`,
  "",
);

/**
 * Inflections library for Haskell
 */
export const inflections = mkPackage(
  nixRaw`pkgs.haskellPackages.inflections`,
  "Inflections library for Haskell",
);

/**
 * InfluxDB client library for Haskell
 */
export const influxdb = mkPackage(
  nixRaw`pkgs.haskellPackages.influxdb`,
  "InfluxDB client library for Haskell",
);

/**
 * Configuration files in the INI format
 */
export const ini = mkPackage(
  nixRaw`pkgs.haskellPackages.ini`,
  "Configuration files in the INI format",
);

/**
 * A class for injective (one-to-one) functions
 */
export const inj = mkPackage(
  nixRaw`pkgs.haskellPackages.inj`,
  "A class for injective (one-to-one) functions",
);

/**
 * A minimalistic template engine
 */
export const inject = mkPackage(
  nixRaw`pkgs.haskellPackages.inject`,
  "A minimalistic template engine",
);

/**
 * Inline some Assembly in ur Haskell!
 */
export const inline_asm = mkPackage(
  nixRaw`pkgs.haskellPackages.inline-asm`,
  "Inline some Assembly in ur Haskell!",
);

/**
 * Write Haskell source files including C code inline. No FFI required.
 */
export const inline_c = mkPackage(
  nixRaw`pkgs.haskellPackages.inline-c`,
  "Write Haskell source files including C code inline. No FFI required.",
);

/**
 * Lets you embed C++ code into Haskell
 */
export const inline_c_cpp = mkPackage(
  nixRaw`pkgs.haskellPackages.inline-c-cpp`,
  "Lets you embed C++ code into Haskell",
);

/**
 * Win32 API Context for the inline-c library
 */
export const inline_c_win32 = mkPackage(
  nixRaw`pkgs.haskellPackages.inline-c-win32`,
  "Win32 API Context for the inline-c library",
);

/**
 * Java interop via inline Java code in Haskell modules
 */
export const inline_java = mkPackage(
  nixRaw`pkgs.haskellPackages.inline-java`,
  "Java interop via inline Java code in Haskell modules",
);

/**
 * Interactive literate programming
 */
export const inliterate = mkPackage(
  nixRaw`pkgs.haskellPackages.inliterate`,
  "Interactive literate programming",
);

/**
 * Extension of the parsers library with more capability and efficiency
 */
export const input_parsers = mkPackage(
  nixRaw`pkgs.haskellPackages.input-parsers`,
  "Extension of the parsers library with more capability and efficiency",
);

/**
 * Associative containers retaining insertion order for traversals
 */
export const insert_ordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.insert-ordered-containers`,
  "Associative containers retaining insertion order for traversals",
);

/**
 * A simple proxy for debugging plaintext protocols communication
 */
export const inspection_proxy = mkPackage(
  nixRaw`pkgs.haskellPackages.inspection-proxy`,
  "A simple proxy for debugging plaintext protocols communication",
);

/**
 * GHC plugin to do inspection testing
 */
export const inspection_testing = mkPackage(
  nixRaw`pkgs.haskellPackages.inspection-testing`,
  "GHC plugin to do inspection testing",
);

/**
 * Create benchmarks from the HAR files
 */
export const inspector_wrecker = mkPackage(
  nixRaw`pkgs.haskellPackages.inspector-wrecker`,
  "Create benchmarks from the HAR files",
);

/**
 * Controls how the compiler searches for instances using type families
 */
export const instance_control = mkPackage(
  nixRaw`pkgs.haskellPackages.instance-control`,
  "Controls how the compiler searches for instances using type families",
);

/**
 * Generic Aeson instances through instant-generics
 */
export const instant_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.instant-aeson`,
  "Generic Aeson instances through instant-generics",
);

/**
 * Generic Serial instances through instant-generics
 */
export const instant_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.instant-bytes`,
  "Generic Serial instances through instant-generics",
);

/**
 * Generic NFData instances through instant-generics
 */
export const instant_deepseq = mkPackage(
  nixRaw`pkgs.haskellPackages.instant-deepseq`,
  "Generic NFData instances through instant-generics",
);

/**
 * Generic Hashable instances through instant-generics
 */
export const instant_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.instant-hashable`,
  "Generic Hashable instances through instant-generics",
);

/**
 * Heterogenous Zipper in Instant Generics
 */
export const instant_zipper = mkPackage(
  nixRaw`pkgs.haskellPackages.instant-zipper`,
  "Heterogenous Zipper in Instant Generics",
);

/**
 * Render Instrument Chords
 */
export const instrument_chord = mkPackage(
  nixRaw`pkgs.haskellPackages.instrument-chord`,
  "Render Instrument Chords",
);

/**
 * Adds a worker for the instrument package that exports to Amazon CloudWatch
 */
export const instrument_cloudwatch = mkPackage(
  nixRaw`pkgs.haskellPackages.instrument-cloudwatch`,
  "Adds a worker for the instrument package that exports to Amazon CloudWatch",
);

/**
 * Checked conversions between integral types
 */
export const int_cast = mkPackage(
  nixRaw`pkgs.haskellPackages.int-cast`,
  "Checked conversions between integral types",
);

/**
 * Conversion from strings to Integer
 */
export const integer_conversion = mkPackage(
  nixRaw`pkgs.haskellPackages.integer-conversion`,
  "Conversion from strings to Integer",
);

/**
 * Integer library based on GMP
 */
export const integer_gmp_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.integer-gmp_1_1`,
  "Integer library based on GMP",
);

/**
 * Integer logarithms
 */
export const integer_logarithms = mkPackage(
  nixRaw`pkgs.haskellPackages.integer-logarithms`,
  "Integer logarithms",
);

/**
 * Integer roots and perfect powers
 */
export const integer_roots = mkPackage(
  nixRaw`pkgs.haskellPackages.integer-roots`,
  "Integer roots and perfect powers",
);

/**
 * Integer, Natural, and Positive
 */
export const integer_types = mkPackage(
  nixRaw`pkgs.haskellPackages.integer-types`,
  "Integer, Natural, and Positive",
);

/**
 * Fast robust numeric integration via tanh-sinh quadrature
 */
export const integration = mkPackage(
  nixRaw`pkgs.haskellPackages.integration`,
  "Fast robust numeric integration via tanh-sinh quadrature",
);

/**
 * Integrate different assays
 */
export const integreat = mkPackage(
  nixRaw`pkgs.haskellPackages.integreat`,
  "Integrate different assays",
);

/**
 * Hardware accelerated AES encryption and Random Number Generation
 */
export const intel_aes = mkPackage(
  nixRaw`pkgs.haskellPackages.intel-aes`,
  "Hardware accelerated AES encryption and Random Number Generation",
);

/**
 * Poll modern Intel/AMD CPU power consumption on Linux via RAPL
 */
export const intel_powermon = mkPackage(
  nixRaw`pkgs.haskellPackages.intel-powermon`,
  "Poll modern Intel/AMD CPU power consumption on Linux via RAPL",
);

/**
 * A type class for interchangeable data
 */
export const interchangeable = mkPackage(
  nixRaw`pkgs.haskellPackages.interchangeable`,
  "A type class for interchangeable data",
);

/**
 * Combinators for supporting interleaving of different behaviours
 */
export const interleave = mkPackage(
  nixRaw`pkgs.haskellPackages.interleave`,
  "Combinators for supporting interleaving of different behaviours",
);

/**
 * Replaces some Prelude functions for enhanced error reporting
 */
export const interlude = mkPackage(
  nixRaw`pkgs.haskellPackages.interlude`,
  "Replaces some Prelude functions for enhanced error reporting",
);

/**
 * Efficient hash-consing for arbitrary data types
 */
export const intern = mkPackage(
  nixRaw`pkgs.haskellPackages.intern`,
  "Efficient hash-consing for arbitrary data types",
);

/**
 * String interpolation done right
 */
export const interpolate = mkPackage(
  nixRaw`pkgs.haskellPackages.interpolate`,
  "String interpolation done right",
);

/**
 * QuasiQuoter for Perl6-style multi-line interpolated strings
 */
export const interpolatedstring_perl6 = mkPackage(
  nixRaw`pkgs.haskellPackages.interpolatedstring-perl6`,
  "QuasiQuoter for Perl6-style multi-line interpolated strings",
);

/**
 * QuasiQuoter for Ruby-style multi-line interpolated strings
 */
export const interpolatedstring_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.interpolatedstring-qq`,
  "QuasiQuoter for Ruby-style multi-line interpolated strings",
);

/**
 * DO NOT USE THIS. interpolatedstring-qq works now.
 */
export const interpolatedstring_qq_mwotton = mkPackage(
  nixRaw`pkgs.haskellPackages.interpolatedstring-qq-mwotton`,
  "DO NOT USE THIS. interpolatedstring-qq works now.",
);

/**
 * piecewise linear and cubic Hermite interpolation
 */
export const interpolation = mkPackage(
  nixRaw`pkgs.haskellPackages.interpolation`,
  "piecewise linear and cubic Hermite interpolation",
);

/**
 * Shared memory and control structures for IPC
 */
export const interprocess = mkPackage(
  nixRaw`pkgs.haskellPackages.interprocess`,
  "Shared memory and control structures for IPC",
);

/**
 * An abstraction over interspersing monadic actions
 */
export const interspersed = mkPackage(
  nixRaw`pkgs.haskellPackages.interspersed`,
  "An abstraction over interspersing monadic actions",
);

/**
 * Intervals of functors
 */
export const interval_functor = mkPackage(
  nixRaw`pkgs.haskellPackages.interval-functor`,
  "Intervals of functors",
);

/**
 * Intervals, and monoids thereof
 */
export const interval_patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.interval-patterns`,
  "Intervals, and monoids thereof",
);

/**
 * Interval Arithmetic
 */
export const intervals = mkPackage(
  nixRaw`pkgs.haskellPackages.intervals`,
  "Interval Arithmetic",
);

/**
 * A graph library that allows to explore edges after their type
 */
export const intmap_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.intmap-graph`,
  "A graph library that allows to explore edges after their type",
);

/**
 * A game of competitive puzzle-design
 */
export const intricacy = mkPackage(
  nixRaw`pkgs.haskellPackages.intricacy`,
  "A game of competitive puzzle-design",
);

/**
 * Intro reexported as Prelude
 */
export const intro_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.intro-prelude`,
  "Intro reexported as Prelude",
);

/**
 * A prelude for the tests of safe new projects
 */
export const introduction_test = mkPackage(
  nixRaw`pkgs.haskellPackages.introduction-test`,
  "A prelude for the tests of safe new projects",
);

/**
 * Pure, mergeable, succinct Int sets
 */
export const intset = mkPackage(
  nixRaw`pkgs.haskellPackages.intset`,
  "Pure, mergeable, succinct Int sets",
);

/**
 * An imperative integer set written in Haskell
 */
export const intset_imperative = mkPackage(
  nixRaw`pkgs.haskellPackages.intset-imperative`,
  "An imperative integer set written in Haskell",
);

/**
 * Haskell98 invariant functors
 */
export const invariant = mkPackage(
  nixRaw`pkgs.haskellPackages.invariant`,
  "Haskell98 invariant functors",
);

/**
 * Project statistics and definition analysis
 */
export const inventory = mkPackage(
  nixRaw`pkgs.haskellPackages.inventory`,
  "Project statistics and definition analysis",
);

/**
 * Automatically generate a functions inverse
 */
export const invert = mkPackage(
  nixRaw`pkgs.haskellPackages.invert`,
  "Automatically generate a functions inverse",
);

/**
 * bidirectional arrows, bijective functions, and invariant functors
 */
export const invertible = mkPackage(
  nixRaw`pkgs.haskellPackages.invertible`,
  "bidirectional arrows, bijective functions, and invariant functors",
);

/**
 * Invertible parsing combinators framework
 */
export const invertible_grammar = mkPackage(
  nixRaw`pkgs.haskellPackages.invertible-grammar`,
  "Invertible parsing combinators framework",
);

/**
 * invertible functions and instances for HList
 */
export const invertible_hlist = mkPackage(
  nixRaw`pkgs.haskellPackages.invertible-hlist`,
  "invertible functions and instances for HList",
);

/**
 * invertible transformer instances for HXT Picklers
 */
export const invertible_hxt = mkPackage(
  nixRaw`pkgs.haskellPackages.invertible-hxt`,
  "invertible transformer instances for HXT Picklers",
);

/**
 * Type classes for concurrency with STM, ST and timing
 */
export const io_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.io-classes`,
  "Type classes for concurrency with STM, ST and timing",
);

/**
 * Experimental MTL instances for io-classes
 */
export const io_classes_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.io-classes-mtl`,
  "Experimental MTL instances for io-classes",
);

/**
 * Easy I/O model to learn IO monad
 */
export const io_machine = mkPackage(
  nixRaw`pkgs.haskellPackages.io-machine`,
  "Easy I/O model to learn IO monad",
);

/**
 * Skeleton library around the IO monad
 */
export const io_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.io-manager`,
  "Skeleton library around the IO monad",
);

/**
 * Memoize IO actions
 */
export const io_memoize = mkPackage(
  nixRaw`pkgs.haskellPackages.io-memoize`,
  "Memoize IO actions",
);

/**
 * Exception safe resource management with dynamic regions
 */
export const io_region = mkPackage(
  nixRaw`pkgs.haskellPackages.io-region`,
  "Exception safe resource management with dynamic regions",
);

/**
 * A pure simulator for monadic concurrency with STM
 */
export const io_sim = mkPackage(
  nixRaw`pkgs.haskellPackages.io-sim`,
  "A pure simulator for monadic concurrency with STM",
);

/**
 * A key-value store in the IO monad
 */
export const io_storage = mkPackage(
  nixRaw`pkgs.haskellPackages.io-storage`,
  "A key-value store in the IO monad",
);

/**
 * Simple, composable, and easy-to-use stream I/O
 */
export const io_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.io-streams`,
  "Simple, composable, and easy-to-use stream I/O",
);

/**
 * HAProxy protocol 1.5 support for io-streams
 */
export const io_streams_haproxy = mkPackage(
  nixRaw`pkgs.haskellPackages.io-streams-haproxy`,
  "HAProxy protocol 1.5 support for io-streams",
);

/**
 * http-client for io-streams
 */
export const io_streams_http = mkPackage(
  nixRaw`pkgs.haskellPackages.io-streams-http`,
  "http-client for io-streams",
);

/**
 * Classes to handle Prelude style IO functions for different datatypes
 */
export const io_string_like = mkPackage(
  nixRaw`pkgs.haskellPackages.io-string-like`,
  "Classes to handle Prelude style IO functions for different datatypes",
);

/**
 * Limit number of IO actions started per second
 */
export const io_throttle = mkPackage(
  nixRaw`pkgs.haskellPackages.io-throttle`,
  "Limit number of IO actions started per second",
);

/**
 * EDSL for concurrent, realtime, embedded programming on top of Ivory
 */
export const ion = mkPackage(
  nixRaw`pkgs.haskellPackages.ion`,
  "EDSL for concurrent, realtime, embedded programming on top of Ivory",
);

/**
 * iorefs with a unique stable index
 */
export const ioref_stable = mkPackage(
  nixRaw`pkgs.haskellPackages.ioref-stable`,
  "iorefs with a unique stable index",
);

/**
 * Library for IP and MAC addresses
 */
export const ip = mkPackage(
  nixRaw`pkgs.haskellPackages.ip`,
  "Library for IP and MAC addresses",
);

/**
 * Commandline tool to deal with IPv6 address text representations
 */
export const ip6addr = mkPackage(
  nixRaw`pkgs.haskellPackages.ip6addr`,
  "Commandline tool to deal with IPv6 address text representations",
);

/**
 * interactive patch editor
 */
export const ipatch = mkPackage(
  nixRaw`pkgs.haskellPackages.ipatch`,
  "interactive patch editor",
);

/**
 * High level inter-process communication library
 */
export const ipc = mkPackage(
  nixRaw`pkgs.haskellPackages.ipc`,
  "High level inter-process communication library",
);

/**
 * Simple inter-process communication through IPCVars
 */
export const ipcvar = mkPackage(
  nixRaw`pkgs.haskellPackages.ipcvar`,
  "Simple inter-process communication through IPCVars",
);

/**
 * Auto-generated IPFS HTTP API
 */
export const ipfs_api = mkPackage(
  nixRaw`pkgs.haskellPackages.ipfs-api`,
  "Auto-generated IPFS HTTP API",
);

/**
 * IPLD Content-IDentifiers <https://github.com/ipld/cid>
 */
export const ipld_cid = mkPackage(
  nixRaw`pkgs.haskellPackages.ipld-cid`,
  "IPLD Content-IDentifiers <https://github.com/ipld/cid>",
);

/**
 * Tiny helper for pretty-printing values in ghci console
 */
export const ipprint = mkPackage(
  nixRaw`pkgs.haskellPackages.ipprint`,
  "Tiny helper for pretty-printing values in ghci console",
);

/**
 * IP Routing Table
 */
export const iproute = mkPackage(
  nixRaw`pkgs.haskellPackages.iproute`,
  "IP Routing Table",
);

/**
 * web-interface for iptables
 */
export const iptadmin = mkPackage(
  nixRaw`pkgs.haskellPackages.iptadmin`,
  "web-interface for iptables",
);

/**
 * Data structure for working with Jupyter notebooks (ipynb)
 */
export const ipynb = mkPackage(
  nixRaw`pkgs.haskellPackages.ipynb`,
  "Data structure for working with Jupyter notebooks (ipynb)",
);

/**
 * A library for creating kernels for IPython frontends
 */
export const ipython_kernel = mkPackage(
  nixRaw`pkgs.haskellPackages.ipython-kernel`,
  "A library for creating kernels for IPython frontends",
);

/**
 * A small library for parsing IRC messages
 */
export const irc = mkPackage(
  nixRaw`pkgs.haskellPackages.irc`,
  "A small library for parsing IRC messages",
);

/**
 * serialization and parsing of IRC messages
 */
export const irc_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-bytestring`,
  "serialization and parsing of IRC messages",
);

/**
 * An IRC client library
 */
export const irc_client = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-client`,
  "An IRC client library",
);

/**
 * Colourize your IRC strings
 */
export const irc_colors = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-colors`,
  "Colourize your IRC strings",
);

/**
 * Streaming IRC message library using conduits
 */
export const irc_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-conduit`,
  "Streaming IRC message library using conduits",
);

/**
 * A CTCP encoding and decoding library for IRC clients
 */
export const irc_ctcp = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-ctcp`,
  "A CTCP encoding and decoding library for IRC clients",
);

/**
 * Library for writing fun IRC bots
 */
export const irc_fun_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-fun-bot`,
  "Library for writing fun IRC bots",
);

/**
 * Another library for writing IRC clients
 */
export const irc_fun_client = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-fun-client`,
  "Another library for writing IRC clients",
);

/**
 * Add color and style decorations to IRC messages
 */
export const irc_fun_color = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-fun-color`,
  "Add color and style decorations to IRC messages",
);

/**
 * Types and functions for working with the IRC protocol
 */
export const irc_fun_messages = mkPackage(
  nixRaw`pkgs.haskellPackages.irc-fun-messages`,
  "Types and functions for working with the IRC protocol",
);

/**
 * None
 */
export const ircbouncer = mkPackage(
  nixRaw`pkgs.haskellPackages.ircbouncer`,
  "None",
);

/**
 * A technical demo for Antisplice
 */
export const ironforge = mkPackage(
  nixRaw`pkgs.haskellPackages.ironforge`,
  "A technical demo for Antisplice",
);

/**
 * Generic pattern predicates
 */
export const is = mkPackage(
  nixRaw`pkgs.haskellPackages.is`,
  "Generic pattern predicates",
);

/**
 * ISBN Validation and Manipulation
 */
export const isbn = mkPackage(
  nixRaw`pkgs.haskellPackages.isbn`,
  "ISBN Validation and Manipulation",
);

/**
 * Check whether a value has been evaluated
 */
export const isevaluated = mkPackage(
  nixRaw`pkgs.haskellPackages.isevaluated`,
  "Check whether a value has been evaluated",
);

/**
 * A program to show the size of image and whether suitable for wallpaper
 */
export const isiz = mkPackage(
  nixRaw`pkgs.haskellPackages.isiz`,
  "A program to show the size of image and whether suitable for wallpaper",
);

/**
 * Check if an HTML element is a link
 */
export const islink = mkPackage(
  nixRaw`pkgs.haskellPackages.islink`,
  "Check if an HTML element is a link",
);

/**
 * Advanced ESMTP library
 */
export const ismtp = mkPackage(
  nixRaw`pkgs.haskellPackages.ismtp`,
  "Advanced ESMTP library",
);

/**
 * A datatype for ISO 3166 country codes
 */
export const iso3166_country_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.iso3166-country-codes`,
  "A datatype for ISO 3166 country codes",
);

/**
 * ISO-639-1 language codes
 */
export const iso639 = mkPackage(
  nixRaw`pkgs.haskellPackages.iso639`,
  "ISO-639-1 language codes",
);

/**
 * Parse and merge ISO 8583-style bitmaps
 */
export const iso8583_bitmaps = mkPackage(
  nixRaw`pkgs.haskellPackages.iso8583-bitmaps`,
  "Parse and merge ISO 8583-style bitmaps",
);

/**
 * Convert to/from the ISO 8601 time format
 */
export const iso8601_time = mkPackage(
  nixRaw`pkgs.haskellPackages.iso8601-time`,
  "Convert to/from the ISO 8601 time format",
);

/**
 * Deriving via arbitrary isomorphisms
 */
export const iso_deriving = mkPackage(
  nixRaw`pkgs.haskellPackages.iso-deriving`,
  "Deriving via arbitrary isomorphisms",
);

/**
 * A (bytestring-) builder for the ISO-14496-12 base media file format
 */
export const isobmff_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.isobmff-builder`,
  "A (bytestring-) builder for the ISO-14496-12 base media file format",
);

/**
 * A portable alternative to GNU Readline
 */
export const isocline = mkPackage(
  nixRaw`pkgs.haskellPackages.isocline`,
  "A portable alternative to GNU Readline",
);

/**
 * Bindings to the isoHunt torrent search API
 */
export const isohunt = mkPackage(
  nixRaw`pkgs.haskellPackages.isohunt`,
  "Bindings to the isoHunt torrent search API",
);

/**
 * Isomorphism typeclass solving the conversion problem
 */
export const isomorphism_class = mkPackage(
  nixRaw`pkgs.haskellPackages.isomorphism-class`,
  "Isomorphism typeclass solving the conversion problem",
);

/**
 * Positive integers test
 */
export const ispositive = mkPackage(
  nixRaw`pkgs.haskellPackages.ispositive`,
  "Positive integers test",
);

/**
 * An implementation of name mangling/demangling for the Itanium ABI
 */
export const itanium_abi = mkPackage(
  nixRaw`pkgs.haskellPackages.itanium-abi`,
  "An implementation of name mangling/demangling for the Itanium ABI",
);

/**
 * iteratees for statistical processing
 */
export const iter_stats = mkPackage(
  nixRaw`pkgs.haskellPackages.iter-stats`,
  "iteratees for statistical processing",
);

/**
 * API for hierarchical multilevel collections
 */
export const iterable = mkPackage(
  nixRaw`pkgs.haskellPackages.iterable`,
  "API for hierarchical multilevel collections",
);

/**
 * Enumeratees for compressing and decompressing streams
 */
export const iteratee_compress = mkPackage(
  nixRaw`pkgs.haskellPackages.iteratee-compress`,
  "Enumeratees for compressing and decompressing streams",
);

/**
 * Iteratee-based I/O
 */
export const iteratee_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.iteratee-mtl`,
  "Iteratee-based I/O",
);

/**
 * Package allowing parsec parser initeratee
 */
export const iteratee_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.iteratee-parsec`,
  "Package allowing parsec parser initeratee",
);

/**
 * Concurrent iteratees using STM
 */
export const iteratee_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.iteratee-stm`,
  "Concurrent iteratees using STM",
);

/**
 * Library for building servers with IterIO
 */
export const iterio_server = mkPackage(
  nixRaw`pkgs.haskellPackages.iterio-server`,
  "Library for building servers with IterIO",
);

/**
 * Orphan Show instances for JuciyPixels image types
 */
export const iterm_show_JuicyPixels = mkPackage(
  nixRaw`pkgs.haskellPackages.iterm-show-JuicyPixels`,
  "Orphan Show instances for JuciyPixels image types",
);

/**
 * Orphan Show instances for diagrams package that render inline in some terminals
 */
export const iterm_show_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.iterm-show-diagrams`,
  "Orphan Show instances for diagrams package that render inline in some terminals",
);

/**
 * Intervals
 */
export const ival = mkPackage(
  nixRaw`pkgs.haskellPackages.ival`,
  "Intervals",
);

/**
 * Write once concurrency primitives
 */
export const ivar_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.ivar-simple`,
  "Write once concurrency primitives",
);

/**
 * Theorem proving library based on dependent type theory
 */
export const ivor = mkPackage(
  nixRaw`pkgs.haskellPackages.ivor`,
  "Theorem proving library based on dependent type theory",
);

/**
 * Manage additional data files during Ivory compilation
 */
export const ivory_artifact = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-artifact`,
  "Manage additional data files during Ivory compilation",
);

/**
 * Ivory register bindings for the Atmega328p
 */
export const ivory_avr_atmega328p_registers = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-avr-atmega328p-registers`,
  "Ivory register bindings for the Atmega328p",
);

/**
 * Ivory C backend
 */
export const ivory_backend_c = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-backend-c`,
  "Ivory C backend",
);

/**
 * Ivory bit-data support
 */
export const ivory_bitdata = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-bitdata`,
  "Ivory bit-data support",
);

/**
 * Simple concrete evaluator for Ivory programs
 */
export const ivory_eval = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-eval`,
  "Simple concrete evaluator for Ivory programs",
);

/**
 * Ivory examples
 */
export const ivory_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-examples`,
  "Ivory examples",
);

/**
 * Ivory hardware model (STM32F4)
 */
export const ivory_hw = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-hw`,
  "Ivory hardware model (STM32F4)",
);

/**
 * Ivory compiler optimizations
 */
export const ivory_opts = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-opts`,
  "Ivory compiler optimizations",
);

/**
 * QuickCheck driver for Ivory
 */
export const ivory_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-quickcheck`,
  "QuickCheck driver for Ivory",
);

/**
 * Serialization library for Ivory
 */
export const ivory_serialize = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-serialize`,
  "Serialization library for Ivory",
);

/**
 * Ivory standard library
 */
export const ivory_stdlib = mkPackage(
  nixRaw`pkgs.haskellPackages.ivory-stdlib`,
  "Ivory standard library",
);

/**
 * A lightweight web framework
 */
export const ivy_web = mkPackage(
  nixRaw`pkgs.haskellPackages.ivy-web`,
  "A lightweight web framework",
);

/**
 * Bindings for the iw C library
 */
export const iwlib = mkPackage(
  nixRaw`pkgs.haskellPackages.iwlib`,
  "Bindings for the iw C library",
);

/**
 * Indexed monads
 */
export const ix = mkPackage(
  nixRaw`pkgs.haskellPackages.ix`,
  "Indexed monads",
);

/**
 * Reshape multi-dimensional arrays
 */
export const ix_shapable = mkPackage(
  nixRaw`pkgs.haskellPackages.ix-shapable`,
  "Reshape multi-dimensional arrays",
);

/**
 * Efficient relational queries on Haskell sets
 */
export const ixset = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset`,
  "Efficient relational queries on Haskell sets",
);

/**
 * Efficient relational queries on Haskell sets
 */
export const ixset_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset-typed`,
  "Efficient relational queries on Haskell sets",
);

/**
 * Binary instance for ixset-typed
 */
export const ixset_typed_binary_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset-typed-binary-instance`,
  "Binary instance for ixset-typed",
);

/**
 * cassava encoding and decoding via ixset-typed
 */
export const ixset_typed_cassava = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset-typed-cassava`,
  "cassava encoding and decoding via ixset-typed",
);

/**
 * Conversions from ixset-typed to other containers
 */
export const ixset_typed_conversions = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset-typed-conversions`,
  "Conversions from ixset-typed to other containers",
);

/**
 * Hashable instance for ixset-typed
 */
export const ixset_typed_hashable_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.ixset-typed-hashable-instance`,
  "Hashable instance for ixset-typed",
);

/**
 * CLI (command line interface) to YQL
 */
export const iyql = mkPackage(
  nixRaw`pkgs.haskellPackages.iyql`,
  "CLI (command line interface) to YQL",
);

/**
 * J in Haskell
 */
export const j = mkPackage(
  nixRaw`pkgs.haskellPackages.j`,
  "J in Haskell",
);

/**
 * j2hs
 */
export const j2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.j2hs`,
  "j2hs",
);

/**
 * Extra functions I require in base
 */
export const ja_base_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ja-base-extra`,
  "Extra functions I require in base",
);

/**
 * Functional, expression-oriented data processing language
 */
export const jacinda = mkPackage(
  nixRaw`pkgs.haskellPackages.jacinda`,
  "Functional, expression-oriented data processing language",
);

/**
 * Bindings for the JACK Audio Connection Kit
 */
export const jack = mkPackage(
  nixRaw`pkgs.haskellPackages.jack`,
  "Bindings for the JACK Audio Connection Kit",
);

/**
 * Jack, zonal, and Schur polynomials
 */
export const jackpolynomials = mkPackage(
  nixRaw`pkgs.haskellPackages.jackpolynomials`,
  "Jack, zonal, and Schur polynomials",
);

/**
 * Neville Theta Functions and Jacobi Elliptic Functions
 */
export const jacobi_elliptic = mkPackage(
  nixRaw`pkgs.haskellPackages.jacobi-elliptic`,
  "Neville Theta Functions and Jacobi Elliptic Functions",
);

/**
 * Jacobi Theta Functions
 */
export const jacobi_theta = mkPackage(
  nixRaw`pkgs.haskellPackages.jacobi-theta`,
  "Jacobi Theta Functions",
);

/**
 * Strip version restrictions from Cabal files
 */
export const jailbreak_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.jailbreak-cabal`,
  "Strip version restrictions from Cabal files",
);

/**
 * Jalaali calendar systems
 */
export const jalaali = mkPackage(
  nixRaw`pkgs.haskellPackages.jalaali`,
  "Jalaali calendar systems",
);

/**
 * Data type of Japanese Calendar (Wareki)
 */
export const japanese_calendar = mkPackage(
  nixRaw`pkgs.haskellPackages.japanese-calendar`,
  "Data type of Japanese Calendar (Wareki)",
);

/**
 * Japanese holidays utility
 */
export const japanese_holidays = mkPackage(
  nixRaw`pkgs.haskellPackages.japanese-holidays`,
  "Japanese holidays utility",
);

/**
 * Utilities for working with the java-bridge package
 */
export const java_bridge_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.java-bridge-extras`,
  "Utilities for working with the java-bridge package",
);

/**
 * Functions to simulate Java's Character class
 */
export const java_character = mkPackage(
  nixRaw`pkgs.haskellPackages.java-character`,
  "Functions to simulate Java's Character class",
);

/**
 * The etude of the Haskell programming
 */
export const java_poker = mkPackage(
  nixRaw`pkgs.haskellPackages.java-poker`,
  "The etude of the Haskell programming",
);

/**
 * Tools for reflecting on Java classes
 */
export const java_reflect = mkPackage(
  nixRaw`pkgs.haskellPackages.java-reflect`,
  "Tools for reflecting on Java classes",
);

/**
 * Java class files
 */
export const javaclass = mkPackage(
  nixRaw`pkgs.haskellPackages.javaclass`,
  "Java class files",
);

/**
 * Extra javascript functions when using GHCJS
 */
export const javascript_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.javascript-extras`,
  "Extra javascript functions when using GHCJS",
);

/**
 * A utility to print the SourceFile attribute of one or more Java class files
 */
export const javasf = mkPackage(
  nixRaw`pkgs.haskellPackages.javasf`,
  "A utility to print the SourceFile attribute of one or more Java class files",
);

/**
 * Extract all JavaScript from an HTML page and consolidate it in one script
 */
export const jespresso = mkPackage(
  nixRaw`pkgs.haskellPackages.jespresso`,
  "Extract all JavaScript from an HTML page and consolidate it in one script",
);

export const jet = mkPackage(
  nixRaw`pkgs.haskellPackages.jet`,
  "",
);

/**
 * Handle Jira wiki markup
 */
export const jira_wiki_markup = mkPackage(
  nixRaw`pkgs.haskellPackages.jira-wiki-markup`,
  "Handle Jira wiki markup",
);

/**
 * Functional sed for JSON
 */
export const jl = mkPackage(
  nixRaw`pkgs.haskellPackages.jl`,
  "Functional sed for JSON",
);

/**
 * QuasiQuotation library for programmatic generation of Javascript code
 */
export const jmacro = mkPackage(
  nixRaw`pkgs.haskellPackages.jmacro`,
  "QuasiQuotation library for programmatic generation of Javascript code",
);

/**
 * Happstack backend for jmacro-rpc
 */
export const jmacro_rpc_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.jmacro-rpc-happstack`,
  "Happstack backend for jmacro-rpc",
);

/**
 * Snap backend for jmacro-rpc
 */
export const jmacro_rpc_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.jmacro-rpc-snap`,
  "Snap backend for jmacro-rpc",
);

/**
 * Jmonkey is very restricted but handy EDSL for JavaScript
 */
export const jmonkey = mkPackage(
  nixRaw`pkgs.haskellPackages.jmonkey`,
  "Jmonkey is very restricted but handy EDSL for JavaScript",
);

/**
 * A job queue library
 */
export const jobqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.jobqueue`,
  "A job queue library",
);

/**
 * A library for creating a jobs management website running custom jobs
 */
export const jobs_ui = mkPackage(
  nixRaw`pkgs.haskellPackages.jobs-ui`,
  "A library for creating a jobs management website running custom jobs",
);

/**
 * Parallel Join Patterns with Guards and Propagation
 */
export const join = mkPackage(
  nixRaw`pkgs.haskellPackages.join`,
  "Parallel Join Patterns with Guards and Propagation",
);

/**
 * Trying to compose non-composable
 */
export const joint = mkPackage(
  nixRaw`pkgs.haskellPackages.joint`,
  "Trying to compose non-composable",
);

/**
 * Geographical Position Calculations
 */
export const jord = mkPackage(
  nixRaw`pkgs.haskellPackages.jord`,
  "Geographical Position Calculations",
);

/**
 * OpenAPI Definitions for Jordan, Automatically
 */
export const jordan_openapi = mkPackage(
  nixRaw`pkgs.haskellPackages.jordan-openapi`,
  "OpenAPI Definitions for Jordan, Automatically",
);

/**
 * Servant Combinators for Jordan
 */
export const jordan_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.jordan-servant`,
  "Servant Combinators for Jordan",
);

/**
 * Servant Client Instances for Jordan Servant Types
 */
export const jordan_servant_client = mkPackage(
  nixRaw`pkgs.haskellPackages.jordan-servant-client`,
  "Servant Client Instances for Jordan Servant Types",
);

/**
 * OpenAPI schemas for Jordan-Powered Servant APIs
 */
export const jordan_servant_openapi = mkPackage(
  nixRaw`pkgs.haskellPackages.jordan-servant-openapi`,
  "OpenAPI schemas for Jordan-Powered Servant APIs",
);

/**
 * Servers for Jordan-Based Servant Combinators
 */
export const jordan_servant_server = mkPackage(
  nixRaw`pkgs.haskellPackages.jordan-servant-server`,
  "Servers for Jordan-Based Servant Combinators",
);

/**
 * JSON Object Signing and Encryption (JOSE) and JSON Web Token (JWT) library
 */
export const jose = mkPackage(
  nixRaw`pkgs.haskellPackages.jose`,
  "JSON Object Signing and Encryption (JOSE) and JSON Web Token (JWT) library",
);

/**
 * JSON Object Signing and Encryption Library
 */
export const jose_jwt = mkPackage(
  nixRaw`pkgs.haskellPackages.jose-jwt`,
  "JSON Object Signing and Encryption Library",
);

/**
 * Tiny markdown notebook
 */
export const jot = mkPackage(
  nixRaw`pkgs.haskellPackages.jot`,
  "Tiny markdown notebook",
);

/**
 * Stream logs using journalctl
 */
export const journalctl_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.journalctl-stream`,
  "Stream logs using journalctl",
);

/**
 * Ephemerides for solar system objects from the JPL Horizons service
 */
export const jpl_horizons_api = mkPackage(
  nixRaw`pkgs.haskellPackages.jpl-horizons-api`,
  "Ephemerides for solar system objects from the JPL Horizons service",
);

/**
 * Jump point search for Haskell
 */
export const jps = mkPackage(
  nixRaw`pkgs.haskellPackages.jps`,
  "Jump point search for Haskell",
);

/**
 * Obtain minified chart.js code
 */
export const js_chart = mkPackage(
  nixRaw`pkgs.haskellPackages.js-chart`,
  "Obtain minified chart.js code",
);

/**
 * Obtain minified jquery.dgtable code
 */
export const js_dgtable = mkPackage(
  nixRaw`pkgs.haskellPackages.js-dgtable`,
  "Obtain minified jquery.dgtable code",
);

/**
 * Obtain minified flot code
 */
export const js_flot = mkPackage(
  nixRaw`pkgs.haskellPackages.js-flot`,
  "Obtain minified flot code",
);

/**
 * Obtain minified jQuery code
 */
export const js_jquery = mkPackage(
  nixRaw`pkgs.haskellPackages.js-jquery`,
  "Obtain minified jQuery code",
);

/**
 * Interface for JavaScript that works with GHCJS and GHC
 */
export const jsaddle = mkPackage(
  nixRaw`pkgs.haskellPackages.jsaddle`,
  "Interface for JavaScript that works with GHCJS and GHC",
);

/**
 * DOM library that uses jsaddle to support both GHCJS and GHC
 */
export const jsaddle_dom = mkPackage(
  nixRaw`pkgs.haskellPackages.jsaddle-dom`,
  "DOM library that uses jsaddle to support both GHCJS and GHC",
);

/**
 * JSaddle Hello World, an example package
 */
export const jsaddle_hello = mkPackage(
  nixRaw`pkgs.haskellPackages.jsaddle-hello`,
  "JSaddle Hello World, an example package",
);

/**
 * Interface for JavaScript that works with GHCJS and GHC
 */
export const jsaddle_webkit2gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.jsaddle-webkit2gtk`,
  "Interface for JavaScript that works with GHCJS and GHC",
);

/**
 * Interface for JavaScript that works with GHCJS and GHC
 */
export const jsaddle_webkitgtk = mkPackage(
  nixRaw`pkgs.haskellPackages.jsaddle-webkitgtk`,
  "Interface for JavaScript that works with GHCJS and GHC",
);

/**
 * High level interface for webkit-javascriptcore
 */
export const jsc = mkPackage(
  nixRaw`pkgs.haskellPackages.jsc`,
  "High level interface for webkit-javascriptcore",
);

/**
 * Javascript Monadic Writer base package
 */
export const jsmw = mkPackage(
  nixRaw`pkgs.haskellPackages.jsmw`,
  "Javascript Monadic Writer base package",
);

/**
 * Support for serialising Haskell to and from JSON
 */
export const json = mkPackage(
  nixRaw`pkgs.haskellPackages.json`,
  "Support for serialising Haskell to and from JSON",
);

/**
 * Support JSON for SQL Database
 */
export const json2_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.json2-hdbc`,
  "Support JSON for SQL Database",
);

/**
 * Defined JSON data types and function for renders JSON to string
 */
export const json2_types = mkPackage(
  nixRaw`pkgs.haskellPackages.json2-types`,
  "Defined JSON data types and function for renders JSON to string",
);

/**
 * Lossy conversion from JSON to Sugar
 */
export const json2sg = mkPackage(
  nixRaw`pkgs.haskellPackages.json2sg`,
  "Lossy conversion from JSON to Sugar",
);

/**
 * Utility to convert a file from JSON to YAML format. (deprecated)
 */
export const json2yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.json2yaml`,
  "Utility to convert a file from JSON to YAML format. (deprecated)",
);

/**
 * Serialising to and from JSON5
 */
export const json5hs = mkPackage(
  nixRaw`pkgs.haskellPackages.json5hs`,
  "Serialising to and from JSON5",
);

/**
 * Support for serialising Haskell to and from JSON
 */
export const json_0_11 = mkPackage(
  nixRaw`pkgs.haskellPackages.json_0_11`,
  "Support for serialising Haskell to and from JSON",
);

/**
 * Universal JSON AST datastructure
 */
export const json_ast = mkPackage(
  nixRaw`pkgs.haskellPackages.json-ast`,
  "Universal JSON AST datastructure",
);

/**
 * Encoders of JSON AST
 */
export const json_ast_json_encoder = mkPackage(
  nixRaw`pkgs.haskellPackages.json-ast-json-encoder`,
  "Encoders of JSON AST",
);

/**
 * Automatic type declaration for JSON input data
 */
export const json_autotype = mkPackage(
  nixRaw`pkgs.haskellPackages.json-autotype`,
  "Automatic type declaration for JSON input data",
);

/**
 * JSON parser that uses byte strings
 */
export const json_b = mkPackage(
  nixRaw`pkgs.haskellPackages.json-b`,
  "JSON parser that uses byte strings",
);

/**
 * Load JSON from files in a directory structure
 */
export const json_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.json-directory`,
  "Load JSON from files in a directory structure",
);

/**
 * Pure-Haskell utilities for dealing with JSON with the enumerator package. (deprecated)
 */
export const json_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.json-enumerator`,
  "Pure-Haskell utilities for dealing with JSON with the enumerator package. (deprecated)",
);

/**
 * JSON Feed
 */
export const json_feed = mkPackage(
  nixRaw`pkgs.haskellPackages.json-feed`,
  "JSON Feed",
);

/**
 * Incremental JSON parser with early termination and a declarative DSL
 */
export const json_incremental_decoder = mkPackage(
  nixRaw`pkgs.haskellPackages.json-incremental-decoder`,
  "Incremental JSON parser with early termination and a declarative DSL",
);

/**
 * Integration layer for "json-pointer" and "aeson"
 */
export const json_pointer_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.json-pointer-aeson`,
  "Integration layer for \"json-pointer\" and \"aeson\"",
);

/**
 * JSON Pointer extensions for Hasql
 */
export const json_pointer_hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.json-pointer-hasql`,
  "JSON Pointer extensions for Hasql",
);

/**
 * Kitchen sink for querying JSON
 */
export const json_query = mkPackage(
  nixRaw`pkgs.haskellPackages.json-query`,
  "Kitchen sink for querying JSON",
);

/**
 * Fully-featured JSON-RPC 2.0 library
 */
export const json_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.json-rpc`,
  "Fully-featured JSON-RPC 2.0 library",
);

/**
 * JSON-RPC 2.0 on the client side.
 */
export const json_rpc_client = mkPackage(
  nixRaw`pkgs.haskellPackages.json-rpc-client`,
  "JSON-RPC 2.0 on the client side.",
);

/**
 * Types and type classes for defining JSON schemas
 */
export const json_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.json-schema`,
  "Types and type classes for defining JSON schemas",
);

/**
 * Generics JSON (de)serialization using generics-sop
 */
export const json_sop = mkPackage(
  nixRaw`pkgs.haskellPackages.json-sop`,
  "Generics JSON (de)serialization using generics-sop",
);

/**
 * Elm code generate for `json-spec`
 */
export const json_spec_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.json-spec-elm`,
  "Elm code generate for `json-spec`",
);

/**
 * Generated elm code for servant APIs
 */
export const json_spec_elm_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.json-spec-elm-servant`,
  "Generated elm code for servant APIs",
);

/**
 * json-spec-openapi
 */
export const json_spec_openapi = mkPackage(
  nixRaw`pkgs.haskellPackages.json-spec-openapi`,
  "json-spec-openapi",
);

/**
 * Keep program state in JSON files
 */
export const json_state = mkPackage(
  nixRaw`pkgs.haskellPackages.json-state`,
  "Keep program state in JSON files",
);

/**
 * Incremental applicative JSON parser
 */
export const json_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.json-stream`,
  "Incremental applicative JSON parser",
);

export const json_to_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.json-to-haskell`,
  "",
);

/**
 * Effectful parsing of JSON documents
 */
export const json_togo = mkPackage(
  nixRaw`pkgs.haskellPackages.json-togo`,
  "Effectful parsing of JSON documents",
);

/**
 * Tokenize JSON
 */
export const json_tokens = mkPackage(
  nixRaw`pkgs.haskellPackages.json-tokens`,
  "Tokenize JSON",
);

/**
 * Basic types for representing JSON
 */
export const json_types = mkPackage(
  nixRaw`pkgs.haskellPackages.json-types`,
  "Basic types for representing JSON",
);

/**
 * Fast and simple JSON encoding toolkit
 */
export const jsonifier = mkPackage(
  nixRaw`pkgs.haskellPackages.jsonifier`,
  "Fast and simple JSON encoding toolkit",
);

/**
 * JSON Lines
 */
export const jsonl = mkPackage(
  nixRaw`pkgs.haskellPackages.jsonl`,
  "JSON Lines",
);

/**
 * Conduit interface to JSONL-encoded data
 */
export const jsonl_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.jsonl-conduit`,
  "Conduit interface to JSONL-encoded data",
);

/**
 * JsonLogic Evaluation
 */
export const jsonlogic = mkPackage(
  nixRaw`pkgs.haskellPackages.jsonlogic`,
  "JsonLogic Evaluation",
);

/**
 * Library to parse and execute JSONPath
 */
export const jsonpath = mkPackage(
  nixRaw`pkgs.haskellPackages.jsonpath`,
  "Library to parse and execute JSONPath",
);

/**
 * JSON to JSON Schema
 */
export const jsons_to_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.jsons-to-schema`,
  "JSON to JSON Schema",
);

/**
 * Extract substructures from JSON by following a path
 */
export const jspath = mkPackage(
  nixRaw`pkgs.haskellPackages.jspath`,
  "Extract substructures from JSON by following a path",
);

/**
 * Manage users in MariaDB >= 10.1.1
 */
export const juandelacosa = mkPackage(
  nixRaw`pkgs.haskellPackages.juandelacosa`,
  "Manage users in MariaDB >= 10.1.1",
);

/**
 * Draw and fill lines, rectangles and polygons
 */
export const juicy_draw = mkPackage(
  nixRaw`pkgs.haskellPackages.juicy-draw`,
  "Draw and fill lines, rectangles and polygons",
);

/**
 * SVG to G-Code converter
 */
export const juicy_gcode = mkPackage(
  nixRaw`pkgs.haskellPackages.juicy-gcode`,
  "SVG to G-Code converter",
);

/**
 * Nothing to see here, move along
 */
export const jump = mkPackage(
  nixRaw`pkgs.haskellPackages.jump`,
  "Nothing to see here, move along",
);

/**
 * an elementary symmetric chiffre for pragmatically protecting one's effects
 */
export const jumpthefive = mkPackage(
  nixRaw`pkgs.haskellPackages.jumpthefive`,
  "an elementary symmetric chiffre for pragmatically protecting one's effects",
);

/**
 * Producing JUnit-style XML test reports
 */
export const junit_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.junit-xml`,
  "Producing JUnit-style XML test reports",
);

/**
 * Call JVM methods from Haskell
 */
export const jvm = mkPackage(
  nixRaw`pkgs.haskellPackages.jvm`,
  "Call JVM methods from Haskell",
);

/**
 * Provides batched marshalling of values between Java and Haskell
 */
export const jvm_batching = mkPackage(
  nixRaw`pkgs.haskellPackages.jvm-batching`,
  "Provides batched marshalling of values between Java and Haskell",
);

/**
 * Expose Java iterators as streams from the streaming package
 */
export const jvm_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.jvm-streaming`,
  "Expose Java iterators as streams from the streaming package",
);

/**
 * JSON Web Token (JWT) decoding and encoding
 */
export const jwt = mkPackage(
  nixRaw`pkgs.haskellPackages.jwt`,
  "JSON Web Token (JWT) decoding and encoding",
);

/**
 * TBA
 */
export const kafka = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka`,
  "TBA",
);

/**
 * UI device events via a Kafka message broker
 */
export const kafka_device = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device`,
  "UI device events via a Kafka message broker",
);

/**
 * GLUT events via a Kafka message broker
 */
export const kafka_device_glut = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device-glut`,
  "GLUT events via a Kafka message broker",
);

/**
 * Linux joystick events via a Kafka message broker
 */
export const kafka_device_joystick = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device-joystick`,
  "Linux joystick events via a Kafka message broker",
);

/**
 * Leap Motion events via a Kafka message broker
 */
export const kafka_device_leap = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device-leap`,
  "Leap Motion events via a Kafka message broker",
);

/**
 * Linux SpaceNavigator events via a Kafka message broker
 */
export const kafka_device_spacenav = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device-spacenav`,
  "Linux SpaceNavigator events via a Kafka message broker",
);

/**
 * VRPN events via a Kafka message broker
 */
export const kafka_device_vrpn = mkPackage(
  nixRaw`pkgs.haskellPackages.kafka-device-vrpn`,
  "VRPN events via a Kafka message broker",
);

/**
 * Haskell Kaleidoscope tutorial
 */
export const kaleidoscope = mkPackage(
  nixRaw`pkgs.haskellPackages.kaleidoscope`,
  "Haskell Kaleidoscope tutorial",
);

/**
 * Kan extensions, Kan lifts, the Yoneda lemma, and (co)density (co)monads
 */
export const kan_extensions = mkPackage(
  nixRaw`pkgs.haskellPackages.kan-extensions`,
  "Kan extensions, Kan lifts, the Yoneda lemma, and (co)density (co)monads",
);

/**
 * A JavaScript push mechanism based on the comet idiom
 */
export const kansas_comet = mkPackage(
  nixRaw`pkgs.haskellPackages.kansas-comet`,
  "A JavaScript push mechanism based on the comet idiom",
);

/**
 * Kansas Lava is a hardware simulator and VHDL generator
 */
export const kansas_lava = mkPackage(
  nixRaw`pkgs.haskellPackages.kansas-lava`,
  "Kansas Lava is a hardware simulator and VHDL generator",
);

/**
 * FPGA Cores Written in Kansas Lava
 */
export const kansas_lava_cores = mkPackage(
  nixRaw`pkgs.haskellPackages.kansas-lava-cores`,
  "FPGA Cores Written in Kansas Lava",
);

/**
 * Kansas Lava support files for the Papilio FPGA board
 */
export const kansas_lava_papilio = mkPackage(
  nixRaw`pkgs.haskellPackages.kansas-lava-papilio`,
  "Kansas Lava support files for the Papilio FPGA board",
);

/**
 * Shake rules for building Kansas Lava projects
 */
export const kansas_lava_shake = mkPackage(
  nixRaw`pkgs.haskellPackages.kansas-lava-shake`,
  "Shake rules for building Kansas Lava projects",
);

/**
 * Good stateful automata
 */
export const karakuri = mkPackage(
  nixRaw`pkgs.haskellPackages.karakuri`,
  "Good stateful automata",
);

/**
 * A simple template engine, inspired by jinja2
 */
export const karver = mkPackage(
  nixRaw`pkgs.haskellPackages.karver`,
  "A simple template engine, inspired by jinja2",
);

/**
 * A structured logging framework
 */
export const katip = mkPackage(
  nixRaw`pkgs.haskellPackages.katip`,
  "A structured logging framework",
);

/**
 * Logstash backend for katip
 */
export const katip_logstash = mkPackage(
  nixRaw`pkgs.haskellPackages.katip-logstash`,
  "Logstash backend for katip",
);

/**
 * Katip scribe that logs to Rollbar
 */
export const katip_rollbar = mkPackage(
  nixRaw`pkgs.haskellPackages.katip-rollbar`,
  "Katip scribe that logs to Rollbar",
);

/**
 * WAI middleware for logging request and response info through katip
 */
export const katip_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.katip-wai`,
  "WAI middleware for logging request and response info through katip",
);

/**
 * Key-value store in single files
 */
export const kawa = mkPackage(
  nixRaw`pkgs.haskellPackages.kawa`,
  "Key-value store in single files",
);

/**
 * Fast concurrent queues much inspired by unagi-chan
 */
export const kazura_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.kazura-queue`,
  "Fast concurrent queues much inspired by unagi-chan",
);

/**
 * Rpoku spoken word programming language
 */
export const kbq_gu = mkPackage(
  nixRaw`pkgs.haskellPackages.kbq-gu`,
  "Rpoku spoken word programming language",
);

/**
 * Build profiles for kdesrc-build
 */
export const kdesrc_build_profiles = mkPackage(
  nixRaw`pkgs.haskellPackages.kdesrc-build-profiles`,
  "Build profiles for kdesrc-build",
);

/**
 * Fast and flexible k-d trees for various types of point queries
 */
export const kdt = mkPackage(
  nixRaw`pkgs.haskellPackages.kdt`,
  "Fast and flexible k-d trees for various types of point queries",
);

/**
 * DSL for creating zero-knowledge proofs
 */
export const keelung = mkPackage(
  nixRaw`pkgs.haskellPackages.keelung`,
  "DSL for creating zero-knowledge proofs",
);

/**
 * TCP keep alive implementation
 */
export const keep_alive = mkPackage(
  nixRaw`pkgs.haskellPackages.keep-alive`,
  "TCP keep alive implementation",
);

/**
 * Mutable memory locations with callbacks
 */
export const keera_callbacks = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-callbacks`,
  "Mutable memory locations with callbacks",
);

/**
 * Rapid Gtk Application Development - I18N
 */
export const keera_hails_i18n = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-i18n`,
  "Rapid Gtk Application Development - I18N",
);

/**
 * Haskell on Gtk rails - Gtk-based controller for MVC applications
 */
export const keera_hails_mvc_controller = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-controller`,
  "Haskell on Gtk rails - Gtk-based controller for MVC applications",
);

/**
 * Haskell on Gtk rails - Gtk-based global environment for MVC applications
 */
export const keera_hails_mvc_environment_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-environment-gtk`,
  "Haskell on Gtk rails - Gtk-based global environment for MVC applications",
);

/**
 * Rapid Gtk Application Development - Reactive Protected Light Models
 */
export const keera_hails_mvc_model_lightmodel = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-model-lightmodel`,
  "Rapid Gtk Application Development - Reactive Protected Light Models",
);

/**
 * Rapid Gtk Application Development - Protected Reactive Models
 */
export const keera_hails_mvc_model_protectedmodel = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-model-protectedmodel`,
  "Rapid Gtk Application Development - Protected Reactive Models",
);

/**
 * Haskell on Gtk rails - Easy handling of configuration files
 */
export const keera_hails_mvc_solutions_config = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-solutions-config`,
  "Haskell on Gtk rails - Easy handling of configuration files",
);

/**
 * Haskell on Gtk rails - Solutions to recurrent problems in Gtk applications
 */
export const keera_hails_mvc_solutions_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-solutions-gtk`,
  "Haskell on Gtk rails - Solutions to recurrent problems in Gtk applications",
);

/**
 * Haskell on Gtk rails - Generic View for MVC applications
 */
export const keera_hails_mvc_view = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-view`,
  "Haskell on Gtk rails - Generic View for MVC applications",
);

/**
 * Haskell on Gtk rails - Gtk-based View for MVC applications
 */
export const keera_hails_mvc_view_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-mvc-view-gtk`,
  "Haskell on Gtk rails - Gtk-based View for MVC applications",
);

/**
 * Reactive Haskell on Rails - CBMVars as reactive values
 */
export const keera_hails_reactive_cbmvar = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-cbmvar`,
  "Reactive Haskell on Rails - CBMVars as reactive values",
);

/**
 * Haskell on Rails - Files as Reactive Values
 */
export const keera_hails_reactive_fs = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-fs`,
  "Haskell on Rails - Files as Reactive Values",
);

/**
 * Haskell on Gtk rails - Reactive Fields for Gtk widgets
 */
export const keera_hails_reactive_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-gtk`,
  "Haskell on Gtk rails - Reactive Fields for Gtk widgets",
);

/**
 * Keera Hails Reactive bindings for HTML DOM via GHCJS
 */
export const keera_hails_reactive_htmldom = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-htmldom`,
  "Keera Hails Reactive bindings for HTML DOM via GHCJS",
);

/**
 * Haskell on Rails - Sockets as Reactive Values
 */
export const keera_hails_reactive_network = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-network`,
  "Haskell on Rails - Sockets as Reactive Values",
);

/**
 * Haskell on Rails - Polling based Readable RVs
 */
export const keera_hails_reactive_polling = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-polling`,
  "Haskell on Rails - Polling based Readable RVs",
);

/**
 * Haskell on Rails - Reactive Fields for WX widgets
 */
export const keera_hails_reactive_wx = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-wx`,
  "Haskell on Rails - Reactive Fields for WX widgets",
);

/**
 * Haskell on Rails - FRP Yampa Signal Functions as RVs
 */
export const keera_hails_reactive_yampa = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactive-yampa`,
  "Haskell on Rails - FRP Yampa Signal Functions as RVs",
);

/**
 * Reactive Haskell on Rails - Lenses applied to Reactive Values
 */
export const keera_hails_reactivelenses = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-hails-reactivelenses`,
  "Reactive Haskell on Rails - Lenses applied to Reactive Values",
);

/**
 * Get notifications when your sitting posture is inappropriate
 */
export const keera_posture = mkPackage(
  nixRaw`pkgs.haskellPackages.keera-posture`,
  "Get notifications when your sitting posture is inappropriate",
);

/**
 * Core parts of Keid engine
 */
export const keid_core = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-core`,
  "Core parts of Keid engine",
);

/**
 * Reactive Banana integration for Keid engine
 */
export const keid_frp_banana = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-frp-banana`,
  "Reactive Banana integration for Keid engine",
);

/**
 * Geometry primitives for Keid engine
 */
export const keid_geometry = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-geometry`,
  "Geometry primitives for Keid engine",
);

/**
 * GLTF loader for Keid engine
 */
export const keid_resource_gltf = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-resource-gltf`,
  "GLTF loader for Keid engine",
);

/**
 * OpenAL sound system for Keid engine
 */
export const keid_sound_openal = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-sound-openal`,
  "OpenAL sound system for Keid engine",
);

/**
 * DearImGui elements for Keid engine
 */
export const keid_ui_dearimgui = mkPackage(
  nixRaw`pkgs.haskellPackages.keid-ui-dearimgui`,
  "DearImGui elements for Keid engine",
);

/**
 * Manage and abstract your packer configurations
 */
export const kerry = mkPackage(
  nixRaw`pkgs.haskellPackages.kerry`,
  "Manage and abstract your packer configurations",
);

/**
 * Web application deployment manager, focusing on Haskell web frameworks
 */
export const keter = mkPackage(
  nixRaw`pkgs.haskellPackages.keter`,
  "Web application deployment manager, focusing on Haskell web frameworks",
);

/**
 * Data validation in Haskell made easy
 */
export const keuringsdienst = mkPackage(
  nixRaw`pkgs.haskellPackages.keuringsdienst`,
  "Data validation in Haskell made easy",
);

/**
 * a dAmn  IRC proxy
 */
export const kevin = mkPackage(
  nixRaw`pkgs.haskellPackages.kevin`,
  "a dAmn  IRC proxy",
);

/**
 * Type-safe unconstrained dynamic typing
 */
export const key = mkPackage(
  nixRaw`pkgs.haskellPackages.key`,
  "Type-safe unconstrained dynamic typing",
);

/**
 * Manage key and button states and statuses
 */
export const key_state = mkPackage(
  nixRaw`pkgs.haskellPackages.key-state`,
  "Manage key and button states and statuses",
);

/**
 * Store of values of arbitrary types
 */
export const key_vault = mkPackage(
  nixRaw`pkgs.haskellPackages.key-vault`,
  "Store of values of arbitrary types",
);

/**
 * Maps web browser keycodes to their corresponding keyboard keys
 */
export const keycode = mkPackage(
  nixRaw`pkgs.haskellPackages.keycode`,
  "Maps web browser keycodes to their corresponding keyboard keys",
);

/**
 * An abstract Handle for accessing collections in stores like Redis
 */
export const keyed_vals = mkPackage(
  nixRaw`pkgs.haskellPackages.keyed-vals`,
  "An abstract Handle for accessing collections in stores like Redis",
);

/**
 * Validate a keyed-vals Handle
 */
export const keyed_vals_hspec_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.keyed-vals-hspec-tests`,
  "Validate a keyed-vals Handle",
);

/**
 * Implements a keyed-vals Handle using in-process memory
 */
export const keyed_vals_mem = mkPackage(
  nixRaw`pkgs.haskellPackages.keyed-vals-mem`,
  "Implements a keyed-vals Handle using in-process memory",
);

/**
 * Access Redis using a keyed-vals Handle
 */
export const keyed_vals_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.keyed-vals-redis`,
  "Access Redis using a keyed-vals Handle",
);

/**
 * Tools for macOS .keylayout files
 */
export const keylayouts = mkPackage(
  nixRaw`pkgs.haskellPackages.keylayouts`,
  "Tools for macOS .keylayout files",
);

/**
 * Keyring access
 */
export const keyring = mkPackage(
  nixRaw`pkgs.haskellPackages.keyring`,
  "Keyring access",
);

/**
 * Keyed functors and containers
 */
export const keys = mkPackage(
  nixRaw`pkgs.haskellPackages.keys`,
  "Keyed functors and containers",
);

/**
 * back up a secret key securely to the cloud
 */
export const keysafe = mkPackage(
  nixRaw`pkgs.haskellPackages.keysafe`,
  "back up a secret key securely to the cloud",
);

/**
 * Managing stores of secret things
 */
export const keystore = mkPackage(
  nixRaw`pkgs.haskellPackages.keystore`,
  "Managing stores of secret things",
);

/**
 * Pure Haskell key/value store implementation
 */
export const keyvaluehash = mkPackage(
  nixRaw`pkgs.haskellPackages.keyvaluehash`,
  "Pure Haskell key/value store implementation",
);

/**
 * Extract data from a keyword-args config file format
 */
export const keyword_args = mkPackage(
  nixRaw`pkgs.haskellPackages.keyword-args`,
  "Extract data from a keyword-args config file format",
);

/**
 * A lightweight structured concurrency library
 */
export const ki = mkPackage(
  nixRaw`pkgs.haskellPackages.ki`,
  "A lightweight structured concurrency library",
);

/**
 * Adaptation of the ki library for the effectful ecosystem
 */
export const ki_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.ki-effectful`,
  "Adaptation of the ki library for the effectful ecosystem",
);

/**
 * A lightweight structured-concurrency library
 */
export const ki_unlifted = mkPackage(
  nixRaw`pkgs.haskellPackages.ki-unlifted`,
  "A lightweight structured-concurrency library",
);

/**
 * None
 */
export const kibro = mkPackage(
  nixRaw`pkgs.haskellPackages.kibro`,
  "None",
);

/**
 * Parser and writer for KiCad files
 */
export const kicad_data = mkPackage(
  nixRaw`pkgs.haskellPackages.kicad-data`,
  "Parser and writer for KiCad files",
);

/**
 * Process KIF iOS test logs
 */
export const kif_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.kif-parser`,
  "Process KIF iOS test logs",
);

/**
 * Boolean strong typing
 */
export const kill_bool = mkPackage(
  nixRaw`pkgs.haskellPackages.kill-bool`,
  "Boolean strong typing",
);

/**
 * Utilities to work with lists of types
 */
export const kind_apply = mkPackage(
  nixRaw`pkgs.haskellPackages.kind-apply`,
  "Utilities to work with lists of types",
);

/**
 * Generic programming in GHC style for arbitrary kinds and GADTs
 */
export const kind_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.kind-generics`,
  "Generic programming in GHC style for arbitrary kinds and GADTs",
);

/**
 * Generic programming in GHC style for arbitrary kinds and GADTs
 */
export const kind_generics_deriving = mkPackage(
  nixRaw`pkgs.haskellPackages.kind-generics-deriving`,
  "Generic programming in GHC style for arbitrary kinds and GADTs",
);

/**
 * Template Haskell support for generating `GenericK` instances
 */
export const kind_generics_th = mkPackage(
  nixRaw`pkgs.haskellPackages.kind-generics-th`,
  "Template Haskell support for generating `GenericK` instances",
);

/**
 * Type-level rationals. Like KnownNat, but for rationals.
 */
export const kind_rational = mkPackage(
  nixRaw`pkgs.haskellPackages.kind-rational`,
  "Type-level rationals. Like KnownNat, but for rationals.",
);

/**
 * Emulation of subkinds and subkind polymorphism
 */
export const kinds = mkPackage(
  nixRaw`pkgs.haskellPackages.kinds`,
  "Emulation of subkinds and subkind polymorphism",
);

/**
 * A dependency manager for Xcode (Objective-C) projects
 */
export const kit = mkPackage(
  nixRaw`pkgs.haskellPackages.kit`,
  "A dependency manager for Xcode (Objective-C) projects",
);

/**
 * Kleene algebra
 */
export const kleene = mkPackage(
  nixRaw`pkgs.haskellPackages.kleene`,
  "Kleene algebra",
);

/**
 * K-means clustering algorithm
 */
export const kmeans = mkPackage(
  nixRaw`pkgs.haskellPackages.kmeans`,
  "K-means clustering algorithm",
);

/**
 * Sequential and parallel implementations of Lloyd's algorithm
 */
export const kmeans_par = mkPackage(
  nixRaw`pkgs.haskellPackages.kmeans-par`,
  "Sequential and parallel implementations of Lloyd's algorithm",
);

/**
 * An implementation of the kmeans clustering algorithm based on the vector package
 */
export const kmeans_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.kmeans-vector`,
  "An implementation of the kmeans clustering algorithm based on the vector package",
);

/**
 * Repa-like array processing using LLVM JIT
 */
export const knead = mkPackage(
  nixRaw`pkgs.haskellPackages.knead`,
  "Repa-like array processing using LLVM JIT",
);

/**
 * Linear algebra and interpolation using LLVM JIT
 */
export const knead_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.knead-arithmetic`,
  "Linear algebra and interpolation using LLVM JIT",
);

/**
 * Ties the knot on data structures that reference each other by unique keys
 */
export const knit = mkPackage(
  nixRaw`pkgs.haskellPackages.knit`,
  "Ties the knot on data structures that reference each other by unique keys",
);

/**
 * a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc
 */
export const knit_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.knit-haskell`,
  "a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc",
);

/**
 * Memory-backed handles
 */
export const knob = mkPackage(
  nixRaw`pkgs.haskellPackages.knob`,
  "Memory-backed handles",
);

/**
 * Koji buildsystem XML-RPC API bindings
 */
export const koji = mkPackage(
  nixRaw`pkgs.haskellPackages.koji`,
  "Koji buildsystem XML-RPC API bindings",
);

/**
 * CLI tool for installing rpms directly from Fedora Koji
 */
export const koji_install = mkPackage(
  nixRaw`pkgs.haskellPackages.koji-install`,
  "CLI tool for installing rpms directly from Fedora Koji",
);

/**
 * Koji CLI tool for querying tasks and installing builds
 */
export const koji_tool = mkPackage(
  nixRaw`pkgs.haskellPackages.koji-tool`,
  "Koji CLI tool for querying tasks and installing builds",
);

/**
 * Utilities for working with many HStringTemplate templates from files
 */
export const kontrakcja_templates = mkPackage(
  nixRaw`pkgs.haskellPackages.kontrakcja-templates`,
  "Utilities for working with many HStringTemplate templates from files",
);

/**
 * The Korfu ORF Utility
 */
export const korfu = mkPackage(
  nixRaw`pkgs.haskellPackages.korfu`,
  "The Korfu ORF Utility",
);

/**
 * Extracts values from /proc/cmdline
 */
export const kparams = mkPackage(
  nixRaw`pkgs.haskellPackages.kparams`,
  "Extracts values from /proc/cmdline",
);

/**
 * A binding to the kqueue event library
 */
export const kqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.kqueue`,
  "A binding to the kqueue event library",
);

/**
 * Krank checks issue tracker link status in your source code
 */
export const krank = mkPackage(
  nixRaw`pkgs.haskellPackages.krank`,
  "Krank checks issue tracker link status in your source code",
);

/**
 * Kolmogorov distribution and Kolmogorov-Smirnov test
 */
export const ks_test = mkPackage(
  nixRaw`pkgs.haskellPackages.ks-test`,
  "Kolmogorov distribution and Kolmogorov-Smirnov test",
);

/**
 * System management tooling
 */
export const ksystools = mkPackage(
  nixRaw`pkgs.haskellPackages.ksystools`,
  "System management tooling",
);

/**
 * Khronos texture format
 */
export const ktx_codec = mkPackage(
  nixRaw`pkgs.haskellPackages.ktx-codec`,
  "Khronos texture format",
);

/**
 * Client library for Kubernetes
 */
export const kubernetes_client = mkPackage(
  nixRaw`pkgs.haskellPackages.kubernetes-client`,
  "Client library for Kubernetes",
);

/**
 * Generator for Boilerplate KURE Combinators
 */
export const kure_your_boilerplate = mkPackage(
  nixRaw`pkgs.haskellPackages.kure-your-boilerplate`,
  "Generator for Boilerplate KURE Combinators",
);

/**
 * Find the alpha emoji
 */
export const kurita = mkPackage(
  nixRaw`pkgs.haskellPackages.kurita`,
  "Find the alpha emoji",
);

/**
 * Key/Value Indexed Table container and formatting library
 */
export const kvitable = mkPackage(
  nixRaw`pkgs.haskellPackages.kvitable`,
  "Key/Value Indexed Table container and formatting library",
);

/**
 * Mid level bindings to Kyoto Cabinet
 */
export const kyotocabinet = mkPackage(
  nixRaw`pkgs.haskellPackages.kyotocabinet`,
  "Mid level bindings to Kyoto Cabinet",
);

/**
 * Labeled tree structure
 */
export const labeled_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.labeled-tree`,
  "Labeled tree structure",
);

/**
 * Anonymous records via named tuples
 */
export const labels = mkPackage(
  nixRaw`pkgs.haskellPackages.labels`,
  "Anonymous records via named tuples",
);

/**
 * an experiment management framework
 */
export const laborantin_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.laborantin-hs`,
  "an experiment management framework",
);

/**
 * LabSat TCP Interface Wrapper
 */
export const labsat = mkPackage(
  nixRaw`pkgs.haskellPackages.labsat`,
  "LabSat TCP Interface Wrapper",
);

/**
 * A complicated turn-based game
 */
export const labyrinth = mkPackage(
  nixRaw`pkgs.haskellPackages.labyrinth`,
  "A complicated turn-based game",
);

/**
 * A complicated turn-based game - Web server
 */
export const labyrinth_server = mkPackage(
  nixRaw`pkgs.haskellPackages.labyrinth-server`,
  "A complicated turn-based game - Web server",
);

/**
 * Generate Ruby clients from Servant APIs
 */
export const lackey = mkPackage(
  nixRaw`pkgs.haskellPackages.lackey`,
  "Generate Ruby clients from Servant APIs",
);

/**
 * fizzy n dizzy
 */
export const lacroix = mkPackage(
  nixRaw`pkgs.haskellPackages.lacroix`,
  "fizzy n dizzy",
);

/**
 * Solve Lagrange multiplier problems
 */
export const lagrangian = mkPackage(
  nixRaw`pkgs.haskellPackages.lagrangian`,
  "Solve Lagrange multiplier problems",
);

/**
 * Minimalistic type-checked compile-time template engine
 */
export const laika = mkPackage(
  nixRaw`pkgs.haskellPackages.laika`,
  "Minimalistic type-checked compile-time template engine",
);

/**
 * Interpreters for lambda calculus, calculus of constructions, and more
 */
export const lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda`,
  "Interpreters for lambda calculus, calculus of constructions, and more",
);

/**
 * RSS 2.0 feed generator
 */
export const lambdaFeed = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdaFeed`,
  "RSS 2.0 feed generator",
);

/**
 * ...
 */
export const lambdaLit = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdaLit`,
  "...",
);

/**
 * Lambda Calculi Abstract Syntax Trees
 */
export const lambda_ast = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda-ast`,
  "Lambda Calculi Abstract Syntax Trees",
);

/**
 * Lambda Calculus interpreter
 */
export const lambda_calculus_interpreter = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda-calculus-interpreter`,
  "Lambda Calculus interpreter",
);

/**
 * a Paralell-DEVS implementaion based on distributed-process
 */
export const lambda_devs = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda-devs`,
  "a Paralell-DEVS implementaion based on distributed-process",
);

/**
 * Declarative command-line parser with type-driven pattern matching
 */
export const lambda_options = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda-options`,
  "Declarative command-line parser with type-driven pattern matching",
);

/**
 * A library to emulate laceholders similar to Scala
 */
export const lambda_placeholders = mkPackage(
  nixRaw`pkgs.haskellPackages.lambda-placeholders`,
  "A library to emulate laceholders similar to Scala",
);

/**
 * Lambdabot is a development tool and advanced IRC bot
 */
export const lambdabot = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot`,
  "Lambdabot is a development tool and advanced IRC bot",
);

/**
 * Lambdabot core functionality
 */
export const lambdabot_core = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-core`,
  "Lambdabot core functionality",
);

/**
 * Lambdabot Haskell plugins
 */
export const lambdabot_haskell_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-haskell-plugins`,
  "Lambdabot Haskell plugins",
);

/**
 * IRC plugins for lambdabot
 */
export const lambdabot_irc_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-irc-plugins`,
  "IRC plugins for lambdabot",
);

/**
 * Lambdabot miscellaneous plugins
 */
export const lambdabot_misc_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-misc-plugins`,
  "Lambdabot miscellaneous plugins",
);

/**
 * Novelty plugins for Lambdabot
 */
export const lambdabot_novelty_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-novelty-plugins`,
  "Novelty plugins for Lambdabot",
);

/**
 * Lambdabot reference plugins
 */
export const lambdabot_reference_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-reference-plugins`,
  "Lambdabot reference plugins",
);

/**
 * Social plugins for Lambdabot
 */
export const lambdabot_social_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-social-plugins`,
  "Social plugins for Lambdabot",
);

/**
 * Lambdabot trusted code
 */
export const lambdabot_trusted = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-trusted`,
  "Lambdabot trusted code",
);

/**
 * Lambdabot for Zulip Chat
 */
export const lambdabot_zulip = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdabot-zulip`,
  "Lambdabot for Zulip Chat",
);

/**
 * Webkit Browser
 */
export const lambdacat = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacat`,
  "Webkit Browser",
);

/**
 * LambdaCms "media" extension
 */
export const lambdacms_media = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacms-media`,
  "LambdaCms \"media\" extension",
);

/**
 * A simple lambda cube type checker
 */
export const lambdacube = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube`,
  "A simple lambda cube type checker",
);

/**
 * Example for combining LambdaCube and Bullet
 */
export const lambdacube_bullet = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-bullet`,
  "Example for combining LambdaCube and Bullet",
);

/**
 * LambdaCube 3D is a DSL to program GPUs
 */
export const lambdacube_compiler = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-compiler`,
  "LambdaCube 3D is a DSL to program GPUs",
);

/**
 * LambdaCube 3D EDSL definition
 */
export const lambdacube_edsl = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-edsl`,
  "LambdaCube 3D EDSL definition",
);

/**
 * Examples for LambdaCube
 */
export const lambdacube_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-examples`,
  "Examples for LambdaCube",
);

/**
 * OpenGL 3.3 Core Profile backend for LambdaCube 3D
 */
export const lambdacube_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-gl`,
  "OpenGL 3.3 Core Profile backend for LambdaCube 3D",
);

/**
 * Samples for LambdaCube 3D
 */
export const lambdacube_samples = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdacube-samples`,
  "Samples for LambdaCube 3D",
);

/**
 * Fpga bus core and serialization for RedPitaya
 */
export const lambdaya_bus = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdaya-bus`,
  "Fpga bus core and serialization for RedPitaya",
);

/**
 * Diff Viewer
 */
export const lambdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.lambdiff`,
  "Diff Viewer",
);

/**
 * A strange and unnecessary selective test-running library
 */
export const lame_tester = mkPackage(
  nixRaw`pkgs.haskellPackages.lame-tester`,
  "A strange and unnecessary selective test-running library",
);

/**
 * Haskell bindings for the Linux Landlock API
 */
export const landlock = mkPackage(
  nixRaw`pkgs.haskellPackages.landlock`,
  "Haskell bindings for the Linux Landlock API",
);

/**
 * A Lisp
 */
export const lang = mkPackage(
  nixRaw`pkgs.haskellPackages.lang`,
  "A Lisp",
);

/**
 * Parser, pretty-printer, and more for the Modula-2 programming language
 */
export const language_Modula2 = mkPackage(
  nixRaw`pkgs.haskellPackages.language-Modula2`,
  "Parser, pretty-printer, and more for the Modula-2 programming language",
);

/**
 * Parsing of ASN1 definitions
 */
export const language_asn1 = mkPackage(
  nixRaw`pkgs.haskellPackages.language-asn1`,
  "Parsing of ASN1 definitions",
);

/**
 * Parser and pretty-printer for ATS
 */
export const language_ats = mkPackage(
  nixRaw`pkgs.haskellPackages.language-ats`,
  "Parser and pretty-printer for ATS",
);

/**
 * Language definition and parser for AVRO files
 */
export const language_avro = mkPackage(
  nixRaw`pkgs.haskellPackages.language-avro`,
  "Language definition and parser for AVRO files",
);

/**
 * Parsing and pretty-printing Bash shell scripts
 */
export const language_bash = mkPackage(
  nixRaw`pkgs.haskellPackages.language-bash`,
  "Parsing and pretty-printing Bash shell scripts",
);

/**
 * Interpreter and language infrastructure for Boogie
 */
export const language_boogie = mkPackage(
  nixRaw`pkgs.haskellPackages.language-boogie`,
  "Interpreter and language infrastructure for Boogie",
);

/**
 * Analysis and generation of C code
 */
export const language_c = mkPackage(
  nixRaw`pkgs.haskellPackages.language-c`,
  "Analysis and generation of C code",
);

/**
 * An implementation of the C99 AST that strictly follows the standard
 */
export const language_c99 = mkPackage(
  nixRaw`pkgs.haskellPackages.language-c99`,
  "An implementation of the C99 AST that strictly follows the standard",
);

/**
 * C-like AST to simplify writing C99 programs
 */
export const language_c99_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.language-c99-simple`,
  "C-like AST to simplify writing C99 programs",
);

/**
 * Utilities for language-c99
 */
export const language_c99_util = mkPackage(
  nixRaw`pkgs.haskellPackages.language-c99-util`,
  "Utilities for language-c99",
);

/**
 * C/CUDA/OpenCL/Objective-C quasiquoting library
 */
export const language_c_quote = mkPackage(
  nixRaw`pkgs.haskellPackages.language-c-quote`,
  "C/CUDA/OpenCL/Objective-C quasiquoting library",
);

/**
 * Manipulating Common Intermediate Language AST
 */
export const language_cil = mkPackage(
  nixRaw`pkgs.haskellPackages.language-cil`,
  "Manipulating Common Intermediate Language AST",
);

/**
 * CSS 2.1 syntax
 */
export const language_css = mkPackage(
  nixRaw`pkgs.haskellPackages.language-css`,
  "CSS 2.1 syntax",
);

/**
 * A language for generative literature
 */
export const language_dickinson = mkPackage(
  nixRaw`pkgs.haskellPackages.language-dickinson`,
  "A language for generative literature",
);

/**
 * Dockerfile parser, pretty-printer and embedded DSL
 */
export const language_docker = mkPackage(
  nixRaw`pkgs.haskellPackages.language-docker`,
  "Dockerfile parser, pretty-printer and embedded DSL",
);

/**
 * Dockerfile parser, pretty-printer and embedded DSL
 */
export const language_docker_11_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.language-docker_11_0_0`,
  "Dockerfile parser, pretty-printer and embedded DSL",
);

/**
 * A library for the analysis and creation of Graphviz DOT files
 */
export const language_dot = mkPackage(
  nixRaw`pkgs.haskellPackages.language-dot`,
  "A library for the analysis and creation of Graphviz DOT files",
);

/**
 * JavaScript parser and pretty-printer library
 */
export const language_ecmascript = mkPackage(
  nixRaw`pkgs.haskellPackages.language-ecmascript`,
  "JavaScript parser and pretty-printer library",
);

/**
 * JavaScript static analysis library
 */
export const language_ecmascript_analysis = mkPackage(
  nixRaw`pkgs.haskellPackages.language-ecmascript-analysis`,
  "JavaScript static analysis library",
);

/**
 * Parser and pretty printer for the Eiffel language
 */
export const language_eiffel = mkPackage(
  nixRaw`pkgs.haskellPackages.language-eiffel`,
  "Parser and pretty printer for the Eiffel language",
);

/**
 * GLSL abstract syntax tree, parser, and pretty-printer
 */
export const language_glsl = mkPackage(
  nixRaw`pkgs.haskellPackages.language-glsl`,
  "GLSL abstract syntax tree, parser, and pretty-printer",
);

/**
 * Module to automatically extract functions from the local code
 */
export const language_haskell_extract = mkPackage(
  nixRaw`pkgs.haskellPackages.language-haskell-extract`,
  "Module to automatically extract functions from the local code",
);

/**
 * Java source manipulation
 */
export const language_java = mkPackage(
  nixRaw`pkgs.haskellPackages.language-java`,
  "Java source manipulation",
);

/**
 * Parser for JavaScript
 */
export const language_javascript = mkPackage(
  nixRaw`pkgs.haskellPackages.language-javascript`,
  "Parser for JavaScript",
);

/**
 * Parser for JavaScript
 */
export const language_javascript_0_7_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.language-javascript_0_7_0_0`,
  "Parser for JavaScript",
);

/**
 * Parser and serializer for the Kort information language
 */
export const language_kort = mkPackage(
  nixRaw`pkgs.haskellPackages.language-kort`,
  "Parser and serializer for the Kort information language",
);

/**
 * Lua parser and pretty-printer
 */
export const language_lua = mkPackage(
  nixRaw`pkgs.haskellPackages.language-lua`,
  "Lua parser and pretty-printer",
);

/**
 * A library for dealing with the Ninja build language
 */
export const language_ninja = mkPackage(
  nixRaw`pkgs.haskellPackages.language-ninja`,
  "A library for dealing with the Ninja build language",
);

/**
 * Data types and functions to represent the Nix language
 */
export const language_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.language-nix`,
  "Data types and functions to represent the Nix language",
);

/**
 * Parser, pretty-printer, and more for the Oberon programming language
 */
export const language_oberon = mkPackage(
  nixRaw`pkgs.haskellPackages.language-oberon`,
  "Parser, pretty-printer, and more for the Oberon programming language",
);

/**
 * Language definition and parser for Protocol Buffers
 */
export const language_protobuf = mkPackage(
  nixRaw`pkgs.haskellPackages.language-protobuf`,
  "Language definition and parser for Protocol Buffers",
);

/**
 * Tools to parse and evaluate the Puppet DSL
 */
export const language_puppet = mkPackage(
  nixRaw`pkgs.haskellPackages.language-puppet`,
  "Tools to parse and evaluate the Puppet DSL",
);

/**
 * Parsing and pretty printing of Python code
 */
export const language_python = mkPackage(
  nixRaw`pkgs.haskellPackages.language-python`,
  "Parsing and pretty printing of Python code",
);

/**
 * Generate coloured XHTML for Python code
 */
export const language_python_colour = mkPackage(
  nixRaw`pkgs.haskellPackages.language-python-colour`,
  "Generate coloured XHTML for Python code",
);

/**
 * testing code for the language-python library
 */
export const language_python_test = mkPackage(
  nixRaw`pkgs.haskellPackages.language-python-test`,
  "testing code for the language-python library",
);

/**
 * Utilities for working with the Qux language
 */
export const language_qux = mkPackage(
  nixRaw`pkgs.haskellPackages.language-qux`,
  "Utilities for working with the Qux language",
);

/**
 * AST and parser for the ZeroC Slice language (Specification language for ICE)
 */
export const language_slice = mkPackage(
  nixRaw`pkgs.haskellPackages.language-slice`,
  "AST and parser for the ZeroC Slice language (Specification language for ICE)",
);

/**
 * Various tools to detect/correct mistakes in words
 */
export const language_spelling = mkPackage(
  nixRaw`pkgs.haskellPackages.language-spelling`,
  "Various tools to detect/correct mistakes in words",
);

/**
 * Parser and pretty printer for the Thrift IDL format
 */
export const language_thrift = mkPackage(
  nixRaw`pkgs.haskellPackages.language-thrift`,
  "Parser and pretty printer for the Thrift IDL format",
);

/**
 * A Parser for the Type Language
 */
export const language_tl = mkPackage(
  nixRaw`pkgs.haskellPackages.language-tl`,
  "A Parser for the Type Language",
);

/**
 * A set of tools for analyzing languages via logic and automata
 */
export const language_toolkit = mkPackage(
  nixRaw`pkgs.haskellPackages.language-toolkit`,
  "A set of tools for analyzing languages via logic and automata",
);

/**
 * VHDL AST and pretty printer in Haskell
 */
export const language_vhdl = mkPackage(
  nixRaw`pkgs.haskellPackages.language-vhdl`,
  "VHDL AST and pretty printer in Haskell",
);

/**
 * Numerical Linear Algebra using LAPACK
 */
export const lapack = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack`,
  "Numerical Linear Algebra using LAPACK",
);

/**
 * Auto-generated interface to Fortran LAPACK via CArrays
 */
export const lapack_carray = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack-carray`,
  "Auto-generated interface to Fortran LAPACK via CArrays",
);

/**
 * Auto-generated interface to Fortran LAPACK via comfort-array
 */
export const lapack_comfort_array = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack-comfort-array`,
  "Auto-generated interface to Fortran LAPACK via comfort-array",
);

/**
 * Auto-generated interface to Fortran LAPACK
 */
export const lapack_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack-ffi`,
  "Auto-generated interface to Fortran LAPACK",
);

/**
 * Generator for Haskell interface to Fortran LAPACK
 */
export const lapack_ffi_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack-ffi-tools`,
  "Generator for Haskell interface to Fortran LAPACK",
);

/**
 * Conversion of objects between 'lapack' and 'hmatrix'
 */
export const lapack_hmatrix = mkPackage(
  nixRaw`pkgs.haskellPackages.lapack-hmatrix`,
  "Conversion of objects between 'lapack' and 'hmatrix'",
);

/**
 * Scalable anonymous records
 */
export const large_anon = mkPackage(
  nixRaw`pkgs.haskellPackages.large-anon`,
  "Scalable anonymous records",
);

/**
 * Efficient compilation for large records, linear in the size of the record
 */
export const large_records = mkPackage(
  nixRaw`pkgs.haskellPackages.large-records`,
  "Efficient compilation for large records, linear in the size of the record",
);

/**
 * Provides Word128, Word192 and Word256 and a way of producing other large words if required
 */
export const largeword = mkPackage(
  nixRaw`pkgs.haskellPackages.largeword`,
  "Provides Word128, Word192 and Word256 and a way of producing other large words if required",
);

/**
 * A high-powered, single-pass tree parser
 */
export const lasercutter = mkPackage(
  nixRaw`pkgs.haskellPackages.lasercutter`,
  "A high-powered, single-pass tree parser",
);

/**
 * Tool to track security alerts on LWN
 */
export const lat = mkPackage(
  nixRaw`pkgs.haskellPackages.lat`,
  "Tool to track security alerts on LWN",
);

/**
 * Parse, format and process LaTeX files
 */
export const latex = mkPackage(
  nixRaw`pkgs.haskellPackages.latex`,
  "Parse, format and process LaTeX files",
);

/**
 * Use actual LaTeX to render formulae inside Hakyll pages
 */
export const latex_formulae_hakyll = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-formulae-hakyll`,
  "Use actual LaTeX to render formulae inside Hakyll pages",
);

/**
 * Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation
 */
export const latex_formulae_pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-formulae-pandoc`,
  "Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation",
);

/**
 * Function table specifications in latex
 */
export const latex_function_tables = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-function-tables`,
  "Function table specifications in latex",
);

/**
 * Automatically inline Haskell snippets into LaTeX documents
 */
export const latex_live_snippets = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-live-snippets`,
  "Automatically inline Haskell snippets into LaTeX documents",
);

/**
 * Use actual LaTeX to render formulae inside Hakyll pages
 */
export const latex_svg_hakyll = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-svg-hakyll`,
  "Use actual LaTeX to render formulae inside Hakyll pages",
);

/**
 * Render LaTeX formulae in pandoc documents to images with an actual LaTeX
 */
export const latex_svg_pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.latex-svg-pandoc`,
  "Render LaTeX formulae in pandoc documents to images with an actual LaTeX",
);

/**
 * Fine-grained library for constructing and manipulating lattices
 */
export const lattices = mkPackage(
  nixRaw`pkgs.haskellPackages.lattices`,
  "Fine-grained library for constructing and manipulating lattices",
);

/**
 * Fine-grained library for constructing and manipulating lattices
 */
export const lattices_2_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.lattices_2_2`,
  "Fine-grained library for constructing and manipulating lattices",
);

/**
 * LaunchDarkly Server-Side SDK - Redis Integration
 */
export const launchdarkly_server_sdk_redis_hedis = mkPackage(
  nixRaw`pkgs.haskellPackages.launchdarkly-server-sdk-redis-hedis`,
  "LaunchDarkly Server-Side SDK - Redis Integration",
);

/**
 * Assert the lawfulness of your typeclass instances
 */
export const lawful = mkPackage(
  nixRaw`pkgs.haskellPackages.lawful`,
  "Assert the lawfulness of your typeclass instances",
);

/**
 * Hedgehog support for lawful-classes
 */
export const lawful_classes_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.lawful-classes-hedgehog`,
  "Hedgehog support for lawful-classes",
);

/**
 * QuickCheck support for lawful-classes
 */
export const lawful_classes_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.lawful-classes-quickcheck`,
  "QuickCheck support for lawful-classes",
);

/**
 * Types for lawful-classes
 */
export const lawful_classes_types = mkPackage(
  nixRaw`pkgs.haskellPackages.lawful-classes-types`,
  "Types for lawful-classes",
);

/**
 * Common mathematical laws
 */
export const lawz = mkPackage(
  nixRaw`pkgs.haskellPackages.lawz`,
  "Common mathematical laws",
);

/**
 * Lax arrows
 */
export const lax = mkPackage(
  nixRaw`pkgs.haskellPackages.lax`,
  "Lax arrows",
);

/**
 * Layered Graph Drawing after Sugiyama
 */
export const layered_graph_drawing = mkPackage(
  nixRaw`pkgs.haskellPackages.layered-graph-drawing`,
  "Layered Graph Drawing after Sugiyama",
);

/**
 * Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.
 */
export const layered_state = mkPackage(
  nixRaw`pkgs.haskellPackages.layered-state`,
  "Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.",
);

/**
 * A prototypical 2d platform game
 */
export const layers_game = mkPackage(
  nixRaw`pkgs.haskellPackages.layers-game`,
  "A prototypical 2d platform game",
);

/**
 * General layouting library. Currently supports layouting 2D areas and can be used as a backend for text pretty printing or automatic windows layouting managers.
 */
export const layouting = mkPackage(
  nixRaw`pkgs.haskellPackages.layouting`,
  "General layouting library. Currently supports layouting 2D areas and can be used as a backend for text pretty printing or automatic windows layouting managers.",
);

/**
 * Explicit laziness for Haskell
 */
export const lazy = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy`,
  "Explicit laziness for Haskell",
);

/**
 * Asynchronous actions that don't start right away
 */
export const lazy_async = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-async`,
  "Asynchronous actions that don't start right away",
);

/**
 * A bracket with lazy resource allocation
 */
export const lazy_bracket = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-bracket`,
  "A bracket with lazy resource allocation",
);

/**
 * Library for caching IO action that leverages on GHC RTS implementation
 */
export const lazy_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-cache`,
  "Library for caching IO action that leverages on GHC RTS implementation",
);

/**
 * Efficient lazy parsers for CSV (comma-separated values)
 */
export const lazy_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-csv`,
  "Efficient lazy parsers for CSV (comma-separated values)",
);

/**
 * Storing computed values for re-use when the same program runs again
 */
export const lazy_hash_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-hash-cache`,
  "Storing computed values for re-use when the same program runs again",
);

/**
 * Lazy IO
 */
export const lazy_io = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-io`,
  "Lazy IO",
);

/**
 * Get lazy with your io-streams
 */
export const lazy_io_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-io-streams`,
  "Get lazy with your io-streams",
);

/**
 * Finds values satisfying a lazy predicate
 */
export const lazy_search = mkPackage(
  nixRaw`pkgs.haskellPackages.lazy-search`,
  "Finds values satisfying a lazy predicate",
);

/**
 * Run IO actions lazily while respecting their order
 */
export const lazyio = mkPackage(
  nixRaw`pkgs.haskellPackages.lazyio`,
  "Run IO actions lazily while respecting their order",
);

/**
 * A library for demand-driven testing of Haskell programs
 */
export const lazysmallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.lazysmallcheck`,
  "A library for demand-driven testing of Haskell programs",
);

/**
 * Differential solving with lazy splines
 */
export const lazysplines = mkPackage(
  nixRaw`pkgs.haskellPackages.lazysplines`,
  "Differential solving with lazy splines",
);

/**
 * L-BFGS optimization
 */
export const lbfgs = mkPackage(
  nixRaw`pkgs.haskellPackages.lbfgs`,
  "L-BFGS optimization",
);

/**
 * O(log n) persistent online lowest common ancestor search without preprocessing
 */
export const lca = mkPackage(
  nixRaw`pkgs.haskellPackages.lca`,
  "O(log n) persistent online lowest common ancestor search without preprocessing",
);

/**
 * Online Latent Dirichlet Allocation
 */
export const lda = mkPackage(
  nixRaw`pkgs.haskellPackages.lda`,
  "Online Latent Dirichlet Allocation",
);

/**
 * Pure Haskell LDAP Client Library
 */
export const ldap_client = mkPackage(
  nixRaw`pkgs.haskellPackages.ldap-client`,
  "Pure Haskell LDAP Client Library",
);

/**
 * Pure Haskell LDAP Client Library
 */
export const ldap_client_og = mkPackage(
  nixRaw`pkgs.haskellPackages.ldap-client-og`,
  "Pure Haskell LDAP Client Library",
);

/**
 * See README for synopsis
 */
export const ldap_scim_bridge = mkPackage(
  nixRaw`pkgs.haskellPackages.ldap-scim-bridge`,
  "See README for synopsis",
);

/**
 * LDIF idempotent apply tool
 */
export const ldapply = mkPackage(
  nixRaw`pkgs.haskellPackages.ldapply`,
  "LDIF idempotent apply tool",
);

/**
 * Datatypes and Aeson instances for parsing LDtk
 */
export const ldtk_types = mkPackage(
  nixRaw`pkgs.haskellPackages.ldtk-types`,
  "Datatypes and Aeson instances for parsing LDtk",
);

/**
 * Robust space leak, and its strictification
 */
export const leaky = mkPackage(
  nixRaw`pkgs.haskellPackages.leaky`,
  "Robust space leak, and its strictification",
);

/**
 * Bonds to Lean theorem prover
 */
export const lean = mkPackage(
  nixRaw`pkgs.haskellPackages.lean`,
  "Bonds to Lean theorem prover",
);

/**
 * A maximally lazy, simple implementation of the Peano numbers with minimal dependencies
 */
export const lean_peano = mkPackage(
  nixRaw`pkgs.haskellPackages.lean-peano`,
  "A maximally lazy, simple implementation of the Peano numbers with minimal dependencies",
);

/**
 * Enumerative property-based testing
 */
export const leancheck = mkPackage(
  nixRaw`pkgs.haskellPackages.leancheck`,
  "Enumerative property-based testing",
);

/**
 * listable instances for small enum types
 */
export const leancheck_enum_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.leancheck-enum-instances`,
  "listable instances for small enum types",
);

/**
 * Common LeanCheck instances
 */
export const leancheck_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.leancheck-instances`,
  "Common LeanCheck instances",
);

/**
 * LeanKit API
 */
export const leankit_api = mkPackage(
  nixRaw`pkgs.haskellPackages.leankit-api`,
  "LeanKit API",
);

/**
 * Types for the Leanpub API
 */
export const leanpub_concepts = mkPackage(
  nixRaw`pkgs.haskellPackages.leanpub-concepts`,
  "Types for the Leanpub API",
);

/**
 * Use the Leanpub API via Wreq
 */
export const leanpub_wreq = mkPackage(
  nixRaw`pkgs.haskellPackages.leanpub-wreq`,
  "Use the Leanpub API via Wreq",
);

/**
 * Leap seconds announced at library release time
 */
export const leapseconds_announced = mkPackage(
  nixRaw`pkgs.haskellPackages.leapseconds-announced`,
  "Leap seconds announced at library release time",
);

/**
 * Haskell code for learning physics
 */
export const learn_physics = mkPackage(
  nixRaw`pkgs.haskellPackages.learn-physics`,
  "Haskell code for learning physics",
);

/**
 * Haskell code for learning physics
 */
export const learn_physics_0_6_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.learn-physics_0_6_6`,
  "Haskell code for learning physics",
);

/**
 * Yet another library for hidden Markov models
 */
export const learning_hmm = mkPackage(
  nixRaw`pkgs.haskellPackages.learning-hmm`,
  "Yet another library for hidden Markov models",
);

/**
 * LEB128 encoding logic for and in Haskell
 */
export const leb128 = mkPackage(
  nixRaw`pkgs.haskellPackages.leb128`,
  "LEB128 encoding logic for and in Haskell",
);

/**
 * Signed and unsigned LEB128 codec for binary library
 */
export const leb128_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.leb128-binary`,
  "Signed and unsigned LEB128 codec for binary library",
);

/**
 * LEB128 and SLEB128 encoding
 */
export const leb128_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.leb128-cereal`,
  "LEB128 and SLEB128 encoding",
);

/**
 * left4dead-inspired roguelike
 */
export const left4deadrl = mkPackage(
  nixRaw`pkgs.haskellPackages.left4deadrl`,
  "left4dead-inspired roguelike",
);

/**
 * Distributed, stateful, homogeneous microservice framework
 */
export const legion = mkPackage(
  nixRaw`pkgs.haskellPackages.legion`,
  "Distributed, stateful, homogeneous microservice framework",
);

/**
 * A discovery service based on Legion
 */
export const legion_discovery = mkPackage(
  nixRaw`pkgs.haskellPackages.legion-discovery`,
  "A discovery service based on Legion",
);

/**
 * Client library for communicating with legion-discovery
 */
export const legion_discovery_client = mkPackage(
  nixRaw`pkgs.haskellPackages.legion-discovery-client`,
  "Client library for communicating with legion-discovery",
);

/**
 * Extra non-essential utilities for building legion applications
 */
export const legion_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.legion-extra`,
  "Extra non-essential utilities for building legion applications",
);

/**
 * Haskell IDE written in Haskell
 */
export const leksah = mkPackage(
  nixRaw`pkgs.haskellPackages.leksah`,
  "Haskell IDE written in Haskell",
);

/**
 * Metadata collection for leksah
 */
export const leksah_server = mkPackage(
  nixRaw`pkgs.haskellPackages.leksah-server`,
  "Metadata collection for leksah",
);

/**
 * Lenses, Folds and Traversals
 */
export const lens = mkPackage(
  nixRaw`pkgs.haskellPackages.lens`,
  "Lenses, Folds and Traversals",
);

/**
 * Instances to mix lens with Accelerate
 */
export const lens_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-accelerate`,
  "Instances to mix lens with Accelerate",
);

/**
 * Monadic Getters and Folds
 */
export const lens_action = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-action`,
  "Monadic Getters and Folds",
);

/**
 * Law-abiding lenses for aeson
 */
export const lens_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-aeson`,
  "Law-abiding lenses for aeson",
);

/**
 * Law-abiding lenses for aeson
 */
export const lens_aeson_1_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-aeson_1_1_3`,
  "Law-abiding lenses for aeson",
);

/**
 * A placeholder for a future lens core package
 */
export const lens_core = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-core`,
  "A placeholder for a future lens core package",
);

export const lens_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-csv`,
  "",
);

/**
 * Error handling in lens chains
 */
export const lens_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-errors`,
  "Error handling in lens chains",
);

/**
 * Lens Families
 */
export const lens_family = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-family`,
  "Lens Families",
);

/**
 * Haskell 2022 Lens Families
 */
export const lens_family_core = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-family-core`,
  "Haskell 2022 Lens Families",
);

/**
 * Generate lens-family style lenses
 */
export const lens_family_th = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-family-th`,
  "Generate lens-family style lenses",
);

/**
 * Indexed version of Plated
 */
export const lens_indexed_plated = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-indexed-plated`,
  "Indexed version of Plated",
);

/**
 * Miscellaneous lens utilities
 */
export const lens_misc = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-misc`,
  "Miscellaneous lens utilities",
);

/**
 * Helper for use with lens
 */
export const lens_named = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-named`,
  "Helper for use with lens",
);

/**
 * QuickCheck properties for lens
 */
export const lens_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-properties`,
  "QuickCheck properties for lens",
);

/**
 * Lens powered regular expression
 */
export const lens_regex = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-regex`,
  "Lens powered regular expression",
);

/**
 * A lensy interface to regular expressions
 */
export const lens_regex_pcre = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-regex-pcre`,
  "A lensy interface to regular expressions",
);

/**
 * Computing lenses generically using generics-sop
 */
export const lens_sop = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-sop`,
  "Computing lenses generically using generics-sop",
);

/**
 * Collection of missing lens utilities
 */
export const lens_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-utils`,
  "Collection of missing lens utilities",
);

/**
 * lens-compatible tools for working with witherable
 */
export const lens_witherable = mkPackage(
  nixRaw`pkgs.haskellPackages.lens-witherable`,
  "lens-compatible tools for working with witherable",
);

/**
 * frugal issue tracker
 */
export const lentil = mkPackage(
  nixRaw`pkgs.haskellPackages.lentil`,
  "frugal issue tracker",
);

/**
 * Van Laarhoven lenses
 */
export const lenz = mkPackage(
  nixRaw`pkgs.haskellPackages.lenz`,
  "Van Laarhoven lenses",
);

/**
 * mtl operations with Van Laarhoven lenses
 */
export const lenz_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.lenz-mtl`,
  "mtl operations with Van Laarhoven lenses",
);

/**
 * Haskell bindings to LevelDB
 */
export const leveldb_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.leveldb-haskell`,
  "Haskell bindings to LevelDB",
);

/**
 * Haskell bindings to LevelDB
 */
export const leveldb_haskell_fork = mkPackage(
  nixRaw`pkgs.haskellPackages.leveldb-haskell-fork`,
  "Haskell bindings to LevelDB",
);

/**
 * Calculate the edit distance between two foldables
 */
export const levenshtein = mkPackage(
  nixRaw`pkgs.haskellPackages.levenshtein`,
  "Calculate the edit distance between two foldables",
);

/**
 * Plots the results of the Levenberg-Marquardt algorithm in a chart
 */
export const levmar_chart = mkPackage(
  nixRaw`pkgs.haskellPackages.levmar-chart`,
  "Plots the results of the Levenberg-Marquardt algorithm in a chart",
);

/**
 * See README for more info
 */
export const lex_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.lex-applicative`,
  "See README for more info",
);

/**
 * Simple lexer based on applicative regular expressions
 */
export const lexer_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.lexer-applicative`,
  "Simple lexer based on applicative regular expressions",
);

/**
 * Lens GUI Toolkit
 */
export const lgtk = mkPackage(
  nixRaw`pkgs.haskellPackages.lgtk`,
  "Lens GUI Toolkit",
);

/**
 * Data structures for the Les Houches Accord
 */
export const lha = mkPackage(
  nixRaw`pkgs.haskellPackages.lha`,
  "Data structures for the Les Houches Accord",
);

/**
 * Simple spreadsheet program
 */
export const lhae = mkPackage(
  nixRaw`pkgs.haskellPackages.lhae`,
  "Simple spreadsheet program",
);

/**
 * Parser and writer for Les-Houches event files
 */
export const lhe = mkPackage(
  nixRaw`pkgs.haskellPackages.lhe`,
  "Parser and writer for Les-Houches event files",
);

/**
 * Compile lhs in bird style to md, html, hs
 */
export const lhs2html = mkPackage(
  nixRaw`pkgs.haskellPackages.lhs2html`,
  "Compile lhs in bird style to md, html, hs",
);

/**
 * Preprocessor for typesetting Haskell sources with LaTeX
 */
export const lhs2tex = mkPackage(
  nixRaw`pkgs.haskellPackages.lhs2tex`,
  "Preprocessor for typesetting Haskell sources with LaTeX",
);

/**
 * A binding to the libBF library
 */
export const libBF = mkPackage(
  nixRaw`pkgs.haskellPackages.libBF`,
  "A binding to the libBF library",
);

/**
 * Haskell interface to libarchive
 */
export const libarchive = mkPackage(
  nixRaw`pkgs.haskellPackages.libarchive`,
  "Haskell interface to libarchive",
);

/**
 * Read many archive formats with libarchive and conduit
 */
export const libarchive_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.libarchive-conduit`,
  "Read many archive formats with libarchive and conduit",
);

/**
 * Haskell bindings to libconfig
 */
export const libconfig = mkPackage(
  nixRaw`pkgs.haskellPackages.libconfig`,
  "Haskell bindings to libconfig",
);

/**
 * A library providing a parser, type checker and evaluator for CSPM
 */
export const libcspm = mkPackage(
  nixRaw`pkgs.haskellPackages.libcspm`,
  "A library providing a parser, type checker and evaluator for CSPM",
);

/**
 * A binding to libffi
 */
export const libffi = mkPackage(
  nixRaw`pkgs.haskellPackages.libffi`,
  "A binding to libffi",
);

/**
 * LibFFI interface with dynamic bidirectional type-driven binding generation
 */
export const libffi_dynamic = mkPackage(
  nixRaw`pkgs.haskellPackages.libffi-dynamic`,
  "LibFFI interface with dynamic bidirectional type-driven binding generation",
);

/**
 * A Haskell binding for libfuse-3.x
 */
export const libfuse3 = mkPackage(
  nixRaw`pkgs.haskellPackages.libfuse3`,
  "A Haskell binding for libfuse-3.x",
);

/**
 * Simple Git Wrapper
 */
export const libgit = mkPackage(
  nixRaw`pkgs.haskellPackages.libgit`,
  "Simple Git Wrapper",
);

/**
 * Store and manipulate data in a graph
 */
export const libgraph = mkPackage(
  nixRaw`pkgs.haskellPackages.libgraph`,
  "Store and manipulate data in a graph",
);

/**
 * Provides shared functionality between iserv and iserv-proxy
 */
export const libiserv_9_6_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.libiserv_9_6_3`,
  "Provides shared functionality between iserv and iserv-proxy",
);

/**
 * Lastfm API interface
 */
export const liblastfm = mkPackage(
  nixRaw`pkgs.haskellPackages.liblastfm`,
  "Lastfm API interface",
);

/**
 * Prelude based on protolude for GHC 8 and beyond
 */
export const liblawless = mkPackage(
  nixRaw`pkgs.haskellPackages.liblawless`,
  "Prelude based on protolude for GHC 8 and beyond",
);

/**
 * liblinear iteratee
 */
export const liblinear_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.liblinear-enumerator`,
  "liblinear iteratee",
);

/**
 * Haskell bindings to the C modbus library
 */
export const libmodbus = mkPackage(
  nixRaw`pkgs.haskellPackages.libmodbus`,
  "Haskell bindings to the C modbus library",
);

/**
 * Prelude based on protolude for GHC 8 and beyond
 */
export const libmolude = mkPackage(
  nixRaw`pkgs.haskellPackages.libmolude`,
  "Prelude based on protolude for GHC 8 and beyond",
);

/**
 * An MPD client library
 */
export const libmpd = mkPackage(
  nixRaw`pkgs.haskellPackages.libmpd`,
  "An MPD client library",
);

/**
 * Bindings to the nix package manager
 */
export const libnix = mkPackage(
  nixRaw`pkgs.haskellPackages.libnix`,
  "Bindings to the nix package manager",
);

/**
 * Bindings to libnotify library
 */
export const libnotify = mkPackage(
  nixRaw`pkgs.haskellPackages.libnotify`,
  "Bindings to libnotify library",
);

/**
 * FFI binding to libNVVM, a compiler SDK component from NVIDIA
 */
export const libnvvm = mkPackage(
  nixRaw`pkgs.haskellPackages.libnvvm`,
  "FFI binding to libNVVM, a compiler SDK component from NVIDIA",
);

/**
 * Raft consensus algorithm
 */
export const libraft = mkPackage(
  nixRaw`pkgs.haskellPackages.libraft`,
  "Raft consensus algorithm",
);

/**
 * Move/rename according a set of rules
 */
export const librarian = mkPackage(
  nixRaw`pkgs.haskellPackages.librarian`,
  "Move/rename according a set of rules",
);

/**
 * Bindings to the Librato API
 */
export const librato = mkPackage(
  nixRaw`pkgs.haskellPackages.librato`,
  "Bindings to the Librato API",
);

/**
 * Use Libravatar, the decentralized avatar delivery service
 */
export const libravatar = mkPackage(
  nixRaw`pkgs.haskellPackages.libravatar`,
  "Use Libravatar, the decentralized avatar delivery service",
);

/**
 * TBA
 */
export const librdkafka = mkPackage(
  nixRaw`pkgs.haskellPackages.librdkafka`,
  "TBA",
);

/**
 * Use Roman Numerals as a Numeric Datatype (sort of)
 */
export const libroman = mkPackage(
  nixRaw`pkgs.haskellPackages.libroman`,
  "Use Roman Numerals as a Numeric Datatype (sort of)",
);

/**
 * Low-level bindings to the libsodium C library
 */
export const libsodium = mkPackage(
  nixRaw`pkgs.haskellPackages.libsodium`,
  "Low-level bindings to the libsodium C library",
);

/**
 * FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)
 */
export const libssh2 = mkPackage(
  nixRaw`pkgs.haskellPackages.libssh2`,
  "FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)",
);

/**
 * Conduit wrappers for libssh2 FFI bindings (see libssh2 package)
 */
export const libssh2_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.libssh2-conduit`,
  "Conduit wrappers for libssh2 FFI bindings (see libssh2 package)",
);

/**
 * StackExchange API interface
 */
export const libstackexchange = mkPackage(
  nixRaw`pkgs.haskellPackages.libstackexchange`,
  "StackExchange API interface",
);

/**
 * Haskell bindings to libsystemd-journal
 */
export const libsystemd_journal = mkPackage(
  nixRaw`pkgs.haskellPackages.libsystemd-journal`,
  "Haskell bindings to libsystemd-journal",
);

/**
 * Haskell binding to libversion
 */
export const libversion = mkPackage(
  nixRaw`pkgs.haskellPackages.libversion`,
  "Haskell binding to libversion",
);

/**
 * FFI bindings to libvirt virtualization API (http://libvirt.org)
 */
export const libvirt_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.libvirt-hs`,
  "FFI bindings to libvirt virtualization API (http://libvirt.org)",
);

/**
 * Haskell binding for libvorbis, for decoding Ogg Vorbis audio files
 */
export const libvorbis = mkPackage(
  nixRaw`pkgs.haskellPackages.libvorbis`,
  "Haskell binding for libvorbis, for decoding Ogg Vorbis audio files",
);

/**
 * Binding to libxml2
 */
export const libxml = mkPackage(
  nixRaw`pkgs.haskellPackages.libxml`,
  "Binding to libxml2",
);

/**
 * Enumerator-based API for libXML's SAX interface
 */
export const libxml_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.libxml-enumerator`,
  "Enumerator-based API for libXML's SAX interface",
);

/**
 * Bindings for the libXML2 SAX interface
 */
export const libxml_sax = mkPackage(
  nixRaw`pkgs.haskellPackages.libxml-sax`,
  "Bindings for the libXML2 SAX interface",
);

/**
 * Low-level, streaming YAML interface
 */
export const libyaml = mkPackage(
  nixRaw`pkgs.haskellPackages.libyaml`,
  "Low-level, streaming YAML interface",
);

/**
 * Conway's Life cellular automaton
 */
export const life = mkPackage(
  nixRaw`pkgs.haskellPackages.life`,
  "Conway's Life cellular automaton",
);

/**
 * GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation
 */
export const lift_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.lift-generics`,
  "GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation",
);

/**
 * Helper methods to define `Read1`, `Read2`, `Show1`, `Show2` instances
 */
export const lift_read_show = mkPackage(
  nixRaw`pkgs.haskellPackages.lift-read-show`,
  "Helper methods to define `Read1`, `Read2`, `Show1`, `Show2` instances",
);

/**
 * Lift a type from a Typeable constraint to a Template Haskell type
 */
export const lift_type = mkPackage(
  nixRaw`pkgs.haskellPackages.lift-type`,
  "Lift a type from a Typeable constraint to a Template Haskell type",
);

/**
 * Run lifted IO operations asynchronously and wait for their results
 */
export const lifted_async = mkPackage(
  nixRaw`pkgs.haskellPackages.lifted-async`,
  "Run lifted IO operations asynchronously and wait for their results",
);

/**
 * lifted IO operations from the base library
 */
export const lifted_base = mkPackage(
  nixRaw`pkgs.haskellPackages.lifted-base`,
  "lifted IO operations from the base library",
);

/**
 * lifted IO operations from the base library
 */
export const lifted_base_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.lifted-base-tf`,
  "lifted IO operations from the base library",
);

/**
 * STM operations lifted through monad transformer stacks
 */
export const lifted_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.lifted-stm`,
  "STM operations lifted through monad transformer stacks",
);

/**
 * lifted IO operations from the threads library
 */
export const lifted_threads = mkPackage(
  nixRaw`pkgs.haskellPackages.lifted-threads`,
  "lifted IO operations from the threads library",
);

/**
 * LIFX LAN API
 */
export const lifx_lan = mkPackage(
  nixRaw`pkgs.haskellPackages.lifx-lan`,
  "LIFX LAN API",
);

/**
 * Lightweight Implementation of Generics and Dynamics
 */
export const ligd = mkPackage(
  nixRaw`pkgs.haskellPackages.ligd`,
  "Lightweight Implementation of Generics and Dynamics",
);

/**
 * Haskell client for lightning-viz REST API
 */
export const lightning_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.lightning-haskell`,
  "Haskell client for lightning-viz REST API",
);

/**
 * LightStep OpenTracing client library
 */
export const lightstep_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.lightstep-haskell`,
  "LightStep OpenTracing client library",
);

/**
 * Lighttpd configuration file tools
 */
export const lighttpd_conf = mkPackage(
  nixRaw`pkgs.haskellPackages.lighttpd-conf`,
  "Lighttpd configuration file tools",
);

/**
 * A QuasiQuoter for lighttpd configuration files
 */
export const lighttpd_conf_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.lighttpd-conf-qq`,
  "A QuasiQuoter for lighttpd configuration files",
);

/**
 * Convert between Haskell, Markdown, Literate Haskell, TeX
 */
export const lima = mkPackage(
  nixRaw`pkgs.haskellPackages.lima`,
  "Convert between Haskell, Markdown, Literate Haskell, TeX",
);

/**
 * representation of Integer Linear Programs
 */
export const limp = mkPackage(
  nixRaw`pkgs.haskellPackages.limp`,
  "representation of Integer Linear Programs",
);

/**
 * Low-dimensional matrices and vectors for graphics and physics
 */
export const lin_alg = mkPackage(
  nixRaw`pkgs.haskellPackages.lin-alg`,
  "Low-dimensional matrices and vectors for graphics and physics",
);

/**
 * L-systems in Haskell
 */
export const lindenmayer = mkPackage(
  nixRaw`pkgs.haskellPackages.lindenmayer`,
  "L-systems in Haskell",
);

/**
 * Haskell SDK for the LINE API
 */
export const line = mkPackage(
  nixRaw`pkgs.haskellPackages.line`,
  "Haskell SDK for the LINE API",
);

/**
 * Simple command-line utility to convert text into PDF
 */
export const line2pdf = mkPackage(
  nixRaw`pkgs.haskellPackages.line2pdf`,
  "Simple command-line utility to convert text into PDF",
);

/**
 * Convert newlines in text
 */
export const line_break = mkPackage(
  nixRaw`pkgs.haskellPackages.line-break`,
  "Convert newlines in text",
);

/**
 * Display the number of bytes of each line
 */
export const line_size = mkPackage(
  nixRaw`pkgs.haskellPackages.line-size`,
  "Display the number of bytes of each line",
);

/**
 * Linear Algebra
 */
export const linear = mkPackage(
  nixRaw`pkgs.haskellPackages.linear`,
  "Linear Algebra",
);

/**
 * Use SMT solvers to solve linear systems over integers and rationals
 */
export const linearEqSolver = mkPackage(
  nixRaw`pkgs.haskellPackages.linearEqSolver`,
  "Use SMT solvers to solve linear systems over integers and rationals",
);

/**
 * Lifting linear vector spaces into Accelerate
 */
export const linear_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-accelerate`,
  "Lifting linear vector spaces into Accelerate",
);

/**
 * Standard library for linear types
 */
export const linear_base = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-base`,
  "Standard library for linear types",
);

/**
 * Compute resistance of linear electrical circuits
 */
export const linear_circuit = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-circuit`,
  "Compute resistance of linear electrical circuits",
);

/**
 * A simple library for linear codes (coding theory, error correction)
 */
export const linear_code = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-code`,
  "A simple library for linear codes (coding theory, error correction)",
);

/**
 * Generic programming library for generalised deriving
 */
export const linear_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-generics`,
  "Generic programming library for generalised deriving",
);

/**
 * Generic programming library for generalised deriving
 */
export const linear_generics_0_2_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-generics_0_2_2`,
  "Generic programming library for generalised deriving",
);

/**
 * A simple grammar for building linear equations and inclusive inequalities
 */
export const linear_grammar = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-grammar`,
  "A simple grammar for building linear equations and inclusive inequalities",
);

/**
 * Linear Programming basic definitions
 */
export const linear_programming = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-programming`,
  "Linear Programming basic definitions",
);

/**
 * Build SMC morphisms using linear types
 */
export const linear_smc = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-smc`,
  "Build SMC morphisms using linear types",
);

/**
 * Linear Algebra
 */
export const linear_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.linear-tests`,
  "Linear Algebra",
);

/**
 * Makes it easy to use the linearscan register allocator with Hoopl
 */
export const linearscan_hoopl = mkPackage(
  nixRaw`pkgs.haskellPackages.linearscan-hoopl`,
  "Makes it easy to use the linearscan register allocator with Hoopl",
);

/**
 * breaks strings to fit width
 */
export const linebreak = mkPackage(
  nixRaw`pkgs.haskellPackages.linebreak`,
  "breaks strings to fit width",
);

/**
 * Use web link relation types (RFC 5988) in Haskell
 */
export const link_relations = mkPackage(
  nixRaw`pkgs.haskellPackages.link-relations`,
  "Use web link relation types (RFC 5988) in Haskell",
);

/**
 * Check for broken links in CI
 */
export const linkcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.linkcheck`,
  "Check for broken links in CI",
);

/**
 * linkchk is a network interface link ping monitor
 */
export const linkchk = mkPackage(
  nixRaw`pkgs.haskellPackages.linkchk`,
  "linkchk is a network interface link ping monitor",
);

/**
 * Combines multiple GHC Core modules into a single module
 */
export const linkcore = mkPackage(
  nixRaw`pkgs.haskellPackages.linkcore`,
  "Combines multiple GHC Core modules into a single module",
);

/**
 * Lightweight library for building HTTP API
 */
export const linnet = mkPackage(
  nixRaw`pkgs.haskellPackages.linnet`,
  "Lightweight library for building HTTP API",
);

/**
 * Aeson JSON support for Linnet
 */
export const linnet_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.linnet-aeson`,
  "Aeson JSON support for Linnet",
);

/**
 * Conduit-backed support for streaming in Linnet
 */
export const linnet_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.linnet-conduit`,
  "Conduit-backed support for streaming in Linnet",
);

/**
 * Linux capabilities Haskell data type
 */
export const linux_capabilities = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-capabilities`,
  "Linux capabilities Haskell data type",
);

/**
 * Retrieve file fragmentation information under Linux
 */
export const linux_file_extents = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-file-extents`,
  "Retrieve file fragmentation information under Linux",
);

/**
 * Retrieve file fragmentation information under Linux
 */
export const linux_file_extents_0_2_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-file-extents_0_2_0_1`,
  "Retrieve file fragmentation information under Linux",
);

/**
 * Linux fbdev (framebuffer device, /dev/fbX) utility functions
 */
export const linux_framebuffer = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-framebuffer`,
  "Linux fbdev (framebuffer device, /dev/fbX) utility functions",
);

/**
 * Thinner binding to the Linux Kernel's inotify interface
 */
export const linux_inotify = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-inotify`,
  "Thinner binding to the Linux Kernel's inotify interface",
);

/**
 * Mount and unmount filesystems
 */
export const linux_mount = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-mount`,
  "Mount and unmount filesystems",
);

/**
 * Work with linux namespaces: create new or enter existing ones
 */
export const linux_namespaces = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-namespaces`,
  "Work with linux namespaces: create new or enter existing ones",
);

/**
 * Work with linux namespaces: create new or enter existing ones
 */
export const linux_namespaces_0_1_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-namespaces_0_1_3_1`,
  "Work with linux namespaces: create new or enter existing ones",
);

/**
 * Wrapping of Linux' ptrace(2)
 */
export const linux_ptrace = mkPackage(
  nixRaw`pkgs.haskellPackages.linux-ptrace`,
  "Wrapping of Linux' ptrace(2)",
);

/**
 * Labeled IO Information Flow Control Library
 */
export const lio = mkPackage(
  nixRaw`pkgs.haskellPackages.lio`,
  "Labeled IO Information Flow Control Library",
);

/**
 * Labeled IO library
 */
export const lio_eci11 = mkPackage(
  nixRaw`pkgs.haskellPackages.lio-eci11`,
  "Labeled IO library",
);

/**
 * Labeled File System interface for LIO
 */
export const lio_fs = mkPackage(
  nixRaw`pkgs.haskellPackages.lio-fs`,
  "Labeled File System interface for LIO",
);

/**
 * RISC-V Core
 */
export const lion = mkPackage(
  nixRaw`pkgs.haskellPackages.lion`,
  "RISC-V Core",
);

/**
 * Drop-in base replacement for LiquidHaskell
 */
export const liquid_base = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-base`,
  "Drop-in base replacement for LiquidHaskell",
);

/**
 * LiquidHaskell specs for the bytestring package
 */
export const liquid_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-bytestring`,
  "LiquidHaskell specs for the bytestring package",
);

/**
 * LiquidHaskell specs for the containers package
 */
export const liquid_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-containers`,
  "LiquidHaskell specs for the containers package",
);

/**
 * Drop-in ghc-prim replacement for LiquidHaskell
 */
export const liquid_ghc_prim = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-ghc-prim`,
  "Drop-in ghc-prim replacement for LiquidHaskell",
);

/**
 * LiquidHaskell specs for the parallel package
 */
export const liquid_parallel = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-parallel`,
  "LiquidHaskell specs for the parallel package",
);

/**
 * A battery-included platform for LiquidHaskell
 */
export const liquid_platform = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-platform`,
  "A battery-included platform for LiquidHaskell",
);

/**
 * General utility modules for LiquidHaskell
 */
export const liquid_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-prelude`,
  "General utility modules for LiquidHaskell",
);

/**
 * LiquidHaskell specs for the vector package
 */
export const liquid_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.liquid-vector`,
  "LiquidHaskell specs for the vector package",
);

/**
 * Liquid Types for Haskell
 */
export const liquidhaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.liquidhaskell`,
  "Liquid Types for Haskell",
);

/**
 * Demo of Liquid Haskell integration for Cabal and Stack
 */
export const liquidhaskell_cabal_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.liquidhaskell-cabal-demo`,
  "Demo of Liquid Haskell integration for Cabal and Stack",
);

/**
 * Simple parser for LISP S-expressions
 */
export const lispparser = mkPackage(
  nixRaw`pkgs.haskellPackages.lispparser`,
  "Simple parser for LISP S-expressions",
);

/**
 * Group and delete duplicates from a list
 */
export const list_duplicate = mkPackage(
  nixRaw`pkgs.haskellPackages.list-duplicate`,
  "Group and delete duplicates from a list",
);

/**
 * Common not-so-common functions for lists
 */
export const list_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.list-extras`,
  "Common not-so-common functions for lists",
);

/**
 * Special takes and drops on lists
 */
export const list_filter = mkPackage(
  nixRaw`pkgs.haskellPackages.list-filter`,
  "Special takes and drops on lists",
);

/**
 * Functions for grouping a list into sublists
 */
export const list_grouping = mkPackage(
  nixRaw`pkgs.haskellPackages.list-grouping`,
  "Functions for grouping a list into sublists",
);

/**
 * Predicates on lists
 */
export const list_predicate = mkPackage(
  nixRaw`pkgs.haskellPackages.list-predicate`,
  "Predicates on lists",
);

/**
 * List all remote forwards for mail accounts stored in a SQL database
 */
export const list_remote_forwards = mkPackage(
  nixRaw`pkgs.haskellPackages.list-remote-forwards`,
  "List all remote forwards for mail accounts stored in a SQL database",
);

/**
 * Easily and clearly create lists with only one element in them
 */
export const list_singleton = mkPackage(
  nixRaw`pkgs.haskellPackages.list-singleton`,
  "Easily and clearly create lists with only one element in them",
);

/**
 * ListT done right
 */
export const list_t = mkPackage(
  nixRaw`pkgs.haskellPackages.list-t`,
  "ListT done right",
);

/**
 * An "attoparsec" adapter for "list-t"
 */
export const list_t_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.list-t-attoparsec`,
  "An \"attoparsec\" adapter for \"list-t\"",
);

/**
 * Streaming HTML parser
 */
export const list_t_html_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.list-t-html-parser`,
  "Streaming HTML parser",
);

/**
 * List monad transformer
 */
export const list_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.list-transformer`,
  "List monad transformer",
);

/**
 * List monad transformer
 */
export const list_transformer_1_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.list-transformer_1_1_0`,
  "List monad transformer",
);

/**
 * List-like operations for tuples
 */
export const list_tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.list-tuple`,
  "List-like operations for tuples",
);

/**
 * Witnesses for working with type-level lists
 */
export const list_witnesses = mkPackage(
  nixRaw`pkgs.haskellPackages.list-witnesses`,
  "Witnesses for working with type-level lists",
);

/**
 * A client library to the ListenBrainz project
 */
export const listenbrainz_client = mkPackage(
  nixRaw`pkgs.haskellPackages.listenbrainz-client`,
  "A client library to the ListenBrainz project",
);

/**
 * Functions for dealing with lists
 */
export const lists = mkPackage(
  nixRaw`pkgs.haskellPackages.lists`,
  "Functions for dealing with lists",
);

/**
 * Additional data and structures to some 'String'-related lists
 */
export const lists_flines = mkPackage(
  nixRaw`pkgs.haskellPackages.lists-flines`,
  "Additional data and structures to some 'String'-related lists",
);

/**
 * Safe wrappers for partial list functions, supporting MonadThrow
 */
export const listsafe = mkPackage(
  nixRaw`pkgs.haskellPackages.listsafe`,
  "Safe wrappers for partial list functions, supporting MonadThrow",
);

/**
 * Append only key-list database
 */
export const liszt = mkPackage(
  nixRaw`pkgs.haskellPackages.liszt`,
  "Append only key-list database",
);

/**
 * A simple tool for literate programming
 */
export const lit = mkPackage(
  nixRaw`pkgs.haskellPackages.lit`,
  "A simple tool for literate programming",
);

/**
 * transform literate source code to Markdown
 */
export const literatex = mkPackage(
  nixRaw`pkgs.haskellPackages.literatex`,
  "transform literate source code to Markdown",
);

/**
 * Basic logging based on monad-logger
 */
export const little_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.little-logger`,
  "Basic logging based on monad-logger",
);

/**
 * When you need just the RIO monad
 */
export const little_rio = mkPackage(
  nixRaw`pkgs.haskellPackages.little-rio`,
  "When you need just the RIO monad",
);

/**
 * Live coding of MIDI music
 */
export const live_sequencer = mkPackage(
  nixRaw`pkgs.haskellPackages.live-sequencer`,
  "Live coding of MIDI music",
);

/**
 * Purely functional sets and heaps
 */
export const llrbtree = mkPackage(
  nixRaw`pkgs.haskellPackages.llrbtree`,
  "Purely functional sets and heaps",
);

/**
 * Bindings to the LLVM compiler toolkit
 */
export const llvm = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm`,
  "Bindings to the LLVM compiler toolkit",
);

/**
 * A Haskell library for analyzing LLVM bitcode
 */
export const llvm_analysis = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-analysis`,
  "A Haskell library for analyzing LLVM bitcode",
);

/**
 * The base types for a mostly pure Haskell LLVM analysis library
 */
export const llvm_base_types = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-base-types`,
  "The base types for a mostly pure Haskell LLVM analysis library",
);

/**
 * Utilities for bindings to the LLVM compiler toolkit
 */
export const llvm_base_util = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-base-util`,
  "Utilities for bindings to the LLVM compiler toolkit",
);

/**
 * A low-level data interoperability binding for LLVM
 */
export const llvm_data_interop = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-data-interop`,
  "A low-level data interoperability binding for LLVM",
);

/**
 * Support for writing an EDSL with LLVM-JIT as target
 */
export const llvm_dsl = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-dsl`,
  "Support for writing an EDSL with LLVM-JIT as target",
);

/**
 * Processor specific intrinsics for the llvm interface
 */
export const llvm_extension = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-extension`,
  "Processor specific intrinsics for the llvm interface",
);

/**
 * Utility functions for the llvm interface
 */
export const llvm_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-extra`,
  "Utility functions for the llvm interface",
);

/**
 * Tools for maintaining the llvm-ffi package
 */
export const llvm_ffi_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-ffi-tools`,
  "Tools for maintaining the llvm-ffi package",
);

/**
 * General purpose LLVM bindings
 */
export const llvm_general = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-general`,
  "General purpose LLVM bindings",
);

/**
 * QuasiQuoting llvm code for llvm-general
 */
export const llvm_general_quote = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-general-quote`,
  "QuasiQuoting llvm code for llvm-general",
);

/**
 * A pretty printer for LLVM IR
 */
export const llvm_hs_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-hs-pretty`,
  "A pretty printer for LLVM IR",
);

/**
 * Pure Haskell LLVM functionality (no FFI)
 */
export const llvm_hs_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-hs-pure`,
  "Pure Haskell LLVM functionality (no FFI)",
);

/**
 * Generate Pkg-Config configuration file for LLVM
 */
export const llvm_pkg_config = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-pkg-config`,
  "Generate Pkg-Config configuration file for LLVM",
);

/**
 * LLVM bitcode parsing library
 */
export const llvm_pretty_bc_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-pretty-bc-parser`,
  "LLVM bitcode parsing library",
);

/**
 * Useful tools built on llvm-analysis
 */
export const llvm_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.llvm-tools`,
  "Useful tools built on llvm-analysis",
);

/**
 * Lightning MDB bindings
 */
export const lmdb = mkPackage(
  nixRaw`pkgs.haskellPackages.lmdb`,
  "Lightning MDB bindings",
);

/**
 * LMonad for Yesod integrates LMonad's IFC with Yesod web applications
 */
export const lmonad_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.lmonad-yesod`,
  "LMonad for Yesod integrates LMonad's IFC with Yesod web applications",
);

/**
 * Lightning Network Daemon (LND) client library for Haskell
 */
export const lnd_client = mkPackage(
  nixRaw`pkgs.haskellPackages.lnd-client`,
  "Lightning Network Daemon (LND) client library for Haskell",
);

/**
 * A command line tool to manage LNURL auth identities
 */
export const lnurl_authenticator = mkPackage(
  nixRaw`pkgs.haskellPackages.lnurl-authenticator`,
  "A command line tool to manage LNURL auth identities",
);

/**
 * Load environment variables from a file
 */
export const load_env = mkPackage(
  nixRaw`pkgs.haskellPackages.load-env`,
  "Load environment variables from a file",
);

/**
 * Load average parsing from /proc/loadavg and bindings to getloadavg (3)
 */
export const loadavg = mkPackage(
  nixRaw`pkgs.haskellPackages.loadavg`,
  "Load average parsing from /proc/loadavg and bindings to getloadavg (3)",
);

/**
 * Line and column positions and ranges in text files
 */
export const loc = mkPackage(
  nixRaw`pkgs.haskellPackages.loc`,
  "Line and column positions and ranges in text files",
);

/**
 * Line and column positions and ranges in text files
 */
export const loc_0_2_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.loc_0_2_0_0`,
  "Line and column positions and ranges in text files",
);

/**
 * Generalised local search within Haskell, for applications in combinatorial optimisation
 */
export const local_search = mkPackage(
  nixRaw`pkgs.haskellPackages.local-search`,
  "Generalised local search within Haskell, for applications in combinatorial optimisation",
);

/**
 * Library for localization (l10n)
 */
export const localization = mkPackage(
  nixRaw`pkgs.haskellPackages.localization`,
  "Library for localization (l10n)",
);

/**
 * GNU Gettext-based messages localization library
 */
export const localize = mkPackage(
  nixRaw`pkgs.haskellPackages.localize`,
  "GNU Gettext-based messages localization library",
);

/**
 * Location-aware variants of partial functions
 */
export const located_base = mkPackage(
  nixRaw`pkgs.haskellPackages.located-base`,
  "Location-aware variants of partial functions",
);

/**
 * Human exchangable identifiers and locators
 */
export const locators = mkPackage(
  nixRaw`pkgs.haskellPackages.locators`,
  "Human exchangable identifiers and locators",
);

/**
 * Support for precise error locations in source files (Template Haskell version)
 */
export const loch_th = mkPackage(
  nixRaw`pkgs.haskellPackages.loch-th`,
  "Support for precise error locations in source files (Template Haskell version)",
);

/**
 * Provide exclusive access to a resource using lock file
 */
export const lock_file = mkPackage(
  nixRaw`pkgs.haskellPackages.lock-file`,
  "Provide exclusive access to a resource using lock file",
);

/**
 * Very simple poll lock
 */
export const locked_poll = mkPackage(
  nixRaw`pkgs.haskellPackages.locked-poll`,
  "Very simple poll lock",
);

/**
 * Michael and Scott lock-free queues
 */
export const lockfree_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.lockfree-queue`,
  "Michael and Scott lock-free queues",
);

/**
 * set a maximum on the number of concurrent actions
 */
export const lockpool = mkPackage(
  nixRaw`pkgs.haskellPackages.lockpool`,
  "set a maximum on the number of concurrent actions",
);

/**
 * Structured logging solution with multiple backends
 */
export const log = mkPackage(
  nixRaw`pkgs.haskellPackages.log`,
  "Structured logging solution with multiple backends",
);

/**
 * A python logging style log library
 */
export const log4hs = mkPackage(
  nixRaw`pkgs.haskellPackages.log4hs`,
  "A python logging style log library",
);

/**
 * Structured logging solution (base package)
 */
export const log_base = mkPackage(
  nixRaw`pkgs.haskellPackages.log-base`,
  "Structured logging solution (base package)",
);

/**
 * Log-domain arithmetic
 */
export const log_domain = mkPackage(
  nixRaw`pkgs.haskellPackages.log-domain`,
  "Log-domain arithmetic",
);

/**
 * Syslog functions for log-effect
 */
export const log_effect_syslog = mkPackage(
  nixRaw`pkgs.haskellPackages.log-effect-syslog`,
  "Syslog functions for log-effect",
);

/**
 * Adaptation of the log library for the effectful ecosystem
 */
export const log_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.log-effectful`,
  "Adaptation of the log library for the effectful ecosystem",
);

/**
 * Structured logging solution (Elasticsearch back end)
 */
export const log_elasticsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.log-elasticsearch`,
  "Structured logging solution (Elasticsearch back end)",
);

/**
 * Structured logging solution (PostgreSQL back end)
 */
export const log_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.log-postgres`,
  "Structured logging solution (PostgreSQL back end)",
);

/**
 * Utils for working with logs
 */
export const log_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.log-utils`,
  "Utils for working with logs",
);

/**
 * Log-domain floating point numbers
 */
export const logfloat = mkPackage(
  nixRaw`pkgs.haskellPackages.logfloat`,
  "Log-domain floating point numbers",
);

/**
 * Formatting
 */
export const logfmt = mkPackage(
  nixRaw`pkgs.haskellPackages.logfmt`,
  "Formatting",
);

/**
 * Run FastLogger in a thread and direct all queued messages to it
 */
export const logger_thread = mkPackage(
  nixRaw`pkgs.haskellPackages.logger-thread`,
  "Run FastLogger in a thread and direct all queued messages to it",
);

/**
 * Simplified logging in IO for application writers
 */
export const logging = mkPackage(
  nixRaw`pkgs.haskellPackages.logging`,
  "Simplified logging in IO for application writers",
);

/**
 * A mtl-style monad transformer for general purpose & compositional logging
 */
export const logging_effect = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-effect`,
  "A mtl-style monad transformer for general purpose & compositional logging",
);

/**
 * Log messages in color
 */
export const logging_effect_colors = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-effect-colors`,
  "Log messages in color",
);

/**
 * Supplemental packages for `logging-effect`
 */
export const logging_effect_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-effect-extra`,
  "Supplemental packages for `logging-effect`",
);

/**
 * Log messages to a posix system log via logging-effect
 */
export const logging_effect_syslog = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-effect-syslog`,
  "Log messages to a posix system log via logging-effect",
);

/**
 * Simple logging abstraction that allows multiple back-ends
 */
export const logging_facade = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-facade`,
  "Simple logging abstraction that allows multiple back-ends",
);

/**
 * Journald back-end for logging-facade
 */
export const logging_facade_journald = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-facade-journald`,
  "Journald back-end for logging-facade",
);

/**
 * A logging back-end to syslog(3) for the logging-facade library
 */
export const logging_facade_syslog = mkPackage(
  nixRaw`pkgs.haskellPackages.logging-facade-syslog`,
  "A logging back-end to syslog(3) for the logging-facade library",
);

/**
 * Import, export etc. for TPTP, a syntax for first-order logic
 */
export const logic_TPTP = mkPackage(
  nixRaw`pkgs.haskellPackages.logic-TPTP`,
  "Import, export etc. for TPTP, a syntax for first-order logic",
);

/**
 * Framework for propositional and first order logic, theorem proving
 */
export const logic_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.logic-classes`,
  "Framework for propositional and first order logic, theorem proving",
);

/**
 * Simple logical constraints 'syntax-sugar' writing library
 */
export const logical_constraints = mkPackage(
  nixRaw`pkgs.haskellPackages.logical-constraints`,
  "Simple logical constraints 'syntax-sugar' writing library",
);

/**
 * A backtracking logic-programming monad
 */
export const logict = mkPackage(
  nixRaw`pkgs.haskellPackages.logict`,
  "A backtracking logic-programming monad",
);

/**
 * A backtracking logic-programming monad
 */
export const logict_0_8_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.logict_0_8_1_0`,
  "A backtracking logic-programming monad",
);

/**
 * Library for logic programming based on haskell package logict
 */
export const logict_state = mkPackage(
  nixRaw`pkgs.haskellPackages.logict-state`,
  "Library for logic programming based on haskell package logict",
);

/**
 * Log Level Datatype
 */
export const loglevel = mkPackage(
  nixRaw`pkgs.haskellPackages.loglevel`,
  "Log Level Datatype",
);

/**
 * A logging framework for Haskell
 */
export const logsink = mkPackage(
  nixRaw`pkgs.haskellPackages.logsink`,
  "A logging framework for Haskell",
);

/**
 * Logstash client library for Haskell
 */
export const logstash = mkPackage(
  nixRaw`pkgs.haskellPackages.logstash`,
  "Logstash client library for Haskell",
);

/**
 * Useful utilities for the Lojban language
 */
export const lojban = mkPackage(
  nixRaw`pkgs.haskellPackages.lojban`,
  "Useful utilities for the Lojban language",
);

/**
 * Prolog with lojban
 */
export const lojysamban = mkPackage(
  nixRaw`pkgs.haskellPackages.lojysamban`,
  "Prolog with lojban",
);

/**
 * A library for lattice cryptography
 */
export const lol = mkPackage(
  nixRaw`pkgs.haskellPackages.lol`,
  "A library for lattice cryptography",
);

/**
 * Lattice-based cryptographic applications using <https://hackage.haskell.org/package/lol lol>.
 */
export const lol_apps = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-apps`,
  "Lattice-based cryptographic applications using <https://hackage.haskell.org/package/lol lol>.",
);

/**
 * A library for benchmarking <https://hackage.haskell.org/package/lol lol>.
 */
export const lol_benches = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-benches`,
  "A library for benchmarking <https://hackage.haskell.org/package/lol lol>.",
);

/**
 * A fast C++ backend for <https://hackage.haskell.org/package/lol lol>.
 */
export const lol_cpp = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-cpp`,
  "A fast C++ backend for <https://hackage.haskell.org/package/lol lol>.",
);

/**
 * A repa backend for <https://hackage.haskell.org/package/lol lol>.
 */
export const lol_repa = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-repa`,
  "A repa backend for <https://hackage.haskell.org/package/lol lol>.",
);

/**
 * A library for testing <https://hackage.haskell.org/package/lol   >.
 */
export const lol_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-tests`,
  "A library for testing <https://hackage.haskell.org/package/lol   >.",
);

/**
 * Type inferencer for LOL ( language)
 */
export const lol_typing = mkPackage(
  nixRaw`pkgs.haskellPackages.lol-typing`,
  "Type inferencer for LOL ( language)",
);

/**
 * A minimum web dev DSL in Haskell
 */
export const loli = mkPackage(
  nixRaw`pkgs.haskellPackages.loli`,
  "A minimum web dev DSL in Haskell",
);

/**
 * Fast Brute-force search using parallelism
 */
export const longshot = mkPackage(
  nixRaw`pkgs.haskellPackages.longshot`,
  "Fast Brute-force search using parallelism",
);

/**
 * A simple text parser with decent errors
 */
export const looksee = mkPackage(
  nixRaw`pkgs.haskellPackages.looksee`,
  "A simple text parser with decent errors",
);

/**
 * Fast loops (for when GHC can't optimize forM_)
 */
export const loop = mkPackage(
  nixRaw`pkgs.haskellPackages.loop`,
  "Fast loops (for when GHC can't optimize forM_)",
);

/**
 * control-monad-loop port for effin
 */
export const loop_effin = mkPackage(
  nixRaw`pkgs.haskellPackages.loop-effin`,
  "control-monad-loop port for effin",
);

/**
 * EDSL for the Michelson Language
 */
export const lorentz = mkPackage(
  nixRaw`pkgs.haskellPackages.lorentz`,
  "EDSL for the Michelson Language",
);

/**
 * An implementation of an adictive two-player card game
 */
export const lostcities = mkPackage(
  nixRaw`pkgs.haskellPackages.lostcities`,
  "An implementation of an adictive two-player card game",
);

/**
 * Amazon Simple Workflow Service Wrapper for Work Pools
 */
export const loup = mkPackage(
  nixRaw`pkgs.haskellPackages.loup`,
  "Amazon Simple Workflow Service Wrapper for Work Pools",
);

/**
 * Low dimensional linear algebra
 */
export const lowlin = mkPackage(
  nixRaw`pkgs.haskellPackages.lowlin`,
  "Low dimensional linear algebra",
);

/**
 * An EDSL for diagrams based based on linear constraints
 */
export const lp_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.lp-diagrams`,
  "An EDSL for diagrams based based on linear constraints",
);

/**
 * LPeg  Parsing Expression Grammars For Lua
 */
export const lpeg = mkPackage(
  nixRaw`pkgs.haskellPackages.lpeg`,
  "LPeg  Parsing Expression Grammars For Lua",
);

/**
 * LPeg  Parsing Expression Grammars For Lua
 */
export const lpeg_1_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.lpeg_1_1_0`,
  "LPeg  Parsing Expression Grammars For Lua",
);

/**
 * a simple, pure LRU cache
 */
export const lrucache = mkPackage(
  nixRaw`pkgs.haskellPackages.lrucache`,
  "a simple, pure LRU cache",
);

/**
 * Combine lrucaching and haxl
 */
export const lrucaching_haxl = mkPackage(
  nixRaw`pkgs.haskellPackages.lrucaching-haxl`,
  "Combine lrucaching and haxl",
);

/**
 * List USB devices
 */
export const ls_usb = mkPackage(
  nixRaw`pkgs.haskellPackages.ls-usb`,
  "List USB devices",
);

/**
 * Haskell library for the Microsoft Language Server Protocol
 */
export const lsp = mkPackage(
  nixRaw`pkgs.haskellPackages.lsp`,
  "Haskell library for the Microsoft Language Server Protocol",
);

/**
 * Haskell library for the Microsoft Language Server Protocol
 */
export const lsp_1_4_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.lsp_1_4_0_0`,
  "Haskell library for the Microsoft Language Server Protocol",
);

/**
 * Functional test framework for LSP servers
 */
export const lsp_test = mkPackage(
  nixRaw`pkgs.haskellPackages.lsp-test`,
  "Functional test framework for LSP servers",
);

/**
 * Haskell library for the Microsoft Language Server Protocol, data types
 */
export const lsp_types = mkPackage(
  nixRaw`pkgs.haskellPackages.lsp-types`,
  "Haskell library for the Microsoft Language Server Protocol, data types",
);

/**
 * Haskell library for the Microsoft Language Server Protocol, data types
 */
export const lsp_types_1_4_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.lsp-types_1_4_0_1`,
  "Haskell library for the Microsoft Language Server Protocol, data types",
);

/**
 * Paint an L-System Grammar
 */
export const lsystem = mkPackage(
  nixRaw`pkgs.haskellPackages.lsystem`,
  "Paint an L-System Grammar",
);

/**
 * Parameterized file evaluator
 */
export const ltext = mkPackage(
  nixRaw`pkgs.haskellPackages.ltext`,
  "Parameterized file evaluator",
);

/**
 * Core functionality for LTI 1.3
 */
export const lti13 = mkPackage(
  nixRaw`pkgs.haskellPackages.lti13`,
  "Core functionality for LTI 1.3",
);

/**
 * Using linear temporal logic (LTL) to verify embedded software and hardware
 */
export const ltl = mkPackage(
  nixRaw`pkgs.haskellPackages.ltl`,
  "Using linear temporal logic (LTL) to verify embedded software and hardware",
);

/**
 * Lua, an embeddable scripting language
 */
export const lua = mkPackage(
  nixRaw`pkgs.haskellPackages.lua`,
  "Lua, an embeddable scripting language",
);

/**
 * Arbitrary instances for Lua types
 */
export const lua_arbitrary = mkPackage(
  nixRaw`pkgs.haskellPackages.lua-arbitrary`,
  "Arbitrary instances for Lua types",
);

/**
 * Library for loading Lua bytecode
 */
export const lua_bytecode = mkPackage(
  nixRaw`pkgs.haskellPackages.lua-bytecode`,
  "Library for loading Lua bytecode",
);

/**
 * Library functions for reading and writing Lua chunks
 */
export const luachunk = mkPackage(
  nixRaw`pkgs.haskellPackages.luachunk`,
  "Library functions for reading and writing Lua chunks",
);

/**
 * information operators: least upper bound (lub) and greatest lower bound (glb)
 */
export const lub = mkPackage(
  nixRaw`pkgs.haskellPackages.lub`,
  "information operators: least upper bound (lub) and greatest lower bound (glb)",
);

/**
 * Clear to write, read and edit DSL for HTML
 */
export const lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid`,
  "Clear to write, read and edit DSL for HTML",
);

/**
 * Clear to write, read and edit DSL for HTML
 */
export const lucid2 = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid2`,
  "Clear to write, read and edit DSL for HTML",
);

/**
 * Lucid2 helper for XStatic
 */
export const lucid2_xstatic = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid2-xstatic`,
  "Lucid2 helper for XStatic",
);

/**
 * Curated list of CDN imports for lucid
 */
export const lucid_cdn = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-cdn`,
  "Curated list of CDN imports for lucid",
);

/**
 * Helper functions for using lucid with colonnade
 */
export const lucid_colonnade = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-colonnade`,
  "Helper functions for using lucid with colonnade",
);

/**
 * Generate more HTML with Lucid - Bootstrap, Rdash, Vega-Lite, Leaflet JS, Email
 */
export const lucid_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-extras`,
  "Generate more HTML with Lucid - Bootstrap, Rdash, Vega-Lite, Leaflet JS, Email",
);

/**
 * Basic Zurb Foundation API in Lucid
 */
export const lucid_foundation = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-foundation`,
  "Basic Zurb Foundation API in Lucid",
);

/**
 * Use htmx in your lucid templates
 */
export const lucid_htmx = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-htmx`,
  "Use htmx in your lucid templates",
);

/**
 * DSL for SVG using lucid for HTML
 */
export const lucid_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-svg`,
  "DSL for SVG using lucid for HTML",
);

/**
 * Lucid helper for XStatic
 */
export const lucid_xstatic = mkPackage(
  nixRaw`pkgs.haskellPackages.lucid-xstatic`,
  "Lucid helper for XStatic",
);

/**
 * Server side feed aggregator/reader
 */
export const lucienne = mkPackage(
  nixRaw`pkgs.haskellPackages.lucienne`,
  "Server side feed aggregator/reader",
);

/**
 * Purely FunctionaL User Interface
 */
export const lui = mkPackage(
  nixRaw`pkgs.haskellPackages.lui`,
  "Purely FunctionaL User Interface",
);

/**
 * File locking
 */
export const lukko = mkPackage(
  nixRaw`pkgs.haskellPackages.lukko`,
  "File locking",
);

/**
 * Trek through your code forest and make logs
 */
export const lumberjack = mkPackage(
  nixRaw`pkgs.haskellPackages.lumberjack`,
  "Trek through your code forest and make logs",
);

/**
 * Luminance samples
 */
export const luminance_samples = mkPackage(
  nixRaw`pkgs.haskellPackages.luminance-samples`,
  "Luminance samples",
);

/**
 * TMVar that can be listened to
 */
export const lvar = mkPackage(
  nixRaw`pkgs.haskellPackages.lvar`,
  "TMVar that can be listened to",
);

/**
 * Parallel scheduler, LVar data structures, and infrastructure to build more
 */
export const lvish = mkPackage(
  nixRaw`pkgs.haskellPackages.lvish`,
  "Parallel scheduler, LVar data structures, and infrastructure to build more",
);

/**
 * High level Haskell bindings to LXC (Linux containers)
 */
export const lxc = mkPackage(
  nixRaw`pkgs.haskellPackages.lxc`,
  "High level Haskell bindings to LXC (Linux containers)",
);

/**
 * LZ4 compression for ByteStrings
 */
export const lz4 = mkPackage(
  nixRaw`pkgs.haskellPackages.lz4`,
  "LZ4 compression for ByteStrings",
);

/**
 * Bindings to LZ4
 */
export const lz4_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.lz4-bytes`,
  "Bindings to LZ4",
);

/**
 * LZ4 compression for conduits
 */
export const lz4_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.lz4-conduit`,
  "LZ4 compression for conduits",
);

/**
 * lz4 bindings for Haskell
 */
export const lz4_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.lz4-hs`,
  "lz4 bindings for Haskell",
);

/**
 * LZMA/XZ compression and decompression
 */
export const lzma = mkPackage(
  nixRaw`pkgs.haskellPackages.lzma`,
  "LZMA/XZ compression and decompression",
);

/**
 * liblzma C library and headers for use by LZMA bindings
 */
export const lzma_clib = mkPackage(
  nixRaw`pkgs.haskellPackages.lzma-clib`,
  "liblzma C library and headers for use by LZMA bindings",
);

/**
 * Conduit interface for lzma/xz compression
 */
export const lzma_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.lzma-conduit`,
  "Conduit interface for lzma/xz compression",
);

/**
 * Enumerator interface for lzma/xz compression
 */
export const lzma_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.lzma-enumerator`,
  "Enumerator interface for lzma/xz compression",
);

/**
 * LZMA/XZ compression and decompression (static)
 */
export const lzma_static = mkPackage(
  nixRaw`pkgs.haskellPackages.lzma-static`,
  "LZMA/XZ compression and decompression (static)",
);

/**
 * Library for talking to the mDNSResponder daemon
 */
export const mDNSResponder_client = mkPackage(
  nixRaw`pkgs.haskellPackages.mDNSResponder-client`,
  "Library for talking to the mDNSResponder daemon",
);

/**
 * Macbeth - A beautiful and minimalistic FICS client
 */
export const macbeth_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.macbeth-lib`,
  "Macbeth - A beautiful and minimalistic FICS client",
);

/**
 * Obtain the host MAC address on *NIX and Windows
 */
export const maccatcher = mkPackage(
  nixRaw`pkgs.haskellPackages.maccatcher`,
  "Obtain the host MAC address on *NIX and Windows",
);

/**
 * Plot charts as unicode strings
 */
export const machination = mkPackage(
  nixRaw`pkgs.haskellPackages.machination`,
  "Plot charts as unicode strings",
);

/**
 * Networked stream transducers
 */
export const machines = mkPackage(
  nixRaw`pkgs.haskellPackages.machines`,
  "Networked stream transducers",
);

/**
 * Machine transducers for Amazonka calls
 */
export const machines_amazonka = mkPackage(
  nixRaw`pkgs.haskellPackages.machines-amazonka`,
  "Machine transducers for Amazonka calls",
);

/**
 * Directory (system) utilities for the machines library
 */
export const machines_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.machines-directory`,
  "Directory (system) utilities for the machines library",
);

/**
 * Process (system) utilities for the machines library
 */
export const machines_process = mkPackage(
  nixRaw`pkgs.haskellPackages.machines-process`,
  "Process (system) utilities for the machines library",
);

/**
 * An API client library for Mackerel
 */
export const mackerel_client = mkPackage(
  nixRaw`pkgs.haskellPackages.mackerel-client`,
  "An API client library for Mackerel",
);

/**
 * Make a macosx app standalone deployable
 */
export const macosx_make_standalone = mkPackage(
  nixRaw`pkgs.haskellPackages.macosx-make-standalone`,
  "Make a macosx app standalone deployable",
);

/**
 * Monadic DSL for building constraint solvers using basic propagators
 */
export const mad_props = mkPackage(
  nixRaw`pkgs.haskellPackages.mad-props`,
  "Monadic DSL for building constraint solvers using basic propagators",
);

/**
 * Interface to C file/magic library
 */
export const magic = mkPackage(
  nixRaw`pkgs.haskellPackages.magic`,
  "Interface to C file/magic library",
);

/**
 * Interact with Magic Wormhole
 */
export const magic_wormhole = mkPackage(
  nixRaw`pkgs.haskellPackages.magic-wormhole`,
  "Interact with Magic Wormhole",
);

/**
 * A web framework that integrates Servant, RIO, EKG, fast-logger, wai-cli
 */
export const magicbane = mkPackage(
  nixRaw`pkgs.haskellPackages.magicbane`,
  "A web framework that integrates Servant, RIO, EKG, fast-logger, wai-cli",
);

/**
 * Compute solutions for Magico puzzle
 */
export const magico = mkPackage(
  nixRaw`pkgs.haskellPackages.magico`,
  "Compute solutions for Magico puzzle",
);

/**
 * magma is an algebraic structure
 */
export const magma = mkPackage(
  nixRaw`pkgs.haskellPackages.magma`,
  "magma is an algebraic structure",
);

/**
 * Magma-like objects
 */
export const magmas = mkPackage(
  nixRaw`pkgs.haskellPackages.magmas`,
  "Magma-like objects",
);

/**
 * ImageBoards to XMPP gate
 */
export const mahoro = mkPackage(
  nixRaw`pkgs.haskellPackages.mahoro`,
  "ImageBoards to XMPP gate",
);

/**
 * A simple static web server
 */
export const maid = mkPackage(
  nixRaw`pkgs.haskellPackages.maid`,
  "A simple static web server",
);

/**
 * Preconfigured email connection pool on top of smtp
 */
export const mail_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.mail-pool`,
  "Preconfigured email connection pool on top of smtp",
);

/**
 * A parser library for DMARC and SMTP TLS reports
 */
export const mail_reports = mkPackage(
  nixRaw`pkgs.haskellPackages.mail-reports`,
  "A parser library for DMARC and SMTP TLS reports",
);

/**
 * Count mailboxes in a SQL database
 */
export const mailbox_count = mkPackage(
  nixRaw`pkgs.haskellPackages.mailbox-count`,
  "Count mailboxes in a SQL database",
);

/**
 * API binding for Mailgun
 */
export const mailgun = mkPackage(
  nixRaw`pkgs.haskellPackages.mailgun`,
  "API binding for Mailgun",
);

/**
 * Capture stdout/stderr/exit code, and replace stdin of your main function
 */
export const main_tester = mkPackage(
  nixRaw`pkgs.haskellPackages.main-tester`,
  "Capture stdout/stderr/exit code, and replace stdin of your main function",
);

/**
 * Pretty printing designed for printing source code
 */
export const mainland_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.mainland-pretty`,
  "Pretty printing designed for printing source code",
);

/**
 * Majordomo protocol for ZeroMQ
 */
export const majordomo = mkPackage(
  nixRaw`pkgs.haskellPackages.majordomo`,
  "Majordomo protocol for ZeroMQ",
);

/**
 * Boyer-Moore Majority Vote Algorithm
 */
export const majority = mkPackage(
  nixRaw`pkgs.haskellPackages.majority`,
  "Boyer-Moore Majority Vote Algorithm",
);

/**
 * Make a cabalized package
 */
export const make_package = mkPackage(
  nixRaw`pkgs.haskellPackages.make-package`,
  "Make a cabalized package",
);

/**
 * Static Website Generator in Haskell
 */
export const mameya = mkPackage(
  nixRaw`pkgs.haskellPackages.mameya`,
  "Static Website Generator in Haskell",
);

/**
 * A monad for managed values
 */
export const managed = mkPackage(
  nixRaw`pkgs.haskellPackages.managed`,
  "A monad for managed values",
);

/**
 * Remote Management Framework
 */
export const managed_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.managed-functions`,
  "Remote Management Framework",
);

/**
 * Simple HTTP-Based Connector for Managed Functions
 */
export const managed_functions_http_connector = mkPackage(
  nixRaw`pkgs.haskellPackages.managed-functions-http-connector`,
  "Simple HTTP-Based Connector for Managed Functions",
);

/**
 * JSON Support for the Managed Functions Framework
 */
export const managed_functions_json = mkPackage(
  nixRaw`pkgs.haskellPackages.managed-functions-json`,
  "JSON Support for the Managed Functions Framework",
);

/**
 * The Haskell/Gtk+ Integrated Live Environment
 */
export const manatee = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee`,
  "The Haskell/Gtk+ Integrated Live Environment",
);

/**
 * Virtual package to install all Manatee packages
 */
export const manatee_all = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-all`,
  "Virtual package to install all Manatee packages",
);

/**
 * Multithread interactive input/search framework for Manatee
 */
export const manatee_anything = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-anything`,
  "Multithread interactive input/search framework for Manatee",
);

/**
 * Browser extension for Manatee
 */
export const manatee_browser = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-browser`,
  "Browser extension for Manatee",
);

/**
 * The core of Manatee
 */
export const manatee_core = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-core`,
  "The core of Manatee",
);

/**
 * Download Manager extension for Manatee
 */
export const manatee_curl = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-curl`,
  "Download Manager extension for Manatee",
);

/**
 * Editor extension for Manatee
 */
export const manatee_editor = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-editor`,
  "Editor extension for Manatee",
);

/**
 * File manager extension for Manatee
 */
export const manatee_filemanager = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-filemanager`,
  "File manager extension for Manatee",
);

/**
 * Image viewer extension for Manatee
 */
export const manatee_imageviewer = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-imageviewer`,
  "Image viewer extension for Manatee",
);

/**
 * IRC client extension for Manatee
 */
export const manatee_ircclient = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-ircclient`,
  "IRC client extension for Manatee",
);

/**
 * Mplayer client extension for Manatee
 */
export const manatee_mplayer = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-mplayer`,
  "Mplayer client extension for Manatee",
);

/**
 * PDF viewer extension for Manatee
 */
export const manatee_pdfviewer = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-pdfviewer`,
  "PDF viewer extension for Manatee",
);

/**
 * Process manager extension for Manatee
 */
export const manatee_processmanager = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-processmanager`,
  "Process manager extension for Manatee",
);

/**
 * Feed reader extension for Manatee
 */
export const manatee_reader = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-reader`,
  "Feed reader extension for Manatee",
);

/**
 * Template code to create Manatee application
 */
export const manatee_template = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-template`,
  "Template code to create Manatee application",
);

/**
 * Terminal Emulator extension for Manatee
 */
export const manatee_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-terminal`,
  "Terminal Emulator extension for Manatee",
);

/**
 * Welcome module to help user play Manatee quickly
 */
export const manatee_welcome = mkPackage(
  nixRaw`pkgs.haskellPackages.manatee-welcome`,
  "Welcome module to help user play Manatee quickly",
);

/**
 * Simple mancala game
 */
export const mancala = mkPackage(
  nixRaw`pkgs.haskellPackages.mancala`,
  "Simple mancala game",
);

/**
 * Library for interfacing with the Mandrill JSON API
 */
export const mandrill = mkPackage(
  nixRaw`pkgs.haskellPackages.mandrill`,
  "Library for interfacing with the Mandrill JSON API",
);

/**
 * Bindings to the MangoPay API
 */
export const mangopay = mkPackage(
  nixRaw`pkgs.haskellPackages.mangopay`,
  "Bindings to the MangoPay API",
);

/**
 * A parser for web documents according to the HTML5 specification
 */
export const mangrove = mkPackage(
  nixRaw`pkgs.haskellPackages.mangrove`,
  "A parser for web documents according to the HTML5 specification",
);

/**
 * Sampling random points on general manifolds
 */
export const manifold_random = mkPackage(
  nixRaw`pkgs.haskellPackages.manifold-random`,
  "Sampling random points on general manifolds",
);

/**
 * The basic classes for the manifolds hierarchy
 */
export const manifolds_core = mkPackage(
  nixRaw`pkgs.haskellPackages.manifolds-core`,
  "The basic classes for the manifolds hierarchy",
);

/**
 * A set of classes and instances for working with key/value mappings
 */
export const map_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.map-classes`,
  "A set of classes and instances for working with key/value mappings",
);

/**
 * Syntax sugar for defining maps
 */
export const map_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.map-syntax`,
  "Syntax sugar for defining maps",
);

/**
 * Bindings to the MapQuest API
 */
export const mapquest_api = mkPackage(
  nixRaw`pkgs.haskellPackages.mapquest-api`,
  "Bindings to the MapQuest API",
);

/**
 * library for MIDI control of hardware
 */
export const maquinitas_tidal = mkPackage(
  nixRaw`pkgs.haskellPackages.maquinitas-tidal`,
  "library for MIDI control of hardware",
);

/**
 * Marching Cubes
 */
export const marching_cubes = mkPackage(
  nixRaw`pkgs.haskellPackages.marching-cubes`,
  "Marching Cubes",
);

/**
 * Marching Cubes
 */
export const marching_cubes2 = mkPackage(
  nixRaw`pkgs.haskellPackages.marching-cubes2`,
  "Marching Cubes",
);

/**
 * Minimal tool to make your blog in Haskell
 */
export const marihana = mkPackage(
  nixRaw`pkgs.haskellPackages.marihana`,
  "Minimal tool to make your blog in Haskell",
);

/**
 * A study of marionetta movements
 */
export const marionetta = mkPackage(
  nixRaw`pkgs.haskellPackages.marionetta`,
  "A study of marionetta movements",
);

/**
 * Convert Markdown to HTML, with XSS protection
 */
export const markdown = mkPackage(
  nixRaw`pkgs.haskellPackages.markdown`,
  "Convert Markdown to HTML, with XSS protection",
);

/**
 * markdown to svg converter
 */
export const markdown2svg = mkPackage(
  nixRaw`pkgs.haskellPackages.markdown2svg`,
  "markdown to svg converter",
);

/**
 * markdown parser with papillon
 */
export const markdown_pap = mkPackage(
  nixRaw`pkgs.haskellPackages.markdown-pap`,
  "markdown parser with papillon",
);

/**
 * Literate Haskell support for Markdown
 */
export const markdown_unlit = mkPackage(
  nixRaw`pkgs.haskellPackages.markdown-unlit`,
  "Literate Haskell support for Markdown",
);

/**
 * Literate Haskell support for Markdown
 */
export const markdown_unlit_0_6_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.markdown-unlit_0_6_0`,
  "Literate Haskell support for Markdown",
);

/**
 * Simple interpreter for Markov's normal algorithms
 */
export const markov = mkPackage(
  nixRaw`pkgs.haskellPackages.markov`,
  "Simple interpreter for Markov's normal algorithms",
);

/**
 * Markov Chains for generating random sequences with a user definable behaviour
 */
export const markov_chain = mkPackage(
  nixRaw`pkgs.haskellPackages.markov-chain`,
  "Markov Chains for generating random sequences with a user definable behaviour",
);

/**
 * Computations for Markov chain usage models
 */
export const markov_chain_usage_model = mkPackage(
  nixRaw`pkgs.haskellPackages.markov-chain-usage-model`,
  "Computations for Markov chain usage models",
);

/**
 * Hidden Markov processes
 */
export const markov_processes = mkPackage(
  nixRaw`pkgs.haskellPackages.markov-processes`,
  "Hidden Markov processes",
);

/**
 * Abstraction for HTML-embedded content
 */
export const markup = mkPackage(
  nixRaw`pkgs.haskellPackages.markup`,
  "Abstraction for HTML-embedded content",
);

/**
 * A markup parser
 */
export const markup_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.markup-parse`,
  "A markup parser",
);

/**
 * A simple markup document preview (markdown, textile, reStructuredText)
 */
export const markup_preview = mkPackage(
  nixRaw`pkgs.haskellPackages.markup-preview`,
  "A simple markup document preview (markdown, textile, reStructuredText)",
);

/**
 * Upload packages to Marmalade
 */
export const marmalade_upload = mkPackage(
  nixRaw`pkgs.haskellPackages.marmalade-upload`,
  "Upload packages to Marmalade",
);

/**
 * Client library for Vaultaire
 */
export const marquise = mkPackage(
  nixRaw`pkgs.haskellPackages.marquise`,
  "Client library for Vaultaire",
);

/**
 * A framework for modular, portable chat bots
 */
export const marvin = mkPackage(
  nixRaw`pkgs.haskellPackages.marvin`,
  "A framework for modular, portable chat bots",
);

/**
 * Markup language preprocessor for Haskell
 */
export const marxup = mkPackage(
  nixRaw`pkgs.haskellPackages.marxup`,
  "Markup language preprocessor for Haskell",
);

/**
 * @minamiyama1994_bot on haskell
 */
export const masakazu_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.masakazu-bot`,
  "@minamiyama1994_bot on haskell",
);

/**
 * Fast and extensible bytestring builder
 */
export const mason = mkPackage(
  nixRaw`pkgs.haskellPackages.mason`,
  "Fast and extensible bytestring builder",
);

/**
 * Massiv () is an Array Library
 */
export const massiv = mkPackage(
  nixRaw`pkgs.haskellPackages.massiv`,
  "Massiv () is an Array Library",
);

/**
 * Import/export of Image files into massiv Arrays
 */
export const massiv_io = mkPackage(
  nixRaw`pkgs.haskellPackages.massiv-io`,
  "Import/export of Image files into massiv Arrays",
);

/**
 * Compatibility of 'massiv' with 'persist'
 */
export const massiv_persist = mkPackage(
  nixRaw`pkgs.haskellPackages.massiv-persist`,
  "Compatibility of 'massiv' with 'persist'",
);

/**
 * Library that contains generators, properties and tests for Massiv Array Library
 */
export const massiv_test = mkPackage(
  nixRaw`pkgs.haskellPackages.massiv-test`,
  "Library that contains generators, properties and tests for Massiv Array Library",
);

/**
 * console mastermind decypher
 */
export const mastermind = mkPackage(
  nixRaw`pkgs.haskellPackages.mastermind`,
  "console mastermind decypher",
);

/**
 * A type class for Matchable Functors
 */
export const matchable = mkPackage(
  nixRaw`pkgs.haskellPackages.matchable`,
  "A type class for Matchable Functors",
);

/**
 * Generates Matchable instances using TemplateHaskell
 */
export const matchable_th = mkPackage(
  nixRaw`pkgs.haskellPackages.matchable-th`,
  "Generates Matchable instances using TemplateHaskell",
);

/**
 * Text matchers
 */
export const matchers = mkPackage(
  nixRaw`pkgs.haskellPackages.matchers`,
  "Text matchers",
);

/**
 * A variety of mathematical utilities
 */
export const math_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.math-extras`,
  "A variety of mathematical utilities",
);

/**
 * Collection of tools for numeric computations
 */
export const math_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.math-functions`,
  "Collection of tools for numeric computations",
);

/**
 * A GLPK backend to the math-programming library
 */
export const math_programming_glpk = mkPackage(
  nixRaw`pkgs.haskellPackages.math-programming-glpk`,
  "A GLPK backend to the math-programming library",
);

/**
 * Utility functions for testing implementations of the math-programming library
 */
export const math_programming_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.math-programming-tests`,
  "Utility functions for testing implementations of the math-programming library",
);

/**
 * A program for creating and managing a static weblog with LaTeX math and diagrams
 */
export const mathblog = mkPackage(
  nixRaw`pkgs.haskellPackages.mathblog`,
  "A program for creating and managing a static weblog with LaTeX math and diagrams",
);

/**
 * Parse and evaluate math expressions with variables and functions
 */
export const mathexpr = mkPackage(
  nixRaw`pkgs.haskellPackages.mathexpr`,
  "Parse and evaluate math expressions with variables and functions",
);

/**
 * Discover your (academic) ancestors!
 */
export const mathgenealogy = mkPackage(
  nixRaw`pkgs.haskellPackages.mathgenealogy`,
  "Discover your (academic) ancestors!",
);

/**
 * A small programming language for numerical computing
 */
export const mathista = mkPackage(
  nixRaw`pkgs.haskellPackages.mathista`,
  "A small programming language for numerical computing",
);

/**
 * Write Mathematica packages in Haskell
 */
export const mathlink = mkPackage(
  nixRaw`pkgs.haskellPackages.mathlink`,
  "Write Mathematica packages in Haskell",
);

/**
 * Math using lists, including FFT and Wavelet
 */
export const mathlist = mkPackage(
  nixRaw`pkgs.haskellPackages.mathlist`,
  "Math using lists, including FFT and Wavelet",
);

/**
 * Matlab bindings and interface
 */
export const matlab = mkPackage(
  nixRaw`pkgs.haskellPackages.matlab`,
  "Matlab bindings and interface",
);

/**
 * Bindings to Matplotlib; a Python plotting library
 */
export const matplotlib = mkPackage(
  nixRaw`pkgs.haskellPackages.matplotlib`,
  "Bindings to Matplotlib; a Python plotting library",
);

/**
 * native matrix based on vector
 */
export const matrices = mkPackage(
  nixRaw`pkgs.haskellPackages.matrices`,
  "native matrix based on vector",
);

/**
 * A native implementation of matrix operations
 */
export const matrix = mkPackage(
  nixRaw`pkgs.haskellPackages.matrix`,
  "A native implementation of matrix operations",
);

/**
 * A matrix client library
 */
export const matrix_client = mkPackage(
  nixRaw`pkgs.haskellPackages.matrix-client`,
  "A matrix client library",
);

/**
 * Parsing and serialization functions for the NIST Matrix Market format
 */
export const matrix_market_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.matrix-market-attoparsec`,
  "Parsing and serialization functions for the NIST Matrix Market format",
);

/**
 * Pure and composable reader and writer of the Matrix Market format
 */
export const matrix_market_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.matrix-market-pure`,
  "Pure and composable reader and writer of the Matrix Market format",
);

/**
 * Type-safe matrix operations
 */
export const matrix_static = mkPackage(
  nixRaw`pkgs.haskellPackages.matrix-static`,
  "Type-safe matrix operations",
);

/**
 * ncurses XMPP client
 */
export const matsuri = mkPackage(
  nixRaw`pkgs.haskellPackages.matsuri`,
  "ncurses XMPP client",
);

/**
 * Terminal client for the Mattermost chat system
 */
export const matterhorn = mkPackage(
  nixRaw`pkgs.haskellPackages.matterhorn`,
  "Terminal client for the Mattermost chat system",
);

/**
 * Client API for Mattermost chat system
 */
export const mattermost_api = mkPackage(
  nixRaw`pkgs.haskellPackages.mattermost-api`,
  "Client API for Mattermost chat system",
);

/**
 * QuickCheck instances for the Mattermost client API library
 */
export const mattermost_api_qc = mkPackage(
  nixRaw`pkgs.haskellPackages.mattermost-api-qc`,
  "QuickCheck instances for the Mattermost client API library",
);

/**
 * Compute Maximum Entropy Distributions
 */
export const maxent = mkPackage(
  nixRaw`pkgs.haskellPackages.maxent`,
  "Compute Maximum Entropy Distributions",
);

/**
 * GUI for maxent-learner-hw
 */
export const maxent_learner_hw_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.maxent-learner-hw-gui`,
  "GUI for maxent-learner-hw",
);

/**
 * Enumerate all maximal cliques of a graph
 */
export const maximal_cliques = mkPackage(
  nixRaw`pkgs.haskellPackages.maximal-cliques`,
  "Enumerate all maximal cliques of a graph",
);

/**
 * Maximal sharing of terms in the lambda calculus with letrec
 */
export const maxsharing = mkPackage(
  nixRaw`pkgs.haskellPackages.maxsharing`,
  "Maximal sharing of terms in the lambda calculus with letrec",
);

/**
 * Simple higher order function for Maybe
 */
export const maybe_justify = mkPackage(
  nixRaw`pkgs.haskellPackages.maybe-justify`,
  "Simple higher order function for Maybe",
);

/**
 * Read and write standard mailbox files
 */
export const mbox = mkPackage(
  nixRaw`pkgs.haskellPackages.mbox`,
  "Read and write standard mailbox files",
);

/**
 * List contents of an mbox file containing e-mails
 */
export const mbox_utility = mkPackage(
  nixRaw`pkgs.haskellPackages.mbox-utility`,
  "List contents of an mbox file containing e-mails",
);

/**
 * An Aeson parsing toolkit
 */
export const mcaeson = mkPackage(
  nixRaw`pkgs.haskellPackages.mcaeson`,
  "An Aeson parsing toolkit",
);

/**
 * Sample from a posterior using Markov chain Monte Carlo
 */
export const mcmc = mkPackage(
  nixRaw`pkgs.haskellPackages.mcmc`,
  "Sample from a posterior using Markov chain Monte Carlo",
);

/**
 * Combinators for MCMC sampling
 */
export const mcmc_samplers = mkPackage(
  nixRaw`pkgs.haskellPackages.mcmc-samplers`,
  "Combinators for MCMC sampling",
);

/**
 * Common types for sampling
 */
export const mcmc_types = mkPackage(
  nixRaw`pkgs.haskellPackages.mcmc-types`,
  "Common types for sampling",
);

/**
 * MD5 Hash
 */
export const md5 = mkPackage(
  nixRaw`pkgs.haskellPackages.md5`,
  "MD5 Hash",
);

/**
 * Command-line tool to run a command on each of the items
 */
export const mdo = mkPackage(
  nixRaw`pkgs.haskellPackages.mdo`,
  "Command-line tool to run a command on each of the items",
);

/**
 * calculate varieties of mean/average using semigroup
 */
export const means = mkPackage(
  nixRaw`pkgs.haskellPackages.means`,
  "calculate varieties of mean/average using semigroup",
);

/**
 * A constructive solid geometry (CSG) modeling language
 */
export const mecha = mkPackage(
  nixRaw`pkgs.haskellPackages.mecha`,
  "A constructive solid geometry (CSG) modeling language",
);

/**
 * Parse song module files from Amiga MED and OctaMED
 */
export const med_module = mkPackage(
  nixRaw`pkgs.haskellPackages.med-module`,
  "Parse song module files from Amiga MED and OctaMED",
);

/**
 * A schema language for JSON
 */
export const medea = mkPackage(
  nixRaw`pkgs.haskellPackages.medea`,
  "A schema language for JSON",
);

/**
 * Mediabus plugin for the Frauenhofer ISO-14496-3 AAC FDK
 */
export const mediabus_fdk_aac = mkPackage(
  nixRaw`pkgs.haskellPackages.mediabus-fdk-aac`,
  "Mediabus plugin for the Frauenhofer ISO-14496-3 AAC FDK",
);

/**
 * Receive and Send RTP Packets
 */
export const mediabus_rtp = mkPackage(
  nixRaw`pkgs.haskellPackages.mediabus-rtp`,
  "Receive and Send RTP Packets",
);

/**
 * Constant-time queries for the median of a stream of numeric data
 */
export const median_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.median-stream`,
  "Constant-time queries for the median of a stream of numeric data",
);

/**
 * Convert MediaWiki text to LaTeX
 */
export const mediawiki2latex = mkPackage(
  nixRaw`pkgs.haskellPackages.mediawiki2latex`,
  "Convert MediaWiki text to LaTeX",
);

/**
 * Handles uploading to Hackage from mega repos
 */
export const mega_sdist = mkPackage(
  nixRaw`pkgs.haskellPackages.mega-sdist`,
  "Handles uploading to Hackage from mega repos",
);

/**
 * Monadic parser combinators
 */
export const megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.megaparsec`,
  "Monadic parser combinators",
);

/**
 * Monadic parser combinators
 */
export const megaparsec_9_5_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.megaparsec_9_5_0`,
  "Monadic parser combinators",
);

/**
 * Test utilities and the test suite of Megaparsec
 */
export const megaparsec_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.megaparsec-tests`,
  "Test utilities and the test suite of Megaparsec",
);

/**
 * Test utilities and the test suite of Megaparsec
 */
export const megaparsec_tests_9_5_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.megaparsec-tests_9_5_0`,
  "Test utilities and the test suite of Megaparsec",
);

/**
 * Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues
 */
export const meldable_heap = mkPackage(
  nixRaw`pkgs.haskellPackages.meldable-heap`,
  "Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues",
);

/**
 * An Elf parser
 */
export const melf = mkPackage(
  nixRaw`pkgs.haskellPackages.melf`,
  "An Elf parser",
);

/**
 * GPIO support for mellon
 */
export const mellon_gpio = mkPackage(
  nixRaw`pkgs.haskellPackages.mellon-gpio`,
  "GPIO support for mellon",
);

/**
 * A REST web service for Mellon controllers
 */
export const mellon_web = mkPackage(
  nixRaw`pkgs.haskellPackages.mellon-web`,
  "A REST web service for Mellon controllers",
);

/**
 * Indices for type level lists
 */
export const membership = mkPackage(
  nixRaw`pkgs.haskellPackages.membership`,
  "Indices for type level lists",
);

/**
 * A memcached client library
 */
export const memcache = mkPackage(
  nixRaw`pkgs.haskellPackages.memcache`,
  "A memcached client library",
);

/**
 * Conduit library for memcache procotol
 */
export const memcache_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.memcache-conduit`,
  "Conduit library for memcache procotol",
);

/**
 * Efficient in memory indexed database
 */
export const memdb = mkPackage(
  nixRaw`pkgs.haskellPackages.memdb`,
  "Efficient in memory indexed database",
);

/**
 * Library for reading Meme XML output
 */
export const memexml = mkPackage(
  nixRaw`pkgs.haskellPackages.memexml`,
  "Library for reading Meme XML output",
);

/**
 * Open temporary anonymous Linux file handles
 */
export const memfd = mkPackage(
  nixRaw`pkgs.haskellPackages.memfd`,
  "Open temporary anonymous Linux file handles",
);

/**
 * A memoization library
 */
export const memoize = mkPackage(
  nixRaw`pkgs.haskellPackages.memoize`,
  "A memoization library",
);

/**
 * memory and related abstraction stuff
 */
export const memory = mkPackage(
  nixRaw`pkgs.haskellPackages.memory`,
  "memory and related abstraction stuff",
);

/**
 * memory and related abstraction stuff
 */
export const memory_cd = mkPackage(
  nixRaw`pkgs.haskellPackages.memory-cd`,
  "memory and related abstraction stuff",
);

/**
 * Hex-string type for Haskell Web3 library
 */
export const memory_hexstring = mkPackage(
  nixRaw`pkgs.haskellPackages.memory-hexstring`,
  "Hex-string type for Haskell Web3 library",
);

/**
 * Command line utility for memorizing scriptures or any other text
 */
export const memscript = mkPackage(
  nixRaw`pkgs.haskellPackages.memscript`,
  "Command line utility for memorizing scriptures or any other text",
);

/**
 * Securely erase memory contents by writing zeros to it
 */
export const memzero = mkPackage(
  nixRaw`pkgs.haskellPackages.memzero`,
  "Securely erase memory contents by writing zeros to it",
);

/**
 * A functor for consistent merging of information
 */
export const merge = mkPackage(
  nixRaw`pkgs.haskellPackages.merge`,
  "A functor for consistent merging of information",
);

/**
 * command line utility to merge bash_history
 */
export const merge_bash_history = mkPackage(
  nixRaw`pkgs.haskellPackages.merge-bash-history`,
  "command line utility to merge bash_history",
);

export const mergeful = mkPackage(
  nixRaw`pkgs.haskellPackages.mergeful`,
  "",
);

export const mergeless = mkPackage(
  nixRaw`pkgs.haskellPackages.mergeless`,
  "",
);

/**
 * Merkle Tree Logs
 */
export const merkle_log = mkPackage(
  nixRaw`pkgs.haskellPackages.merkle-log`,
  "Merkle Tree Logs",
);

/**
 * A modified Merkle Patricia DB
 */
export const merkle_patricia_db = mkPackage(
  nixRaw`pkgs.haskellPackages.merkle-patricia-db`,
  "A modified Merkle Patricia DB",
);

/**
 * An implementation of a Merkle tree and merkle tree proofs of inclusion
 */
export const merkle_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.merkle-tree`,
  "An implementation of a Merkle tree and merkle tree proofs of inclusion",
);

/**
 * Generate high quality pseudorandom numbers using a SIMD Fast Mersenne Twister
 */
export const mersenne_random = mkPackage(
  nixRaw`pkgs.haskellPackages.mersenne-random`,
  "Generate high quality pseudorandom numbers using a SIMD Fast Mersenne Twister",
);

/**
 * Generate high quality pseudorandom numbers purely using a Mersenne Twister
 */
export const mersenne_random_pure64 = mkPackage(
  nixRaw`pkgs.haskellPackages.mersenne-random-pure64`,
  "Generate high quality pseudorandom numbers purely using a Mersenne Twister",
);

/**
 * Temporary message-db for integration testing
 */
export const message_db_temp = mkPackage(
  nixRaw`pkgs.haskellPackages.message-db-temp`,
  "Temporary message-db for integration testing",
);

/**
 * Serialize instance for Message Pack Object
 */
export const messagepack = mkPackage(
  nixRaw`pkgs.haskellPackages.messagepack`,
  "Serialize instance for Message Pack Object",
);

/**
 * Support for integrated Accelerate computations within Meta-par
 */
export const meta_par_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.meta-par-accelerate`,
  "Support for integrated Accelerate computations within Meta-par",
);

/**
 * metamorphisms: ana . cata or understanding folds and unfolds
 */
export const metamorphic = mkPackage(
  nixRaw`pkgs.haskellPackages.metamorphic`,
  "metamorphisms: ana . cata or understanding folds and unfolds",
);

/**
 * a tiny ghc api wrapper
 */
export const metaplug = mkPackage(
  nixRaw`pkgs.haskellPackages.metaplug`,
  "a tiny ghc api wrapper",
);

/**
 * Australian METAR
 */
export const metar = mkPackage(
  nixRaw`pkgs.haskellPackages.metar`,
  "Australian METAR",
);

/**
 * HTTP for METAR
 */
export const metar_http = mkPackage(
  nixRaw`pkgs.haskellPackages.metar-http`,
  "HTTP for METAR",
);

/**
 * High-performance application metric tracking
 */
export const metrics = mkPackage(
  nixRaw`pkgs.haskellPackages.metrics`,
  "High-performance application metric tracking",
);

/**
 * A simple tcp and udp socket server framework
 */
export const metro = mkPackage(
  nixRaw`pkgs.haskellPackages.metro`,
  "A simple tcp and udp socket server framework",
);

/**
 * Socket transport for metro
 */
export const metro_socket = mkPackage(
  nixRaw`pkgs.haskellPackages.metro-socket`,
  "Socket transport for metro",
);

/**
 * Crypto transport for metro
 */
export const metro_transport_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.metro-transport-crypto`,
  "Crypto transport for metro",
);

/**
 * TLS transport for metro
 */
export const metro_transport_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.metro-transport-tls`,
  "TLS transport for metro",
);

/**
 * Websockets transport for metro
 */
export const metro_transport_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.metro-transport-websockets`,
  "Websockets transport for metro",
);

/**
 * XOR transport for metro
 */
export const metro_transport_xor = mkPackage(
  nixRaw`pkgs.haskellPackages.metro-transport-xor`,
  "XOR transport for metro",
);

/**
 * Time Synchronized execution
 */
export const metronome = mkPackage(
  nixRaw`pkgs.haskellPackages.metronome`,
  "Time Synchronized execution",
);

/**
 * Equation solver and calculator  la metafont
 */
export const mfsolve = mkPackage(
  nixRaw`pkgs.haskellPackages.mfsolve`,
  "Equation solver and calculator  la metafont",
);

/**
 * A Micro service gateway
 */
export const micro_gateway = mkPackage(
  nixRaw`pkgs.haskellPackages.micro-gateway`,
  "A Micro service gateway",
);

/**
 * A tiny JSON library with light dependency footprint
 */
export const microaeson = mkPackage(
  nixRaw`pkgs.haskellPackages.microaeson`,
  "A tiny JSON library with light dependency footprint",
);

/**
 * Microbenchmark Haskell code
 */
export const microbench = mkPackage(
  nixRaw`pkgs.haskellPackages.microbench`,
  "Microbenchmark Haskell code",
);

/**
 * microc compiler
 */
export const microc = mkPackage(
  nixRaw`pkgs.haskellPackages.microc`,
  "microc compiler",
);

/**
 * Microformats 2 types (with Aeson instances)
 */
export const microformats2_types = mkPackage(
  nixRaw`pkgs.haskellPackages.microformats2-types`,
  "Microformats 2 types (with Aeson instances)",
);

/**
 * A tiny lens library with no dependencies
 */
export const microlens = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens`,
  "A tiny lens library with no dependencies",
);

/**
 * Law-abiding lenses for Aeson, using microlens
 */
export const microlens_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-aeson`,
  "Law-abiding lenses for Aeson, using microlens",
);

/**
 * True folds and getters for microlens
 */
export const microlens_contra = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-contra`,
  "True folds and getters for microlens",
);

/**
 * microlens + array, bytestring, containers, transformers
 */
export const microlens_ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-ghc`,
  "microlens + array, bytestring, containers, transformers",
);

/**
 * microlens support for Reader/Writer/State from mtl
 */
export const microlens_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-mtl`,
  "microlens support for Reader/Writer/State from mtl",
);

/**
 * microlens + all batteries included (best for apps)
 */
export const microlens_platform = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-platform`,
  "microlens + all batteries included (best for apps)",
);

/**
 * Automatic generation of record lenses for microlens
 */
export const microlens_th = mkPackage(
  nixRaw`pkgs.haskellPackages.microlens-th`,
  "Automatic generation of record lenses for microlens",
);

/**
 * Tiny QuickCheck test library with minimal dependencies
 */
export const microspec = mkPackage(
  nixRaw`pkgs.haskellPackages.microspec`,
  "Tiny QuickCheck test library with minimal dependencies",
);

/**
 * Mustache templates for Haskell
 */
export const microstache = mkPackage(
  nixRaw`pkgs.haskellPackages.microstache`,
  "Mustache templates for Haskell",
);

/**
 * A tiny library for benchmarking IO actions
 */
export const microtimer = mkPackage(
  nixRaw`pkgs.haskellPackages.microtimer`,
  "A tiny library for benchmarking IO actions",
);

/**
 * Hot-swappable FRP
 */
export const midair = mkPackage(
  nixRaw`pkgs.haskellPackages.midair`,
  "Hot-swappable FRP",
);

/**
 * Handling of MIDI messages and files
 */
export const midi = mkPackage(
  nixRaw`pkgs.haskellPackages.midi`,
  "Handling of MIDI messages and files",
);

/**
 * Convert between datatypes of the midi and the alsa packages
 */
export const midi_alsa = mkPackage(
  nixRaw`pkgs.haskellPackages.midi-alsa`,
  "Convert between datatypes of the midi and the alsa packages",
);

/**
 * Convert MIDI file to music box punch tape
 */
export const midi_music_box = mkPackage(
  nixRaw`pkgs.haskellPackages.midi-music-box`,
  "Convert MIDI file to music box punch tape",
);

/**
 * Utility functions for processing MIDI files
 */
export const midi_util = mkPackage(
  nixRaw`pkgs.haskellPackages.midi-util`,
  "Utility functions for processing MIDI files",
);

/**
 * A Memory-like (Concentration, Pairs, ...) game for tones
 */
export const midimory = mkPackage(
  nixRaw`pkgs.haskellPackages.midimory`,
  "A Memory-like (Concentration, Pairs, ...) game for tones",
);

/**
 * Build lightweight and composable servers
 */
export const mig = mkPackage(
  nixRaw`pkgs.haskellPackages.mig`,
  "Build lightweight and composable servers",
);

/**
 * Simple Web Server in Haskell
 */
export const mighttpd = mkPackage(
  nixRaw`pkgs.haskellPackages.mighttpd`,
  "Simple Web Server in Haskell",
);

/**
 * The Metropolis algorithm
 */
export const mighty_metropolis = mkPackage(
  nixRaw`pkgs.haskellPackages.mighty-metropolis`,
  "The Metropolis algorithm",
);

/**
 * Semi-automatic database schema migrations
 */
export const migrant_core = mkPackage(
  nixRaw`pkgs.haskellPackages.migrant-core`,
  "Semi-automatic database schema migrations",
);

/**
 * Semi-automatic database schema migrations
 */
export const migrant_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.migrant-hdbc`,
  "Semi-automatic database schema migrations",
);

/**
 * Semi-automatic database schema migrations
 */
export const migrant_sqlite_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.migrant-sqlite-simple`,
  "Semi-automatic database schema migrations",
);

/**
 * Working with MIME types
 */
export const mime = mkPackage(
  nixRaw`pkgs.haskellPackages.mime`,
  "Working with MIME types",
);

/**
 * Compose MIME email messages
 */
export const mime_mail = mkPackage(
  nixRaw`pkgs.haskellPackages.mime-mail`,
  "Compose MIME email messages",
);

/**
 * Send mime-mail messages via Amazon SES
 */
export const mime_mail_ses = mkPackage(
  nixRaw`pkgs.haskellPackages.mime-mail-ses`,
  "Send mime-mail messages via Amazon SES",
);

/**
 * MIME implementation for String's
 */
export const mime_string = mkPackage(
  nixRaw`pkgs.haskellPackages.mime-string`,
  "MIME implementation for String's",
);

/**
 * Basic mime-type handling types and functions
 */
export const mime_types = mkPackage(
  nixRaw`pkgs.haskellPackages.mime-types`,
  "Basic mime-type handling types and functions",
);

/**
 * Double-ended priority queues
 */
export const min_max_pqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.min-max-pqueue`,
  "Double-ended priority queues",
);

/**
 * TBA
 */
export const minecraft = mkPackage(
  nixRaw`pkgs.haskellPackages.minecraft`,
  "TBA",
);

/**
 * a DSL for generating minecraft commands and levels
 */
export const minecraft_data = mkPackage(
  nixRaw`pkgs.haskellPackages.minecraft-data`,
  "a DSL for generating minecraft commands and levels",
);

/**
 * Minesweeper simulation using neural networks
 */
export const mines = mkPackage(
  nixRaw`pkgs.haskellPackages.mines`,
  "Minesweeper simulation using neural networks",
);

/**
 * Minesweeper game which is always solvable without guessing
 */
export const minesweeper = mkPackage(
  nixRaw`pkgs.haskellPackages.minesweeper`,
  "Minesweeper game which is always solvable without guessing",
);

/**
 * Template Haskell Implementation of Egison Pattern Matching
 */
export const mini_egison = mkPackage(
  nixRaw`pkgs.haskellPackages.mini-egison`,
  "Template Haskell Implementation of Egison Pattern Matching",
);

/**
 * Bindings to Miniball, a smallest enclosing ball library
 */
export const miniball = mkPackage(
  nixRaw`pkgs.haskellPackages.miniball`,
  "Bindings to Miniball, a smallest enclosing ball library",
);

/**
 * Minimal bindings to libcurl
 */
export const minicurl = mkPackage(
  nixRaw`pkgs.haskellPackages.minicurl`,
  "Minimal bindings to libcurl",
);

/**
 * A SDL2-based graphics library, batteries-included
 */
export const minilight = mkPackage(
  nixRaw`pkgs.haskellPackages.minilight`,
  "A SDL2-based graphics library, batteries-included",
);

/**
 * A binding library of minilight for Lua langauge
 */
export const minilight_lua = mkPackage(
  nixRaw`pkgs.haskellPackages.minilight-lua`,
  "A binding library of minilight for Lua langauge",
);

/**
 * Minimal ini like configuration library with a few extras
 */
export const minimal_configuration = mkPackage(
  nixRaw`pkgs.haskellPackages.minimal-configuration`,
  "Minimal ini like configuration library with a few extras",
);

/**
 * English spelling functions with an emphasis on simplicity
 */
export const minimorph = mkPackage(
  nixRaw`pkgs.haskellPackages.minimorph`,
  "English spelling functions with an emphasis on simplicity",
);

/**
 * Shows how to run grabber on Mac OS X
 */
export const minimung = mkPackage(
  nixRaw`pkgs.haskellPackages.minimung`,
  "Shows how to run grabber on Mac OS X",
);

/**
 * A MinIO Haskell Library for Amazon S3 compatible cloud storage
 */
export const minio_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.minio-hs`,
  "A MinIO Haskell Library for Amazon S3 compatible cloud storage",
);

/**
 * fast and simple operational monad
 */
export const minioperational = mkPackage(
  nixRaw`pkgs.haskellPackages.minioperational`,
  "fast and simple operational monad",
);

/**
 * Minimalistic file rotation utility
 */
export const minirotate = mkPackage(
  nixRaw`pkgs.haskellPackages.minirotate`,
  "Minimalistic file rotation utility",
);

/**
 * A Haskell bundle of the Minisat SAT solver
 */
export const minisat = mkPackage(
  nixRaw`pkgs.haskellPackages.minisat`,
  "A Haskell bundle of the Minisat SAT solver",
);

/**
 * High-level Haskell bindings for the MiniSat SAT solver
 */
export const minisat_solver = mkPackage(
  nixRaw`pkgs.haskellPackages.minisat-solver`,
  "High-level Haskell bindings for the MiniSat SAT solver",
);

/**
 * Simple and lightweight benchmark utilities
 */
export const miniterion = mkPackage(
  nixRaw`pkgs.haskellPackages.miniterion`,
  "Simple and lightweight benchmark utilities",
);

/**
 * Layout and render text with TrueType fonts using OpenGL
 */
export const minitypeset_opengl = mkPackage(
  nixRaw`pkgs.haskellPackages.minitypeset-opengl`,
  "Layout and render text with TrueType fonts using OpenGL",
);

/**
 * Simple English clause creation from arbitrary words
 */
export const miniutter = mkPackage(
  nixRaw`pkgs.haskellPackages.miniutter`,
  "Simple English clause creation from arbitrary words",
);

/**
 * Express the minimum length of a container in its type
 */
export const minlen = mkPackage(
  nixRaw`pkgs.haskellPackages.minlen`,
  "Express the minimum length of a container in its type",
);

/**
 * A reliable way to detect the presence of a MinTTY console on Windows
 */
export const mintty = mkPackage(
  nixRaw`pkgs.haskellPackages.mintty`,
  "A reliable way to detect the presence of a MinTTY console on Windows",
);

/**
 * fortune-mod clone
 */
export const misfortune = mkPackage(
  nixRaw`pkgs.haskellPackages.misfortune`,
  "fortune-mod clone",
);

/**
 * AWS Library
 */
export const mismi_kernel = mkPackage(
  nixRaw`pkgs.haskellPackages.mismi-kernel`,
  "AWS Library",
);

/**
 * AWS Library
 */
export const mismi_s3_core = mkPackage(
  nixRaw`pkgs.haskellPackages.mismi-s3-core`,
  "AWS Library",
);

/**
 * A tasty Haskell front-end framework
 */
export const miso = mkPackage(
  nixRaw`pkgs.haskellPackages.miso`,
  "A tasty Haskell front-end framework",
);

/**
 * Convert HTML to miso View syntax
 */
export const miso_from_html = mkPackage(
  nixRaw`pkgs.haskellPackages.miso-from-html`,
  "Convert HTML to miso View syntax",
);

/**
 * A Haskell git implimentation
 */
export const miss = mkPackage(
  nixRaw`pkgs.haskellPackages.miss`,
  "A Haskell git implimentation",
);

/**
 * Useability extras built on top of miss
 */
export const miss_porcelain = mkPackage(
  nixRaw`pkgs.haskellPackages.miss-porcelain`,
  "Useability extras built on top of miss",
);

/**
 * Convenience functions for FFI work
 */
export const missing_foreign = mkPackage(
  nixRaw`pkgs.haskellPackages.missing-foreign`,
  "Convenience functions for FFI work",
);

/**
 * Haskell interface to Python
 */
export const missing_py2 = mkPackage(
  nixRaw`pkgs.haskellPackages.missing-py2`,
  "Haskell interface to Python",
);

/**
 * Vim plugin manager written in Haskell
 */
export const miv = mkPackage(
  nixRaw`pkgs.haskellPackages.miv`,
  "Vim plugin manager written in Haskell",
);

/**
 * Find optimal mixed strategies for two-player games
 */
export const mixed_strategies = mkPackage(
  nixRaw`pkgs.haskellPackages.mixed-strategies`,
  "Find optimal mixed strategies for two-player games",
);

/**
 * Alternative Prelude with numeric and logic expressions typed bottom-up
 */
export const mixed_types_num = mkPackage(
  nixRaw`pkgs.haskellPackages.mixed-types-num`,
  "Alternative Prelude with numeric and logic expressions typed bottom-up",
);

/**
 * Makes an OS X .app bundle from a binary.
 */
export const mkbndl = mkPackage(
  nixRaw`pkgs.haskellPackages.mkbndl`,
  "Makes an OS X .app bundle from a binary.",
);

/**
 * Monadic List alternative to lazy I/O
 */
export const mlist = mkPackage(
  nixRaw`pkgs.haskellPackages.mlist`,
  "Monadic List alternative to lazy I/O",
);

/**
 * Memory mapped files for POSIX and Windows
 */
export const mmap = mkPackage(
  nixRaw`pkgs.haskellPackages.mmap`,
  "Memory mapped files for POSIX and Windows",
);

/**
 * Strict markdown processor for writers
 */
export const mmark = mkPackage(
  nixRaw`pkgs.haskellPackages.mmark`,
  "Strict markdown processor for writers",
);

/**
 * Command line interface to the MMark markdown processor
 */
export const mmark_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.mmark-cli`,
  "Command line interface to the MMark markdown processor",
);

/**
 * Commonly useful extensions for the MMark markdown processor
 */
export const mmark_ext = mkPackage(
  nixRaw`pkgs.haskellPackages.mmark-ext`,
  "Commonly useful extensions for the MMark markdown processor",
);

/**
 * Monad morphisms
 */
export const mmorph = mkPackage(
  nixRaw`pkgs.haskellPackages.mmorph`,
  "Monad morphisms",
);

/**
 * Monad morphisms
 */
export const mmorph_1_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.mmorph_1_1_3`,
  "Monad morphisms",
);

/**
 * A library that can be used for multiple Ord a => a -> b transformations
 */
export const mmsyn2_array = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn2-array`,
  "A library that can be used for multiple Ord a => a -> b transformations",
);

/**
 * Data that is taken from the ukrainian-phonetics-basic-array for optimization
 */
export const mmsyn2_array_ukrainian_data = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn2-array-ukrainian-data`,
  "Data that is taken from the ukrainian-phonetics-basic-array for optimization",
);

/**
 * A library that can be used for multiple Hashable a => a -> b transformations
 */
export const mmsyn2_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn2-hashable`,
  "A library that can be used for multiple Hashable a => a -> b transformations",
);

/**
 * A small library to deal with executable endings
 */
export const mmsyn3 = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn3`,
  "A small library to deal with executable endings",
);

/**
 * Various additional operations on lists (some with intermediate Monads)
 */
export const mmsyn5 = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn5`,
  "Various additional operations on lists (some with intermediate Monads)",
);

/**
 * A musical instrument synthesizer or a tool for Ukrainian language listening
 */
export const mmsyn6ukr = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn6ukr`,
  "A musical instrument synthesizer or a tool for Ukrainian language listening",
);

/**
 * Produces a sound recording specified by the Ukrainian text
 */
export const mmsyn7h = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn7h`,
  "Produces a sound recording specified by the Ukrainian text",
);

/**
 * Modifies the amplitudes of the sounds representations created by mmsyn7ukr-array and mmsyn7ukr packages
 */
export const mmsyn7l = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn7l`,
  "Modifies the amplitudes of the sounds representations created by mmsyn7ukr-array and mmsyn7ukr packages",
);

/**
 * Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs
 */
export const mmsyn7s = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn7s`,
  "Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs",
);

/**
 * A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h
 */
export const mmsyn7ukr = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn7ukr`,
  "A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h",
);

/**
 * A simple reduced basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h-array, dobutokO2-array and other similar packages
 */
export const mmsyn7ukr_array = mkPackage(
  nixRaw`pkgs.haskellPackages.mmsyn7ukr-array`,
  "A simple reduced basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h-array, dobutokO2-array and other similar packages",
);

/**
 * MonadBase type-class for mmtl
 */
export const mmtl_base = mkPackage(
  nixRaw`pkgs.haskellPackages.mmtl-base`,
  "MonadBase type-class for mmtl",
);

/**
 * Read and write IDX data that is used in e.g. the MNIST database.
 */
export const mnist_idx = mkPackage(
  nixRaw`pkgs.haskellPackages.mnist-idx`,
  "Read and write IDX data that is used in e.g. the MNIST database.",
);

/**
 * conduit utilities for MNIST IDX files
 */
export const mnist_idx_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.mnist-idx-conduit`,
  "conduit utilities for MNIST IDX files",
);

/**
 * Language-agnostic analyzer for positional morphosyntactic tags
 */
export const moan = mkPackage(
  nixRaw`pkgs.haskellPackages.moan`,
  "Language-agnostic analyzer for positional morphosyntactic tags",
);

/**
 * Mock time in tests
 */
export const mock_time = mkPackage(
  nixRaw`pkgs.haskellPackages.mock-time`,
  "Mock time in tests",
);

/**
 * Support functions for automated testing
 */
export const mockery = mkPackage(
  nixRaw`pkgs.haskellPackages.mockery`,
  "Support functions for automated testing",
);

/**
 * Fast type-safe modular arithmetic
 */
export const mod = mkPackage(
  nixRaw`pkgs.haskellPackages.mod`,
  "Fast type-safe modular arithmetic",
);

/**
 * Modern library for working with URIs
 */
export const modern_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.modern-uri`,
  "Modern library for working with URIs",
);

/**
 * Modify fasta (and CLIP) files in several optional ways
 */
export const modify_fasta = mkPackage(
  nixRaw`pkgs.haskellPackages.modify-fasta`,
  "Modify fasta (and CLIP) files in several optional ways",
);

/**
 * Haskell source splitter driven by special comments
 */
export const modsplit = mkPackage(
  nixRaw`pkgs.haskellPackages.modsplit`,
  "Haskell source splitter driven by special comments",
);

/**
 * Type-safe modular arithmetic
 */
export const modular = mkPackage(
  nixRaw`pkgs.haskellPackages.modular`,
  "Type-safe modular arithmetic",
);

/**
 * A type for integers modulo some constant
 */
export const modular_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.modular-arithmetic`,
  "A type for integers modulo some constant",
);

/**
 * Reifying ClassyPrelude a la ModularPrelude
 */
export const modular_prelude_classy = mkPackage(
  nixRaw`pkgs.haskellPackages.modular-prelude-classy`,
  "Reifying ClassyPrelude a la ModularPrelude",
);

/**
 * Find the modularity of a network
 */
export const modularity = mkPackage(
  nixRaw`pkgs.haskellPackages.modularity`,
  "Find the modularity of a network",
);

/**
 * Modular C code generator
 */
export const modulo = mkPackage(
  nixRaw`pkgs.haskellPackages.modulo`,
  "Modular C code generator",
);

/**
 * A glorified string replacement tool
 */
export const mole = mkPackage(
  nixRaw`pkgs.haskellPackages.mole`,
  "A glorified string replacement tool",
);

/**
 * Overloading of concurrency variables
 */
export const monadIO = mkPackage(
  nixRaw`pkgs.haskellPackages.monadIO`,
  "Overloading of concurrency variables",
);

/**
 * A collection of monad transformers
 */
export const monadLib = mkPackage(
  nixRaw`pkgs.haskellPackages.monadLib`,
  "A collection of monad transformers",
);

/**
 * A better error monad transformer
 */
export const monad_abort_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-abort-fd`,
  "A better error monad transformer",
);

/**
 * An applicative monad that batches commands for later more efficient execution
 */
export const monad_batcher = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-batcher`,
  "An applicative monad that batches commands for later more efficient execution",
);

/**
 * A library for probabilistic programming
 */
export const monad_bayes = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-bayes`,
  "A library for probabilistic programming",
);

/**
 * This package has been removed
 */
export const monad_bool = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-bool`,
  "This package has been removed",
);

/**
 * These as a transformer, ChronicleT
 */
export const monad_chronicle = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-chronicle`,
  "These as a transformer, ChronicleT",
);

/**
 * more flexible mtl
 */
export const monad_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-classes`,
  "more flexible mtl",
);

/**
 * monad-classes based typeclass for Ollie's logging-effect LoggingT
 */
export const monad_classes_logging = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-classes-logging`,
  "monad-classes based typeclass for Ollie's logging-effect LoggingT",
);

/**
 * Monadic conversion between complex data structures and unique integers
 */
export const monad_codec = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-codec`,
  "Monadic conversion between complex data structures and unique integers",
);

/**
 * Transformer for TCP connection with TLS and SOCKS support
 */
export const monad_connect = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-connect`,
  "Transformer for TCP connection with TLS and SOCKS support",
);

/**
 * Lift control operations, like exception catching, through monad transformers
 */
export const monad_control = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-control`,
  "Lift control operations, like exception catching, through monad transformers",
);

/**
 * Stronger classes than monad-control
 */
export const monad_control_identity = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-control-identity`,
  "Stronger classes than monad-control",
);

/**
 * Coroutine monad transformer for suspending and resuming monadic computations
 */
export const monad_coroutine = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-coroutine`,
  "Coroutine monad transformer for suspending and resuming monadic computations",
);

/**
 * A monad transformer for weighted graph searches
 */
export const monad_dijkstra = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-dijkstra`,
  "A monad transformer for weighted graph searches",
);

/**
 * Exstensible monadic exceptions
 */
export const monad_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-exception`,
  "Exstensible monadic exceptions",
);

/**
 * Extra utility functions for working with monads
 */
export const monad_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-extras`,
  "Extra utility functions for working with monads",
);

/**
 * Guard monadic computations with cleanup actions
 */
export const monad_finally = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-finally`,
  "Guard monadic computations with cleanup actions",
);

/**
 * A simple monad for generating fresh integers
 */
export const monad_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-gen`,
  "A simple monad for generating fresh integers",
);

/**
 * Monad transformer for incremental hashing
 */
export const monad_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-hash`,
  "Monad transformer for incremental hashing",
);

/**
 * A class of monads which can do http requests
 */
export const monad_http = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-http`,
  "A class of monads which can do http requests",
);

/**
 * Monads with an unsaveInterleaveIO-like operation
 */
export const monad_interleave = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-interleave`,
  "Monads with an unsaveInterleaveIO-like operation",
);

/**
 * Adapters between MonadIO and MonadBase IO
 */
export const monad_io_adapter = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-io-adapter`,
  "Adapters between MonadIO and MonadBase IO",
);

/**
 * Pure logger typeclass and monad transformer
 */
export const monad_journal = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-journal`,
  "Pure logger typeclass and monad transformer",
);

/**
 * A class of monads which can log messages
 */
export const monad_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-logger`,
  "A class of monads which can log messages",
);

/**
 * JSON logging using monad-logger interface
 */
export const monad_logger_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-logger-aeson`,
  "JSON logging using monad-logger interface",
);

/**
 * Utilities for composing loggers, coloring output, plus a few orphan instances
 */
export const monad_logger_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-logger-extras`,
  "Utilities for composing loggers, coloring output, plus a few orphan instances",
);

/**
 * JSON-friendly Logging APIs
 */
export const monad_logger_json = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-logger-json`,
  "JSON-friendly Logging APIs",
);

/**
 * Logstash backend for monad-logger
 */
export const monad_logger_logstash = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-logger-logstash`,
  "Logstash backend for monad-logger",
);

/**
 * Monadic loops
 */
export const monad_loops = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-loops`,
  "Monadic loops",
);

/**
 * Monadic loops for STM
 */
export const monad_loops_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-loops-stm`,
  "Monadic loops for STM",
);

/**
 * Markov process monad
 */
export const monad_markov = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-markov`,
  "Markov process monad",
);

/**
 * Memoization monad transformer
 */
export const monad_memo = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-memo`,
  "Memoization monad transformer",
);

/**
 * An extensible and type-safe wrapper around EKG metrics
 */
export const monad_metrics_extensible = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-metrics-extensible`,
  "An extensible and type-safe wrapper around EKG metrics",
);

/**
 * Monad for observation extraction
 */
export const monad_ox = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-ox`,
  "Monad for observation extraction",
);

/**
 * A library for parallel programming based on a monad
 */
export const monad_par = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-par`,
  "A library for parallel programming based on a monad",
);

/**
 * Combinators and extra features for Par monads
 */
export const monad_par_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-par-extras`,
  "Combinators and extra features for Par monads",
);

/**
 * Parallel execution of monadic computations
 */
export const monad_parallel = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-parallel`,
  "Parallel execution of monadic computations",
);

/**
 * Lift control operations like exception catching through monad transformers
 */
export const monad_peel = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-peel`,
  "Lift control operations like exception catching through monad transformers",
);

/**
 * Lift control operations like exception catching through monad transformers
 */
export const monad_peel_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-peel_0_3`,
  "Lift control operations like exception catching through monad transformers",
);

/**
 * Type class for monad transformers stack with pirimitive base monad
 */
export const monad_primitive = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-primitive`,
  "Type class for monad transformers stack with pirimitive base monad",
);

/**
 * Monad products
 */
export const monad_products = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-products`,
  "Monad products",
);

/**
 * Resumption and reactive resumption monads for Haskell
 */
export const monad_resumption = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-resumption`,
  "Resumption and reactive resumption monads for Haskell",
);

/**
 * A new, simple, composable concurrency abstraction
 */
export const monad_schedule = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-schedule`,
  "A new, simple, composable concurrency abstraction",
);

/**
 * Provides a MonadST class
 */
export const monad_st = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-st`,
  "Provides a MonadST class",
);

/**
 * Utility library for monads, particularly those involving state
 */
export const monad_state = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-state`,
  "Utility library for monads, particularly those involving state",
);

/**
 * ST-like monad capturing variables to regions and supporting STM
 */
export const monad_stlike_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-stlike-stm`,
  "ST-like monad capturing variables to regions and supporting STM",
);

/**
 * MonadSTM class analogous to MonadIO
 */
export const monad_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-stm`,
  "MonadSTM class analogous to MonadIO",
);

/**
 * Stateful supply monad
 */
export const monad_supply = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-supply`,
  "Stateful supply monad",
);

/**
 * Type class for monads which carry the notion of the current time
 */
export const monad_time = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-time`,
  "Type class for monads which carry the notion of the current time",
);

/**
 * Adaptation of the monad-time library for the effectful ecosystem
 */
export const monad_time_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-time-effectful`,
  "Adaptation of the monad-time library for the effectful ecosystem",
);

/**
 * Typeclasses for representing monad transformer unlifting
 */
export const monad_unlift = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-unlift`,
  "Typeclasses for representing monad transformer unlifting",
);

/**
 * Typeclasses for representing monad transformer unlifting
 */
export const monad_unlift_ref = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-unlift-ref`,
  "Typeclasses for representing monad transformer unlifting",
);

/**
 * A monad transformer for data validation
 */
export const monad_validate = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-validate`,
  "A monad transformer for data validation",
);

/**
 * Generic operations over variables
 */
export const monad_var = mkPackage(
  nixRaw`pkgs.haskellPackages.monad-var`,
  "Generic operations over variables",
);

/**
 * Extract underlying monads from monad transformers
 */
export const monadbi = mkPackage(
  nixRaw`pkgs.haskellPackages.monadbi`,
  "Extract underlying monads from monad transformers",
);

/**
 * Monadic functions which provide Choice and Parallelism
 */
export const monadfibre = mkPackage(
  nixRaw`pkgs.haskellPackages.monadfibre`,
  "Monadic functions which provide Choice and Parallelism",
);

/**
 * Boxed and unboxed arrays for monad transformers
 */
export const monadic_arrays = mkPackage(
  nixRaw`pkgs.haskellPackages.monadic-arrays`,
  "Boxed and unboxed arrays for monad transformers",
);

/**
 * GHC plugin to desugar ! into do-notation
 */
export const monadic_bang = mkPackage(
  nixRaw`pkgs.haskellPackages.monadic-bang`,
  "GHC plugin to desugar ! into do-notation",
);

/**
 * Recursion Schemes for Monadic version
 */
export const monadic_recursion_schemes = mkPackage(
  nixRaw`pkgs.haskellPackages.monadic-recursion-schemes`,
  "Recursion Schemes for Monadic version",
);

/**
 * Constraint Programming
 */
export const monadiccp_gecode = mkPackage(
  nixRaw`pkgs.haskellPackages.monadiccp-gecode`,
  "Constraint Programming",
);

/**
 * Reversibly allow monad transformer stacks to run in IO
 */
export const monadio_unwrappable = mkPackage(
  nixRaw`pkgs.haskellPackages.monadio-unwrappable`,
  "Reversibly allow monad transformer stacks to run in IO",
);

/**
 * Monadic versions of list functions
 */
export const monadlist = mkPackage(
  nixRaw`pkgs.haskellPackages.monadlist`,
  "Monadic versions of list functions",
);

/**
 * A class for monads which can keep a monadic call trace
 */
export const monadloc = mkPackage(
  nixRaw`pkgs.haskellPackages.monadloc`,
  "A class for monads which can keep a monadic call trace",
);

/**
 * A monoid for monads
 */
export const monadoid = mkPackage(
  nixRaw`pkgs.haskellPackages.monadoid`,
  "A monoid for monads",
);

export const monadology = mkPackage(
  nixRaw`pkgs.haskellPackages.monadology`,
  "",
);

/**
 * The best ideas in monad-related classes and types
 */
export const monadology_0_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.monadology_0_3`,
  "The best ideas in monad-related classes and types",
);

/**
 * Haskell98 partial maps and filters over MonadPlus
 */
export const monadplus = mkPackage(
  nixRaw`pkgs.haskellPackages.monadplus`,
  "Haskell98 partial maps and filters over MonadPlus",
);

/**
 * Monad classes, using functional dependencies
 */
export const monads_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.monads-fd`,
  "Monad classes, using functional dependencies",
);

/**
 * Monad classes, using type families
 */
export const monads_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.monads-tf`,
  "Monad classes, using type families",
);

/**
 * Monad classes, using type families
 */
export const monads_tf_0_3_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.monads-tf_0_3_0_1`,
  "Monad classes, using type families",
);

/**
 * A type-class for transforming monads (homomorphism) in a transformer
 */
export const monadtransform = mkPackage(
  nixRaw`pkgs.haskellPackages.monadtransform`,
  "A type-class for transforming monads (homomorphism) in a transformer",
);

/**
 * Monadic interface for TokyoTyrant
 */
export const monarch = mkPackage(
  nixRaw`pkgs.haskellPackages.monarch`,
  "Monadic interface for TokyoTyrant",
);

/**
 * Mid-level bindings for the MonetDB API (mapi)
 */
export const monetdb_mapi = mkPackage(
  nixRaw`pkgs.haskellPackages.monetdb-mapi`,
  "Mid-level bindings for the MonetDB API (mapi)",
);

/**
 * Driver (client) for MongoDB, a free, scalable, fast, document DBMS
 */
export const mongoDB = mkPackage(
  nixRaw`pkgs.haskellPackages.mongoDB`,
  "Driver (client) for MongoDB, a free, scalable, fast, document DBMS",
);

/**
 * Mongrel2 Handler Library
 */
export const mongrel2_handler = mkPackage(
  nixRaw`pkgs.haskellPackages.mongrel2-handler`,
  "Mongrel2 Handler Library",
);

/**
 * A system state collecting library and application
 */
export const monky = mkPackage(
  nixRaw`pkgs.haskellPackages.monky`,
  "A system state collecting library and application",
);

/**
 * Type classes for mapping, folding, and traversing monomorphic containers
 */
export const mono_traversable = mkPackage(
  nixRaw`pkgs.haskellPackages.mono-traversable`,
  "Type classes for mapping, folding, and traversing monomorphic containers",
);

/**
 * Extra typeclass instances for mono-traversable
 */
export const mono_traversable_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.mono-traversable-instances`,
  "Extra typeclass instances for mono-traversable",
);

/**
 * Type-classes for interacting with monomorphic containers with a key
 */
export const mono_traversable_keys = mkPackage(
  nixRaw`pkgs.haskellPackages.mono-traversable-keys`,
  "Type-classes for interacting with monomorphic containers with a key",
);

/**
 * Wrapper providing Foldable instance for MonoFoldables
 */
export const mono_traversable_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.mono-traversable-wrapper`,
  "Wrapper providing Foldable instance for MonoFoldables",
);

/**
 * Various extra monoid-related definitions and utilities
 */
export const monoid_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-extras`,
  "Various extra monoid-related definitions and utilities",
);

/**
 * A monoidal map with the right group instance
 */
export const monoid_map = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-map`,
  "A monoidal map with the right group instance",
);

/**
 * Support for modifying record fields of monoidal type
 */
export const monoid_record = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-record`,
  "Support for modifying record fields of monoidal type",
);

/**
 * Monoids for calculation of statistics of sample
 */
export const monoid_statistics = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-statistics`,
  "Monoids for calculation of statistics of sample",
);

/**
 * Subclasses of Monoid
 */
export const monoid_subclasses = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-subclasses`,
  "Subclasses of Monoid",
);

/**
 * Monoid counterparts to some ubiquitous monad transformers
 */
export const monoid_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.monoid-transformer`,
  "Monoid counterparts to some ubiquitous monad transformers",
);

/**
 * Containers with monoidal accumulation
 */
export const monoidal_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.monoidal-containers`,
  "Containers with monoidal accumulation",
);

/**
 * A GUI library for writing native Haskell applications
 */
export const monomer = mkPackage(
  nixRaw`pkgs.haskellPackages.monomer`,
  "A GUI library for writing native Haskell applications",
);

/**
 * Monomer Flatpak Example Application
 */
export const monomer_flatpak_example = mkPackage(
  nixRaw`pkgs.haskellPackages.monomer-flatpak-example`,
  "Monomer Flatpak Example Application",
);

/**
 * A datagrid widget for the Monomer library
 */
export const monomer_hagrid = mkPackage(
  nixRaw`pkgs.haskellPackages.monomer-hagrid`,
  "A datagrid widget for the Monomer library",
);

/**
 * Library to convert polymorphic datatypes to/from its monomorphic represetation
 */
export const monomorphic = mkPackage(
  nixRaw`pkgs.haskellPackages.monomorphic`,
  "Library to convert polymorphic datatypes to/from its monomorphic represetation",
);

/**
 * A monad and transformer for Monte Carlo calculations
 */
export const monte_carlo = mkPackage(
  nixRaw`pkgs.haskellPackages.monte-carlo`,
  "A monad and transformer for Monte Carlo calculations",
);

/**
 * MonthName
 */
export const months = mkPackage(
  nixRaw`pkgs.haskellPackages.months`,
  "MonthName",
);

/**
 * Efficient search weighted by an ordered monoid with monus
 */
export const monus_weighted_search = mkPackage(
  nixRaw`pkgs.haskellPackages.monus-weighted-search`,
  "Efficient search weighted by an ordered monoid with monus",
);

/**
 * Genetic algorithm library
 */
export const moo = mkPackage(
  nixRaw`pkgs.haskellPackages.moo`,
  "Genetic algorithm library",
);

/**
 * Invocation helpers for the ReaderT-record-of-functions style
 */
export const moo_nad = mkPackage(
  nixRaw`pkgs.haskellPackages.moo-nad`,
  "Invocation helpers for the ReaderT-record-of-functions style",
);

/**
 * A web service framework for Haskell, similar in purpose to dropwizard
 */
export const moonshine = mkPackage(
  nixRaw`pkgs.haskellPackages.moonshine`,
  "A web service framework for Haskell, similar in purpose to dropwizard",
);

/**
 * A few more collections
 */
export const more_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.more-containers`,
  "A few more collections",
);

/**
 * Initial project template from stack
 */
export const more_extensible_effects = mkPackage(
  nixRaw`pkgs.haskellPackages.more-extensible-effects`,
  "Initial project template from stack",
);

/**
 * Developer tools for the Michelson Language
 */
export const morley = mkPackage(
  nixRaw`pkgs.haskellPackages.morley`,
  "Developer tools for the Michelson Language",
);

/**
 * Client to interact with the Tezos blockchain
 */
export const morley_client = mkPackage(
  nixRaw`pkgs.haskellPackages.morley-client`,
  "Client to interact with the Tezos blockchain",
);

/**
 * A custom prelude used in Morley
 */
export const morley_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.morley-prelude`,
  "A custom prelude used in Morley",
);

/**
 * Upgradeability infrastructure based on Morley
 */
export const morley_upgradeable = mkPackage(
  nixRaw`pkgs.haskellPackages.morley-upgradeable`,
  "Upgradeability infrastructure based on Morley",
);

/**
 * A multi-lingual, typed, workflow language
 */
export const morloc = mkPackage(
  nixRaw`pkgs.haskellPackages.morloc`,
  "A multi-lingual, typed, workflow language",
);

/**
 * A simple database migrator for PostgreSQL
 */
export const morph = mkPackage(
  nixRaw`pkgs.haskellPackages.morph`,
  "A simple database migrator for PostgreSQL",
);

/**
 * Morpheus GraphQL
 */
export const morpheus_graphql = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql`,
  "Morpheus GraphQL",
);

/**
 * Morpheus GraphQL App
 */
export const morpheus_graphql_app = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-app`,
  "Morpheus GraphQL App",
);

/**
 * Morpheus GraphQL Client
 */
export const morpheus_graphql_client = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-client`,
  "Morpheus GraphQL Client",
);

/**
 * Morpheus GraphQL CLI
 */
export const morpheus_graphql_code_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-code-gen`,
  "Morpheus GraphQL CLI",
);

/**
 * Morpheus GraphQL CLI
 */
export const morpheus_graphql_code_gen_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-code-gen-utils`,
  "Morpheus GraphQL CLI",
);

/**
 * Morpheus GraphQL Core
 */
export const morpheus_graphql_core = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-core`,
  "Morpheus GraphQL Core",
);

/**
 * Morpheus GraphQL
 */
export const morpheus_graphql_server = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-server`,
  "Morpheus GraphQL",
);

/**
 * Morpheus GraphQL Subscriptions
 */
export const morpheus_graphql_subscriptions = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-subscriptions`,
  "Morpheus GraphQL Subscriptions",
);

/**
 * Morpheus GraphQL Test
 */
export const morpheus_graphql_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.morpheus-graphql-tests`,
  "Morpheus GraphQL Test",
);

/**
 * It's all about functions
 */
export const morphisms = mkPackage(
  nixRaw`pkgs.haskellPackages.morphisms`,
  "It's all about functions",
);

/**
 * Inventory is state and store
 */
export const morphisms_functors_inventory = mkPackage(
  nixRaw`pkgs.haskellPackages.morphisms-functors-inventory`,
  "Inventory is state and store",
);

/**
 * Mosquitto client library bindings
 */
export const mosquitto_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.mosquitto-hs`,
  "Mosquitto client library bindings",
);

/**
 * Haskell client for Moss
 */
export const moss = mkPackage(
  nixRaw`pkgs.haskellPackages.moss`,
  "Haskell client for Moss",
);

/**
 * General purpose migrations library
 */
export const moto = mkPackage(
  nixRaw`pkgs.haskellPackages.moto`,
  "General purpose migrations library",
);

/**
 * PostgreSQL-based migrations registry for moto
 */
export const moto_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.moto-postgresql`,
  "PostgreSQL-based migrations registry for moto",
);

/**
 * Type-safe effectful state machines in Haskell
 */
export const motor = mkPackage(
  nixRaw`pkgs.haskellPackages.motor`,
  "Type-safe effectful state machines in Haskell",
);

/**
 * Generate state diagrams from Motor FSM typeclasses
 */
export const motor_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.motor-diagrams`,
  "Generate state diagrams from Motor FSM typeclasses",
);

/**
 * list mount points
 */
export const mountpoints = mkPackage(
  nixRaw`pkgs.haskellPackages.mountpoints`,
  "list mount points",
);

/**
 * This is a library for calculating moving averages on lists of numbers
 */
export const moving_averages = mkPackage(
  nixRaw`pkgs.haskellPackages.moving-averages`,
  "This is a library for calculating moving averages on lists of numbers",
);

/**
 * Music player for linux
 */
export const mp = mkPackage(
  nixRaw`pkgs.haskellPackages.mp`,
  "Music player for linux",
);

/**
 * MP3 decoder for teaching
 */
export const mp3decoder = mkPackage(
  nixRaw`pkgs.haskellPackages.mp3decoder`,
  "MP3 decoder for teaching",
);

/**
 * MPD/PowerMate executable
 */
export const mpdmate = mkPackage(
  nixRaw`pkgs.haskellPackages.mpdmate`,
  "MPD/PowerMate executable",
);

/**
 * Efficient effect handlers based on evidence-passing semantics
 */
export const mpeff = mkPackage(
  nixRaw`pkgs.haskellPackages.mpeff`,
  "Efficient effect handlers based on evidence-passing semantics",
);

/**
 * Mpg132 bindings
 */
export const mpg123_bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.mpg123-bindings`,
  "Mpg132 bindings",
);

/**
 * MPI bindings for Haskell
 */
export const mpi_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.mpi-hs`,
  "MPI bindings for Haskell",
);

/**
 * MPI bindings for Haskell
 */
export const mpi_hs_0_7_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.mpi-hs_0_7_3_0`,
  "MPI bindings for Haskell",
);

/**
 * MPI bindings for Haskell
 */
export const mpi_hs_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.mpi-hs-binary`,
  "MPI bindings for Haskell",
);

/**
 * MPI bindings for Haskell
 */
export const mpi_hs_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.mpi-hs-cereal`,
  "MPI bindings for Haskell",
);

/**
 * MPI bindings for Haskell
 */
export const mpi_hs_store = mkPackage(
  nixRaw`pkgs.haskellPackages.mpi-hs-store`,
  "MPI bindings for Haskell",
);

/**
 * Save your spot when watching movies with @mplayer@
 */
export const mplayer_spot = mkPackage(
  nixRaw`pkgs.haskellPackages.mplayer-spot`,
  "Save your spot when watching movies with @mplayer@",
);

/**
 * Simple multivariate polynomials
 */
export const mpolynomials = mkPackage(
  nixRaw`pkgs.haskellPackages.mpolynomials`,
  "Simple multivariate polynomials",
);

/**
 * A minimalish prelude
 */
export const mprelude = mkPackage(
  nixRaw`pkgs.haskellPackages.mprelude`,
  "A minimalish prelude",
);

/**
 * a monadic, extensible pretty printing library
 */
export const mpretty = mkPackage(
  nixRaw`pkgs.haskellPackages.mpretty`,
  "a monadic, extensible pretty printing library",
);

/**
 * Simple equational reasoning for a Haskell-ish language
 */
export const mprover = mkPackage(
  nixRaw`pkgs.haskellPackages.mprover`,
  "Simple equational reasoning for a Haskell-ish language",
);

/**
 * simply oo
 */
export const mps = mkPackage(
  nixRaw`pkgs.haskellPackages.mps`,
  "simply oo",
);

/**
 * Datastructures to describe TCP and MPTCP connections
 */
export const mptcp = mkPackage(
  nixRaw`pkgs.haskellPackages.mptcp`,
  "Datastructures to describe TCP and MPTCP connections",
);

/**
 * A Multipath TCP path manager
 */
export const mptcp_pm = mkPackage(
  nixRaw`pkgs.haskellPackages.mptcp-pm`,
  "A Multipath TCP path manager",
);

/**
 * A Multipath TCP analyzer
 */
export const mptcpanalyzer = mkPackage(
  nixRaw`pkgs.haskellPackages.mptcpanalyzer`,
  "A Multipath TCP analyzer",
);

/**
 * A simple way to read environment variables in Haskell
 */
export const mr_env = mkPackage(
  nixRaw`pkgs.haskellPackages.mr-env`,
  "A simple way to read environment variables in Haskell",
);

/**
 * TDS Protocol implemented in Haskell
 */
export const ms_tds = mkPackage(
  nixRaw`pkgs.haskellPackages.ms-tds`,
  "TDS Protocol implemented in Haskell",
);

/**
 * Aeson adapter for MessagePack
 */
export const msgpack_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-aeson`,
  "Aeson adapter for MessagePack",
);

/**
 * A Haskell implementation of MessagePack
 */
export const msgpack_arbitrary = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-arbitrary`,
  "A Haskell implementation of MessagePack",
);

/**
 * A Haskell implementation of MessagePack
 */
export const msgpack_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-binary`,
  "A Haskell implementation of MessagePack",
);

/**
 * An IDL Compiler for MessagePack
 */
export const msgpack_idl = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-idl`,
  "An IDL Compiler for MessagePack",
);

/**
 * A Haskell implementation of MessagePack
 */
export const msgpack_persist = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-persist`,
  "A Haskell implementation of MessagePack",
);

/**
 * A MessagePack-RPC Implementation
 */
export const msgpack_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-rpc`,
  "A MessagePack-RPC Implementation",
);

/**
 * A MessagePack-RPC Implementation
 */
export const msgpack_rpc_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-rpc-conduit`,
  "A MessagePack-RPC Implementation",
);

/**
 * A Haskell implementation of MessagePack
 */
export const msgpack_testsuite = mkPackage(
  nixRaw`pkgs.haskellPackages.msgpack-testsuite`,
  "A Haskell implementation of MessagePack",
);

/**
 * A command line tool to change backlit colors of your MSI keyboards
 */
export const msi_kb_backlit = mkPackage(
  nixRaw`pkgs.haskellPackages.msi-kb-backlit`,
  "A command line tool to change backlit colors of your MSI keyboards",
);

/**
 * SQL Server client library implemented in Haskell
 */
export const mssql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.mssql-simple`,
  "SQL Server client library implemented in Haskell",
);

/**
 * MState: A consistent State monad for concurrent applications
 */
export const mstate = mkPackage(
  nixRaw`pkgs.haskellPackages.mstate`,
  "MState: A consistent State monad for concurrent applications",
);

/**
 * Monitor Setup Utility
 */
export const msu = mkPackage(
  nixRaw`pkgs.haskellPackages.msu`,
  "Monitor Setup Utility",
);

/**
 * Library to communicate with Mt.Gox
 */
export const mtgoxapi = mkPackage(
  nixRaw`pkgs.haskellPackages.mtgoxapi`,
  "Library to communicate with Mt.Gox",
);

/**
 * Monad classes for transformers, using functional dependencies
 */
export const mtl_2_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.mtl_2_3_1`,
  "Monad classes for transformers, using functional dependencies",
);

/**
 * Backported Control.Monad.Except module from mtl
 */
export const mtl_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.mtl-compat`,
  "Backported Control.Monad.Except module from mtl",
);

/**
 * Reexports of most definitions from "mtl" and "transformers"
 */
export const mtl_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.mtl-prelude`,
  "Reexports of most definitions from \"mtl\" and \"transformers\"",
);

/**
 * MTL classes without the functional dependency
 */
export const mtl_unleashed = mkPackage(
  nixRaw`pkgs.haskellPackages.mtl-unleashed`,
  "MTL classes without the functional dependency",
);

/**
 * Lift substacks of monad transformer stacks
 */
export const mtl_uplift = mkPackage(
  nixRaw`pkgs.haskellPackages.mtl-uplift`,
  "Lift substacks of monad transformer stacks",
);

/**
 * parse library using mtl package
 */
export const mtlparse = mkPackage(
  nixRaw`pkgs.haskellPackages.mtlparse`,
  "parse library using mtl package",
);

/**
 * Tree with Meta and Content parameters
 */
export const mtree = mkPackage(
  nixRaw`pkgs.haskellPackages.mtree`,
  "Tree with Meta and Content parameters",
);

/**
 * Avro serialization support for Mu microservices
 */
export const mu_avro = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-avro`,
  "Avro serialization support for Mu microservices",
);

/**
 * GraphQL support for Mu
 */
export const mu_graphql = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-graphql`,
  "GraphQL support for Mu",
);

/**
 * gRPC clients from Mu definitions
 */
export const mu_grpc_client = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-grpc-client`,
  "gRPC clients from Mu definitions",
);

/**
 * gRPC for Mu, common modules for client and server
 */
export const mu_grpc_common = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-grpc-common`,
  "gRPC for Mu, common modules for client and server",
);

/**
 * gRPC servers for Mu definitions
 */
export const mu_grpc_server = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-grpc-server`,
  "gRPC servers for Mu definitions",
);

/**
 * Utilities for interoperation between Mu and Kafka
 */
export const mu_kafka = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-kafka`,
  "Utilities for interoperation between Mu and Kafka",
);

/**
 * Lenses for @mu-schema@ terms
 */
export const mu_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-lens`,
  "Lenses for @mu-schema@ terms",
);

/**
 * Optics for @mu-schema@ terms
 */
export const mu_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-optics`,
  "Optics for @mu-schema@ terms",
);

/**
 * Utilities for interoperation between Mu and Persistent
 */
export const mu_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-persistent`,
  "Utilities for interoperation between Mu and Persistent",
);

/**
 * Metrics support for Mu using Prometheus
 */
export const mu_prometheus = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-prometheus`,
  "Metrics support for Mu using Prometheus",
);

/**
 * Protocol Buffers serialization and gRPC schema import for Mu microservices
 */
export const mu_protobuf = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-protobuf`,
  "Protocol Buffers serialization and gRPC schema import for Mu microservices",
);

/**
 * Protocol-independent declaration of services and servers
 */
export const mu_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-rpc`,
  "Protocol-independent declaration of services and servers",
);

/**
 * Servant servers for Mu definitions
 */
export const mu_servant_server = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-servant-server`,
  "Servant servers for Mu definitions",
);

/**
 * Tracing support for Mu
 */
export const mu_tracing = mkPackage(
  nixRaw`pkgs.haskellPackages.mu-tracing`,
  "Tracing support for Mu",
);

/**
 * A library to produce simple ciphers for use with lambdabot
 */
export const mucipher = mkPackage(
  nixRaw`pkgs.haskellPackages.mucipher`,
  "A library to produce simple ciphers for use with lambdabot",
);

/**
 * A simple document-oriented database
 */
export const muesli = mkPackage(
  nixRaw`pkgs.haskellPackages.muesli`,
  "A simple document-oriented database",
);

/**
 * Safely evaluate pure Haskell expressions
 */
export const mueval = mkPackage(
  nixRaw`pkgs.haskellPackages.mueval`,
  "Safely evaluate pure Haskell expressions",
);

/**
 * A tool supporting multi cabal project builds
 */
export const multi_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.multi-cabal`,
  "A tool supporting multi cabal project builds",
);

/**
 * A few multimap variants
 */
export const multi_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.multi-containers`,
  "A few multimap variants",
);

/**
 * Multiple Exceptions
 */
export const multi_except = mkPackage(
  nixRaw`pkgs.haskellPackages.multi-except`,
  "Multiple Exceptions",
);

/**
 * Trie of sets, as a model for compound names having multiple values
 */
export const multi_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.multi-trie`,
  "Trie of sets, as a model for compound names having multiple values",
);

/**
 * Self-identifying base encodings, implementation of <https://github.com/multiformats/multihash>
 */
export const multibase = mkPackage(
  nixRaw`pkgs.haskellPackages.multibase`,
  "Self-identifying base encodings, implementation of <https://github.com/multiformats/multihash>",
);

/**
 * Uncurry functions with multiple arguments
 */
export const multicurryable = mkPackage(
  nixRaw`pkgs.haskellPackages.multicurryable`,
  "Uncurry functions with multiple arguments",
);

/**
 * create many files from one
 */
export const multifile = mkPackage(
  nixRaw`pkgs.haskellPackages.multifile`,
  "create many files from one",
);

/**
 * Bidirectional Two-level Transformation of XML Schemas
 */
export const multifocal = mkPackage(
  nixRaw`pkgs.haskellPackages.multifocal`,
  "Bidirectional Two-level Transformation of XML Schemas",
);

/**
 * Self-identifying hashes, implementation of <https://github.com/multiformats/multihash>
 */
export const multihash_cryptonite = mkPackage(
  nixRaw`pkgs.haskellPackages.multihash-cryptonite`,
  "Self-identifying hashes, implementation of <https://github.com/multiformats/multihash>",
);

/**
 * CBOR encoding of multihashes
 */
export const multihash_serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.multihash-serialise`,
  "CBOR encoding of multihashes",
);

/**
 * hashmap from keys to hashsets
 */
export const multihashmap = mkPackage(
  nixRaw`pkgs.haskellPackages.multihashmap`,
  "hashmap from keys to hashsets",
);

/**
 * Conduit-based input/output capability for multilinear package
 */
export const multilinear_io = mkPackage(
  nixRaw`pkgs.haskellPackages.multilinear-io`,
  "Conduit-based input/output capability for multilinear package",
);

/**
 * A multimap
 */
export const multimap = mkPackage(
  nixRaw`pkgs.haskellPackages.multimap`,
  "A multimap",
);

/**
 * Parsers for the HTTP multipart format
 */
export const multipart = mkPackage(
  nixRaw`pkgs.haskellPackages.multipart`,
  "Parsers for the HTTP multipart format",
);

/**
 * Handling of multipart names in various casing styles
 */
export const multipart_names = mkPackage(
  nixRaw`pkgs.haskellPackages.multipart-names`,
  "Handling of multipart names in various casing styles",
);

/**
 * Lightweight generic library for mutually recursive data types
 */
export const multiplate = mkPackage(
  nixRaw`pkgs.haskellPackages.multiplate`,
  "Lightweight generic library for mutually recursive data types",
);

/**
 * Wrapper program for duplicity, adding config files
 */
export const multiplicity = mkPackage(
  nixRaw`pkgs.haskellPackages.multiplicity`,
  "Wrapper program for duplicity, adding config files",
);

/**
 * Read and write from appropriate persistent sql instances in replicated environments
 */
export const multipool_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.multipool-persistent`,
  "Read and write from appropriate persistent sql instances in replicated environments",
);

/**
 * Read and write appropriately from both master and replicated postgresql instances
 */
export const multipool_persistent_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.multipool-persistent-postgresql`,
  "Read and write appropriately from both master and replicated postgresql instances",
);

export const multipool_postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.multipool-postgresql-simple`,
  "",
);

/**
 * Multiprocess architecture library
 */
export const multiprocess = mkPackage(
  nixRaw`pkgs.haskellPackages.multiprocess`,
  "Multiprocess architecture library",
);

/**
 * Alternative multirec instances deriver
 */
export const multirec_alt_deriver = mkPackage(
  nixRaw`pkgs.haskellPackages.multirec-alt-deriver`,
  "Alternative multirec instances deriver",
);

/**
 * Generic Data.Binary instances using MultiRec.
 */
export const multirec_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.multirec-binary`,
  "Generic Data.Binary instances using MultiRec.",
);

/**
 * The Data.MultiSet container type
 */
export const multiset = mkPackage(
  nixRaw`pkgs.haskellPackages.multiset`,
  "The Data.MultiSet container type",
);

/**
 * Combinatorial algorithms over multisets
 */
export const multiset_comb = mkPackage(
  nixRaw`pkgs.haskellPackages.multiset-comb`,
  "Combinatorial algorithms over multisets",
);

/**
 * Multi-set rewrite rules with guards and a parallel execution scheme
 */
export const multisetrewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.multisetrewrite`,
  "Multi-set rewrite rules with guards and a parallel execution scheme",
);

/**
 * like mtl's ReaderT / WriterT / StateT, but more than one contained value/type
 */
export const multistate = mkPackage(
  nixRaw`pkgs.haskellPackages.multistate`,
  "like mtl's ReaderT / WriterT / StateT, but more than one contained value/type",
);

/**
 * Traverse data types via generics, acting on multiple types simultaneously
 */
export const multiwalk = mkPackage(
  nixRaw`pkgs.haskellPackages.multiwalk`,
  "Traverse data types via generics, acting on multiple types simultaneously",
);

/**
 * MUtually Recursive Definitions Explicitly Represented
 */
export const murder = mkPackage(
  nixRaw`pkgs.haskellPackages.murder`,
  "MUtually Recursive Definitions Explicitly Represented",
);

/**
 * Pure Haskell implementation of the MurmurHash3 x86 algorithm
 */
export const murmur3 = mkPackage(
  nixRaw`pkgs.haskellPackages.murmur3`,
  "Pure Haskell implementation of the MurmurHash3 x86 algorithm",
);

/**
 * MurmurHash2 implementation for Haskell
 */
export const murmur_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.murmur-hash`,
  "MurmurHash2 implementation for Haskell",
);

/**
 * 32-bit non-cryptographic hashing
 */
export const murmurhash3 = mkPackage(
  nixRaw`pkgs.haskellPackages.murmurhash3`,
  "32-bit non-cryptographic hashing",
);

/**
 * Minimalist MPD client
 */
export const mushu = mkPackage(
  nixRaw`pkgs.haskellPackages.mushu`,
  "Minimalist MPD client",
);

/**
 * Abstract representation of musical articulation
 */
export const music_articulation = mkPackage(
  nixRaw`pkgs.haskellPackages.music-articulation`,
  "Abstract representation of musical articulation",
);

/**
 * Implementation of basic western musical theory objects
 */
export const music_diatonic = mkPackage(
  nixRaw`pkgs.haskellPackages.music-diatonic`,
  "Implementation of basic western musical theory objects",
);

/**
 * Abstract representation of musical dynamics
 */
export const music_dynamics = mkPackage(
  nixRaw`pkgs.haskellPackages.music-dynamics`,
  "Abstract representation of musical dynamics",
);

/**
 * Overloaded dynamics literals
 */
export const music_dynamics_literal = mkPackage(
  nixRaw`pkgs.haskellPackages.music-dynamics-literal`,
  "Overloaded dynamics literals",
);

/**
 * Diagrams-based visualization of musical data structures
 */
export const music_graphics = mkPackage(
  nixRaw`pkgs.haskellPackages.music-graphics`,
  "Diagrams-based visualization of musical data structures",
);

/**
 * Musical instruments, parts and playing techniques
 */
export const music_parts = mkPackage(
  nixRaw`pkgs.haskellPackages.music-parts`,
  "Musical instruments, parts and playing techniques",
);

/**
 * Musical pitch representation
 */
export const music_pitch = mkPackage(
  nixRaw`pkgs.haskellPackages.music-pitch`,
  "Musical pitch representation",
);

/**
 * Overloaded pitch literals
 */
export const music_pitch_literal = mkPackage(
  nixRaw`pkgs.haskellPackages.music-pitch-literal`,
  "Overloaded pitch literals",
);

/**
 * Some useful preludes for the Music Suite
 */
export const music_preludes = mkPackage(
  nixRaw`pkgs.haskellPackages.music-preludes`,
  "Some useful preludes for the Music Suite",
);

/**
 * Musical score and part representation
 */
export const music_score = mkPackage(
  nixRaw`pkgs.haskellPackages.music-score`,
  "Musical score and part representation",
);

/**
 * Interaction with Sibelius
 */
export const music_sibelius = mkPackage(
  nixRaw`pkgs.haskellPackages.music-sibelius`,
  "Interaction with Sibelius",
);

/**
 * A set of libraries for composition, analysis and manipulation of music
 */
export const music_suite = mkPackage(
  nixRaw`pkgs.haskellPackages.music-suite`,
  "A set of libraries for composition, analysis and manipulation of music",
);

/**
 * Send an email to all MusicBrainz editors
 */
export const musicbrainz_email = mkPackage(
  nixRaw`pkgs.haskellPackages.musicbrainz-email`,
  "Send an email to all MusicBrainz editors",
);

/**
 * A representation of the MusicXML format
 */
export const musicxml2 = mkPackage(
  nixRaw`pkgs.haskellPackages.musicxml2`,
  "A representation of the MusicXML format",
);

/**
 * A mustache template parser library
 */
export const mustache = mkPackage(
  nixRaw`pkgs.haskellPackages.mustache`,
  "A mustache template parser library",
);

/**
 * Abstactions and concrete implementations of mutable containers
 */
export const mutable_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.mutable-containers`,
  "Abstactions and concrete implementations of mutable containers",
);

/**
 * iteratees based upon mutable buffers
 */
export const mutable_iter = mkPackage(
  nixRaw`pkgs.haskellPackages.mutable-iter`,
  "iteratees based upon mutable buffers",
);

/**
 * Interoperate mutable references with regular lens
 */
export const mutable_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.mutable-lens`,
  "Interoperate mutable references with regular lens",
);

/**
 * Watches your screensaver and (un)mutes music when you (un)lock the screen
 */
export const mute_unmute = mkPackage(
  nixRaw`pkgs.haskellPackages.mute-unmute`,
  "Watches your screensaver and (un)mutes music when you (un)lock the screen",
);

/**
 * A trivial lock based on MVar
 */
export const mvar_lock = mkPackage(
  nixRaw`pkgs.haskellPackages.mvar-lock`,
  "A trivial lock based on MVar",
);

/**
 * Concurrent and combinable updates
 */
export const mvc_updates = mkPackage(
  nixRaw`pkgs.haskellPackages.mvc-updates`,
  "Concurrent and combinable updates",
);

/**
 * Client library for metaverse systems like Second Life
 */
export const mvclient = mkPackage(
  nixRaw`pkgs.haskellPackages.mvclient`,
  "Client library for metaverse systems like Second Life",
);

/**
 * Sampling function-based probability distributions
 */
export const mwc_probability = mkPackage(
  nixRaw`pkgs.haskellPackages.mwc-probability`,
  "Sampling function-based probability distributions",
);

/**
 * A Markov stochastic transition operator with logging
 */
export const mwc_probability_transition = mkPackage(
  nixRaw`pkgs.haskellPackages.mwc-probability-transition`,
  "A Markov stochastic transition operator with logging",
);

/**
 * Fast, high quality pseudo random number generation
 */
export const mwc_random = mkPackage(
  nixRaw`pkgs.haskellPackages.mwc-random`,
  "Fast, high quality pseudo random number generation",
);

/**
 * Generate Accelerate arrays filled with high quality pseudorandom numbers
 */
export const mwc_random_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.mwc-random-accelerate`,
  "Generate Accelerate arrays filled with high quality pseudorandom numbers",
);

/**
 * Monadic interface for mwc-random
 */
export const mwc_random_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.mwc-random-monad`,
  "Monadic interface for mwc-random",
);

/**
 * ISO 3166-2:MX State Codes and Names
 */
export const mx_state_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.mx-state-codes`,
  "ISO 3166-2:MX State Codes and Names",
);

/**
 * mxnet dataiters
 */
export const mxnet_dataiter = mkPackage(
  nixRaw`pkgs.haskellPackages.mxnet-dataiter`,
  "mxnet dataiters",
);

/**
 * Examples for MXNet in Haskell
 */
export const mxnet_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.mxnet-examples`,
  "Examples for MXNet in Haskell",
);

/**
 * Train a neural network with MXNet in Haskell
 */
export const mxnet_nn = mkPackage(
  nixRaw`pkgs.haskellPackages.mxnet-nn`,
  "Train a neural network with MXNet in Haskell",
);

/**
 * None
 */
export const myTestlll = mkPackage(
  nixRaw`pkgs.haskellPackages.myTestlll`,
  "None",
);

/**
 * Binding to mybitcoin.com's Shopping Cart Interface.
 */
export const mybitcoin_sci = mkPackage(
  nixRaw`pkgs.haskellPackages.mybitcoin-sci`,
  "Binding to mybitcoin.com's Shopping Cart Interface.",
);

export const myers_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.myers-diff`,
  "",
);

/**
 * Sessions and continuations for Snap web apps
 */
export const mysnapsession = mkPackage(
  nixRaw`pkgs.haskellPackages.mysnapsession`,
  "Sessions and continuations for Snap web apps",
);

/**
 * Example projects using mysnapsession
 */
export const mysnapsession_example = mkPackage(
  nixRaw`pkgs.haskellPackages.mysnapsession-example`,
  "Example projects using mysnapsession",
);

/**
 * A low-level MySQL client library
 */
export const mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.mysql`,
  "A low-level MySQL client library",
);

/**
 * Adds a interface like mysql-simple to mysql-haskell
 */
export const mysql_haskell_nem = mkPackage(
  nixRaw`pkgs.haskellPackages.mysql-haskell-nem`,
  "Adds a interface like mysql-simple to mysql-haskell",
);

/**
 * TLS support for mysql-haskell package using openssl
 */
export const mysql_haskell_openssl = mkPackage(
  nixRaw`pkgs.haskellPackages.mysql-haskell-openssl`,
  "TLS support for mysql-haskell package using openssl",
);

/**
 * A mid-level MySQL client library
 */
export const mysql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.mysql-simple`,
  "A mid-level MySQL client library",
);

/**
 * Typed extension to mysql simple
 */
export const mysql_simple_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.mysql-simple-typed`,
  "Typed extension to mysql simple",
);

/**
 * Web application to view and kill MySQL queries
 */
export const mywatch = mkPackage(
  nixRaw`pkgs.haskellPackages.mywatch`,
  "Web application to view and kill MySQL queries",
);

/**
 * Tool to keep track of what you have been working on and where
 */
export const mywork = mkPackage(
  nixRaw`pkgs.haskellPackages.mywork`,
  "Tool to keep track of what you have been working on and where",
);

/**
 * Abstract Protocol Loop
 */
export const n2o = mkPackage(
  nixRaw`pkgs.haskellPackages.n2o`,
  "Abstract Protocol Loop",
);

/**
 * Nitro Elements, Events and Actions
 */
export const n2o_nitro = mkPackage(
  nixRaw`pkgs.haskellPackages.n2o-nitro`,
  "Nitro Elements, Events and Actions",
);

/**
 * N2O adapter for WebSockets
 */
export const n2o_web = mkPackage(
  nixRaw`pkgs.haskellPackages.n2o-web`,
  "N2O adapter for WebSockets",
);

/**
 * An n-ary version of Functor
 */
export const n_ary_functor = mkPackage(
  nixRaw`pkgs.haskellPackages.n-ary-functor`,
  "An n-ary version of Functor",
);

/**
 * Utility to call iwconfig
 */
export const n_m = mkPackage(
  nixRaw`pkgs.haskellPackages.n-m`,
  "Utility to call iwconfig",
);

/**
 * Package for writing monitoring plugins
 */
export const nagios_check = mkPackage(
  nixRaw`pkgs.haskellPackages.nagios-check`,
  "Package for writing monitoring plugins",
);

/**
 * EDSL to specify Nagios configuration files
 */
export const nagios_config = mkPackage(
  nixRaw`pkgs.haskellPackages.nagios-config`,
  "EDSL to specify Nagios configuration files",
);

/**
 * Parse Nagios performance data
 */
export const nagios_perfdata = mkPackage(
  nixRaw`pkgs.haskellPackages.nagios-perfdata`,
  "Parse Nagios performance data",
);

/**
 * Client library for the Nakadi Event Broker
 */
export const nakadi_client = mkPackage(
  nixRaw`pkgs.haskellPackages.nakadi-client`,
  "Client library for the Nakadi Event Broker",
);

/**
 * Tool to keep namecoin names updated and well
 */
export const namecoin_update = mkPackage(
  nixRaw`pkgs.haskellPackages.namecoin-update`,
  "Tool to keep namecoin names updated and well",
);

/**
 * Named parameters (keyword arguments) for Haskell
 */
export const named = mkPackage(
  nixRaw`pkgs.haskellPackages.named`,
  "Named parameters (keyword arguments) for Haskell",
);

/**
 * A simple formlet library with named formlets
 */
export const named_formlet = mkPackage(
  nixRaw`pkgs.haskellPackages.named-formlet`,
  "A simple formlet library with named formlets",
);

/**
 * Flexible records with named fields
 */
export const named_records = mkPackage(
  nixRaw`pkgs.haskellPackages.named-records`,
  "Flexible records with named fields",
);

/**
 * client support for named-servant
 */
export const named_servant_client = mkPackage(
  nixRaw`pkgs.haskellPackages.named-servant-client`,
  "client support for named-servant",
);

/**
 * server support for named-servant
 */
export const named_servant_server = mkPackage(
  nixRaw`pkgs.haskellPackages.named-servant-server`,
  "server support for named-servant",
);

/**
 * A parameterized named text type and associated functionality
 */
export const named_text = mkPackage(
  nixRaw`pkgs.haskellPackages.named-text`,
  "A parameterized named text type and associated functionality",
);

/**
 * Type level names
 */
export const names = mkPackage(
  nixRaw`pkgs.haskellPackages.names`,
  "Type level names",
);

/**
 * Manipulate name strings for TH
 */
export const names_th = mkPackage(
  nixRaw`pkgs.haskellPackages.names-th`,
  "Manipulate name strings for TH",
);

/**
 * A Generic Haskell library for managing namespaces
 */
export const namespace = mkPackage(
  nixRaw`pkgs.haskellPackages.namespace`,
  "A Generic Haskell library for managing namespaces",
);

/**
 * Small library for Erlang-style actor semantics
 */
export const nano_erl = mkPackage(
  nixRaw`pkgs.haskellPackages.nano-erl`,
  "Small library for Erlang-style actor semantics",
);

/**
 * A lightweight implementation of a subset of Hspec's API
 */
export const nanospec = mkPackage(
  nixRaw`pkgs.haskellPackages.nanospec`,
  "A lightweight implementation of a subset of Hspec's API",
);

/**
 * Haskell bindings for nanovg
 */
export const nanovg = mkPackage(
  nixRaw`pkgs.haskellPackages.nanovg`,
  "Haskell bindings for nanovg",
);

/**
 * Performs  (Japan Kanji Aptitude Test) level analysis on given Kanji
 */
export const nanq = mkPackage(
  nixRaw`pkgs.haskellPackages.nanq`,
  "Performs  (Japan Kanji Aptitude Test) level analysis on given Kanji",
);

/**
 * Lazy binary natural numbers
 */
export const nat = mkPackage(
  nixRaw`pkgs.haskellPackages.nat`,
  "Lazy binary natural numbers",
);

/**
 * Refinement types for natural numbers with an optics interface
 */
export const nat_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.nat-optics`,
  "Refinement types for natural numbers with an optics interface",
);

/**
 * Native library manager for Windows
 */
export const native = mkPackage(
  nixRaw`pkgs.haskellPackages.native`,
  "Native library manager for Windows",
);

/**
 * Natural numbers
 */
export const nats = mkPackage(
  nixRaw`pkgs.haskellPackages.nats`,
  "Natural numbers",
);

/**
 * Haskell API for NATS messaging system
 */
export const nats_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.nats-queue`,
  "Haskell API for NATS messaging system",
);

/**
 * Arithmetic of natural numbers
 */
export const natural_arithmetic = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-arithmetic`,
  "Arithmetic of natural numbers",
);

/**
 * Induction over natural numbers
 */
export const natural_induction = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-induction`,
  "Induction over natural numbers",
);

/**
 * Natural numbers tagged with a type-level representation of the number
 */
export const natural_number = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-number`,
  "Natural numbers tagged with a type-level representation of the number",
);

/**
 * Natural numbers
 */
export const natural_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-numbers`,
  "Natural numbers",
);

/**
 * User-friendly text collation
 */
export const natural_sort = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-sort`,
  "User-friendly text collation",
);

/**
 * A natural transformation package
 */
export const natural_transformation = mkPackage(
  nixRaw`pkgs.haskellPackages.natural-transformation`,
  "A natural transformation package",
);

/**
 * Natural-order string comparison
 */
export const naturalcomp = mkPackage(
  nixRaw`pkgs.haskellPackages.naturalcomp`,
  "Natural-order string comparison",
);

/**
 * Constructors and related functions for natural numbers
 */
export const naturals = mkPackage(
  nixRaw`pkgs.haskellPackages.naturals`,
  "Constructors and related functions for natural numbers",
);

/**
 * CPU load and memory usage indicators for i3bar
 */
export const nc_indicators = mkPackage(
  nixRaw`pkgs.haskellPackages.nc-indicators`,
  "CPU load and memory usage indicators for i3bar",
);

/**
 * Conduit-based parsing and serialization for newline delimited JSON
 */
export const ndjson_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.ndjson-conduit`,
  "Conduit-based parsing and serialization for newline delimited JSON",
);

/**
 * A quasiquoter for neat and simple multiline text interpolation
 */
export const neat_interpolation = mkPackage(
  nixRaw`pkgs.haskellPackages.neat-interpolation`,
  "A quasiquoter for neat and simple multiline text interpolation",
);

/**
 * a task management tool for Haskell
 */
export const nemesis = mkPackage(
  nixRaw`pkgs.haskellPackages.nemesis`,
  "a task management tool for Haskell",
);

/**
 * A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration
 */
export const nemesis_titan = mkPackage(
  nixRaw`pkgs.haskellPackages.nemesis-titan`,
  "A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration",
);

/**
 * A CLI adapter to map Lua's CLI to Neovim's CLI for lua interpretation
 */
export const neolua = mkPackage(
  nixRaw`pkgs.haskellPackages.neolua`,
  "A CLI adapter to map Lua's CLI to Neovim's CLI for lua interpretation",
);

/**
 * Nerf, a named entity recognition tool based on linear-chain CRFs
 */
export const nerf = mkPackage(
  nixRaw`pkgs.haskellPackages.nerf`,
  "Nerf, a named entity recognition tool based on linear-chain CRFs",
);

/**
 * WAI adapter for Nero server applications
 */
export const nero_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.nero-wai`,
  "WAI adapter for Nero server applications",
);

/**
 * Run Nero server applications with Warp
 */
export const nero_warp = mkPackage(
  nixRaw`pkgs.haskellPackages.nero-warp`,
  "Run Nero server applications with Warp",
);

/**
 * Declarative, compositional Wai responses
 */
export const nested_routes = mkPackage(
  nixRaw`pkgs.haskellPackages.nested-routes`,
  "Declarative, compositional Wai responses",
);

/**
 * Nested set model implementation
 */
export const nested_sets = mkPackage(
  nixRaw`pkgs.haskellPackages.nested-sets`,
  "Nested set model implementation",
);

/**
 * An MQTT Protocol Implementation
 */
export const net_mqtt = mkPackage(
  nixRaw`pkgs.haskellPackages.net-mqtt`,
  "An MQTT Protocol Implementation",
);

/**
 * An MQTT Protocol Implementation
 */
export const net_mqtt_0_8_6_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.net-mqtt_0_8_6_0`,
  "An MQTT Protocol Implementation",
);

/**
 * Optics for net-mqtt
 */
export const net_mqtt_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.net-mqtt-lens`,
  "Optics for net-mqtt",
);

/**
 * Make RPC calls via an MQTT broker
 */
export const net_mqtt_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.net-mqtt-rpc`,
  "Make RPC calls via an MQTT broker",
);

/**
 * A graph database middleware to maintain a time-varying graph
 */
export const net_spider = mkPackage(
  nixRaw`pkgs.haskellPackages.net-spider`,
  "A graph database middleware to maintain a time-varying graph",
);

/**
 * CLI option parsers for NetSpider objects
 */
export const net_spider_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.net-spider-cli`,
  "CLI option parsers for NetSpider objects",
);

/**
 * Conversion between net-spider and pangraph
 */
export const net_spider_pangraph = mkPackage(
  nixRaw`pkgs.haskellPackages.net-spider-pangraph`,
  "Conversion between net-spider and pangraph",
);

/**
 * NetSpider data model and utility for RPL networks
 */
export const net_spider_rpl = mkPackage(
  nixRaw`pkgs.haskellPackages.net-spider-rpl`,
  "NetSpider data model and utility for RPL networks",
);

/**
 * CLI executable of NetSpider.RPL.
 */
export const net_spider_rpl_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.net-spider-rpl-cli`,
  "CLI executable of NetSpider.RPL.",
);

/**
 * Bindings to the low-level netcode.io library.
 */
export const netcode_io = mkPackage(
  nixRaw`pkgs.haskellPackages.netcode-io`,
  "Bindings to the low-level netcode.io library.",
);

/**
 * The NetCore compiler and runtime system for OpenFlow networks
 */
export const netcore = mkPackage(
  nixRaw`pkgs.haskellPackages.netcore`,
  "The NetCore compiler and runtime system for OpenFlow networks",
);

/**
 * Helper modules for CArray wrappers to BLAS and LAPACK
 */
export const netlib_carray = mkPackage(
  nixRaw`pkgs.haskellPackages.netlib-carray`,
  "Helper modules for CArray wrappers to BLAS and LAPACK",
);

/**
 * Helper modules for comfort-array wrappers to BLAS and LAPACK
 */
export const netlib_comfort_array = mkPackage(
  nixRaw`pkgs.haskellPackages.netlib-comfort-array`,
  "Helper modules for comfort-array wrappers to BLAS and LAPACK",
);

/**
 * Helper modules for FFI to BLAS and LAPACK
 */
export const netlib_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.netlib-ffi`,
  "Helper modules for FFI to BLAS and LAPACK",
);

/**
 * Enumerator tools for text-based network protocols
 */
export const netlines = mkPackage(
  nixRaw`pkgs.haskellPackages.netlines`,
  "Enumerator tools for text-based network protocols",
);

/**
 * Netlink communication for Haskell
 */
export const netlink = mkPackage(
  nixRaw`pkgs.haskellPackages.netlink`,
  "Netlink communication for Haskell",
);

/**
 * Netlist AST
 */
export const netlist = mkPackage(
  nixRaw`pkgs.haskellPackages.netlist`,
  "Netlist AST",
);

/**
 * Convert a Netlist AST to VHDL
 */
export const netlist_to_vhdl = mkPackage(
  nixRaw`pkgs.haskellPackages.netlist-to-vhdl`,
  "Convert a Netlist AST to VHDL",
);

/**
 * Loading PBM, PGM, PPM image files
 */
export const netpbm = mkPackage(
  nixRaw`pkgs.haskellPackages.netpbm`,
  "Loading PBM, PGM, PPM image files",
);

/**
 * Parser for .netrc files
 */
export const netrc = mkPackage(
  nixRaw`pkgs.haskellPackages.netrc`,
  "Parser for .netrc files",
);

/**
 * Enumerator-based netstring parsing
 */
export const netstring_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.netstring-enumerator`,
  "Enumerator-based netstring parsing",
);

/**
 * safe nettle binding
 */
export const nettle = mkPackage(
  nixRaw`pkgs.haskellPackages.nettle`,
  "safe nettle binding",
);

/**
 * FRP for controlling networks of OpenFlow switches
 */
export const nettle_frp = mkPackage(
  nixRaw`pkgs.haskellPackages.nettle-frp`,
  "FRP for controlling networks of OpenFlow switches",
);

/**
 * DSL for describing OpenFlow networks, and a compiler generating NetKit labs
 */
export const nettle_netkit = mkPackage(
  nixRaw`pkgs.haskellPackages.nettle-netkit`,
  "DSL for describing OpenFlow networks, and a compiler generating NetKit labs",
);

/**
 * OpenFlow protocol messages, binary formats, and servers
 */
export const nettle_openflow = mkPackage(
  nixRaw`pkgs.haskellPackages.nettle-openflow`,
  "OpenFlow protocol messages, binary formats, and servers",
);

/**
 * Functional reactive programming library
 */
export const netwire = mkPackage(
  nixRaw`pkgs.haskellPackages.netwire`,
  "Functional reactive programming library",
);

/**
 * Input handling abstractions for netwire
 */
export const netwire_input = mkPackage(
  nixRaw`pkgs.haskellPackages.netwire-input`,
  "Input handling abstractions for netwire",
);

/**
 * GLFW instance of netwire-input
 */
export const netwire_input_glfw = mkPackage(
  nixRaw`pkgs.haskellPackages.netwire-input-glfw`,
  "GLFW instance of netwire-input",
);

/**
 * Low-level networking interface
 */
export const network = mkPackage(
  nixRaw`pkgs.haskellPackages.network`,
  "Low-level networking interface",
);

/**
 * Low-level networking interface
 */
export const network_2_6_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.network_2_6_3_1`,
  "Low-level networking interface",
);

/**
 * Haskell API for I2P anonymous networking
 */
export const network_anonymous_i2p = mkPackage(
  nixRaw`pkgs.haskellPackages.network-anonymous-i2p`,
  "Haskell API for I2P anonymous networking",
);

/**
 * Haskell API for Tor anonymous networking
 */
export const network_anonymous_tor = mkPackage(
  nixRaw`pkgs.haskellPackages.network-anonymous-tor`,
  "Haskell API for Tor anonymous networking",
);

/**
 * POSIX network database (<netdb.h>) API
 */
export const network_bsd = mkPackage(
  nixRaw`pkgs.haskellPackages.network-bsd`,
  "POSIX network database (<netdb.h>) API",
);

/**
 * Network byte order utilities
 */
export const network_byte_order = mkPackage(
  nixRaw`pkgs.haskellPackages.network-byte-order`,
  "Network byte order utilities",
);

/**
 * Stream socket data using conduits. (deprecated)
 */
export const network_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.network-conduit`,
  "Stream socket data using conduits. (deprecated)",
);

/**
 * Create TLS-aware network code with conduits
 */
export const network_conduit_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.network-conduit-tls`,
  "Create TLS-aware network code with conduits",
);

/**
 * Create TLS-aware network code with conduits
 */
export const network_conduit_tls_1_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.network-conduit-tls_1_4_0`,
  "Create TLS-aware network code with conduits",
);

/**
 * A wrapper around a generic stream-like connection
 */
export const network_connection = mkPackage(
  nixRaw`pkgs.haskellPackages.network-connection`,
  "A wrapper around a generic stream-like connection",
);

/**
 * Library for network data structures and their serialization
 */
export const network_data = mkPackage(
  nixRaw`pkgs.haskellPackages.network-data`,
  "Library for network data structures and their serialization",
);

/**
 * Domain Name System data structures
 */
export const network_dns = mkPackage(
  nixRaw`pkgs.haskellPackages.network-dns`,
  "Domain Name System data structures",
);

/**
 * Enumerators for network sockets
 */
export const network_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.network-enumerator`,
  "Enumerators for network sockets",
);

/**
 * Networking support with a cleaner API
 */
export const network_fancy = mkPackage(
  nixRaw`pkgs.haskellPackages.network-fancy`,
  "Networking support with a cleaner API",
);

/**
 * HaNS to Network shims for easier HaNS integration
 */
export const network_hans = mkPackage(
  nixRaw`pkgs.haskellPackages.network-hans`,
  "HaNS to Network shims for easier HaNS integration",
);

/**
 * Access the local computer's basic network configuration
 */
export const network_info = mkPackage(
  nixRaw`pkgs.haskellPackages.network-info`,
  "Access the local computer's basic network configuration",
);

/**
 * Haskell bindings for the ifreq structure
 */
export const network_interfacerequest = mkPackage(
  nixRaw`pkgs.haskellPackages.network-interfacerequest`,
  "Haskell bindings for the ifreq structure",
);

/**
 * Internet Protocol data structures
 */
export const network_ip = mkPackage(
  nixRaw`pkgs.haskellPackages.network-ip`,
  "Internet Protocol data structures",
);

/**
 * MessagePack RPC
 */
export const network_messagepack_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.network-messagepack-rpc`,
  "MessagePack RPC",
);

/**
 * WebSocket backend for MessagePack RPC
 */
export const network_messagepack_rpc_websocket = mkPackage(
  nixRaw`pkgs.haskellPackages.network-messagepack-rpc-websocket`,
  "WebSocket backend for MessagePack RPC",
);

/**
 * A ByteString based library for writing HTTP(S) servers and clients
 */
export const network_minihttp = mkPackage(
  nixRaw`pkgs.haskellPackages.network-minihttp`,
  "A ByteString based library for writing HTTP(S) servers and clients",
);

/**
 * Simple multicast library
 */
export const network_multicast = mkPackage(
  nixRaw`pkgs.haskellPackages.network-multicast`,
  "Simple multicast library",
);

/**
 * Haskell bindings for low-level packet sockets (AF_PACKET)
 */
export const network_netpacket = mkPackage(
  nixRaw`pkgs.haskellPackages.network-netpacket`,
  "Haskell bindings for low-level packet sockets (AF_PACKET)",
);

/**
 * Library for writing PGI applications
 */
export const network_pgi = mkPackage(
  nixRaw`pkgs.haskellPackages.network-pgi`,
  "Library for writing PGI applications",
);

/**
 * Client library for the XMPP protocol
 */
export const network_protocol_xmpp = mkPackage(
  nixRaw`pkgs.haskellPackages.network-protocol-xmpp`,
  "Client library for the XMPP protocol",
);

/**
 * A cross-platform RPC library
 */
export const network_rpca = mkPackage(
  nixRaw`pkgs.haskellPackages.network-rpca`,
  "A cross-platform RPC library",
);

/**
 * Simple network runner library
 */
export const network_run = mkPackage(
  nixRaw`pkgs.haskellPackages.network-run`,
  "Simple network runner library",
);

/**
 * Simple network sockets usage patterns
 */
export const network_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.network-simple`,
  "Simple network sockets usage patterns",
);

/**
 * Simple interface to TLS secured network sockets
 */
export const network_simple_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.network-simple-tls`,
  "Simple interface to TLS secured network sockets",
);

/**
 * Simple interface to WebSockets
 */
export const network_simple_ws = mkPackage(
  nixRaw`pkgs.haskellPackages.network-simple-ws`,
  "Simple interface to WebSockets",
);

/**
 * Simple interface to TLS secured WebSockets
 */
export const network_simple_wss = mkPackage(
  nixRaw`pkgs.haskellPackages.network-simple-wss`,
  "Simple interface to TLS secured WebSockets",
);

/**
 * ByteString and Text streams for networking
 */
export const network_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.network-stream`,
  "ByteString and Text streams for networking",
);

/**
 * A few network topic model implementations for bayes-stack
 */
export const network_topic_models = mkPackage(
  nixRaw`pkgs.haskellPackages.network-topic-models`,
  "A few network topic model implementations for bayes-stack",
);

/**
 * Network abstraction layer
 */
export const network_transport = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport`,
  "Network abstraction layer",
);

/**
 * Compose network transports
 */
export const network_transport_composed = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport-composed`,
  "Compose network transports",
);

/**
 * In-memory instantiation of Network.Transport
 */
export const network_transport_inmemory = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport-inmemory`,
  "In-memory instantiation of Network.Transport",
);

/**
 * TCP instantiation of Network.Transport
 */
export const network_transport_tcp = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport-tcp`,
  "TCP instantiation of Network.Transport",
);

/**
 * Unit tests for Network.Transport implementations
 */
export const network_transport_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport-tests`,
  "Unit tests for Network.Transport implementations",
);

/**
 * ZeroMQ backend for network-transport
 */
export const network_transport_zeromq = mkPackage(
  nixRaw`pkgs.haskellPackages.network-transport-zeromq`,
  "ZeroMQ backend for network-transport",
);

/**
 * Types for representing ICMP and ICMPv6 messages
 */
export const network_types_icmp = mkPackage(
  nixRaw`pkgs.haskellPackages.network-types-icmp`,
  "Types for representing ICMP and ICMPv6 messages",
);

/**
 * UDP library
 */
export const network_udp = mkPackage(
  nixRaw`pkgs.haskellPackages.network-udp`,
  "UDP library",
);

/**
 * Network functions that do not throw exceptions
 */
export const network_unexceptional = mkPackage(
  nixRaw`pkgs.haskellPackages.network-unexceptional`,
  "Network functions that do not throw exceptions",
);

/**
 * URI manipulation
 */
export const network_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.network-uri`,
  "URI manipulation",
);

/**
 * Pseudo-package encapsulating flag(network-uri) Cabal boilerplate
 */
export const network_uri_flag = mkPackage(
  nixRaw`pkgs.haskellPackages.network-uri-flag`,
  "Pseudo-package encapsulating flag(network-uri) Cabal boilerplate",
);

/**
 * FromJSON and ToJSON Instances for Network.URI
 */
export const network_uri_json = mkPackage(
  nixRaw`pkgs.haskellPackages.network-uri-json`,
  "FromJSON and ToJSON Instances for Network.URI",
);

/**
 * Lenses for network-uri
 */
export const network_uri_lenses = mkPackage(
  nixRaw`pkgs.haskellPackages.network-uri-lenses`,
  "Lenses for network-uri",
);

/**
 * A small utility to declare type-safe static URIs
 */
export const network_uri_static = mkPackage(
  nixRaw`pkgs.haskellPackages.network-uri-static`,
  "A small utility to declare type-safe static URIs",
);

/**
 * Lightweight library for waiting on networked services to become available
 */
export const network_wait = mkPackage(
  nixRaw`pkgs.haskellPackages.network-wait`,
  "Lightweight library for waiting on networked services to become available",
);

/**
 * WebSocket library
 */
export const network_websocket = mkPackage(
  nixRaw`pkgs.haskellPackages.network-websocket`,
  "WebSocket library",
);

/**
 * Neural Networks in native Haskell
 */
export const neural = mkPackage(
  nixRaw`pkgs.haskellPackages.neural`,
  "Neural Networks in native Haskell",
);

/**
 * Yet Another High Performance and Extendable Neural Network in Haskell
 */
export const neural_network_base = mkPackage(
  nixRaw`pkgs.haskellPackages.neural-network-base`,
  "Yet Another High Performance and Extendable Neural Network in Haskell",
);

/**
 * Future-proof system for plain-text notes
 */
export const neuron = mkPackage(
  nixRaw`pkgs.haskellPackages.neuron`,
  "Future-proof system for plain-text notes",
);

/**
 * A mailgun backend for the newsletter package
 */
export const newsletter_mailgun = mkPackage(
  nixRaw`pkgs.haskellPackages.newsletter-mailgun`,
  "A mailgun backend for the newsletter package",
);

/**
 * Exact and approximate synthesis of quantum circuits
 */
export const newsynth = mkPackage(
  nixRaw`pkgs.haskellPackages.newsynth`,
  "Exact and approximate synthesis of quantum circuits",
);

/**
 * A typeclass and set of functions for working with newtypes
 */
export const newtype = mkPackage(
  nixRaw`pkgs.haskellPackages.newtype`,
  "A typeclass and set of functions for working with newtypes",
);

/**
 * A typeclass and set of functions for working with newtypes
 */
export const newtype_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.newtype-generics`,
  "A typeclass and set of functions for working with newtypes",
);

/**
 * Newtype Wrapper Zoo
 */
export const newtype_zoo = mkPackage(
  nixRaw`pkgs.haskellPackages.newtype-zoo`,
  "Newtype Wrapper Zoo",
);

/**
 * Extra functions for the Control.Newtype typeclass
 */
export const newtyper = mkPackage(
  nixRaw`pkgs.haskellPackages.newtyper`,
  "Extra functions for the Control.Newtype typeclass",
);

/**
 * NF data type to statically enforce normal form
 */
export const nf = mkPackage(
  nixRaw`pkgs.haskellPackages.nf`,
  "NF data type to statically enforce normal form",
);

/**
 * libnfc bindings
 */
export const nfc = mkPackage(
  nixRaw`pkgs.haskellPackages.nfc`,
  "libnfc bindings",
);

/**
 * Ngram models for compressing and classifying text
 */
export const ngram = mkPackage(
  nixRaw`pkgs.haskellPackages.ngram`,
  "Ngram models for compressing and classifying text",
);

/**
 * Helper module for Nginx haskell module
 */
export const ngx_export = mkPackage(
  nixRaw`pkgs.haskellPackages.ngx-export`,
  "Helper module for Nginx haskell module",
);

/**
 * Build custom libraries for Nginx haskell module
 */
export const ngx_export_distribution = mkPackage(
  nixRaw`pkgs.haskellPackages.ngx-export-distribution`,
  "Build custom libraries for Nginx haskell module",
);

/**
 * Extra tools for Nginx haskell module
 */
export const ngx_export_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.ngx-export-tools`,
  "Extra tools for Nginx haskell module",
);

/**
 * More extra tools for Nginx haskell module
 */
export const ngx_export_tools_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ngx-export-tools-extra`,
  "More extra tools for Nginx haskell module",
);

/**
 * Pretty print the standard output of default `Show` instances
 */
export const nicify = mkPackage(
  nixRaw`pkgs.haskellPackages.nicify`,
  "Pretty print the standard output of default `Show` instances",
);

/**
 * Pretty print the standard output of default `Show` instances
 */
export const nicify_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.nicify-lib`,
  "Pretty print the standard output of default `Show` instances",
);

/**
 * Command line utility publishes Nike+ runs on blogs and Twitter
 */
export const nikepub = mkPackage(
  nixRaw`pkgs.haskellPackages.nikepub`,
  "Command line utility publishes Nike+ runs on blogs and Twitter",
);

/**
 * Finite nimber arithmetic
 */
export const nimber = mkPackage(
  nixRaw`pkgs.haskellPackages.nimber`,
  "Finite nimber arithmetic",
);

/**
 * IDL compiler and RPC/distributed object framework for microservices
 */
export const nirum = mkPackage(
  nixRaw`pkgs.haskellPackages.nirum`,
  "IDL compiler and RPC/distributed object framework for microservices",
);

/**
 * Easy dependency management for Nix projects
 */
export const niv = mkPackage(
  nixRaw`pkgs.haskellPackages.niv`,
  "Easy dependency management for Nix projects",
);

/**
 * Deploy Nix-built software to a NixOS machine
 */
export const nix_deploy = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-deploy`,
  "Deploy Nix-built software to a NixOS machine",
);

/**
 * Parse and render *.drv files
 */
export const nix_derivation = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-derivation`,
  "Parse and render *.drv files",
);

/**
 * Explain why two Nix derivations differ
 */
export const nix_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-diff`,
  "Explain why two Nix derivations differ",
);

/**
 * Reify the Nix build graph into a Haskell graph data structure
 */
export const nix_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-graph`,
  "Reify the Nix build graph into a Haskell graph data structure",
);

/**
 * Parse and render .narinfo files
 */
export const nix_narinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-narinfo`,
  "Parse and render .narinfo files",
);

/**
 * Knowledge of Nix's installation directories
 */
export const nix_paths = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-paths`,
  "Knowledge of Nix's installation directories",
);

/**
 * Lightweight dependency management with Nix
 */
export const nix_thunk = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-thunk`,
  "Lightweight dependency management with Nix",
);

/**
 * Interactively browse a Nix store paths dependencies
 */
export const nix_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.nix-tree`,
  "Interactively browse a Nix store paths dependencies",
);

/**
 * An opinionated formatter for Nix
 */
export const nixfmt = mkPackage(
  nixRaw`pkgs.haskellPackages.nixfmt`,
  "An opinionated formatter for Nix",
);

/**
 * this package is obsolete; see cabal2nix instead
 */
export const nixos_types = mkPackage(
  nixRaw`pkgs.haskellPackages.nixos-types`,
  "this package is obsolete; see cabal2nix instead",
);

/**
 * Manipulating the National Corpus of Polish (NKJP)
 */
export const nkjp = mkPackage(
  nixRaw`pkgs.haskellPackages.nkjp`,
  "Manipulating the National Corpus of Polish (NKJP)",
);

/**
 * Low-level bindings to the NLOPT optimization library
 */
export const nlopt_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.nlopt-haskell`,
  "Low-level bindings to the NLOPT optimization library",
);

/**
 * NLP scoring command-line programs
 */
export const nlp_scores_scripts = mkPackage(
  nixRaw`pkgs.haskellPackages.nlp-scores-scripts`,
  "NLP scoring command-line programs",
);

/**
 * Workaround for GHC bug #2189
 */
export const no_buffering_workaround = mkPackage(
  nixRaw`pkgs.haskellPackages.no-buffering-workaround`,
  "Workaround for GHC bug #2189",
);

/**
 * A type class for choosing sentinel-like values
 */
export const no_value = mkPackage(
  nixRaw`pkgs.haskellPackages.no-value`,
  "A type class for choosing sentinel-like values",
);

/**
 * Name-binding & alpha-equivalence
 */
export const nom = mkPackage(
  nixRaw`pkgs.haskellPackages.nom`,
  "Name-binding & alpha-equivalence",
);

/**
 * Binders and alpha-equivalence made easy
 */
export const nominal = mkPackage(
  nixRaw`pkgs.haskellPackages.nominal`,
  "Binders and alpha-equivalence made easy",
);

/**
 * REST API for Nomyx
 */
export const nomyx_api = mkPackage(
  nixRaw`pkgs.haskellPackages.nomyx-api`,
  "REST API for Nomyx",
);

/**
 * A Nomic game in haskell
 */
export const nomyx_core = mkPackage(
  nixRaw`pkgs.haskellPackages.nomyx-core`,
  "A Nomic game in haskell",
);

/**
 * Language to express rules for Nomic
 */
export const nomyx_language = mkPackage(
  nixRaw`pkgs.haskellPackages.nomyx-language`,
  "Language to express rules for Nomic",
);

/**
 * Library of rules for Nomyx
 */
export const nomyx_library = mkPackage(
  nixRaw`pkgs.haskellPackages.nomyx-library`,
  "Library of rules for Nomyx",
);

/**
 * A Nomic game in haskell
 */
export const nomyx_server = mkPackage(
  nixRaw`pkgs.haskellPackages.nomyx-server`,
  "A Nomic game in haskell",
);

/**
 * List-like structures with static restrictions on the number of elements
 */
export const non_empty = mkPackage(
  nixRaw`pkgs.haskellPackages.non-empty`,
  "List-like structures with static restrictions on the number of elements",
);

/**
 * Non-empty sequence
 */
export const non_empty_sequence = mkPackage(
  nixRaw`pkgs.haskellPackages.non-empty-sequence`,
  "Non-empty sequence",
);

/**
 * Non empty Data.Text type
 */
export const non_empty_text = mkPackage(
  nixRaw`pkgs.haskellPackages.non-empty-text`,
  "Non empty Data.Text type",
);

/**
 * Non-negative numbers
 */
export const non_negative = mkPackage(
  nixRaw`pkgs.haskellPackages.non-negative`,
  "Non-negative numbers",
);

/**
 * Generate cryptographic nonces
 */
export const nonce = mkPackage(
  nixRaw`pkgs.haskellPackages.nonce`,
  "Generate cryptographic nonces",
);

/**
 * A monad and monad transformer for nondeterministic computations
 */
export const nondeterminism = mkPackage(
  nixRaw`pkgs.haskellPackages.nondeterminism`,
  "A monad and monad transformer for nondeterministic computations",
);

/**
 * NonEmpty for Alternative types
 */
export const nonempty_alternative = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-alternative`,
  "NonEmpty for Alternative types",
);

/**
 * Non-empty variants of containers data types, with full API
 */
export const nonempty_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-containers`,
  "Non-empty variants of containers data types, with full API",
);

/**
 * Non-empty vectors
 */
export const nonempty_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-vector`,
  "Non-empty vectors",
);

/**
 * Create NonEmpty version of any container
 */
export const nonempty_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-wrapper`,
  "Create NonEmpty version of any container",
);

/**
 * aeson instances for 'NonEmpty'
 */
export const nonempty_wrapper_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-wrapper-aeson`,
  "aeson instances for 'NonEmpty'",
);

/**
 * QuickCheck instance for 'NonEmpty'
 */
export const nonempty_wrapper_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-wrapper-quickcheck`,
  "QuickCheck instance for 'NonEmpty'",
);

/**
 * 'NonEmpty' wrappers for text
 */
export const nonempty_wrapper_text = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-wrapper-text`,
  "'NonEmpty' wrappers for text",
);

/**
 * A non-empty comonadic list zipper
 */
export const nonempty_zipper = mkPackage(
  nixRaw`pkgs.haskellPackages.nonempty-zipper`,
  "A non-empty comonadic list zipper",
);

/**
 * A NonEmptyMap Implementation
 */
export const nonemptymap = mkPackage(
  nixRaw`pkgs.haskellPackages.nonemptymap`,
  "A NonEmptyMap Implementation",
);

/**
 * Free structures sans laws
 */
export const nonfree = mkPackage(
  nixRaw`pkgs.haskellPackages.nonfree`,
  "Free structures sans laws",
);

/**
 * Low-dimensional vectors
 */
export const nonlinear = mkPackage(
  nixRaw`pkgs.haskellPackages.nonlinear`,
  "Low-dimensional vectors",
);

/**
 * Wrapper of nonlinear-optimization package for using with AD package
 */
export const nonlinear_optimization_ad = mkPackage(
  nixRaw`pkgs.haskellPackages.nonlinear-optimization-ad`,
  "Wrapper of nonlinear-optimization package for using with AD package",
);

/**
 * Wrapper of nonlinear-optimization package for using with backprop package
 */
export const nonlinear_optimization_backprop = mkPackage(
  nixRaw`pkgs.haskellPackages.nonlinear-optimization-backprop`,
  "Wrapper of nonlinear-optimization package for using with backprop package",
);

/**
 * Minimum fuss normally distributed random values
 */
export const normaldistribution = mkPackage(
  nixRaw`pkgs.haskellPackages.normaldistribution`,
  "Minimum fuss normally distributed random values",
);

/**
 * Normalize data using a variety of methods
 */
export const normalize = mkPackage(
  nixRaw`pkgs.haskellPackages.normalize`,
  "Normalize data using a variety of methods",
);

/**
 * Sort and align Haskell import statements
 */
export const normalize_imports = mkPackage(
  nixRaw`pkgs.haskellPackages.normalize-imports`,
  "Sort and align Haskell import statements",
);

/**
 * Painless 3D graphics, no affiliation with gloss
 */
export const not_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.not-gloss`,
  "Painless 3D graphics, no affiliation with gloss",
);

/**
 * examples for not-gloss
 */
export const not_gloss_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.not-gloss-examples`,
  "examples for not-gloss",
);

/**
 * Useful utility functions that only depend on base
 */
export const not_in_base = mkPackage(
  nixRaw`pkgs.haskellPackages.not-in-base`,
  "Useful utility functions that only depend on base",
);

/**
 * Examine values for unexpected thunks
 */
export const nothunks = mkPackage(
  nixRaw`pkgs.haskellPackages.nothunks`,
  "Examine values for unexpected thunks",
);

export const notifications_tray_icon = mkPackage(
  nixRaw`pkgs.haskellPackages.notifications-tray-icon`,
  "",
);

/**
 * Haskell binding to Notmuch, the mail indexer
 */
export const notmuch = mkPackage(
  nixRaw`pkgs.haskellPackages.notmuch`,
  "Haskell binding to Notmuch, the mail indexer",
);

/**
 * A web interface to the notmuch email indexer
 */
export const notmuch_web = mkPackage(
  nixRaw`pkgs.haskellPackages.notmuch-web`,
  "A web interface to the notmuch email indexer",
);

/**
 * Zeit Now haskell-side integration and introspection tools
 */
export const now_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.now-haskell`,
  "Zeit Now haskell-side integration and introspection tools",
);

/**
 * Here document without variable expansion like PHP Nowdoc
 */
export const nowdoc = mkPackage(
  nixRaw`pkgs.haskellPackages.nowdoc`,
  "Here document without variable expansion like PHP Nowdoc",
);

/**
 * NumericPrelude extras
 */
export const np_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.np-extras`,
  "NumericPrelude extras",
);

/**
 * Concurrency library in the style of Erlang/OTP
 */
export const nqe = mkPackage(
  nixRaw`pkgs.haskellPackages.nqe`,
  "Concurrency library in the style of Erlang/OTP",
);

/**
 * Read environment variables as settings to build 12-factor apps
 */
export const nri_env_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-env-parser`,
  "Read environment variables as settings to build 12-factor apps",
);

/**
 * Make Elm style HTTP requests
 */
export const nri_http = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-http`,
  "Make Elm style HTTP requests",
);

/**
 * Functions for working with Kafka
 */
export const nri_kafka = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-kafka`,
  "Functions for working with Kafka",
);

/**
 * Report log spans collected by nri-prelude
 */
export const nri_observability = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-observability`,
  "Report log spans collected by nri-prelude",
);

/**
 * Make queries against Postgresql
 */
export const nri_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-postgresql`,
  "Make queries against Postgresql",
);

/**
 * A Prelude inspired by the Elm programming language
 */
export const nri_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-prelude`,
  "A Prelude inspired by the Elm programming language",
);

/**
 * An intuitive hedis wrapper library
 */
export const nri_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-redis`,
  "An intuitive hedis wrapper library",
);

/**
 * A library to simplify writing golden tests for encoding types
 */
export const nri_test_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.nri-test-encoding`,
  "A library to simplify writing golden tests for encoding types",
);

/**
 * DSL for producing Windows Installer using NSIS
 */
export const nsis = mkPackage(
  nixRaw`pkgs.haskellPackages.nsis`,
  "DSL for producing Windows Installer using NSIS",
);

/**
 * Computing the nth prime
 */
export const nth_prime = mkPackage(
  nixRaw`pkgs.haskellPackages.nth-prime`,
  "Computing the nth prime",
);

/**
 * A tiny statically typed functional programming language
 */
export const ntha = mkPackage(
  nixRaw`pkgs.haskellPackages.ntha`,
  "A tiny statically typed functional programming language",
);

export const nthable = mkPackage(
  nixRaw`pkgs.haskellPackages.nthable`,
  "",
);

/**
 * N-ary sum/product types
 */
export const ntype = mkPackage(
  nixRaw`pkgs.haskellPackages.ntype`,
  "N-ary sum/product types",
);

/**
 * Non-negative numbers
 */
export const num_non_negative = mkPackage(
  nixRaw`pkgs.haskellPackages.num-non-negative`,
  "Non-negative numbers",
);

/**
 * A library for real numbers
 */
export const number = mkPackage(
  nixRaw`pkgs.haskellPackages.number`,
  "A library for real numbers",
);

/**
 * Number of digits in a number in decimal and hexadecimal representation
 */
export const number_length = mkPackage(
  nixRaw`pkgs.haskellPackages.number-length`,
  "Number of digits in a number in decimal and hexadecimal representation",
);

/**
 * Flexible and accurate (for a given precision) numerical->string conversion
 */
export const number_show = mkPackage(
  nixRaw`pkgs.haskellPackages.number-show`,
  "Flexible and accurate (for a given precision) numerical->string conversion",
);

/**
 * A sequence of semigroups, for composing stuff in multiple spatial directions
 */
export const numbered_semigroups = mkPackage(
  nixRaw`pkgs.haskellPackages.numbered-semigroups`,
  "A sequence of semigroups, for composing stuff in multiple spatial directions",
);

/**
 * Combinators for creating bijections from some type to the natural numbers
 */
export const numbering = mkPackage(
  nixRaw`pkgs.haskellPackages.numbering`,
  "Combinators for creating bijections from some type to the natural numbers",
);

/**
 * Various number types
 */
export const numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.numbers`,
  "Various number types",
);

/**
 * Convert numbers to number words
 */
export const numerals = mkPackage(
  nixRaw`pkgs.haskellPackages.numerals`,
  "Convert numbers to number words",
);

/**
 * Convert numbers to number words
 */
export const numerals_base = mkPackage(
  nixRaw`pkgs.haskellPackages.numerals-base`,
  "Convert numbers to number words",
);

/**
 * Numeric Domains
 */
export const numeric_domains = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-domains`,
  "Numeric Domains",
);

/**
 * Useful tools from the C standard library
 */
export const numeric_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-extras`,
  "Useful tools from the C standard library",
);

/**
 * Type-level numeric types and classes
 */
export const numeric_kinds = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-kinds`,
  "Type-level numeric types and classes",
);

/**
 * Various floating point limit related constants
 */
export const numeric_limits = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-limits`,
  "Various floating point limit related constants",
);

/**
 * Integral and rational log2 algorithms
 */
export const numeric_logarithms = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-logarithms`,
  "Integral and rational log2 algorithms",
);

/**
 * Ode solvers
 */
export const numeric_ode = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-ode`,
  "Ode solvers",
);

/**
 * Unified interface to various numerical optimization algorithms
 */
export const numeric_optimization = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-optimization`,
  "Unified interface to various numerical optimization algorithms",
);

/**
 * Wrapper of numeric-optimization package for using with AD package
 */
export const numeric_optimization_ad = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-optimization-ad`,
  "Wrapper of numeric-optimization package for using with AD package",
);

/**
 * Wrapper of numeric-optimization package for using with backprop package
 */
export const numeric_optimization_backprop = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-optimization-backprop`,
  "Wrapper of numeric-optimization package for using with backprop package",
);

/**
 * An experimental alternative hierarchy of numeric type classes
 */
export const numeric_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-prelude`,
  "An experimental alternative hierarchy of numeric type classes",
);

/**
 * Math and quantum mechanics
 */
export const numeric_quest = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-quest`,
  "Math and quantum mechanics",
);

/**
 * Collection of numerical tools for integration, differentiation etc
 */
export const numeric_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.numeric-tools`,
  "Collection of numerical tools for integration, differentiation etc",
);

/**
 * core package for Numerical Haskell project
 */
export const numerical = mkPackage(
  nixRaw`pkgs.haskellPackages.numerical`,
  "core package for Numerical Haskell project",
);

/**
 * Numerical integration
 */
export const numerical_integration = mkPackage(
  nixRaw`pkgs.haskellPackages.numerical-integration`,
  "Numerical integration",
);

/**
 * Peano numbers with attendant bells and whistles
 */
export const numericpeano = mkPackage(
  nixRaw`pkgs.haskellPackages.numericpeano`,
  "Peano numbers with attendant bells and whistles",
);

/**
 * A numeric class hierarchy
 */
export const numhask = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask`,
  "A numeric class hierarchy",
);

/**
 * A numeric class hierarchy
 */
export const numhask_0_11_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask_0_11_1_0`,
  "A numeric class hierarchy",
);

/**
 * Multi-dimensional arrays
 */
export const numhask_array = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-array`,
  "Multi-dimensional arrays",
);

/**
 * Multi-dimensional arrays
 */
export const numhask_array_0_11_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-array_0_11_0_1`,
  "Multi-dimensional arrays",
);

/**
 * Laws and tests for numhask
 */
export const numhask_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-hedgehog`,
  "Laws and tests for numhask",
);

/**
 * See readme.md
 */
export const numhask_histogram = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-histogram`,
  "See readme.md",
);

/**
 * Numbers that are range representations
 */
export const numhask_range = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-range`,
  "Numbers that are range representations",
);

/**
 * Laws and tests for numhask
 */
export const numhask_test = mkPackage(
  nixRaw`pkgs.haskellPackages.numhask-test`,
  "Laws and tests for numhask",
);

/**
 * None
 */
export const nums = mkPackage(
  nixRaw`pkgs.haskellPackages.nums`,
  "None",
);

/**
 * Type-level integers, using TypeNats, Data Kinds, and Closed Type Families
 */
export const numtype_dk = mkPackage(
  nixRaw`pkgs.haskellPackages.numtype-dk`,
  "Type-level integers, using TypeNats, Data Kinds, and Closed Type Families",
);

/**
 * NURBS
 */
export const nurbs = mkPackage(
  nixRaw`pkgs.haskellPackages.nurbs`,
  "NURBS",
);

export const nuxeo = mkPackage(
  nixRaw`pkgs.haskellPackages.nuxeo`,
  "",
);

/**
 * Generate nix sources expr for the latest version of packages
 */
export const nvfetcher = mkPackage(
  nixRaw`pkgs.haskellPackages.nvfetcher`,
  "Generate nix sources expr for the latest version of packages",
);

/**
 * Haskell plugin backend for neovim
 */
export const nvim_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.nvim-hs`,
  "Haskell plugin backend for neovim",
);

/**
 * Haskell plugin backend for neovim
 */
export const nvim_hs_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.nvim-hs-contrib`,
  "Haskell plugin backend for neovim",
);

/**
 * Neovim plugin that runs ghcid to update the quickfix list
 */
export const nvim_hs_ghcid = mkPackage(
  nixRaw`pkgs.haskellPackages.nvim-hs-ghcid`,
  "Neovim plugin that runs ghcid to update the quickfix list",
);

/**
 * FFI bindings to NVVM
 */
export const nvvm = mkPackage(
  nixRaw`pkgs.haskellPackages.nvvm`,
  "FFI bindings to NVVM",
);

/**
 * Bored? Nyan cat!
 */
export const nyan = mkPackage(
  nixRaw`pkgs.haskellPackages.nyan`,
  "Bored? Nyan cat!",
);

/**
 * Flexible production-scale string interpolation library
 */
export const nyan_interpolation = mkPackage(
  nixRaw`pkgs.haskellPackages.nyan-interpolation`,
  "Flexible production-scale string interpolation library",
);

/**
 * Customize your nyan interpolator!
 */
export const nyan_interpolation_core = mkPackage(
  nixRaw`pkgs.haskellPackages.nyan-interpolation-core`,
  "Customize your nyan interpolator!",
);

/**
 * Simplified lightweight interpolation
 */
export const nyan_interpolation_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.nyan-interpolation-simple`,
  "Simplified lightweight interpolation",
);

/**
 * An interactive GUI for manipulating L-systems
 */
export const nymphaea = mkPackage(
  nixRaw`pkgs.haskellPackages.nymphaea`,
  "An interactive GUI for manipulating L-systems",
);

/**
 * A bullet-hell game made with SDL2
 */
export const nyx_game = mkPackage(
  nixRaw`pkgs.haskellPackages.nyx-game`,
  "A bullet-hell game made with SDL2",
);

/**
 * Type-safe time library
 */
export const o_clock = mkPackage(
  nixRaw`pkgs.haskellPackages.o-clock`,
  "Type-safe time library",
);

/**
 * Type-safe time library
 */
export const o_clock_1_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.o-clock_1_4_0`,
  "Type-safe time library",
);

/**
 * Composable concurrent computation done right
 */
export const oath = mkPackage(
  nixRaw`pkgs.haskellPackages.oath`,
  "Composable concurrent computation done right",
);

/**
 * Fully Automatic Luxury OAuth 1.0a headers
 */
export const oauth10a = mkPackage(
  nixRaw`pkgs.haskellPackages.oauth10a`,
  "Fully Automatic Luxury OAuth 1.0a headers",
);

/**
 * OAuth2 jwt-bearer client flow as per rfc7523
 */
export const oauth2_jwt_bearer = mkPackage(
  nixRaw`pkgs.haskellPackages.oauth2-jwt-bearer`,
  "OAuth2 jwt-bearer client flow as per rfc7523",
);

/**
 * Communicate to OBD interfaces over ELM327
 */
export const obd = mkPackage(
  nixRaw`pkgs.haskellPackages.obd`,
  "Communicate to OBD interfaces over ELM327",
);

/**
 * Ordered Reduced Binary Decision Diagrams
 */
export const obdd = mkPackage(
  nixRaw`pkgs.haskellPackages.obdd`,
  "Ordered Reduced Binary Decision Diagrams",
);

/**
 * Oberon0 Compiler
 */
export const oberon0 = mkPackage(
  nixRaw`pkgs.haskellPackages.oberon0`,
  "Oberon0 Compiler",
);

/**
 * Reads and writes obj models
 */
export const obj = mkPackage(
  nixRaw`pkgs.haskellPackages.obj`,
  "Reads and writes obj models",
);

/**
 * Rather unique identifier for things that need to be stored
 */
export const objectid = mkPackage(
  nixRaw`pkgs.haskellPackages.objectid`,
  "Rather unique identifier for things that need to be stored",
);

/**
 * Composable objects
 */
export const objective = mkPackage(
  nixRaw`pkgs.haskellPackages.objective`,
  "Composable objects",
);

/**
 * An implementation of the Oblivious Transfer protocol in Haskell
 */
export const oblivious_transfer = mkPackage(
  nixRaw`pkgs.haskellPackages.oblivious-transfer`,
  "An implementation of the Oblivious Transfer protocol in Haskell",
);

/**
 * Continuation patterns
 */
export const observable = mkPackage(
  nixRaw`pkgs.haskellPackages.observable`,
  "Continuation patterns",
);

/**
 * Simple observable sharing
 */
export const observable_sharing = mkPackage(
  nixRaw`pkgs.haskellPackages.observable-sharing`,
  "Simple observable sharing",
);

/**
 * Object capability based IO
 */
export const ocap_io = mkPackage(
  nixRaw`pkgs.haskellPackages.ocap-io`,
  "Object capability based IO",
);

/**
 * Owned channels in the Ownership Monad
 */
export const ochan = mkPackage(
  nixRaw`pkgs.haskellPackages.ochan`,
  "Owned channels in the Ownership Monad",
);

/**
 * A module to manage payroll books for Japanese companies
 */
export const ochintin_daicho = mkPackage(
  nixRaw`pkgs.haskellPackages.ochintin-daicho`,
  "A module to manage payroll books for Japanese companies",
);

/**
 * Parse Rocket League replays
 */
export const octane = mkPackage(
  nixRaw`pkgs.haskellPackages.octane`,
  "Parse Rocket League replays",
);

/**
 * A tested, minimal wrapper around GitHub's API
 */
export const octohat = mkPackage(
  nixRaw`pkgs.haskellPackages.octohat`,
  "A tested, minimal wrapper around GitHub's API",
);

/**
 * Lisp with more dynamism, more power, more simplicity
 */
export const octopus = mkPackage(
  nixRaw`pkgs.haskellPackages.octopus`,
  "Lisp with more dynamism, more power, more simplicity",
);

/**
 * Oculus Rift ffi providing head tracking data
 */
export const oculus = mkPackage(
  nixRaw`pkgs.haskellPackages.oculus`,
  "Oculus Rift ffi providing head tracking data",
);

/**
 * Haskell binding to the ODBC API, aimed at SQL Server driver
 */
export const odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.odbc`,
  "Haskell binding to the ODBC API, aimed at SQL Server driver",
);

/**
 * A full-featured PostgreSQL-backed job queue (with an admin UI)
 */
export const odd_jobs = mkPackage(
  nixRaw`pkgs.haskellPackages.odd-jobs`,
  "A full-featured PostgreSQL-backed job queue (with an admin UI)",
);

/**
 * Oracle Database Bindings
 */
export const odpic_raw = mkPackage(
  nixRaw`pkgs.haskellPackages.odpic-raw`,
  "Oracle Database Bindings",
);

/**
 * Convert Open Document Spreadsheet ODS to CSV
 */
export const ods2csv = mkPackage(
  nixRaw`pkgs.haskellPackages.ods2csv`,
  "Convert Open Document Spreadsheet ODS to CSV",
);

/**
 * Interface to the Online Encyclopedia of Integer Sequences (OEIS)
 */
export const oeis = mkPackage(
  nixRaw`pkgs.haskellPackages.oeis`,
  "Interface to the Online Encyclopedia of Integer Sequences (OEIS)",
);

/**
 * A parser for simplified-syntax OFF files
 */
export const off_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.off-simple`,
  "A parser for simplified-syntax OFF files",
);

/**
 * Parser for OFX data
 */
export const ofx = mkPackage(
  nixRaw`pkgs.haskellPackages.ofx`,
  "Parser for OFX data",
);

/**
 * Ogma: Helper tool to interoperate between Copilot and other languages
 */
export const ogma_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-cli`,
  "Ogma: Helper tool to interoperate between Copilot and other languages",
);

/**
 * Ogma: Helper tool to interoperate between Copilot and other languages
 */
export const ogma_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-core`,
  "Ogma: Helper tool to interoperate between Copilot and other languages",
);

/**
 * Ogma: Helper tool to interoperate between Copilot and other languages
 */
export const ogma_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-extra`,
  "Ogma: Helper tool to interoperate between Copilot and other languages",
);

/**
 * Ogma: Runtime Monitor translator: Copilot Language Endpoints
 */
export const ogma_language_copilot = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-language-copilot`,
  "Ogma: Runtime Monitor translator: Copilot Language Endpoints",
);

/**
 * Ogma: Runtime Monitor translator: FRET Component Specification Frontend
 */
export const ogma_language_fret_cs = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-language-fret-cs`,
  "Ogma: Runtime Monitor translator: FRET Component Specification Frontend",
);

/**
 * Ogma: Runtime Monitor translator: FRET Component Requirement DB Frontend
 */
export const ogma_language_fret_reqs = mkPackage(
  nixRaw`pkgs.haskellPackages.ogma-language-fret-reqs`,
  "Ogma: Runtime Monitor translator: FRET Component Requirement DB Frontend",
);

/**
 * OpenID Connect 1.0 library for RP
 */
export const oidc_client = mkPackage(
  nixRaw`pkgs.haskellPackages.oidc-client`,
  "OpenID Connect 1.0 library for RP",
);

/**
 * wrapper for OIS input manager for use with hogre
 */
export const ois_input_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.ois-input-manager`,
  "wrapper for OIS input manager for use with hogre",
);

/**
 * locale library
 */
export const old_locale = mkPackage(
  nixRaw`pkgs.haskellPackages.old-locale`,
  "locale library",
);

/**
 * Time library
 */
export const old_time = mkPackage(
  nixRaw`pkgs.haskellPackages.old-time`,
  "Time library",
);

/**
 * An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay
 */
export const olwrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.olwrapper`,
  "An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay",
);

/**
 * Concurrency utilities
 */
export const om_fork = mkPackage(
  nixRaw`pkgs.haskellPackages.om-fork`,
  "Concurrency utilities",
);

/**
 * om-kubernetes
 */
export const om_kubernetes = mkPackage(
  nixRaw`pkgs.haskellPackages.om-kubernetes`,
  "om-kubernetes",
);

/**
 * Legion Framework
 */
export const om_legion = mkPackage(
  nixRaw`pkgs.haskellPackages.om-legion`,
  "Legion Framework",
);

/**
 * Plugin-based import warnings
 */
export const om_plugin_imports = mkPackage(
  nixRaw`pkgs.haskellPackages.om-plugin-imports`,
  "Plugin-based import warnings",
);

/**
 * Utilities for showing string-like things
 */
export const om_show = mkPackage(
  nixRaw`pkgs.haskellPackages.om-show`,
  "Utilities for showing string-like things",
);

/**
 * Misc. time utilites
 */
export const om_time = mkPackage(
  nixRaw`pkgs.haskellPackages.om-time`,
  "Misc. time utilites",
);

/**
 * Data encoding and decoding command line utilities
 */
export const omnicodec = mkPackage(
  nixRaw`pkgs.haskellPackages.omnicodec`,
  "Data encoding and decoding command line utilities",
);

/**
 * memoization for IO actions and functions
 */
export const once = mkPackage(
  nixRaw`pkgs.haskellPackages.once`,
  "memoization for IO actions and functions",
);

/**
 * Anonymous coproduct type
 */
export const oneOfN = mkPackage(
  nixRaw`pkgs.haskellPackages.oneOfN`,
  "Anonymous coproduct type",
);

/**
 * Pretty-printing short Aeson values as text
 */
export const one_line_aeson_text = mkPackage(
  nixRaw`pkgs.haskellPackages.one-line-aeson-text`,
  "Pretty-printing short Aeson values as text",
);

/**
 * Constraint-based generics
 */
export const one_liner = mkPackage(
  nixRaw`pkgs.haskellPackages.one-liner`,
  "Constraint-based generics",
);

/**
 * Generics-based implementations for common typeclasses
 */
export const one_liner_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.one-liner-instances`,
  "Generics-based implementations for common typeclasses",
);

/**
 * HMAC-Based and Time-Based One-Time Passwords
 */
export const one_time_password = mkPackage(
  nixRaw`pkgs.haskellPackages.one-time-password`,
  "HMAC-Based and Time-Based One-Time Passwords",
);

/**
 * See readme.md
 */
export const online_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.online-csv`,
  "See readme.md",
);

/**
 * A grep-like tool for filtering on words or lines
 */
export const only = mkPackage(
  nixRaw`pkgs.haskellPackages.only`,
  "A grep-like tool for filtering on words or lines",
);

/**
 * Support for OO-like prototypes
 */
export const oo_prototypes = mkPackage(
  nixRaw`pkgs.haskellPackages.oo-prototypes`,
  "Support for OO-like prototypes",
);

/**
 * Combinators for handling errors of many types in a composable way
 */
export const oops = mkPackage(
  nixRaw`pkgs.haskellPackages.oops`,
  "Combinators for handling errors of many types in a composable way",
);

/**
 * Oops examples
 */
export const oops_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.oops-examples`,
  "Oops examples",
);

/**
 * An SQL-generating DSL targeting PostgreSQL
 */
export const opaleye = mkPackage(
  nixRaw`pkgs.haskellPackages.opaleye`,
  "An SQL-generating DSL targeting PostgreSQL",
);

/**
 * An SQL-generating DSL targeting PostgreSQL
 */
export const opaleye_0_10_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.opaleye_0_10_1_1`,
  "An SQL-generating DSL targeting PostgreSQL",
);

/**
 * OPC XML-DA Client
 */
export const opc_xml_da_client = mkPackage(
  nixRaw`pkgs.haskellPackages.opc-xml-da-client`,
  "OPC XML-DA Client",
);

/**
 * Open algebraic data type examples
 */
export const open_adt_tutorial = mkPackage(
  nixRaw`pkgs.haskellPackages.open-adt-tutorial`,
  "Open algebraic data type examples",
);

/**
 * Open a web browser from Haskell
 */
export const open_browser = mkPackage(
  nixRaw`pkgs.haskellPackages.open-browser`,
  "Open a web browser from Haskell",
);

export const open_symbology = mkPackage(
  nixRaw`pkgs.haskellPackages.open-symbology`,
  "",
);

/**
 * Open type representations and dynamic types
 */
export const open_typerep = mkPackage(
  nixRaw`pkgs.haskellPackages.open-typerep`,
  "Open type representations and dynamic types",
);

/**
 * Extensible, type-safe unions
 */
export const open_union = mkPackage(
  nixRaw`pkgs.haskellPackages.open-union`,
  "Extensible, type-safe unions",
);

/**
 * open witnesses
 */
export const open_witness = mkPackage(
  nixRaw`pkgs.haskellPackages.open-witness`,
  "open witnesses",
);

/**
 * Unofficial OpenAI servant types
 */
export const openai_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.openai-servant`,
  "Unofficial OpenAI servant types",
);

/**
 * Low-level bindings to OpenAL
 */
export const openal_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.openal-ffi`,
  "Low-level bindings to OpenAL",
);

/**
 * Haskell binding to OpenCV-3.x
 */
export const opencv = mkPackage(
  nixRaw`pkgs.haskellPackages.opencv`,
  "Haskell binding to OpenCV-3.x",
);

/**
 * Haskell binding to OpenCV-3.x extra modules
 */
export const opencv_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.opencv-extra`,
  "Haskell binding to OpenCV-3.x extra modules",
);

/**
 * Library for writing images in OpenEXR HDR file format
 */
export const openexr_write = mkPackage(
  nixRaw`pkgs.haskellPackages.openexr-write`,
  "Library for writing images in OpenEXR HDR file format",
);

/**
 * Library and example for using DLP stereo in OpenGL
 */
export const opengl_dlp_stereo = mkPackage(
  nixRaw`pkgs.haskellPackages.opengl-dlp-stereo`,
  "Library and example for using DLP stereo in OpenGL",
);

/**
 * Library and example for using a SpaceNavigator-compatible 3-D mouse with OpenGL
 */
export const opengl_spacenavigator = mkPackage(
  nixRaw`pkgs.haskellPackages.opengl-spacenavigator`,
  "Library and example for using a SpaceNavigator-compatible 3-D mouse with OpenGL",
);

/**
 * Implementation of cryptography for use with OpenPGP using the Crypto library
 */
export const openpgp_Crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.openpgp-Crypto`,
  "Implementation of cryptography for use with OpenPGP using the Crypto library",
);

/**
 * OpenPGP (RFC4880) ASCII Armor codec
 */
export const openpgp_asciiarmor = mkPackage(
  nixRaw`pkgs.haskellPackages.openpgp-asciiarmor`,
  "OpenPGP (RFC4880) ASCII Armor codec",
);

/**
 * Implement cryptography for OpenPGP using crypto-api compatible libraries
 */
export const openpgp_crypto_api = mkPackage(
  nixRaw`pkgs.haskellPackages.openpgp-crypto-api`,
  "Implement cryptography for OpenPGP using crypto-api compatible libraries",
);

/**
 * Haskell API Wrapper for the Open Source License API
 */
export const opensource = mkPackage(
  nixRaw`pkgs.haskellPackages.opensource`,
  "Haskell API Wrapper for the Open Source License API",
);

/**
 * Fetch OpenSSH keys from a GitHub team
 */
export const openssh_github_keys = mkPackage(
  nixRaw`pkgs.haskellPackages.openssh-github-keys`,
  "Fetch OpenSSH keys from a GitHub team",
);

/**
 * Create OpenSSL keypairs
 */
export const openssl_createkey = mkPackage(
  nixRaw`pkgs.haskellPackages.openssl-createkey`,
  "Create OpenSSL keypairs",
);

/**
 * OpenSSL network support for io-streams
 */
export const openssl_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.openssl-streams`,
  "OpenSSL network support for io-streams",
);

export const opentelemetry = mkPackage(
  nixRaw`pkgs.haskellPackages.opentelemetry`,
  "",
);

export const opentelemetry_lightstep = mkPackage(
  nixRaw`pkgs.haskellPackages.opentelemetry-lightstep`,
  "",
);

/**
 * GHC plugin for open telemetry
 */
export const opentelemetry_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.opentelemetry-plugin`,
  "GHC plugin for open telemetry",
);

export const opentelemetry_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.opentelemetry-wai`,
  "",
);

/**
 * The standard theory library
 */
export const opentheory = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory`,
  "The standard theory library",
);

/**
 * Natural number to bit-list conversions
 */
export const opentheory_bits = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-bits`,
  "Natural number to bit-list conversions",
);

/**
 * Bytes
 */
export const opentheory_byte = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-byte`,
  "Bytes",
);

/**
 * The divides relation on natural numbers
 */
export const opentheory_divides = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-divides`,
  "The divides relation on natural numbers",
);

/**
 * Fibonacci numbers
 */
export const opentheory_fibonacci = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-fibonacci`,
  "Fibonacci numbers",
);

/**
 * Stream parsers
 */
export const opentheory_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-parser`,
  "Stream parsers",
);

/**
 * Prime natural numbers
 */
export const opentheory_prime = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-prime`,
  "Prime natural numbers",
);

/**
 * Haskell primitives used by OpenTheory packages
 */
export const opentheory_primitive = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-primitive`,
  "Haskell primitives used by OpenTheory packages",
);

/**
 * Probability
 */
export const opentheory_probability = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-probability`,
  "Probability",
);

/**
 * Infinite stream types
 */
export const opentheory_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-stream`,
  "Infinite stream types",
);

/**
 * Unicode characters
 */
export const opentheory_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.opentheory-unicode`,
  "Unicode characters",
);

/**
 * An OpenTok SDK for Haskell
 */
export const opentok = mkPackage(
  nixRaw`pkgs.haskellPackages.opentok`,
  "An OpenTok SDK for Haskell",
);

/**
 * OpenTracing instrumentation of http-client
 */
export const opentracing_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-http-client`,
  "OpenTracing instrumentation of http-client",
);

/**
 * Jaeger backend for OpenTracing
 */
export const opentracing_jaeger = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-jaeger`,
  "Jaeger backend for OpenTracing",
);

/**
 * Middleware adding OpenTracing tracing for WAI applications
 */
export const opentracing_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-wai`,
  "Middleware adding OpenTracing tracing for WAI applications",
);

/**
 * Zipkin OpenTracing Backend Commons
 */
export const opentracing_zipkin_common = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-zipkin-common`,
  "Zipkin OpenTracing Backend Commons",
);

/**
 * Zipkin V1 backend for OpenTracing
 */
export const opentracing_zipkin_v1 = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-zipkin-v1`,
  "Zipkin V1 backend for OpenTracing",
);

/**
 * Zipkin V2 backend for OpenTracing
 */
export const opentracing_zipkin_v2 = mkPackage(
  nixRaw`pkgs.haskellPackages.opentracing-zipkin-v2`,
  "Zipkin V2 backend for OpenTracing",
);

/**
 * Access data at OpenWeatherMap
 */
export const openweathermap = mkPackage(
  nixRaw`pkgs.haskellPackages.openweathermap`,
  "Access data at OpenWeatherMap",
);

/**
 * Implementation of difficult monads made easy with operational semantics
 */
export const operational = mkPackage(
  nixRaw`pkgs.haskellPackages.operational`,
  "Implementation of difficult monads made easy with operational semantics",
);

/**
 * A version of Operational suitable for extensible EDSLs
 */
export const operational_alacarte = mkPackage(
  nixRaw`pkgs.haskellPackages.operational-alacarte`,
  "A version of Operational suitable for extensible EDSLs",
);

/**
 * MonadProgram typeclass for the operational package
 */
export const operational_class = mkPackage(
  nixRaw`pkgs.haskellPackages.operational-class`,
  "MonadProgram typeclass for the operational package",
);

/**
 * Representing and handling OPML subscription information
 */
export const opml = mkPackage(
  nixRaw`pkgs.haskellPackages.opml`,
  "Representing and handling OPML subscription information",
);

/**
 * Streaming parser/renderer for the OPML 2.0 format.
 */
export const opml_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.opml-conduit`,
  "Streaming parser/renderer for the OPML 2.0 format.",
);

/**
 * Optics as an abstract interface
 */
export const optics = mkPackage(
  nixRaw`pkgs.haskellPackages.optics`,
  "Optics as an abstract interface",
);

/**
 * Optics as an abstract interface: core definitions
 */
export const optics_core = mkPackage(
  nixRaw`pkgs.haskellPackages.optics-core`,
  "Optics as an abstract interface: core definitions",
);

/**
 * Extra utilities and instances for optics-core
 */
export const optics_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.optics-extra`,
  "Extra utilities and instances for optics-core",
);

/**
 * A tiny package containing operators missing from the official package
 */
export const optics_operators = mkPackage(
  nixRaw`pkgs.haskellPackages.optics-operators`,
  "A tiny package containing operators missing from the official package",
);

/**
 * Optics construction using TemplateHaskell
 */
export const optics_th = mkPackage(
  nixRaw`pkgs.haskellPackages.optics-th`,
  "Optics construction using TemplateHaskell",
);

/**
 * Utilities for compatibility with van Laarhoven optics
 */
export const optics_vl = mkPackage(
  nixRaw`pkgs.haskellPackages.optics-vl`,
  "Utilities for compatibility with van Laarhoven optics",
);

/**
 * Command-line arguments parsing for Hasql
 */
export const optima_for_hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.optima-for-hasql`,
  "Command-line arguments parsing for Hasql",
);

/**
 * Optimal Block boundary determination for rsync-like behaviours
 */
export const optimal_blocks = mkPackage(
  nixRaw`pkgs.haskellPackages.optimal-blocks`,
  "Optimal Block boundary determination for rsync-like behaviours",
);

/**
 * A supercompiler for f-lite
 */
export const optimusprime = mkPackage(
  nixRaw`pkgs.haskellPackages.optimusprime`,
  "A supercompiler for f-lite",
);

/**
 * A strict version of Maybe
 */
export const option = mkPackage(
  nixRaw`pkgs.haskellPackages.option`,
  "A strict version of Maybe",
);

/**
 * Optional function arguments
 */
export const optional_args = mkPackage(
  nixRaw`pkgs.haskellPackages.optional-args`,
  "Optional function arguments",
);

/**
 * A powerful and easy-to-use command-line option parser
 */
export const options = mkPackage(
  nixRaw`pkgs.haskellPackages.options`,
  "A powerful and easy-to-use command-line option parser",
);

/**
 * Powerful and easy command-line option parser
 */
export const options_1_2_1_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.options_1_2_1_2`,
  "Powerful and easy command-line option parser",
);

/**
 * Utilities and combinators for parsing command line options
 */
export const optparse_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-applicative`,
  "Utilities and combinators for parsing command line options",
);

/**
 * Utilities and combinators for parsing command line options
 */
export const optparse_applicative_0_15_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-applicative_0_15_1_0`,
  "Utilities and combinators for parsing command line options",
);

/**
 * Utilities and combinators for parsing command line options
 */
export const optparse_applicative_0_18_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-applicative_0_18_1_0`,
  "Utilities and combinators for parsing command line options",
);

/**
 * Utility functions for working with optparse-applicative
 */
export const optparse_applicative_cmdline_util = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-applicative-cmdline-util`,
  "Utility functions for working with optparse-applicative",
);

/**
 * Declarative command line option parser
 */
export const optparse_declarative = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-declarative`,
  "Declarative command line option parser",
);

/**
 * An enum-text based toolkit for optparse-applicative
 */
export const optparse_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-enum`,
  "An enum-text based toolkit for optparse-applicative",
);

/**
 * Auto-generate a command-line parser for your datatype
 */
export const optparse_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-generic`,
  "Auto-generate a command-line parser for your datatype",
);

/**
 * Auto-generate a command-line parser for your datatype
 */
export const optparse_generic_1_5_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-generic_1_5_1`,
  "Auto-generate a command-line parser for your datatype",
);

/**
 * Simple interface to optparse-applicative
 */
export const optparse_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-simple`,
  "Simple interface to optparse-applicative",
);

/**
 * Data.Text helpers for optparse-applicative
 */
export const optparse_text = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-text`,
  "Data.Text helpers for optparse-applicative",
);

export const optparse_version = mkPackage(
  nixRaw`pkgs.haskellPackages.optparse-version`,
  "",
);

/**
 * FFI bindings for libopusfile
 */
export const opusfile = mkPackage(
  nixRaw`pkgs.haskellPackages.opusfile`,
  "FFI bindings for libopusfile",
);

/**
 * Types and functions for Kepler orbits
 */
export const orbits = mkPackage(
  nixRaw`pkgs.haskellPackages.orbits`,
  "Types and functions for Kepler orbits",
);

/**
 * Haskell Wiki Library
 */
export const orchid = mkPackage(
  nixRaw`pkgs.haskellPackages.orchid`,
  "Haskell Wiki Library",
);

/**
 * Haskell Wiki Demo
 */
export const orchid_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.orchid-demo`,
  "Haskell Wiki Demo",
);

/**
 * Creating Ord instances instantly
 */
export const ord_adhoc = mkPackage(
  nixRaw`pkgs.haskellPackages.ord-adhoc`,
  "Creating Ord instances instantly",
);

/**
 * Algorithms for the order maintenance problem with a safe interface
 */
export const order_maintenance = mkPackage(
  nixRaw`pkgs.haskellPackages.order-maintenance`,
  "Algorithms for the order maintenance problem with a safe interface",
);

/**
 * Order statistic trees based on weight-balanced trees
 */
export const order_statistic_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.order-statistic-tree`,
  "Order statistic trees based on weight-balanced trees",
);

/**
 * Set- and Map-like types that remember the order elements were inserted
 */
export const ordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.ordered-containers`,
  "Set- and Map-like types that remember the order elements were inserted",
);

/**
 * Utilities for Orderings
 */
export const ordering_util = mkPackage(
  nixRaw`pkgs.haskellPackages.ordering-util`,
  "Utilities for Orderings",
);

/**
 * Fork concurrent worker threads and produce ordered results
 */
export const orderly_workers = mkPackage(
  nixRaw`pkgs.haskellPackages.orderly-workers`,
  "Fork concurrent worker threads and produce ordered results",
);

/**
 * basic orders
 */
export const orders = mkPackage(
  nixRaw`pkgs.haskellPackages.orders`,
  "basic orders",
);

/**
 * Convert numbers to words in different languages
 */
export const ordinal = mkPackage(
  nixRaw`pkgs.haskellPackages.ordinal`,
  "Convert numbers to words in different languages",
);

/**
 * Basic org to anki exporter
 */
export const org2anki = mkPackage(
  nixRaw`pkgs.haskellPackages.org2anki`,
  "Basic org to anki exporter",
);

/**
 * Parser for Emacs org-mode files
 */
export const org_mode = mkPackage(
  nixRaw`pkgs.haskellPackages.org-mode`,
  "Parser for Emacs org-mode files",
);

/**
 * Lucid integration for org-mode
 */
export const org_mode_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.org-mode-lucid`,
  "Lucid integration for org-mode",
);

/**
 * Statistics visualizer for org-mode
 */
export const orgstat = mkPackage(
  nixRaw`pkgs.haskellPackages.orgstat`,
  "Statistics visualizer for org-mode",
);

/**
 * A formatter for Haskell source code
 */
export const ormolu = mkPackage(
  nixRaw`pkgs.haskellPackages.ormolu`,
  "A formatter for Haskell source code",
);

/**
 * A formatter for Haskell source code
 */
export const ormolu_0_5_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ormolu_0_5_2_0`,
  "A formatter for Haskell source code",
);

/**
 * A formatter for Haskell source code
 */
export const ormolu_0_7_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ormolu_0_7_2_0`,
  "A formatter for Haskell source code",
);

/**
 * Multidimensional arrays inspired by APL
 */
export const orthotope = mkPackage(
  nixRaw`pkgs.haskellPackages.orthotope`,
  "Multidimensional arrays inspired by APL",
);

/**
 * Some algorithms from hmatrix
 */
export const orthotope_hmatrix = mkPackage(
  nixRaw`pkgs.haskellPackages.orthotope-hmatrix`,
  "Some algorithms from hmatrix",
);

/**
 * /etc/os-release helpers
 */
export const os_release = mkPackage(
  nixRaw`pkgs.haskellPackages.os-release`,
  "/etc/os-release helpers",
);

/**
 * Show keys pressed with an on-screen display (Linux only)
 */
export const osdkeys = mkPackage(
  nixRaw`pkgs.haskellPackages.osdkeys`,
  "Show keys pressed with an on-screen display (Linux only)",
);

/**
 * Download Open Street Map tiles
 */
export const osm_download = mkPackage(
  nixRaw`pkgs.haskellPackages.osm-download`,
  "Download Open Street Map tiles",
);

/**
 * OTP Authenticator (a la google) command line client
 */
export const otp_authenticator = mkPackage(
  nixRaw`pkgs.haskellPackages.otp-authenticator`,
  "OTP Authenticator (a la google) command line client",
);

/**
 * External sorting package based on Conduit
 */
export const outsort = mkPackage(
  nixRaw`pkgs.haskellPackages.outsort`,
  "External sorting package based on Conduit",
);

/**
 * A purely functional E-Graph library
 */
export const overeasy = mkPackage(
  nixRaw`pkgs.haskellPackages.overeasy`,
  "A purely functional E-Graph library",
);

/**
 * Hang loose with your lambdas!
 */
export const overhang = mkPackage(
  nixRaw`pkgs.haskellPackages.overhang`,
  "Hang loose with your lambdas!",
);

/**
 * Finite overloading
 */
export const overload = mkPackage(
  nixRaw`pkgs.haskellPackages.overload`,
  "Finite overloading",
);

/**
 * Collect a tree of errors and pretty-print
 */
export const pa_error_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-error-tree`,
  "Collect a tree of errors and pretty-print",
);

/**
 * Vertical parsing of values
 */
export const pa_field_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-field-parser`,
  "Vertical parsing of values",
);

/**
 * Our JSON parsers/encoders
 */
export const pa_json = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-json`,
  "Our JSON parsers/encoders",
);

/**
 * Labels, and labelled tuples and enums (GHC >9.2)
 */
export const pa_label = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-label`,
  "Labels, and labelled tuples and enums (GHC >9.2)",
);

/**
 * The Possehl Analytics Prelude
 */
export const pa_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-prelude`,
  "The Possehl Analytics Prelude",
);

/**
 * Some pretty-printing helpers
 */
export const pa_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-pretty`,
  "Some pretty-printing helpers",
);

/**
 * Helper functions for spawning subprocesses
 */
export const pa_run_command = mkPackage(
  nixRaw`pkgs.haskellPackages.pa-run-command`,
  "Helper functions for spawning subprocesses",
);

/**
 * Utilities for working with cabal packages and your package database
 */
export const package_o_tron = mkPackage(
  nixRaw`pkgs.haskellPackages.package-o-tron`,
  "Utilities for working with cabal packages and your package database",
);

/**
 * Universal build and CI testing for Haskell packages
 */
export const packcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.packcheck`,
  "Universal build and CI testing for Haskell packages",
);

/**
 * Fast byte serializer and unserializer
 */
export const packer = mkPackage(
  nixRaw`pkgs.haskellPackages.packer`,
  "Fast byte serializer and unserializer",
);

/**
 * Time Library for Pact
 */
export const pact_time = mkPackage(
  nixRaw`pkgs.haskellPackages.pact-time`,
  "Time Library for Pact",
);

/**
 * Controlling padKONTROL native mode
 */
export const padKONTROL = mkPackage(
  nixRaw`pkgs.haskellPackages.padKONTROL`,
  "Controlling padKONTROL native mode",
);

/**
 * API to the Paddle payment processor
 */
export const paddle = mkPackage(
  nixRaw`pkgs.haskellPackages.paddle`,
  "API to the Paddle payment processor",
);

/**
 * Open up a pager, like 'less' or 'more'
 */
export const pager = mkPackage(
  nixRaw`pkgs.haskellPackages.pager`,
  "Open up a pager, like 'less' or 'more'",
);

/**
 * Client library for PagerDuty Integration and REST APIs
 */
export const pagerduty = mkPackage(
  nixRaw`pkgs.haskellPackages.pagerduty`,
  "Client library for PagerDuty Integration and REST APIs",
);

/**
 * Framework-agnostic pagination boilerplate
 */
export const pagination = mkPackage(
  nixRaw`pkgs.haskellPackages.pagination`,
  "Framework-agnostic pagination boilerplate",
);

/**
 * Pagure REST client library
 */
export const pagure = mkPackage(
  nixRaw`pkgs.haskellPackages.pagure`,
  "Pagure REST client library",
);

/**
 * Pagure client
 */
export const pagure_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.pagure-cli`,
  "Pagure client",
);

/**
 * Colorization of text for command-line output
 */
export const paint = mkPackage(
  nixRaw`pkgs.haskellPackages.paint`,
  "Colorization of text for command-line output",
);

/**
 * Bilinear pairings
 */
export const pairing = mkPackage(
  nixRaw`pkgs.haskellPackages.pairing`,
  "Bilinear pairings",
);

/**
 * Utilities for choosing and creating color schemes
 */
export const palette = mkPackage(
  nixRaw`pkgs.haskellPackages.palette`,
  "Utilities for choosing and creating color schemes",
);

/**
 * Finding palindromes in strings
 */
export const palindromes = mkPackage(
  nixRaw`pkgs.haskellPackages.palindromes`,
  "Finding palindromes in strings",
);

/**
 * Haskell binding for C PAM API
 */
export const pam = mkPackage(
  nixRaw`pkgs.haskellPackages.pam`,
  "Haskell binding for C PAM API",
);

/**
 * A simple static blog engine
 */
export const panda = mkPackage(
  nixRaw`pkgs.haskellPackages.panda`,
  "A simple static blog engine",
);

/**
 * Conversion between markup formats
 */
export const pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc`,
  "Conversion between markup formats",
);

/**
 * Conversion between markup formats
 */
export const pandoc_3_1_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc_3_1_8`,
  "Conversion between markup formats",
);

/**
 * Insert a preamble before pandoc-citeproc's bibliography
 */
export const pandoc_citeproc_preamble = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-citeproc-preamble`,
  "Insert a preamble before pandoc-citeproc's bibliography",
);

/**
 * Conversion between documentation formats
 */
export const pandoc_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-cli`,
  "Conversion between documentation formats",
);

/**
 * Pandoc filter for cross-references
 */
export const pandoc_crossref = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-crossref`,
  "Pandoc filter for cross-references",
);

/**
 * Pandoc filter for cross-references
 */
export const pandoc_crossref_0_3_17_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-crossref_0_3_17_0`,
  "Pandoc filter for cross-references",
);

/**
 * Decodes pandoc to dhall
 */
export const pandoc_dhall_decoder = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-dhall-decoder`,
  "Decodes pandoc to dhall",
);

/**
 * A Pandoc filter for emphasizing code in fenced blocks
 */
export const pandoc_emphasize_code = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-emphasize-code`,
  "A Pandoc filter for emphasizing code in fenced blocks",
);

/**
 * Syntax highlighting customization for Pandoc
 */
export const pandoc_highlighting_extensions = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-highlighting-extensions`,
  "Syntax highlighting customization for Pandoc",
);

/**
 * A Pandoc filter for including code from source files
 */
export const pandoc_include_code = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-include-code`,
  "A Pandoc filter for including code from source files",
);

/**
 * Japanese-specific markup filters for pandoc
 */
export const pandoc_japanese_filters = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-japanese-filters`,
  "Japanese-specific markup filters for pandoc",
);

/**
 * Lua engine to power custom pandoc conversions
 */
export const pandoc_lua_engine = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-lua-engine`,
  "Lua engine to power custom pandoc conversions",
);

/**
 * Use pandoc types in Lua
 */
export const pandoc_lua_marshal = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-lua-marshal`,
  "Use pandoc types in Lua",
);

/**
 * A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice
 */
export const pandoc_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-plot`,
  "A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice",
);

/**
 * Pandoc document conversion as an HTTP servant-server
 */
export const pandoc_server = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-server`,
  "Pandoc document conversion as an HTTP servant-server",
);

/**
 * Convert Pandoc Markdown-style footnotes into sidenotes
 */
export const pandoc_sidenote = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-sidenote`,
  "Convert Pandoc Markdown-style footnotes into sidenotes",
);

/**
 * Pandoc filter to customize links, images and paragraphs
 */
export const pandoc_stylefrommeta = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-stylefrommeta`,
  "Pandoc filter to customize links, images and paragraphs",
);

/**
 * A tool to convert symbolic regression expressions into different formats
 */
export const pandoc_symreg = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-symreg`,
  "A tool to convert symbolic regression expressions into different formats",
);

/**
 * A tool to convert symbolic regression expressions into different formats
 */
export const pandoc_symreg_0_2_1_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-symreg_0_2_1_3`,
  "A tool to convert symbolic regression expressions into different formats",
);

/**
 * MonadThrow behaviour for Pandoc
 */
export const pandoc_throw = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-throw`,
  "MonadThrow behaviour for Pandoc",
);

/**
 * Types for representing a structured document
 */
export const pandoc_types = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-types`,
  "Types for representing a structured document",
);

/**
 * Pandoc filter for native Vim code highlighting
 */
export const pandoc_vimhl = mkPackage(
  nixRaw`pkgs.haskellPackages.pandoc-vimhl`,
  "Pandoc filter for native Vim code highlighting",
);

/**
 * ...
 */
export const pandora_io = mkPackage(
  nixRaw`pkgs.haskellPackages.pandora-io`,
  "...",
);

/**
 * Merge environment variables and command line options generically
 */
export const panfiguration = mkPackage(
  nixRaw`pkgs.haskellPackages.panfiguration`,
  "Merge environment variables and command line options generically",
);

/**
 * Binding to the Pango text rendering engine
 */
export const pango = mkPackage(
  nixRaw`pkgs.haskellPackages.pango`,
  "Binding to the Pango text rendering engine",
);

/**
 * A convenient way to panic
 */
export const panic = mkPackage(
  nixRaw`pkgs.haskellPackages.panic`,
  "A convenient way to panic",
);

/**
 * Content addressable Haskell package management
 */
export const pantry = mkPackage(
  nixRaw`pkgs.haskellPackages.pantry`,
  "Content addressable Haskell package management",
);

/**
 * Content addressable Haskell package management
 */
export const pantry_0_5_2_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.pantry_0_5_2_1`,
  "Content addressable Haskell package management",
);

/**
 * Content addressable Haskell package management
 */
export const pantry_0_9_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.pantry_0_9_2`,
  "Content addressable Haskell package management",
);

/**
 * Reasonable default import
 */
export const papa = mkPackage(
  nixRaw`pkgs.haskellPackages.papa`,
  "Reasonable default import",
);

/**
 * Prelude with only useful functions
 */
export const papa_base = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-base`,
  "Prelude with only useful functions",
);

/**
 * Useful base functions reimplemented
 */
export const papa_base_implement = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-base-implement`,
  "Useful base functions reimplemented",
);

/**
 * Prelude with only useful functions
 */
export const papa_bifunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-bifunctors`,
  "Prelude with only useful functions",
);

/**
 * export useful functions from `bifunctors`
 */
export const papa_bifunctors_export = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-bifunctors-export`,
  "export useful functions from `bifunctors`",
);

/**
 * useful `bifunctors` functions reimplemented
 */
export const papa_bifunctors_implement = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-bifunctors-implement`,
  "useful `bifunctors` functions reimplemented",
);

/**
 * Reasonable default import
 */
export const papa_export = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-export`,
  "Reasonable default import",
);

/**
 * Reasonable default import
 */
export const papa_implement = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-implement`,
  "Reasonable default import",
);

/**
 * Prelude with only useful functions
 */
export const papa_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-lens`,
  "Prelude with only useful functions",
);

/**
 * Prelude with only useful functions
 */
export const papa_semigroupoids = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-semigroupoids`,
  "Prelude with only useful functions",
);

/**
 * export useful functions from `semigroupoids`
 */
export const papa_semigroupoids_export = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-semigroupoids-export`,
  "export useful functions from `semigroupoids`",
);

/**
 * Prelude with only useful functions
 */
export const papa_x = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-x`,
  "Prelude with only useful functions",
);

/**
 * export useful functions
 */
export const papa_x_export = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-x-export`,
  "export useful functions",
);

/**
 * useful functions reimplemented
 */
export const papa_x_implement = mkPackage(
  nixRaw`pkgs.haskellPackages.papa-x-implement`,
  "useful functions reimplemented",
);

/**
 * The Haskell library and examples for the kids programming robot paprika
 */
export const paprika = mkPackage(
  nixRaw`pkgs.haskellPackages.paprika`,
  "The Haskell library and examples for the kids programming robot paprika",
);

/**
 * ParDual class for Parallel <-> Sequential
 */
export const par_dual = mkPackage(
  nixRaw`pkgs.haskellPackages.par-dual`,
  "ParDual class for Parallel <-> Sequential",
);

/**
 * Traverse a directory in parallel
 */
export const par_traverse = mkPackage(
  nixRaw`pkgs.haskellPackages.par-traverse`,
  "Traverse a directory in parallel",
);

/**
 * Text paragraph formatting
 */
export const para = mkPackage(
  nixRaw`pkgs.haskellPackages.para`,
  "Text paragraph formatting",
);

/**
 * Parallel programming library
 */
export const parallel = mkPackage(
  nixRaw`pkgs.haskellPackages.parallel`,
  "Parallel programming library",
);

/**
 * Combinators for executing IO actions in parallel on a thread pool
 */
export const parallel_io = mkPackage(
  nixRaw`pkgs.haskellPackages.parallel-io`,
  "Combinators for executing IO actions in parallel on a thread pool",
);

/**
 * Parallel Tree Search
 */
export const parallel_tree_search = mkPackage(
  nixRaw`pkgs.haskellPackages.parallel-tree-search`,
  "Parallel Tree Search",
);

/**
 * Parameterized/indexed monoids and monads using only a single parameter type variable
 */
export const parameterized = mkPackage(
  nixRaw`pkgs.haskellPackages.parameterized`,
  "Parameterized/indexed monoids and monads using only a single parameter type variable",
);

/**
 * Classes and data structures for working with data-kind indexed types
 */
export const parameterized_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.parameterized-utils`,
  "Classes and data structures for working with data-kind indexed types",
);

/**
 * Generate labelled test/benchmark trees from sets of parameters
 */
export const paramtree = mkPackage(
  nixRaw`pkgs.haskellPackages.paramtree`,
  "Generate labelled test/benchmark trees from sets of parameters",
);

/**
 * Generalised parser combinators - Attoparsec interface
 */
export const parco_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.parco-attoparsec`,
  "Generalised parser combinators - Attoparsec interface",
);

/**
 * Generalised parser combinators - Parsec interface
 */
export const parco_parsec = mkPackage(
  nixRaw`pkgs.haskellPackages.parco-parsec`,
  "Generalised parser combinators - Parsec interface",
);

/**
 * Examples to accompany the book "Parallel and Concurrent Programming in Haskell"
 */
export const parconc_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.parconc-examples`,
  "Examples to accompany the book \"Parallel and Concurrent Programming in Haskell\"",
);

/**
 * Monoids for dealing with Pareto efficiency
 */
export const pareto_front = mkPackage(
  nixRaw`pkgs.haskellPackages.pareto-front`,
  "Monoids for dealing with Pareto efficiency",
);

/**
 * A quick-and-dirty, low-friction benchmark tool with immediate feedback
 */
export const park_bench = mkPackage(
  nixRaw`pkgs.haskellPackages.park-bench`,
  "A quick-and-dirty, low-friction benchmark tool with immediate feedback",
);

/**
 * Simply interfacing the parallel port on linux
 */
export const parport = mkPackage(
  nixRaw`pkgs.haskellPackages.parport`,
  "Simply interfacing the parallel port on linux",
);

/**
 * Streaming Parquet reader
 */
export const parquet_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.parquet-hs`,
  "Streaming Parquet reader",
);

/**
 * DIMACS CNF parser library
 */
export const parse_dimacs = mkPackage(
  nixRaw`pkgs.haskellPackages.parse-dimacs`,
  "DIMACS CNF parser library",
);

/**
 * generate command line arguments from a --help output
 */
export const parse_help = mkPackage(
  nixRaw`pkgs.haskellPackages.parse-help`,
  "generate command line arguments from a --help output",
);

/**
 * Parse command-line arguments
 */
export const parseargs = mkPackage(
  nixRaw`pkgs.haskellPackages.parseargs`,
  "Parse command-line arguments",
);

/**
 * Portable monadic parser combinators
 */
export const parsec1 = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec1`,
  "Portable monadic parser combinators",
);

/**
 * Utilities for parsing numbers from Char sequences
 */
export const parsec3_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec3-numbers`,
  "Utilities for parsing numbers from Char sequences",
);

/**
 * Monadic parser combinators
 */
export const parsec_3_1_17_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec_3_1_17_0`,
  "Monadic parser combinators",
);

/**
 * Class of types that can be constructed from their text representation
 */
export const parsec_class = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-class`,
  "Class of types that can be constructed from their text representation",
);

/**
 * Some miscellaneous basic string parsers
 */
export const parsec_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-extra`,
  "Some miscellaneous basic string parsers",
);

/**
 * Parsec API encoded as a deeply-embedded DSL, for debugging and analysis
 */
export const parsec_free = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-free`,
  "Parsec API encoded as a deeply-embedded DSL, for debugging and analysis",
);

/**
 * Utilities for parsing numbers from strings
 */
export const parsec_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-numbers`,
  "Utilities for parsing numbers from strings",
);

/**
 * Parsec combinators for parsing Haskell numeric types
 */
export const parsec_numeric = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-numeric`,
  "Parsec combinators for parsing Haskell numeric types",
);

/**
 * Applicative permutation parser for Parsec intended as a replacement for Text.Parsec.Perm.
 */
export const parsec_permutation = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-permutation`,
  "Applicative permutation parser for Parsec intended as a replacement for Text.Parsec.Perm.",
);

/**
 * Parsec parsers for Tagsoup tag streams
 */
export const parsec_tagsoup = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-tagsoup`,
  "Parsec parsers for Tagsoup tag streams",
);

/**
 * Add a hierarchical trace to Parsec parsers
 */
export const parsec_trace = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-trace`,
  "Add a hierarchical trace to Parsec parsers",
);

/**
 * Utility functions and combinators for Text.Parsec
 */
export const parsec_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.parsec-utils`,
  "Utility functions and combinators for Text.Parsec",
);

/**
 * Data and time parsing for CalendarTime
 */
export const parsedate = mkPackage(
  nixRaw`pkgs.haskellPackages.parsedate`,
  "Data and time parsing for CalendarTime",
);

/**
 * Parallel Parsing Processes
 */
export const parsek = mkPackage(
  nixRaw`pkgs.haskellPackages.parsek`,
  "Parallel Parsing Processes",
);

/**
 * Lightweight package providing commonly useful parser combinators
 */
export const parser_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.parser-combinators`,
  "Lightweight package providing commonly useful parser combinators",
);

/**
 * Parsing combinators
 */
export const parsers = mkPackage(
  nixRaw`pkgs.haskellPackages.parsers`,
  "Parsing combinators",
);

/**
 * NMR-STAR file format parser
 */
export const parsestar = mkPackage(
  nixRaw`pkgs.haskellPackages.parsestar`,
  "NMR-STAR file format parser",
);

/**
 * A fast parser combinator library backed by Typed Template Haskell
 */
export const parsley = mkPackage(
  nixRaw`pkgs.haskellPackages.parsley`,
  "A fast parser combinator library backed by Typed Template Haskell",
);

/**
 * A collection of GHC plugins to work with parsley
 */
export const parsley_garnish = mkPackage(
  nixRaw`pkgs.haskellPackages.parsley-garnish`,
  "A collection of GHC plugins to work with parsley",
);

/**
 * Parsing factorized
 */
export const partage = mkPackage(
  nixRaw`pkgs.haskellPackages.partage`,
  "Parsing factorized",
);

/**
 * A nullary type class for partial functions
 */
export const partial = mkPackage(
  nixRaw`pkgs.haskellPackages.partial`,
  "A nullary type class for partial functions",
);

/**
 * A composable exception handler
 */
export const partial_handler = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-handler`,
  "A composable exception handler",
);

/**
 * Partial isomorphisms
 */
export const partial_isomorphisms = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-isomorphisms`,
  "Partial isomorphisms",
);

/**
 * Provides typeclass suitable for types admitting a partial order
 */
export const partial_order = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-order`,
  "Provides typeclass suitable for types admitting a partial order",
);

/**
 * A partial binary associative operator
 */
export const partial_semigroup = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-semigroup`,
  "A partial binary associative operator",
);

/**
 * Property testing for partial semigroups using Hedgehog
 */
export const partial_semigroup_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-semigroup-hedgehog`,
  "Property testing for partial semigroups using Hedgehog",
);

/**
 * Testing utilities for the partial-semigroup package
 */
export const partial_semigroup_test = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-semigroup-test`,
  "Testing utilities for the partial-semigroup package",
);

/**
 * Datatype for passing around unresolved URIs
 */
export const partial_uri = mkPackage(
  nixRaw`pkgs.haskellPackages.partial-uri`,
  "Datatype for passing around unresolved URIs",
);

/**
 * Deterministic password generator command line interface
 */
export const passman_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.passman-cli`,
  "Deterministic password generator command line interface",
);

/**
 * Hashing and checking of passwords
 */
export const password = mkPackage(
  nixRaw`pkgs.haskellPackages.password`,
  "Hashing and checking of passwords",
);

/**
 * typeclass instances for password package
 */
export const password_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.password-instances`,
  "typeclass instances for password package",
);

/**
 * Types for handling passwords
 */
export const password_types = mkPackage(
  nixRaw`pkgs.haskellPackages.password-types`,
  "Types for handling passwords",
);

/**
 * Terminal-based presentations using Pandoc
 */
export const patat = mkPackage(
  nixRaw`pkgs.haskellPackages.patat`,
  "Terminal-based presentations using Pandoc",
);

/**
 * Data structures for describing changes to other data structures
 */
export const patch = mkPackage(
  nixRaw`pkgs.haskellPackages.patch`,
  "Data structures for describing changes to other data structures",
);

/**
 * A library for patching functions and data structures
 */
export const patch_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.patch-combinators`,
  "A library for patching functions and data structures",
);

/**
 * Compose a big image from overlapping parts
 */
export const patch_image = mkPackage(
  nixRaw`pkgs.haskellPackages.patch-image`,
  "Compose a big image from overlapping parts",
);

/**
 * Support for well-typed paths
 */
export const path = mkPackage(
  nixRaw`pkgs.haskellPackages.path`,
  "Support for well-typed paths",
);

/**
 * Support for well-typed paths
 */
export const path_0_9_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.path_0_9_0`,
  "Support for well-typed paths",
);

/**
 * Binary instance for Path
 */
export const path_binary_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.path-binary-instance`,
  "Binary instance for Path",
);

/**
 * ToDhall and FromDhall instances for Path
 */
export const path_dhall_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.path-dhall-instance`,
  "ToDhall and FromDhall instances for Path",
);

/**
 * Enumeration of common filetype extensions for use with the path library
 */
export const path_extensions = mkPackage(
  nixRaw`pkgs.haskellPackages.path-extensions`,
  "Enumeration of common filetype extensions for use with the path library",
);

/**
 * URLs without host information
 */
export const path_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.path-extra`,
  "URLs without host information",
);

/**
 * URLs without host information
 */
export const path_extra_0_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.path-extra_0_3_1`,
  "URLs without host information",
);

/**
 * Interface to directory package for users of path
 */
export const path_io = mkPackage(
  nixRaw`pkgs.haskellPackages.path-io`,
  "Interface to directory package for users of path",
);

/**
 * PathLike, FileLike and DirLike type classes for the Path library
 */
export const path_like = mkPackage(
  nixRaw`pkgs.haskellPackages.path-like`,
  "PathLike, FileLike and DirLike type classes for the Path library",
);

/**
 * Components of paths
 */
export const path_pieces = mkPackage(
  nixRaw`pkgs.haskellPackages.path-pieces`,
  "Components of paths",
);

/**
 * Read and write UTF-8 text files
 */
export const path_text_utf8 = mkPackage(
  nixRaw`pkgs.haskellPackages.path-text-utf8`,
  "Read and write UTF-8 text files",
);

/**
 * Read and write UTF-8 text files
 */
export const path_text_utf8_0_0_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.path-text-utf8_0_0_2_0`,
  "Read and write UTF-8 text files",
);

/**
 * `Data.Tree` for file paths
 */
export const path_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.path-tree`,
  "`Data.Tree` for file paths",
);

/**
 * Handful of simple utility functions for the path library
 */
export const path_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.path-utils`,
  "Handful of simple utility functions for the path library",
);

/**
 * pathfinding in grid and graphs
 */
export const pathfinding = mkPackage(
  nixRaw`pkgs.haskellPackages.pathfinding`,
  "pathfinding in grid and graphs",
);

/**
 * A toy pathfinding library
 */
export const pathfindingcore = mkPackage(
  nixRaw`pkgs.haskellPackages.pathfindingcore`,
  "A toy pathfinding library",
);

/**
 * Pathological ByteStrings for testing
 */
export const pathological_bytestrings = mkPackage(
  nixRaw`pkgs.haskellPackages.pathological-bytestrings`,
  "Pathological ByteStrings for testing",
);

/**
 * Library for representing and manipulating type-safe file paths
 */
export const paths = mkPackage(
  nixRaw`pkgs.haskellPackages.paths`,
  "Library for representing and manipulating type-safe file paths",
);

/**
 * Type-safe replacement for System.FilePath etc
 */
export const pathtype = mkPackage(
  nixRaw`pkgs.haskellPackages.pathtype`,
  "Type-safe replacement for System.FilePath etc",
);

/**
 * Path walking utilities for Haskell programs
 */
export const pathwalk = mkPackage(
  nixRaw`pkgs.haskellPackages.pathwalk`,
  "Path walking utilities for Haskell programs",
);

/**
 * Patience diff and longest increasing subsequence
 */
export const patience = mkPackage(
  nixRaw`pkgs.haskellPackages.patience`,
  "Patience diff and longest increasing subsequence",
);

/**
 * Sentry SDK
 */
export const patrol = mkPackage(
  nixRaw`pkgs.haskellPackages.patrol`,
  "Sentry SDK",
);

/**
 * Arrows for Pretty Printing
 */
export const pattern_arrows = mkPackage(
  nixRaw`pkgs.haskellPackages.pattern-arrows`,
  "Arrows for Pretty Printing",
);

/**
 * A library for compiling pattern-matching to decision trees
 */
export const pattern_matcher = mkPackage(
  nixRaw`pkgs.haskellPackages.pattern-matcher`,
  "A library for compiling pattern-matching to decision trees",
);

/**
 * Common patterns in message-oriented applications
 */
export const patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.patterns`,
  "Common patterns in message-oriented applications",
);

/**
 * Greatest convex majorants and least concave minorants
 */
export const pava = mkPackage(
  nixRaw`pkgs.haskellPackages.pava`,
  "Greatest convex majorants and least concave minorants",
);

/**
 * This is an unofficial client for the Paymill API
 */
export const paymill = mkPackage(
  nixRaw`pkgs.haskellPackages.paymill`,
  "This is an unofficial client for the Paymill API",
);

/**
 * A client to connect to PayPal's REST API (v1)
 */
export const paypal_rest_client = mkPackage(
  nixRaw`pkgs.haskellPackages.paypal-rest-client`,
  "A client to connect to PayPal's REST API (v1)",
);

/**
 * Haskell implementation of the PBKDF functions from RFC-2898
 */
export const pbkdf = mkPackage(
  nixRaw`pkgs.haskellPackages.pbkdf`,
  "Haskell implementation of the PBKDF functions from RFC-2898",
);

/**
 * A system-independent interface for user-level packet capture
 */
export const pcap = mkPackage(
  nixRaw`pkgs.haskellPackages.pcap`,
  "A system-independent interface for user-level packet capture",
);

/**
 * Conduit <-> libpcap
 */
export const pcap_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.pcap-conduit`,
  "Conduit <-> libpcap",
);

/**
 * Convert a pcap into an enumerator
 */
export const pcap_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.pcap-enumerator`,
  "Convert a pcap into an enumerator",
);

export const pcapng = mkPackage(
  nixRaw`pkgs.haskellPackages.pcapng`,
  "",
);

/**
 * A one file compiler for PCF
 */
export const pcf = mkPackage(
  nixRaw`pkgs.haskellPackages.pcf`,
  "A one file compiler for PCF",
);

/**
 * PCF font parsing and rendering library
 */
export const pcf_font = mkPackage(
  nixRaw`pkgs.haskellPackages.pcf-font`,
  "PCF font parsing and rendering library",
);

/**
 * Haskell bindings to the PCG random number generator
 */
export const pcg_random = mkPackage(
  nixRaw`pkgs.haskellPackages.pcg-random`,
  "Haskell bindings to the PCG random number generator",
);

/**
 * Regular expressions via the PCRE2 C library (included)
 */
export const pcre2 = mkPackage(
  nixRaw`pkgs.haskellPackages.pcre2`,
  "Regular expressions via the PCRE2 C library (included)",
);

/**
 * A regexp (regex) library on top of pcre-light you can actually use
 */
export const pcre_heavy = mkPackage(
  nixRaw`pkgs.haskellPackages.pcre-heavy`,
  "A regexp (regex) library on top of pcre-light you can actually use",
);

/**
 * Nicer interface to regex-pcre
 */
export const pcre_less = mkPackage(
  nixRaw`pkgs.haskellPackages.pcre-less`,
  "Nicer interface to regex-pcre",
);

/**
 * Portable regex library for Perl 5 compatible regular expressions
 */
export const pcre_light = mkPackage(
  nixRaw`pkgs.haskellPackages.pcre-light`,
  "Portable regex library for Perl 5 compatible regular expressions",
);

/**
 * Perl-like substitute and split for PCRE regexps
 */
export const pcre_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.pcre-utils`,
  "Perl-like substitute and split for PCRE regexps",
);

/**
 * Fedora Product Definition Center service
 */
export const pdc = mkPackage(
  nixRaw`pkgs.haskellPackages.pdc`,
  "Fedora Product Definition Center service",
);

/**
 * Simple command-line utility to convert PDF into text
 */
export const pdf2line = mkPackage(
  nixRaw`pkgs.haskellPackages.pdf2line`,
  "Simple command-line utility to convert PDF into text",
);

/**
 * Tool to generate PDF from haskintex templates and YAML input
 */
export const pdf_slave = mkPackage(
  nixRaw`pkgs.haskellPackages.pdf-slave`,
  "Tool to generate PDF from haskintex templates and YAML input",
);

/**
 * A collection of tools for processing PDF files
 */
export const pdf_toolbox_content = mkPackage(
  nixRaw`pkgs.haskellPackages.pdf-toolbox-content`,
  "A collection of tools for processing PDF files",
);

/**
 * A collection of tools for processing PDF files
 */
export const pdf_toolbox_core = mkPackage(
  nixRaw`pkgs.haskellPackages.pdf-toolbox-core`,
  "A collection of tools for processing PDF files",
);

/**
 * A collection of tools for processing PDF files
 */
export const pdf_toolbox_document = mkPackage(
  nixRaw`pkgs.haskellPackages.pdf-toolbox-document`,
  "A collection of tools for processing PDF files",
);

/**
 * Name a PDF file using information from the pdfinfo command
 */
export const pdfname = mkPackage(
  nixRaw`pkgs.haskellPackages.pdfname`,
  "Name a PDF file using information from the pdfinfo command",
);

/**
 * split two-column PDFs, so there is one column per page
 */
export const pdfsplit = mkPackage(
  nixRaw`pkgs.haskellPackages.pdfsplit`,
  "split two-column PDFs, so there is one column per page",
);

/**
 * Experiemental library for composable interactive programs
 */
export const peakachu = mkPackage(
  nixRaw`pkgs.haskellPackages.peakachu`,
  "Experiemental library for composable interactive programs",
);

/**
 * Peano numbers
 */
export const peano = mkPackage(
  nixRaw`pkgs.haskellPackages.peano`,
  "Peano numbers",
);

/**
 * Lazy Peano numbers including observable infinity value
 */
export const peano_inf = mkPackage(
  nixRaw`pkgs.haskellPackages.peano-inf`,
  "Lazy Peano numbers including observable infinity value",
);

/**
 * pec embedded compiler
 */
export const pec = mkPackage(
  nixRaw`pkgs.haskellPackages.pec`,
  "pec embedded compiler",
);

/**
 * An implementation of Pedersen commitment schemes
 */
export const pedersen_commitment = mkPackage(
  nixRaw`pkgs.haskellPackages.pedersen-commitment`,
  "An implementation of Pedersen commitment schemes",
);

/**
 * Package to solve the Generalized Pell Equation
 */
export const pell = mkPackage(
  nixRaw`pkgs.haskellPackages.pell`,
  "Package to solve the Generalized Pell Equation",
);

/**
 * Privacy Enhanced Mail (PEM) format reader and writer
 */
export const pem = mkPackage(
  nixRaw`pkgs.haskellPackages.pem`,
  "Privacy Enhanced Mail (PEM) format reader and writer",
);

/**
 * Tools for manipulating the Penn TreeBank
 */
export const penn_treebank = mkPackage(
  nixRaw`pkgs.haskellPackages.penn-treebank`,
  "Tools for manipulating the Penn TreeBank",
);

/**
 * Extensible double-entry accounting system
 */
export const penny = mkPackage(
  nixRaw`pkgs.haskellPackages.penny`,
  "Extensible double-entry accounting system",
);

/**
 * Deprecated - use penny package instead
 */
export const penny_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.penny-bin`,
  "Deprecated - use penny package instead",
);

/**
 * Deprecated - use penny package instead
 */
export const penny_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.penny-lib`,
  "Deprecated - use penny package instead",
);

/**
 * Create beautiful diagrams just by typing mathematical notation in plain text
 */
export const penrose = mkPackage(
  nixRaw`pkgs.haskellPackages.penrose`,
  "Create beautiful diagrams just by typing mathematical notation in plain text",
);

/**
 * A parser for PE object files
 */
export const peparser = mkPackage(
  nixRaw`pkgs.haskellPackages.peparser`,
  "A parser for PE object files",
);

/**
 * simple printf-style string formatting
 */
export const percent_format = mkPackage(
  nixRaw`pkgs.haskellPackages.percent-format`,
  "simple printf-style string formatting",
);

/**
 * Find duplicate images
 */
export const perceptual_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.perceptual-hash`,
  "Find duplicate images",
);

/**
 * Robust persistence for acyclic immutable data
 */
export const perdure = mkPackage(
  nixRaw`pkgs.haskellPackages.perdure`,
  "Robust persistence for acyclic immutable data",
);

/**
 * Low-level run time measurement
 */
export const perf = mkPackage(
  nixRaw`pkgs.haskellPackages.perf`,
  "Low-level run time measurement",
);

/**
 * analysis example using perf
 */
export const perf_analysis = mkPackage(
  nixRaw`pkgs.haskellPackages.perf-analysis`,
  "analysis example using perf",
);

/**
 * Perfect minimal hashing implementation in native Haskell
 */
export const perfect_hash_generator = mkPackage(
  nixRaw`pkgs.haskellPackages.perfect-hash-generator`,
  "Perfect minimal hashing implementation in native Haskell",
);

/**
 * A perfect hashing library for mapping bytestrings to values
 */
export const perfecthash = mkPackage(
  nixRaw`pkgs.haskellPackages.perfecthash`,
  "A perfect hashing library for mapping bytestrings to values",
);

/**
 * Parse and format date periods, collapse and expand their text representations
 */
export const period = mkPackage(
  nixRaw`pkgs.haskellPackages.period`,
  "Parse and format date periods, collapse and expand their text representations",
);

/**
 * Periodic task system haskell client
 */
export const periodic_client = mkPackage(
  nixRaw`pkgs.haskellPackages.periodic-client`,
  "Periodic task system haskell client",
);

/**
 * Periodic task system haskell client executables
 */
export const periodic_client_exe = mkPackage(
  nixRaw`pkgs.haskellPackages.periodic-client-exe`,
  "Periodic task system haskell client executables",
);

/**
 * Periodic task system haskell server
 */
export const periodic_server = mkPackage(
  nixRaw`pkgs.haskellPackages.periodic-server`,
  "Periodic task system haskell server",
);

/**
 * permutation Applicative and Monad with many mtl instances
 */
export const perm = mkPackage(
  nixRaw`pkgs.haskellPackages.perm`,
  "permutation Applicative and Monad with many mtl instances",
);

/**
 * Permutations of finite sets
 */
export const permutations = mkPackage(
  nixRaw`pkgs.haskellPackages.permutations`,
  "Permutations of finite sets",
);

/**
 * Binding between SQL database values and haskell records
 */
export const persistable_record = mkPackage(
  nixRaw`pkgs.haskellPackages.persistable-record`,
  "Binding between SQL database values and haskell records",
);

/**
 * HDBC and Relational-Record instances of PostgreSQL extended types
 */
export const persistable_types_HDBC_pg = mkPackage(
  nixRaw`pkgs.haskellPackages.persistable-types-HDBC-pg`,
  "HDBC and Relational-Record instances of PostgreSQL extended types",
);

/**
 * Type-safe, multi-backend data serialization
 */
export const persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent`,
  "Type-safe, multi-backend data serialization",
);

/**
 * Type-safe, multi-backend data serialization
 */
export const persistent_2_14_6_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent_2_14_6_0`,
  "Type-safe, multi-backend data serialization",
);

/**
 * Parses a Persist Model file and produces Audit Models
 */
export const persistent_audit = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-audit`,
  "Parses a Persist Model file and produces Audit Models",
);

/**
 * Persistent module discover utilities
 */
export const persistent_discover = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-discover`,
  "Persistent module discover utilities",
);

/**
 * Persistent module discover utilities
 */
export const persistent_discover_0_1_0_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-discover_0_1_0_7`,
  "Persistent module discover utilities",
);

/**
 * Documentation DSL for persistent entities
 */
export const persistent_documentation = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-documentation`,
  "Documentation DSL for persistent entities",
);

/**
 * Persistent based event sourcing
 */
export const persistent_event_source = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-event-source`,
  "Persistent based event sourcing",
);

/**
 * Persistent based event sourcing
 */
export const persistent_eventsource = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-eventsource`,
  "Persistent based event sourcing",
);

/**
 * Declare Persistent entities using SQL SELECT query syntax
 */
export const persistent_hssqlppp = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-hssqlppp`,
  "Declare Persistent entities using SQL SELECT query syntax",
);

/**
 * Persistent instances for types in iproute
 */
export const persistent_instances_iproute = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-instances-iproute`,
  "Persistent instances for types in iproute",
);

/**
 * Persistent instances for types in iproute
 */
export const persistent_iproute = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-iproute`,
  "Persistent instances for types in iproute",
);

/**
 * lens helpers for persistent
 */
export const persistent_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-lens`,
  "lens helpers for persistent",
);

/**
 * A thread-safe (STM) persistency interface for finite map types
 */
export const persistent_map = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-map`,
  "A thread-safe (STM) persistency interface for finite map types",
);

/**
 * Manual migrations for the persistent library
 */
export const persistent_migration = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-migration`,
  "Manual migrations for the persistent library",
);

/**
 * Monad transformer for the persistent API
 */
export const persistent_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-mtl`,
  "Monad transformer for the persistent API",
);

/**
 * Backend for the persistent library using MySQL database server
 */
export const persistent_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-mysql`,
  "Backend for the persistent library using MySQL database server",
);

/**
 * A pure haskell backend for the persistent library using MySQL database server
 */
export const persistent_mysql_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-mysql-haskell`,
  "A pure haskell backend for the persistent library using MySQL database server",
);

/**
 * A pure haskell backend for the persistent library using MySQL database server
 */
export const persistent_mysql_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-mysql-pure`,
  "A pure haskell backend for the persistent library using MySQL database server",
);

/**
 * Efficient and correct pagination for persistent or esqueleto queries
 */
export const persistent_pagination = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-pagination`,
  "Efficient and correct pagination for persistent or esqueleto queries",
);

/**
 * Parse persistent model files
 */
export const persistent_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-parser`,
  "Parse persistent model files",
);

/**
 * Backend for the persistent library using postgresql
 */
export const persistent_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-postgresql`,
  "Backend for the persistent library using postgresql",
);

/**
 * Template-Haskell helpers for integrating protobufs with persistent
 */
export const persistent_protobuf = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-protobuf`,
  "Template-Haskell helpers for integrating protobufs with persistent",
);

/**
 * Provides a quasi-quoter for raw SQL for persistent
 */
export const persistent_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-qq`,
  "Provides a quasi-quoter for raw SQL for persistent",
);

/**
 * Provides a quasi-quoter for raw SQL for persistent
 */
export const persistent_qq_2_12_0_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-qq_2_12_0_6`,
  "Provides a quasi-quoter for raw SQL for persistent",
);

/**
 * Backend for persistent library using Redis
 */
export const persistent_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-redis`,
  "Backend for persistent library using Redis",
);

/**
 * Haskell references backed by an IntMap for persistence and reversibility
 */
export const persistent_refs = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-refs`,
  "Haskell references backed by an IntMap for persistence and reversibility",
);

/**
 * relational-record on persisten backends
 */
export const persistent_relational_record = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-relational-record`,
  "relational-record on persisten backends",
);

/**
 * Database agnostic, spatially indexed type for geographic points
 */
export const persistent_spatial = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-spatial`,
  "Database agnostic, spatially indexed type for geographic points",
);

/**
 * Backend for the persistent library using sqlite3
 */
export const persistent_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-sqlite`,
  "Backend for the persistent library using sqlite3",
);

/**
 * Backend for the persistent library using sqlite3
 */
export const persistent_sqlite_2_13_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-sqlite_2_13_2_0`,
  "Backend for the persistent library using sqlite3",
);

/**
 * Type-safe, non-relational, multi-backend persistence
 */
export const persistent_template = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-template`,
  "Type-safe, non-relational, multi-backend persistence",
);

/**
 * Tests for Persistent
 */
export const persistent_test = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-test`,
  "Tests for Persistent",
);

/**
 * Type safe access to multiple database schemata
 */
export const persistent_typed_db = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-typed-db`,
  "Type safe access to multiple database schemata",
);

/**
 * A persistent sequence based on array mapped tries
 */
export const persistent_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-vector`,
  "A persistent sequence based on array mapped tries",
);

/**
 * Backend for persistent library using Zookeeper
 */
export const persistent_zookeeper = mkPackage(
  nixRaw`pkgs.haskellPackages.persistent-zookeeper`,
  "Backend for persistent library using Zookeeper",
);

/**
 * Persona (BrowserID) Identity Provider
 */
export const persona_idp = mkPackage(
  nixRaw`pkgs.haskellPackages.persona-idp`,
  "Persona (BrowserID) Identity Provider",
);

/**
 * Pretty Easy YOshikuni-made TLS library
 */
export const peyotls = mkPackage(
  nixRaw`pkgs.haskellPackages.peyotls`,
  "Pretty Easy YOshikuni-made TLS library",
);

/**
 * Codec parts of Pretty Easy YOshikuni-made TLS library
 */
export const peyotls_codec = mkPackage(
  nixRaw`pkgs.haskellPackages.peyotls-codec`,
  "Codec parts of Pretty Easy YOshikuni-made TLS library",
);

/**
 * A pleasant PostgreSQL layer
 */
export const pg_entity = mkPackage(
  nixRaw`pkgs.haskellPackages.pg-entity`,
  "A pleasant PostgreSQL layer",
);

/**
 * Client library for pg-harness-server
 */
export const pg_harness_client = mkPackage(
  nixRaw`pkgs.haskellPackages.pg-harness-client`,
  "Client library for pg-harness-server",
);

/**
 * Pure Haskell implementation of PGM image format
 */
export const pgm = mkPackage(
  nixRaw`pkgs.haskellPackages.pgm`,
  "Pure Haskell implementation of PGM image format",
);

/**
 * Translate between binary data and a human-readable collection of words
 */
export const pgp_wordlist = mkPackage(
  nixRaw`pkgs.haskellPackages.pgp-wordlist`,
  "Translate between binary data and a human-readable collection of words",
);

/**
 * Phantom State Transformer. Like State Monad, but without values.
 */
export const phantom_state = mkPackage(
  nixRaw`pkgs.haskellPackages.phantom-state`,
  "Phantom State Transformer. Like State Monad, but without values.",
);

/**
 * FAT filesystem sort utility
 */
export const phatsort = mkPackage(
  nixRaw`pkgs.haskellPackages.phatsort`,
  "FAT filesystem sort utility",
);

/**
 * Library for checking if a given link is in a phishtank json file
 */
export const phizzle = mkPackage(
  nixRaw`pkgs.haskellPackages.phizzle`,
  "Library for checking if a given link is in a phishtank json file",
);

/**
 * Extended functionality of PhLADiPreLiO
 */
export const phladiprelio_general_datatype = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-general-datatype`,
  "Extended functionality of PhLADiPreLiO",
);

/**
 * A shared by different general implementations of the PhLADiPreLiO functionality
 */
export const phladiprelio_general_shared = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-general-shared`,
  "A shared by different general implementations of the PhLADiPreLiO functionality",
);

/**
 * A generalized functionality of PhLADiPreLiO for different languages that uses hash algorithms
 */
export const phladiprelio_general_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-general-simple`,
  "A generalized functionality of PhLADiPreLiO for different languages that uses hash algorithms",
);

/**
 * Allows to estimate some kind of the rhythmicity properties for the text
 */
export const phladiprelio_rhythmicity_shared = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-rhythmicity-shared`,
  "Allows to estimate some kind of the rhythmicity properties for the text",
);

/**
 * Common for Ukrainian and general data for test mode
 */
export const phladiprelio_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-tests`,
  "Common for Ukrainian and general data for test mode",
);

/**
 * A shared by different Ukrainian implementations of the PhLADiPreLiO functionality
 */
export const phladiprelio_ukrainian_shared = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-ukrainian-shared`,
  "A shared by different Ukrainian implementations of the PhLADiPreLiO functionality",
);

/**
 * A PhLADiPreLiO implementation for Ukrainian that uses hashes and asynchronous concurrency
 */
export const phladiprelio_ukrainian_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.phladiprelio-ukrainian-simple`,
  "A PhLADiPreLiO implementation for Ukrainian that uses hashes and asynchronous concurrency",
);

/**
 * Phonetic codes: Soundex and Phonix
 */
export const phonetic_code = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-code`,
  "Phonetic codes: Soundex and Phonix",
);

/**
 * A basics of the phonetic-languages (PhLADiPreLiO-related) functionality
 */
export const phonetic_languages_basis = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-basis`,
  "A basics of the phonetic-languages (PhLADiPreLiO-related) functionality",
);

/**
 * A generalization of the uniqueness-periods-vector-common package
 */
export const phonetic_languages_common = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-common`,
  "A generalization of the uniqueness-periods-vector-common package",
);

/**
 * Constraints to filter the needed permutations
 */
export const phonetic_languages_constraints = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-constraints`,
  "Constraints to filter the needed permutations",
);

/**
 * Constraints to filter the needed permutations
 */
export const phonetic_languages_constraints_array = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-constraints-array`,
  "Constraints to filter the needed permutations",
);

/**
 * A generalization of the uniqueness-periods-vector-examples functionality
 */
export const phonetic_languages_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-examples`,
  "A generalization of the uniqueness-periods-vector-examples functionality",
);

/**
 * Allows to change the structure of the function output
 */
export const phonetic_languages_filters_array = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-filters-array`,
  "Allows to change the structure of the function output",
);

/**
 * A generalization of the uniqueness-periods-vector-general functionality
 */
export const phonetic_languages_general = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-general`,
  "A generalization of the uniqueness-periods-vector-general functionality",
);

/**
 * Commonly used versions of the phonetic-languages-common package
 */
export const phonetic_languages_permutations = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-permutations`,
  "Commonly used versions of the phonetic-languages-common package",
);

/**
 * Permutations and universal set related functions for the phonetic-languages series
 */
export const phonetic_languages_permutations_array = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-permutations-array`,
  "Permutations and universal set related functions for the phonetic-languages series",
);

/**
 * A library for working with generalized phonetic languages usage
 */
export const phonetic_languages_phonetics_basics = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-phonetics-basics`,
  "A library for working with generalized phonetic languages usage",
);

/**
 * Some common shared between different packages functions
 */
export const phonetic_languages_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-plus`,
  "Some common shared between different packages functions",
);

/**
 * A generalization of the uniqueness-periods-vector-properties package
 */
export const phonetic_languages_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-properties`,
  "A generalization of the uniqueness-periods-vector-properties package",
);

/**
 * Allows to estimate the rhythmicity properties for the text
 */
export const phonetic_languages_rhythmicity = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-rhythmicity`,
  "Allows to estimate the rhythmicity properties for the text",
);

/**
 * A basics of the phonetic-languages functionality that can be groupped
 */
export const phonetic_languages_simplified_base = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-base`,
  "A basics of the phonetic-languages functionality that can be groupped",
);

/**
 * A simplified version of the phonetic-languages-functionality
 */
export const phonetic_languages_simplified_common = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-common`,
  "A simplified version of the phonetic-languages-functionality",
);

/**
 * Helps to create Ukrainian texts with the given phonetic properties
 */
export const phonetic_languages_simplified_examples_array = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-examples-array`,
  "Helps to create Ukrainian texts with the given phonetic properties",
);

/**
 * Some commonly used by phonetic-languages-simplified* series functions
 */
export const phonetic_languages_simplified_examples_common = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-examples-common`,
  "Some commonly used by phonetic-languages-simplified* series functions",
);

/**
 * Some common code for phonetic languages generalized functionality
 */
export const phonetic_languages_simplified_generalized_examples_common = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-generalized-examples-common`,
  "Some common code for phonetic languages generalized functionality",
);

/**
 * Simplified and somewhat optimized version of the phonetic-languages-examples
 */
export const phonetic_languages_simplified_lists_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-lists-examples`,
  "Simplified and somewhat optimized version of the phonetic-languages-examples",
);

/**
 * Common functionality for 'with-tuples' and old version of properties
 */
export const phonetic_languages_simplified_properties_array_common = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-properties-array-common`,
  "Common functionality for 'with-tuples' and old version of properties",
);

/**
 * A generalization of the uniqueness-periods-vector-properties package
 */
export const phonetic_languages_simplified_properties_lists = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-properties-lists`,
  "A generalization of the uniqueness-periods-vector-properties package",
);

/**
 * A generalization of the uniqueness-periods-vector-properties package
 */
export const phonetic_languages_simplified_properties_lists_double = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-simplified-properties-lists-double`,
  "A generalization of the uniqueness-periods-vector-properties package",
);

/**
 * Prepares Ukrainian text to be used as a phonetic language text
 */
export const phonetic_languages_ukrainian = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-ukrainian`,
  "Prepares Ukrainian text to be used as a phonetic language text",
);

/**
 * Prepares Ukrainian text to be used as a phonetic language text
 */
export const phonetic_languages_ukrainian_array = mkPackage(
  nixRaw`pkgs.haskellPackages.phonetic-languages-ukrainian-array`,
  "Prepares Ukrainian text to be used as a phonetic language text",
);

/**
 * Functional user interfaces
 */
export const phooey = mkPackage(
  nixRaw`pkgs.haskellPackages.phooey`,
  "Functional user interfaces",
);

/**
 * Rename photo image files based on EXIF shoot date
 */
export const photoname = mkPackage(
  nixRaw`pkgs.haskellPackages.photoname`,
  "Rename photo image files based on EXIF shoot date",
);

/**
 * Utility for clustering phylogenetic trees in Newick format based on Robinson-Foulds distance
 */
export const phybin = mkPackage(
  nixRaw`pkgs.haskellPackages.phybin`,
  "Utility for clustering phylogenetic trees in Newick format based on Robinson-Foulds distance",
);

/**
 * dimensions, quantities and constants
 */
export const physics = mkPackage(
  nixRaw`pkgs.haskellPackages.physics`,
  "dimensions, quantities and constants",
);

/**
 * Remotely controlling Java Swing applications
 */
export const pianola = mkPackage(
  nixRaw`pkgs.haskellPackages.pianola`,
  "Remotely controlling Java Swing applications",
);

/**
 * Bindings to the PicoSAT solver
 */
export const picosat = mkPackage(
  nixRaw`pkgs.haskellPackages.picosat`,
  "Bindings to the PicoSAT solver",
);

/**
 * a simple PID controller
 */
export const pid = mkPackage(
  nixRaw`pkgs.haskellPackages.pid`,
  "a simple PID controller",
);

/**
 * Do signal handling and orphan reaping for Unix PID1 init processes
 */
export const pid1 = mkPackage(
  nixRaw`pkgs.haskellPackages.pid1`,
  "Do signal handling and orphan reaping for Unix PID1 init processes",
);

/**
 * Run an IO action protected by a pidfile
 */
export const pidfile = mkPackage(
  nixRaw`pkgs.haskellPackages.pidfile`,
  "Run an IO action protected by a pidfile",
);

/**
 * Yet another Haskell build system
 */
export const pier = mkPackage(
  nixRaw`pkgs.haskellPackages.pier`,
  "Yet another Haskell build system",
);

/**
 * Yet another text-to-html converter
 */
export const piki = mkPackage(
  nixRaw`pkgs.haskellPackages.piki`,
  "Yet another text-to-html converter",
);

/**
 * Back up the notes you've saved to Pinboard
 */
export const pinboard_notes_backup = mkPackage(
  nixRaw`pkgs.haskellPackages.pinboard-notes-backup`,
  "Back up the notes you've saved to Pinboard",
);

/**
 * An alternative implementation of Thrift for Haskell
 */
export const pinch = mkPackage(
  nixRaw`pkgs.haskellPackages.pinch`,
  "An alternative implementation of Thrift for Haskell",
);

/**
 * An alternative implementation of Thrift for Haskell
 */
export const pinch_0_5_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.pinch_0_5_0_0`,
  "An alternative implementation of Thrift for Haskell",
);

/**
 * Functional 2D Game Framework
 */
export const pine = mkPackage(
  nixRaw`pkgs.haskellPackages.pine`,
  "Functional 2D Game Framework",
);

/**
 * icmp echo requests
 */
export const ping = mkPackage(
  nixRaw`pkgs.haskellPackages.ping`,
  "icmp echo requests",
);

/**
 * Attoparsec parsers of ping utility
 */
export const ping_parser_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.ping-parser-attoparsec`,
  "Attoparsec parsers of ping utility",
);

/**
 * Haskell Ping wrapper
 */
export const ping_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.ping-wrapper`,
  "Haskell Ping wrapper",
);

/**
 * Preserve warnings in a GHCi session
 */
export const pinned_warnings = mkPackage(
  nixRaw`pkgs.haskellPackages.pinned-warnings`,
  "Preserve warnings in a GHCi session",
);

/**
 * A gateway for various cloud notification services
 */
export const pinpon = mkPackage(
  nixRaw`pkgs.haskellPackages.pinpon`,
  "A gateway for various cloud notification services",
);

/**
 * A bidirectional bridge between pipes and iteratees
 */
export const pipe_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.pipe-enumerator`,
  "A bidirectional bridge between pipes and iteratees",
);

/**
 * Open your editor, pipe the output to the system clipboard
 */
export const pipeclip = mkPackage(
  nixRaw`pkgs.haskellPackages.pipeclip`,
  "Open your editor, pipe the output to the system clipboard",
);

/**
 * Conduit with a smaller core
 */
export const piped = mkPackage(
  nixRaw`pkgs.haskellPackages.piped`,
  "Conduit with a smaller core",
);

/**
 * Continuation patterns
 */
export const pipeline = mkPackage(
  nixRaw`pkgs.haskellPackages.pipeline`,
  "Continuation patterns",
);

/**
 * Compositional pipelines
 */
export const pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes`,
  "Compositional pipelines",
);

/**
 * Encode and decode JSON streams using Aeson and Pipes
 */
export const pipes_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-aeson`,
  "Encode and decode JSON streams using Aeson and Pipes",
);

/**
 * Attoparsec and Pipes integration
 */
export const pipes_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-attoparsec`,
  "Attoparsec and Pipes integration",
);

/**
 * Streaming parsing in the pipes-core framework with Attoparsec
 */
export const pipes_attoparsec_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-attoparsec-streaming`,
  "Streaming parsing in the pipes-core framework with Attoparsec",
);

/**
 * Encode and decode binary streams using the pipes and binary libraries
 */
export const pipes_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-binary`,
  "Encode and decode binary streams using the pipes and binary libraries",
);

/**
 * ByteString support for pipes
 */
export const pipes_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-bytestring`,
  "ByteString support for pipes",
);

/**
 * Pipes for Noise-secured network connections
 */
export const pipes_cacophony = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cacophony`,
  "Pipes for Noise-secured network connections",
);

/**
 * Encode and decode cborg streams using the pipes and cborg libraries
 */
export const pipes_cborg = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cborg`,
  "Encode and decode cborg streams using the pipes and cborg libraries",
);

/**
 * Pipes-based combinators for cellular data processing
 */
export const pipes_cellular = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cellular`,
  "Pipes-based combinators for cellular data processing",
);

/**
 * Efficient pipes-based cellular CSV codec
 */
export const pipes_cellular_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cellular-csv`,
  "Efficient pipes-based cellular CSV codec",
);

/**
 * A streaming serialization library on top of "pipes" and "cereal-plus"
 */
export const pipes_cereal_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cereal-plus`,
  "A streaming serialization library on top of \"pipes\" and \"cereal-plus\"",
);

/**
 * Streaming to and from subprocesses using Pipes
 */
export const pipes_cliff = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-cliff`,
  "Streaming to and from subprocesses using Pipes",
);

/**
 * Concurrency for the pipes ecosystem
 */
export const pipes_concurrency = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-concurrency`,
  "Concurrency for the pipes ecosystem",
);

/**
 * Conduit adapters
 */
export const pipes_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-conduit`,
  "Conduit adapters",
);

/**
 * Pipes utilities for interfacing with the courier message-passing framework
 */
export const pipes_courier = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-courier`,
  "Pipes utilities for interfacing with the courier message-passing framework",
);

/**
 * Fast, streaming csv parser
 */
export const pipes_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-csv`,
  "Fast, streaming csv parser",
);

/**
 * Various basic utilities for Pipes
 */
export const pipes_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-extra`,
  "Various basic utilities for Pipes",
);

/**
 * Extra utilities for pipes
 */
export const pipes_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-extras`,
  "Extra utilities for pipes",
);

/**
 * Streaming parsers for Fasta and Fastq
 */
export const pipes_fastx = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-fastx`,
  "Streaming parsers for Fasta and Fastq",
);

/**
 * Fast traversal of directory trees using pipes
 */
export const pipes_files = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-files`,
  "Fast traversal of directory trees using pipes",
);

/**
 * Reactively combines Producers so that a value is yielded as soon as possible
 */
export const pipes_fluid = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-fluid`,
  "Reactively combines Producers so that a value is yielded as soon as possible",
);

/**
 * Group streams into substreams
 */
export const pipes_group = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-group`,
  "Group streams into substreams",
);

/**
 * HTTP client with pipes interface
 */
export const pipes_http = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-http`,
  "HTTP client with pipes interface",
);

/**
 * Illumina NGS data processing
 */
export const pipes_illumina = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-illumina`,
  "Illumina NGS data processing",
);

/**
 * Kafka in the Pipes ecosystem
 */
export const pipes_kafka = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-kafka`,
  "Kafka in the Pipes ecosystem",
);

/**
 * Streaming processing of CSV files preceded by key-value pairs
 */
export const pipes_key_value_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-key-value-csv`,
  "Streaming processing of CSV files preceded by key-value pairs",
);

/**
 * Miscellaneous utilities for pipes, required by glazier-tutorial
 */
export const pipes_misc = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-misc`,
  "Miscellaneous utilities for pipes, required by glazier-tutorial",
);

/**
 * Stream results from MongoDB
 */
export const pipes_mongodb = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-mongodb`,
  "Stream results from MongoDB",
);

/**
 * Use network sockets together with the pipes library
 */
export const pipes_network = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-network`,
  "Use network sockets together with the pipes library",
);

/**
 * TLS-secured network connections support for pipes
 */
export const pipes_network_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-network-tls`,
  "TLS-secured network connections support for pipes",
);

/**
 * merge two ordered Producers into a new Producer
 */
export const pipes_ordered_zip = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-ordered-zip`,
  "merge two ordered Producers into a new Producer",
);

/**
 * P2P network nodes with pipes
 */
export const pipes_p2p = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-p2p`,
  "P2P network nodes with pipes",
);

/**
 * Examples using pipes-p2p
 */
export const pipes_p2p_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-p2p-examples`,
  "Examples using pipes-p2p",
);

/**
 * Parsing infrastructure for the pipes ecosystem
 */
export const pipes_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-parse`,
  "Parsing infrastructure for the pipes ecosystem",
);

/**
 * Convert various postgresql-simple calls to work with pipes
 */
export const pipes_postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-postgresql-simple`,
  "Convert various postgresql-simple calls to work with pipes",
);

/**
 * Pipes for pulse-simple audio
 */
export const pipes_pulse_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-pulse-simple`,
  "Pipes for pulse-simple audio",
);

/**
 * Producers for handling randomness
 */
export const pipes_random = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-random`,
  "Producers for handling randomness",
);

/**
 * Safety for the pipes ecosystem
 */
export const pipes_safe = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-safe`,
  "Safety for the pipes ecosystem",
);

/**
 * properly streaming text
 */
export const pipes_text = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-text`,
  "properly streaming text",
);

/**
 * A port of wai-conduit for the pipes ecosystem
 */
export const pipes_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-wai`,
  "A port of wai-conduit for the pipes ecosystem",
);

/**
 * WebSockets in the Pipes framework
 */
export const pipes_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-websockets`,
  "WebSockets in the Pipes framework",
);

/**
 * Zlib and GZip compression and decompression for Pipes streams
 */
export const pipes_zlib = mkPackage(
  nixRaw`pkgs.haskellPackages.pipes-zlib`,
  "Zlib and GZip compression and decompression for Pipes streams",
);

/**
 * A dependently typed core language
 */
export const pisigma = mkPackage(
  nixRaw`pkgs.haskellPackages.pisigma`,
  "A dependently typed core language",
);

/**
 * Pitch tracking library
 */
export const pitchtrack = mkPackage(
  nixRaw`pkgs.haskellPackages.pitchtrack`,
  "Pitch tracking library",
);

/**
 * Haskell game engine like fantasy console
 */
export const piyo = mkPackage(
  nixRaw`pkgs.haskellPackages.piyo`,
  "Haskell game engine like fantasy console",
);

/**
 * RSA encryption with PKCS1 padding
 */
export const pkcs1 = mkPackage(
  nixRaw`pkgs.haskellPackages.pkcs1`,
  "RSA encryption with PKCS1 padding",
);

/**
 * RPM package tree diff tool
 */
export const pkgtreediff = mkPackage(
  nixRaw`pkgs.haskellPackages.pkgtreediff`,
  "RPM package tree diff tool",
);

/**
 * Implementation of the PKTree spatial index data structure
 */
export const pktree = mkPackage(
  nixRaw`pkgs.haskellPackages.pktree`,
  "Implementation of the PKTree spatial index data structure",
);

/**
 * A utility for X11 that moves the mouse cursor using the keyboard
 */
export const place_cursor_at = mkPackage(
  nixRaw`pkgs.haskellPackages.place-cursor-at`,
  "A utility for X11 that moves the mouse cursor using the keyboard",
);

/**
 * Placeholders for use while developing Haskell code
 */
export const placeholders = mkPackage(
  nixRaw`pkgs.haskellPackages.placeholders`,
  "Placeholders for use while developing Haskell code",
);

/**
 * Plaid.com api integration library
 */
export const plaid = mkPackage(
  nixRaw`pkgs.haskellPackages.plaid`,
  "Plaid.com api integration library",
);

/**
 * Planet Mitchell
 */
export const planet_mitchell = mkPackage(
  nixRaw`pkgs.haskellPackages.planet-mitchell`,
  "Planet Mitchell",
);

/**
 * Library to glue together playlists and http-client
 */
export const playlists_http = mkPackage(
  nixRaw`pkgs.haskellPackages.playlists-http`,
  "Library to glue together playlists and http-client",
);

/**
 * run a subprocess, combining stdout and stderr
 */
export const plex = mkPackage(
  nixRaw`pkgs.haskellPackages.plex`,
  "run a subprocess, combining stdout and stderr",
);

/**
 * plot data from stdin through socketed
 */
export const plocketed = mkPackage(
  nixRaw`pkgs.haskellPackages.plocketed`,
  "plot data from stdin through socketed",
);

/**
 * A plotting library, exportable as eps/pdf/svg/png or renderable with gtk
 */
export const plot = mkPackage(
  nixRaw`pkgs.haskellPackages.plot`,
  "A plotting library, exportable as eps/pdf/svg/png or renderable with gtk",
);

/**
 * A lightweight plotting library, exporting to SVG
 */
export const plot_light = mkPackage(
  nixRaw`pkgs.haskellPackages.plot-light`,
  "A lightweight plotting library, exporting to SVG",
);

/**
 * Example binaries for plot-light
 */
export const plot_light_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.plot-light-examples`,
  "Example binaries for plot-light",
);

/**
 * Plotter-like fonts i.e. a series of straight lines which make letter shapes.
 */
export const plotfont = mkPackage(
  nixRaw`pkgs.haskellPackages.plotfont`,
  "Plotter-like fonts i.e. a series of straight lines which make letter shapes.",
);

/**
 * Haskell bindings to Plotly.js
 */
export const plotlyhs = mkPackage(
  nixRaw`pkgs.haskellPackages.plotlyhs`,
  "Haskell bindings to Plotly.js",
);

/**
 * A useful cli tool to draw figures
 */
export const ploton = mkPackage(
  nixRaw`pkgs.haskellPackages.ploton`,
  "A useful cli tool to draw figures",
);

/**
 * Plotserver API
 */
export const plotserver_api = mkPackage(
  nixRaw`pkgs.haskellPackages.plotserver-api`,
  "Plotserver API",
);

/**
 * Contravariant logging library
 */
export const plow_log = mkPackage(
  nixRaw`pkgs.haskellPackages.plow-log`,
  "Contravariant logging library",
);

/**
 * A library and technique for handling errors via plucking constraints
 */
export const plucky = mkPackage(
  nixRaw`pkgs.haskellPackages.plucky`,
  "A library and technique for handling errors via plucking constraints",
);

/**
 * Automatic recompilation and reloading of haskell modules
 */
export const plugins_auto = mkPackage(
  nixRaw`pkgs.haskellPackages.plugins-auto`,
  "Automatic recompilation and reloading of haskell modules",
);

/**
 * PLY file loader
 */
export const ply_loader = mkPackage(
  nixRaw`pkgs.haskellPackages.ply-loader`,
  "PLY file loader",
);

/**
 * read/write png file
 */
export const png_file = mkPackage(
  nixRaw`pkgs.haskellPackages.png-file`,
  "read/write png file",
);

/**
 * Pure Haskell loader for PNG images
 */
export const pngload = mkPackage(
  nixRaw`pkgs.haskellPackages.pngload`,
  "Pure Haskell loader for PNG images",
);

/**
 * PNM image format header parsing and pretty printing
 */
export const pnm = mkPackage(
  nixRaw`pkgs.haskellPackages.pnm`,
  "PNM image format header parsing and pretty printing",
);

/**
 * Multi-backend (zookeeper and sqlite) DNS Server using persistent-library
 */
export const pocket_dns = mkPackage(
  nixRaw`pkgs.haskellPackages.pocket-dns`,
  "Multi-backend (zookeeper and sqlite) DNS Server using persistent-library",
);

/**
 * Point octree, with bounding boxes
 */
export const point_octree = mkPackage(
  nixRaw`pkgs.haskellPackages.point-octree`,
  "Point octree, with bounding boxes",
);

/**
 * Pointed and copointed data
 */
export const pointed = mkPackage(
  nixRaw`pkgs.haskellPackages.pointed`,
  "Pointed and copointed data",
);

/**
 * A zipper-like comonad which works as a list, tracking a position
 */
export const pointedlist = mkPackage(
  nixRaw`pkgs.haskellPackages.pointedlist`,
  "A zipper-like comonad which works as a list, tracking a position",
);

/**
 * Tool for refactoring expressions into pointfree form
 */
export const pointfree = mkPackage(
  nixRaw`pkgs.haskellPackages.pointfree`,
  "Tool for refactoring expressions into pointfree form",
);

/**
 * Some common point-free combinators
 */
export const pointless_fun = mkPackage(
  nixRaw`pkgs.haskellPackages.pointless-fun`,
  "Some common point-free combinators",
);

/**
 * Pointless Lenses library
 */
export const pointless_lenses = mkPackage(
  nixRaw`pkgs.haskellPackages.pointless-lenses`,
  "Pointless Lenses library",
);

/**
 * Pointless Rewrite library
 */
export const pointless_rewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.pointless-rewrite`,
  "Pointless Rewrite library",
);

/**
 * Discord verification bot
 */
export const poke = mkPackage(
  nixRaw`pkgs.haskellPackages.poke`,
  "Discord verification bot",
);

/**
 * Texas holdem hand evaluation and simulation
 */
export const poker = mkPackage(
  nixRaw`pkgs.haskellPackages.poker`,
  "Texas holdem hand evaluation and simulation",
);

/**
 * Complex numbers in polar form
 */
export const polar = mkPackage(
  nixRaw`pkgs.haskellPackages.polar`,
  "Complex numbers in polar form",
);

/**
 * A library for manipulating the historical dictionary of Polish (deprecated)
 */
export const polh_lexicon = mkPackage(
  nixRaw`pkgs.haskellPackages.polh-lexicon`,
  "A library for manipulating the historical dictionary of Polish (deprecated)",
);

/**
 * Handling the PoliMorf dictionary
 */
export const polimorf = mkPackage(
  nixRaw`pkgs.haskellPackages.polimorf`,
  "Handling the PoliMorf dictionary",
);

/**
 * Bindings to poll.h
 */
export const poll = mkPackage(
  nixRaw`pkgs.haskellPackages.poll`,
  "Bindings to poll.h",
);

/**
 * Polyvariadic functions mapping to a given monoid
 */
export const polyToMonoid = mkPackage(
  nixRaw`pkgs.haskellPackages.polyToMonoid`,
  "Polyvariadic functions mapping to a given monoid",
);

/**
 * Tools for working with functions of undetermined arity
 */
export const poly_arity = mkPackage(
  nixRaw`pkgs.haskellPackages.poly-arity`,
  "Tools for working with functions of undetermined arity",
);

/**
 * Polykinded extensible records
 */
export const poly_rec = mkPackage(
  nixRaw`pkgs.haskellPackages.poly-rec`,
  "Polykinded extensible records",
);

/**
 * Wrap together data and it's constraints
 */
export const polydata = mkPackage(
  nixRaw`pkgs.haskellPackages.polydata`,
  "Wrap together data and it's constraints",
);

/**
 * Polygonal maps
 */
export const polymap = mkPackage(
  nixRaw`pkgs.haskellPackages.polymap`,
  "Polygonal maps",
);

/**
 * Multivariate polynomial rings
 */
export const polynomial_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.polynomial-algebra`,
  "Multivariate polynomial rings",
);

/**
 * A solver for systems of polynomial equations in bernstein form
 */
export const polynomials_bernstein = mkPackage(
  nixRaw`pkgs.haskellPackages.polynomials-bernstein`,
  "A solver for systems of polynomial equations in bernstein form",
);

/**
 * A variety of alternative parser combinator libraries
 */
export const polyparse = mkPackage(
  nixRaw`pkgs.haskellPackages.polyparse`,
  "A variety of alternative parser combinator libraries",
);

/**
 * Higher-order, low-boilerplate free monads
 */
export const polysemy = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy`,
  "Higher-order, low-boilerplate free monads",
);

/**
 * Experimental, RandomFu effect and interpreters for polysemy
 */
export const polysemy_RandomFu = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-RandomFu`,
  "Experimental, RandomFu effect and interpreters for polysemy",
);

/**
 * Account management with Servant and Polysemy
 */
export const polysemy_account = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-account`,
  "Account management with Servant and Polysemy",
);

/**
 * Account management with Servant and Polysemy
 */
export const polysemy_account_api = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-account-api`,
  "Account management with Servant and Polysemy",
);

/**
 * QuickCheck for Polysemy
 */
export const polysemy_check = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-check`,
  "QuickCheck for Polysemy",
);

/**
 * A Polysemy effect for Chronos
 */
export const polysemy_chronos = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-chronos`,
  "A Polysemy effect for Chronos",
);

/**
 * Polysemy effects for concurrency
 */
export const polysemy_conc = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-conc`,
  "Polysemy effects for concurrency",
);

/**
 * Polysemy effects for databases
 */
export const polysemy_db = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-db`,
  "Polysemy effects for databases",
);

/**
 * Extra Input and Output functions for polysemy
 */
export const polysemy_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-extra`,
  "Extra Input and Output functions for polysemy",
);

/**
 * Low level filesystem operations for polysemy
 */
export const polysemy_fs = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-fs`,
  "Low level filesystem operations for polysemy",
);

/**
 * Run a KVStore as a filesystem in polysemy
 */
export const polysemy_fskvstore = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-fskvstore`,
  "Run a KVStore as a filesystem in polysemy",
);

/**
 * Polysemy effects for databases
 */
export const polysemy_hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-hasql`,
  "Polysemy effects for databases",
);

/**
 * Test utilities for polysemy-hasql
 */
export const polysemy_hasql_test = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-hasql-test`,
  "Test utilities for polysemy-hasql",
);

/**
 * Polysemy effects for HTTP clients
 */
export const polysemy_http = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-http`,
  "Polysemy effects for HTTP clients",
);

/**
 * Run a KVStore as a single json file in polysemy
 */
export const polysemy_kvstore_jsonfile = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-kvstore-jsonfile`,
  "Run a KVStore as a single json file in polysemy",
);

/**
 * Polysemy effects for logging
 */
export const polysemy_log = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-log`,
  "Polysemy effects for logging",
);

/**
 * Colog adapters for Polysemy.Log
 */
export const polysemy_log_co = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-log-co`,
  "Colog adapters for Polysemy.Log",
);

/**
 * Di adapters for polysemy-log
 */
export const polysemy_log_di = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-log-di`,
  "Di adapters for polysemy-log",
);

/**
 * Domain modelling algebra for polysemy
 */
export const polysemy_methodology = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-methodology`,
  "Domain modelling algebra for polysemy",
);

/**
 * Logging functions for polysemy-methodology
 */
export const polysemy_methodology_co_log = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-methodology-co-log`,
  "Logging functions for polysemy-methodology",
);

/**
 * Functions for using polysemy-methodology with composite
 */
export const polysemy_methodology_composite = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-methodology-composite`,
  "Functions for using polysemy-methodology with composite",
);

/**
 * Mocking framework for polysemy effects
 */
export const polysemy_mocks = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-mocks`,
  "Mocking framework for polysemy effects",
);

/**
 * Polysemy versions of Path functions
 */
export const polysemy_path = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-path`,
  "Polysemy versions of Path functions",
);

/**
 * Disambiguate obvious uses of effects
 */
export const polysemy_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-plugin`,
  "Disambiguate obvious uses of effects",
);

/**
 * Polysemy error tracking
 */
export const polysemy_resume = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-resume`,
  "Polysemy error tracking",
);

/**
 * Well-typed filesystem operation effects
 */
export const polysemy_scoped_fs = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-scoped-fs`,
  "Well-typed filesystem operation effects",
);

/**
 * A Polysemy effect for time
 */
export const polysemy_time = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-time`,
  "A Polysemy effect for time",
);

/**
 * Uncontrolled toy effect for polysemy
 */
export const polysemy_uncontrolled = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-uncontrolled`,
  "Uncontrolled toy effect for polysemy",
);

/**
 * Experimental video processing DSL for polysemy
 */
export const polysemy_video = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-video`,
  "Experimental video processing DSL for polysemy",
);

/**
 * Functions for mapping vinyl records in polysemy
 */
export const polysemy_vinyl = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-vinyl`,
  "Functions for mapping vinyl records in polysemy",
);

/**
 * Start web servers from within a Polysemy effect stack
 */
export const polysemy_webserver = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-webserver`,
  "Start web servers from within a Polysemy effect stack",
);

/**
 * Experimental, user-contributed effects and interpreters for polysemy
 */
export const polysemy_zoo = mkPackage(
  nixRaw`pkgs.haskellPackages.polysemy-zoo`,
  "Experimental, user-contributed effects and interpreters for polysemy",
);

/**
 * Online XML parsing with polyparse and tagsoup
 */
export const polysoup = mkPackage(
  nixRaw`pkgs.haskellPackages.polysoup`,
  "Online XML parsing with polyparse and tagsoup",
);

/**
 * Utilities for polytypeable
 */
export const polytypeable_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.polytypeable-utils`,
  "Utilities for polytypeable",
);

/**
 * pomodoro timer
 */
export const pomodoro = mkPackage(
  nixRaw`pkgs.haskellPackages.pomodoro`,
  "pomodoro timer",
);

/**
 * Extended Personal Media Network (XPMN) media server
 */
export const pontarius_mediaserver = mkPackage(
  nixRaw`pkgs.haskellPackages.pontarius-mediaserver`,
  "Extended Personal Media Network (XPMN) media server",
);

/**
 * An XMPP client library
 */
export const pontarius_xmpp = mkPackage(
  nixRaw`pkgs.haskellPackages.pontarius-xmpp`,
  "An XMPP client library",
);

/**
 * An XMPP client library
 */
export const pontarius_xmpp_0_5_6_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.pontarius-xmpp_0_5_6_8`,
  "An XMPP client library",
);

/**
 * Can I have a pony?
 */
export const pony = mkPackage(
  nixRaw`pkgs.haskellPackages.pony`,
  "Can I have a pony?",
);

/**
 * Run jobs on a limited number of threads and support data dependencies
 */
export const pooled_io = mkPackage(
  nixRaw`pkgs.haskellPackages.pooled-io`,
  "Run jobs on a limited number of threads and support data dependencies",
);

/**
 * popenhs is a popen-like library for Haskell
 */
export const popenhs = mkPackage(
  nixRaw`pkgs.haskellPackages.popenhs`,
  "popenhs is a popen-like library for Haskell",
);

/**
 * Empty Cabal package
 */
export const populate_setup_exe_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.populate-setup-exe-cache`,
  "Empty Cabal package",
);

/**
 * Express portable, composable and reusable data tasks and pipelines
 */
export const porcupine_core = mkPackage(
  nixRaw`pkgs.haskellPackages.porcupine-core`,
  "Express portable, composable and reusable data tasks and pipelines",
);

/**
 * A location accessor for porcupine to connect to HTTP sources/sinks
 */
export const porcupine_http = mkPackage(
  nixRaw`pkgs.haskellPackages.porcupine-http`,
  "A location accessor for porcupine to connect to HTTP sources/sinks",
);

/**
 * A location accessor for porcupine to connect to AWS S3 sources/sinks
 */
export const porcupine_s3 = mkPackage(
  nixRaw`pkgs.haskellPackages.porcupine-s3`,
  "A location accessor for porcupine to connect to AWS S3 sources/sinks",
);

/**
 * Utilities for creating and waiting on ports
 */
export const port_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.port-utils`,
  "Utilities for creating and waiting on ports",
);

/**
 * Alternative 'lines' implementation that understands CR-LF and CR
 */
export const portable_lines = mkPackage(
  nixRaw`pkgs.haskellPackages.portable-lines`,
  "Alternative 'lines' implementation that understands CR-LF and CR",
);

/**
 * Lenses for the AST of Template Haskell 2.11 and Template Haskell < 2.11
 */
export const portable_template_haskell_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.portable-template-haskell-lens`,
  "Lenses for the AST of Template Haskell 2.11 and Template Haskell < 2.11",
);

/**
 * Haskell bindings for the PortAudio library
 */
export const portaudio = mkPackage(
  nixRaw`pkgs.haskellPackages.portaudio`,
  "Haskell bindings for the PortAudio library",
);

/**
 * Implementation of the Porter stemming algorithm
 */
export const porter = mkPackage(
  nixRaw`pkgs.haskellPackages.porter`,
  "Implementation of the Porter stemming algorithm",
);

/**
 * Rendering to pseudo-Haskell syntax
 */
export const portray = mkPackage(
  nixRaw`pkgs.haskellPackages.portray`,
  "Rendering to pseudo-Haskell syntax",
);

/**
 * Pretty structural diffs between two values
 */
export const portray_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.portray-diff`,
  "Pretty structural diffs between two values",
);

/**
 * HUnit assertions based on portray-diff
 */
export const portray_diff_hunit = mkPackage(
  nixRaw`pkgs.haskellPackages.portray-diff-hunit`,
  "HUnit assertions based on portray-diff",
);

/**
 * QuickCheck tests with portray-diff
 */
export const portray_diff_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.portray-diff-quickcheck`,
  "QuickCheck tests with portray-diff",
);

/**
 * Portray backend for pretty
 */
export const portray_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.portray-pretty`,
  "Portray backend for pretty",
);

/**
 * Portray backend for prettyprinter
 */
export const portray_prettyprinter = mkPackage(
  nixRaw`pkgs.haskellPackages.portray-prettyprinter`,
  "Portray backend for prettyprinter",
);

/**
 * The Haskell Ports Library
 */
export const ports = mkPackage(
  nixRaw`pkgs.haskellPackages.ports`,
  "The Haskell Ports Library",
);

/**
 * Library to interact with port tools on FreeBSD
 */
export const ports_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.ports-tools`,
  "Library to interact with port tools on FreeBSD",
);

/**
 * positive numbers
 */
export const pos = mkPackage(
  nixRaw`pkgs.haskellPackages.pos`,
  "positive numbers",
);

/**
 * Simple extensible library to run SQL file against PostgreSQL database
 */
export const poseidon = mkPackage(
  nixRaw`pkgs.haskellPackages.poseidon`,
  "Simple extensible library to run SQL file against PostgreSQL database",
);

/**
 * Extension of Poseidon library for Postgis (Spatial and Geographic objects for PostgreSQL)
 */
export const poseidon_postgis = mkPackage(
  nixRaw`pkgs.haskellPackages.poseidon-postgis`,
  "Extension of Poseidon library for Postgis (Spatial and Geographic objects for PostgreSQL)",
);

/**
 * Positive integers
 */
export const positive = mkPackage(
  nixRaw`pkgs.haskellPackages.positive`,
  "Positive integers",
);

/**
 * POSIX error codes
 */
export const posix_error_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-error-codes`,
  "POSIX error codes",
);

/**
 * Quote arguments to be passed through the Unix shell
 */
export const posix_escape = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-escape`,
  "Quote arguments to be passed through the Unix shell",
);

/**
 * Nice wrapper around POSIX fcntl advisory locks
 */
export const posix_filelock = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-filelock`,
  "Nice wrapper around POSIX fcntl advisory locks",
);

/**
 * POSIX filepath/directory functionality
 */
export const posix_paths = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-paths`,
  "POSIX filepath/directory functionality",
);

/**
 * Pseudo terminal interaction with subprocesses
 */
export const posix_pty = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-pty`,
  "Pseudo terminal interaction with subprocesses",
);

/**
 * Bindings to the POSIX socket API
 */
export const posix_socket = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-socket`,
  "Bindings to the POSIX socket API",
);

/**
 * Bindings to POSIX clock and timer functions
 */
export const posix_timer = mkPackage(
  nixRaw`pkgs.haskellPackages.posix-timer`,
  "Bindings to POSIX clock and timer functions",
);

/**
 * Three valued Data.Maybe
 */
export const possible = mkPackage(
  nixRaw`pkgs.haskellPackages.possible`,
  "Three valued Data.Maybe",
);

/**
 * type Possibly a = Either String a
 */
export const possibly = mkPackage(
  nixRaw`pkgs.haskellPackages.possibly`,
  "type Possibly a = Either String a",
);

/**
 * Send messages to a handle concurrently without getting them mixed
 */
export const post_mess_age = mkPackage(
  nixRaw`pkgs.haskellPackages.post-mess-age`,
  "Send messages to a handle concurrently without getting them mixed",
);

/**
 * An Options type representing options for postgres connections
 */
export const postgres_options = mkPackage(
  nixRaw`pkgs.haskellPackages.postgres-options`,
  "An Options type representing options for postgres connections",
);

/**
 * Encoders and decoders for the PostgreSQL's binary format
 */
export const postgresql_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-binary`,
  "Encoders and decoders for the PostgreSQL's binary format",
);

/**
 * Persistent compatibility for postgresql-common
 */
export const postgresql_common_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-common-persistent`,
  "Persistent compatibility for postgresql-common",
);

/**
 * Initial project postgresql-connector from stack
 */
export const postgresql_connector = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-connector`,
  "Initial project postgresql-connector from stack",
);

/**
 * Format data to feed to a PostgreSQL COPY FROM statement
 */
export const postgresql_copy_escape = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-copy-escape`,
  "Format data to feed to a PostgreSQL COPY FROM statement",
);

/**
 * PostgreSQL error codes
 */
export const postgresql_error_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-error-codes`,
  "PostgreSQL error codes",
);

/**
 * low-level binding to libpq
 */
export const postgresql_libpq = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-libpq`,
  "low-level binding to libpq",
);

/**
 * low-level binding to libpq
 */
export const postgresql_libpq_0_10_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-libpq_0_10_0_0`,
  "low-level binding to libpq",
);

/**
 * Minimal dependency PostgreSQL notifications library
 */
export const postgresql_libpq_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-libpq-notify`,
  "Minimal dependency PostgreSQL notifications library",
);

/**
 * PostgreSQL Schema Migrations
 */
export const postgresql_migration = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-migration`,
  "PostgreSQL Schema Migrations",
);

/**
 * Converter for question mark style and dollar sign style of PostgreSQL SQL
 */
export const postgresql_placeholder_converter = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-placeholder-converter`,
  "Converter for question mark style and dollar sign style of PostgreSQL SQL",
);

/**
 * pure Haskell PostgreSQL driver
 */
export const postgresql_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-pure`,
  "pure Haskell PostgreSQL driver",
);

/**
 * PostgreSQL Schema Management
 */
export const postgresql_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-schema`,
  "PostgreSQL Schema Management",
);

/**
 * Mid-Level PostgreSQL client library
 */
export const postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple`,
  "Mid-Level PostgreSQL client library",
);

/**
 * Mid-Level PostgreSQL client library
 */
export const postgresql_simple_0_7_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple_0_7_0_0`,
  "Mid-Level PostgreSQL client library",
);

/**
 * Interpolated SQL queries via quasiquotation
 */
export const postgresql_simple_interpolate = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-interpolate`,
  "Interpolated SQL queries via quasiquotation",
);

/**
 * Instances for using ltree with postgresql-simple
 */
export const postgresql_simple_ltree = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-ltree`,
  "Instances for using ltree with postgresql-simple",
);

/**
 * An optparse-applicative and envy parser for postgres options
 */
export const postgresql_simple_opts = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-opts`,
  "An optparse-applicative and envy parser for postgres options",
);

/**
 * A PostgreSQL backed queue
 */
export const postgresql_simple_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-queue`,
  "A PostgreSQL backed queue",
);

/**
 * Typed extension for PostgreSQL simple
 */
export const postgresql_simple_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-typed`,
  "Typed extension for PostgreSQL simple",
);

/**
 * Parse postgres:// url into ConnectInfo
 */
export const postgresql_simple_url = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-simple-url`,
  "Parse postgres:// url into ConnectInfo",
);

/**
 * PostgreSQL AST parsing and rendering
 */
export const postgresql_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-syntax`,
  "PostgreSQL AST parsing and rendering",
);

/**
 * a transactional monad on top of postgresql-simple
 */
export const postgresql_transactional = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-transactional`,
  "a transactional monad on top of postgresql-simple",
);

/**
 * A safe transaction monad for use with various PostgreSQL Haskell libraries
 */
export const postgresql_tx = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-tx`,
  "A safe transaction monad for use with various PostgreSQL Haskell libraries",
);

/**
 * postgresql-tx interfacing for use with postgresql-query
 */
export const postgresql_tx_query = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-tx-query`,
  "postgresql-tx interfacing for use with postgresql-query",
);

/**
 * postgresql-tx interfacing for use with squeal-postgresql
 */
export const postgresql_tx_squeal = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-tx-squeal`,
  "postgresql-tx interfacing for use with squeal-postgresql",
);

/**
 * Connection interop from postgresql-simple connections to postgresql-libpq connections
 */
export const postgresql_tx_squeal_compat_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-tx-squeal-compat-simple`,
  "Connection interop from postgresql-simple connections to postgresql-libpq connections",
);

/**
 * PostgreSQL interface with compile-time SQL type checking, optional HDBC backend
 */
export const postgresql_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-typed`,
  "PostgreSQL interface with compile-time SQL type checking, optional HDBC backend",
);

/**
 * PostgreSQL interface with compile-time SQL type checking, optional HDBC backend
 */
export const postgresql_typed_0_6_2_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.postgresql-typed_0_6_2_4`,
  "PostgreSQL interface with compile-time SQL type checking, optional HDBC backend",
);

/**
 * REST API for any Postgres database
 */
export const postgrest = mkPackage(
  nixRaw`pkgs.haskellPackages.postgrest`,
  "REST API for any Postgres database",
);

/**
 * Library for postmarkapp.com HTTP Api
 */
export const postmark = mkPackage(
  nixRaw`pkgs.haskellPackages.postmark`,
  "Library for postmarkapp.com HTTP Api",
);

/**
 * Simple streaming in IO
 */
export const potoki = mkPackage(
  nixRaw`pkgs.haskellPackages.potoki`,
  "Simple streaming in IO",
);

/**
 * Streaming serialization
 */
export const potoki_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.potoki-cereal`,
  "Streaming serialization",
);

/**
 * Integration of "potoki" and "conduit"
 */
export const potoki_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.potoki-conduit`,
  "Integration of \"potoki\" and \"conduit\"",
);

/**
 * Integration of "potoki" and "hasql"
 */
export const potoki_hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.potoki-hasql`,
  "Integration of \"potoki\" and \"hasql\"",
);

/**
 * Streaming ZLib decompression
 */
export const potoki_zlib = mkPackage(
  nixRaw`pkgs.haskellPackages.potoki-zlib`,
  "Streaming ZLib decompression",
);

/**
 * Trace bitmap images to paths using potrace
 */
export const potrace = mkPackage(
  nixRaw`pkgs.haskellPackages.potrace`,
  "Trace bitmap images to paths using potrace",
);

/**
 * Potrace bindings for the diagrams library
 */
export const potrace_diagrams = mkPackage(
  nixRaw`pkgs.haskellPackages.potrace-diagrams`,
  "Potrace bindings for the diagrams library",
);

/**
 * A flexible job queue with exchangeable backends
 */
export const powerqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.powerqueue`,
  "A flexible job queue with exchangeable backends",
);

/**
 * A distributed worker backend for powerqueu
 */
export const powerqueue_distributed = mkPackage(
  nixRaw`pkgs.haskellPackages.powerqueue-distributed`,
  "A distributed worker backend for powerqueu",
);

/**
 * A Amazon SQS backend for powerqueue
 */
export const powerqueue_sqs = mkPackage(
  nixRaw`pkgs.haskellPackages.powerqueue-sqs`,
  "A Amazon SQS backend for powerqueue",
);

/**
 * a tiny PPM image generator
 */
export const ppm = mkPackage(
  nixRaw`pkgs.haskellPackages.ppm`,
  "a tiny PPM image generator",
);

/**
 * Pretty Print containers in a tabular format
 */
export const pptable = mkPackage(
  nixRaw`pkgs.haskellPackages.pptable`,
  "Pretty Print containers in a tabular format",
);

/**
 * Reliable, persistent, fast priority queues
 */
export const pqueue = mkPackage(
  nixRaw`pkgs.haskellPackages.pqueue`,
  "Reliable, persistent, fast priority queues",
);

/**
 * Reliable, persistent, fast priority queues
 */
export const pqueue_1_5_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.pqueue_1_5_0_0`,
  "Reliable, persistent, fast priority queues",
);

/**
 * Fully encapsulated monad transformers with queuelike functionality
 */
export const pqueue_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.pqueue-mtl`,
  "Fully encapsulated monad transformers with queuelike functionality",
);

/**
 * Practice Room
 */
export const practice_room = mkPackage(
  nixRaw`pkgs.haskellPackages.practice-room`,
  "Practice Room",
);

/**
 * Alternative Show class that gives shorter view if possible
 */
export const pragmatic_show = mkPackage(
  nixRaw`pkgs.haskellPackages.pragmatic-show`,
  "Alternative Show class that gives shorter view if possible",
);

/**
 * A first class record field library
 */
export const prairie = mkPackage(
  nixRaw`pkgs.haskellPackages.prairie`,
  "A first class record field library",
);

/**
 * Simple cached predicates
 */
export const pred_set = mkPackage(
  nixRaw`pkgs.haskellPackages.pred-set`,
  "Simple cached predicates",
);

/**
 * Predicative tries
 */
export const pred_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.pred-trie`,
  "Predicative tries",
);

/**
 * A library for writing predicates and transformations over predicates in Haskell
 */
export const predicate_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.predicate-transformers`,
  "A library for writing predicates and transformations over predicates in Haskell",
);

/**
 * A couple of convenience functions for forming predicates
 */
export const predicates = mkPackage(
  nixRaw`pkgs.haskellPackages.predicates`,
  "A couple of convenience functions for forming predicates",
);

/**
 * Predict the future, backtrack on failure
 */
export const predictive = mkPackage(
  nixRaw`pkgs.haskellPackages.predictive`,
  "Predict the future, backtrack on failure",
);

/**
 * Tests and QuickCheck generators to accompany prednote
 */
export const prednote_test = mkPackage(
  nixRaw`pkgs.haskellPackages.prednote-test`,
  "Tests and QuickCheck generators to accompany prednote",
);

/**
 * Prefetch stdin even before stdout is ready
 */
export const prefetch = mkPackage(
  nixRaw`pkgs.haskellPackages.prefetch`,
  "Prefetch stdin even before stdout is ready",
);

export const prefix_expression = mkPackage(
  nixRaw`pkgs.haskellPackages.prefix-expression`,
  "",
);

/**
 * A basic library for SI/IEC prefix units
 */
export const prefix_units = mkPackage(
  nixRaw`pkgs.haskellPackages.prefix-units`,
  "A basic library for SI/IEC prefix units",
);

/**
 * A Prelude
 */
export const prelate = mkPackage(
  nixRaw`pkgs.haskellPackages.prelate`,
  "A Prelude",
);

/**
 * Provide Prelude with fixed content across GHC versions
 */
export const prelude2010 = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude2010`,
  "Provide Prelude with fixed content across GHC versions",
);

/**
 * Provide Prelude and Data.List with fixed content across GHC versions
 */
export const prelude_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude-compat`,
  "Provide Prelude and Data.List with fixed content across GHC versions",
);

/**
 * An EDSL-motivated subset of the Prelude
 */
export const prelude_edsl = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude-edsl`,
  "An EDSL-motivated subset of the Prelude",
);

/**
 * Higher order versions of Prelude classes
 */
export const prelude_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude-extras`,
  "Higher order versions of Prelude classes",
);

/**
 * A slightly better (but conservative) Prelude
 */
export const prelude_prime = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude-prime`,
  "A slightly better (but conservative) Prelude",
);

/**
 * A redefinition of the Prelude's Enum class in order to render it safe
 */
export const prelude_safeenum = mkPackage(
  nixRaw`pkgs.haskellPackages.prelude-safeenum`,
  "A redefinition of the Prelude's Enum class in order to render it safe",
);

/**
 * Generalizes List functions and replaces partials with NonEmpty equivalents
 */
export const preludeplus = mkPackage(
  nixRaw`pkgs.haskellPackages.preludeplus`,
  "Generalizes List functions and replaces partials with NonEmpty equivalents",
);

/**
 * A framework for extending Haskell's syntax via quick-and-dirty preprocessors
 */
export const preprocessor_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.preprocessor-tools`,
  "A framework for extending Haskell's syntax via quick-and-dirty preprocessors",
);

/**
 * An HDBC connector for Presto
 */
export const presto_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.presto-hdbc`,
  "An HDBC connector for Presto",
);

/**
 * Haskell2010 structured text formatting
 */
export const prettify = mkPackage(
  nixRaw`pkgs.haskellPackages.prettify`,
  "Haskell2010 structured text formatting",
);

/**
 * prettier function composition by ()
 */
export const prettyFunctionComposing = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyFunctionComposing`,
  "prettier function composition by ()",
);

/**
 * Pretty-printing library
 */
export const pretty_1_1_3_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty_1_1_3_6`,
  "Pretty-printing library",
);

/**
 * Pretty printing class similar to Show
 */
export const pretty_class = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-class`,
  "Pretty printing class similar to Show",
);

/**
 * Pretty printing a diff of two values
 */
export const pretty_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-diff`,
  "Pretty printing a diff of two values",
);

/**
 * Typeclass for human-readable display
 */
export const pretty_display = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-display`,
  "Typeclass for human-readable display",
);

/**
 * Pretty error messages for runtime invariants
 */
export const pretty_error = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-error`,
  "Pretty error messages for runtime invariants",
);

/**
 * A library for hex dumps of ByteStrings
 */
export const pretty_hex = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-hex`,
  "A library for hex dumps of ByteStrings",
);

/**
 * Produce nice human-readable HTML
 */
export const pretty_html = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-html`,
  "Produce nice human-readable HTML",
);

/**
 * Pretty relative time
 */
export const pretty_relative_time = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-relative-time`,
  "Pretty relative time",
);

/**
 * Tools for working with derived `Show` instances and generic inspection of values
 */
export const pretty_show = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-show`,
  "Tools for working with derived `Show` instances and generic inspection of values",
);

/**
 * Like pretty-show, but only for ansi-wl-pprint
 */
export const pretty_show_ansi_wl = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-show-ansi-wl`,
  "Like pretty-show, but only for ansi-wl-pprint",
);

/**
 * pretty printer for data types with a 'Show' instance
 */
export const pretty_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-simple`,
  "pretty printer for data types with a 'Show' instance",
);

/**
 * A generic pretty-printer using generics-sop
 */
export const pretty_sop = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-sop`,
  "A generic pretty-printer using generics-sop",
);

/**
 * Styling and coloring terminal output with ANSI escape sequences
 */
export const pretty_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-terminal`,
  "Styling and coloring terminal output with ANSI escape sequences",
);

/**
 * Pretty-print trees
 */
export const pretty_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-tree`,
  "Pretty-print trees",
);

/**
 * A small pretty printing DSL for complex types
 */
export const pretty_types = mkPackage(
  nixRaw`pkgs.haskellPackages.pretty-types`,
  "A small pretty printing DSL for complex types",
);

/**
 * Pretty print charts from ghci
 */
export const prettychart = mkPackage(
  nixRaw`pkgs.haskellPackages.prettychart`,
  "Pretty print charts from ghci",
);

/**
 * Pretty printing class similar to Show
 */
export const prettyclass = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyclass`,
  "Pretty printing class similar to Show",
);

/**
 * API for prettyprinting custom syntax trees (extracted from elm-format)
 */
export const prettyprint_avh4 = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprint-avh4`,
  "API for prettyprinting custom syntax trees (extracted from elm-format)",
);

/**
 * A modern, easy to use, well-documented, extensible pretty-printer
 */
export const prettyprinter = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter`,
  "A modern, easy to use, well-documented, extensible pretty-printer",
);

/**
 * ANSI terminal backend for the prettyprinter package
 */
export const prettyprinter_ansi_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-ansi-terminal`,
  "ANSI terminal backend for the prettyprinter package",
);

/**
 * Some useful combinators for the prettyprinter package
 */
export const prettyprinter_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-combinators`,
  "Some useful combinators for the prettyprinter package",
);

/**
 * Drop-in compatibility package to migrate from annotated-wl-pprint to prettyprinter
 */
export const prettyprinter_compat_annotated_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-compat-annotated-wl-pprint`,
  "Drop-in compatibility package to migrate from annotated-wl-pprint to prettyprinter",
);

/**
 * Drop-in compatibility package to migrate from ansi-wl-pprint to prettyprinter
 */
export const prettyprinter_compat_ansi_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-compat-ansi-wl-pprint`,
  "Drop-in compatibility package to migrate from ansi-wl-pprint to prettyprinter",
);

/**
 * Drop-in compatibility package to migrate from wl-pprint to prettyprinter
 */
export const prettyprinter_compat_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-compat-wl-pprint`,
  "Drop-in compatibility package to migrate from wl-pprint to prettyprinter",
);

/**
 * Converter from ansi-wl-pprint documents to prettyprinter-based ones
 */
export const prettyprinter_convert_ansi_wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-convert-ansi-wl-pprint`,
  "Converter from ansi-wl-pprint documents to prettyprinter-based ones",
);

/**
 * A prettyprinter backend for graphviz
 */
export const prettyprinter_graphviz = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-graphviz`,
  "A prettyprinter backend for graphviz",
);

/**
 * Efficient interpolation for Prettyprinter
 */
export const prettyprinter_interp = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-interp`,
  "Efficient interpolation for Prettyprinter",
);

/**
 * A prettyprinter backend for lucid
 */
export const prettyprinter_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.prettyprinter-lucid`,
  "A prettyprinter backend for lucid",
);

/**
 * The method of previewing data (instead of wholly show-ing it)
 */
export const preview = mkPackage(
  nixRaw`pkgs.haskellPackages.preview`,
  "The method of previewing data (instead of wholly show-ing it)",
);

/**
 * Catch errors thrown from pure computations using primops
 */
export const prim_spoon = mkPackage(
  nixRaw`pkgs.haskellPackages.prim-spoon`,
  "Catch errors thrown from pure computations using primops",
);

/**
 * Opaque unique identifiers in primitive state monads
 */
export const prim_uniq = mkPackage(
  nixRaw`pkgs.haskellPackages.prim-uniq`,
  "Opaque unique identifiers in primitive state monads",
);

/**
 * Unified interface for memory managemenet
 */
export const primal_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.primal-memory`,
  "Unified interface for memory managemenet",
);

/**
 * Bindings to the primecount library
 */
export const primecount = mkPackage(
  nixRaw`pkgs.haskellPackages.primecount`,
  "Bindings to the primecount library",
);

/**
 * Efficient, purely functional generation of prime numbers
 */
export const primes = mkPackage(
  nixRaw`pkgs.haskellPackages.primes`,
  "Efficient, purely functional generation of prime numbers",
);

/**
 * FFI bindings for the primesieve library
 */
export const primesieve = mkPackage(
  nixRaw`pkgs.haskellPackages.primesieve`,
  "FFI bindings for the primesieve library",
);

/**
 * Primitive memory-related operations
 */
export const primitive = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive`,
  "Primitive memory-related operations",
);

/**
 * Addresses to unmanaged memory
 */
export const primitive_addr = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-addr`,
  "Addresses to unmanaged memory",
);

/**
 * containers backed by arrays
 */
export const primitive_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-containers`,
  "containers backed by arrays",
);

/**
 * Extras for the "primitive" library
 */
export const primitive_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-extras`,
  "Extras for the \"primitive\" library",
);

/**
 * Types for offsets into unboxed arrays
 */
export const primitive_offset = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-offset`,
  "Types for offsets into unboxed arrays",
);

/**
 * Serialisation of primitive types
 */
export const primitive_serial = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-serial`,
  "Serialisation of primitive types",
);

/**
 * Unaligned access to primitive arrays
 */
export const primitive_unaligned = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-unaligned`,
  "Unaligned access to primitive arrays",
);

/**
 * Primitive GHC types with unlifted types inside
 */
export const primitive_unlifted = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-unlifted`,
  "Primitive GHC types with unlifted types inside",
);

/**
 * Primitive GHC types with unlifted types inside
 */
export const primitive_unlifted_2_1_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.primitive-unlifted_2_1_0_0`,
  "Primitive GHC types with unlifted types inside",
);

/**
 * ImageBoard on Happstack and HSP
 */
export const primula_board = mkPackage(
  nixRaw`pkgs.haskellPackages.primula-board`,
  "ImageBoard on Happstack and HSP",
);

/**
 * Jabber-bot for primula-board ImageBoard
 */
export const primula_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.primula-bot`,
  "Jabber-bot for primula-board ImageBoard",
);

/**
 * nonempty and positive functions
 */
export const primus = mkPackage(
  nixRaw`pkgs.haskellPackages.primus`,
  "nonempty and positive functions",
);

/**
 * Print all ANSI console colors
 */
export const print_console_colors = mkPackage(
  nixRaw`pkgs.haskellPackages.print-console-colors`,
  "Print all ANSI console colors",
);

/**
 * A Perl printf like formatter
 */
export const printf_mauke = mkPackage(
  nixRaw`pkgs.haskellPackages.printf-mauke`,
  "A Perl printf like formatter",
);

/**
 * Type safe interface for Text.Printf
 */
export const printf_safe = mkPackage(
  nixRaw`pkgs.haskellPackages.printf-safe`,
  "Type safe interface for Text.Printf",
);

/**
 * Simple tool to display some text on an on-screen display
 */
export const printxosd = mkPackage(
  nixRaw`pkgs.haskellPackages.printxosd`,
  "Simple tool to display some text on an on-screen display",
);

/**
 * Cooperative task prioritization
 */
export const priority_sync = mkPackage(
  nixRaw`pkgs.haskellPackages.priority-sync`,
  "Cooperative task prioritization",
);

/**
 * Upload a package to the public or private hackage, building its docs
 */
export const private_hackage_uploader = mkPackage(
  nixRaw`pkgs.haskellPackages.private-hackage-uploader`,
  "Upload a package to the public or private hackage, building its docs",
);

/**
 * Provides privilege separated versions of the concurrency primitives
 */
export const privileged_concurrency = mkPackage(
  nixRaw`pkgs.haskellPackages.privileged-concurrency`,
  "Provides privilege separated versions of the concurrency primitives",
);

/**
 * Convert colors to different color spaces, interpolate colors, and transform colors
 */
export const prizm = mkPackage(
  nixRaw`pkgs.haskellPackages.prizm`,
  "Convert colors to different color spaces, interpolate colors, and transform colors",
);

/**
 * Discrete probability monad
 */
export const prob = mkPackage(
  nixRaw`pkgs.haskellPackages.prob`,
  "Discrete probability monad",
);

/**
 * Probabilistic Functional Programming
 */
export const probability = mkPackage(
  nixRaw`pkgs.haskellPackages.probability`,
  "Probabilistic Functional Programming",
);

/**
 * Parse process information for Linux
 */
export const proc = mkPackage(
  nixRaw`pkgs.haskellPackages.proc`,
  "Parse process information for Linux",
);

/**
 * Parse /proc/net/{tcp,tcp6,udp,udp6}
 */
export const proc_net = mkPackage(
  nixRaw`pkgs.haskellPackages.proc-net`,
  "Parse /proc/net/{tcp,tcp6,udp,udp6}",
);

/**
 * Process libraries
 */
export const process_1_6_18_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.process_1_6_18_0`,
  "Process libraries",
);

/**
 * Process extras
 */
export const process_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.process-extras`,
  "Process extras",
);

/**
 * IterIO Process Library
 */
export const process_iterio = mkPackage(
  nixRaw`pkgs.haskellPackages.process-iterio`,
  "IterIO Process Library",
);

/**
 * Run a process and do reportsing on its progress
 */
export const process_progress = mkPackage(
  nixRaw`pkgs.haskellPackages.process-progress`,
  "Run a process and do reportsing on its progress",
);

/**
 * Quasi-Quoters for exec process
 */
export const process_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.process-qq`,
  "Quasi-Quoters for exec process",
);

/**
 * Streaming interface to system processes
 */
export const process_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.process-streaming`,
  "Streaming interface to system processes",
);

/**
 * Computer graphics for kids and artists with Processing implemented in Haskell
 */
export const processing_for_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.processing-for-haskell`,
  "Computer graphics for kids and artists with Processing implemented in Haskell",
);

/**
 * a creation kit for instruction sets and cpu simulators and development tools
 */
export const processor_creative_kit = mkPackage(
  nixRaw`pkgs.haskellPackages.processor-creative-kit`,
  "a creation kit for instruction sets and cpu simulators and development tools",
);

/**
 * Ergonomic process launching with extreme flexibility and speed
 */
export const procex = mkPackage(
  nixRaw`pkgs.haskellPackages.procex`,
  "Ergonomic process launching with extreme flexibility and speed",
);

/**
 * Pure structures that can be incrementally created in impure code
 */
export const procrastinating_structure = mkPackage(
  nixRaw`pkgs.haskellPackages.procrastinating-structure`,
  "Pure structures that can be incrementally created in impure code",
);

/**
 * An IO library for testing interactive command line programs
 */
export const proctest = mkPackage(
  nixRaw`pkgs.haskellPackages.proctest`,
  "An IO library for testing interactive command line programs",
);

/**
 * Simple streaming datatype
 */
export const producer = mkPackage(
  nixRaw`pkgs.haskellPackages.producer`,
  "Simple streaming datatype",
);

/**
 * Product category
 */
export const product = mkPackage(
  nixRaw`pkgs.haskellPackages.product`,
  "Product category",
);

/**
 * product-profunctors
 */
export const product_profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.product-profunctors`,
  "product-profunctors",
);

/**
 * Convert GHC profiles into GraphViz's dot format
 */
export const prof2dot = mkPackage(
  nixRaw`pkgs.haskellPackages.prof2dot`,
  "Convert GHC profiles into GraphViz's dot format",
);

/**
 * Restructure GHC profile reports
 */
export const profiterole = mkPackage(
  nixRaw`pkgs.haskellPackages.profiterole`,
  "Restructure GHC profile reports",
);

/**
 * Profunctor arrows
 */
export const profunctor_arrows = mkPackage(
  nixRaw`pkgs.haskellPackages.profunctor-arrows`,
  "Profunctor arrows",
);

/**
 * This package has been absorbed into profunctors 4.0
 */
export const profunctor_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.profunctor-extras`,
  "This package has been absorbed into profunctors 4.0",
);

/**
 * Profunctor miscellany
 */
export const profunctor_misc = mkPackage(
  nixRaw`pkgs.haskellPackages.profunctor-misc`,
  "Profunctor miscellany",
);

/**
 * Profunctors
 */
export const profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.profunctors`,
  "Profunctors",
);

/**
 * Programs with Environments and Managed Resources
 */
export const program = mkPackage(
  nixRaw`pkgs.haskellPackages.program`,
  "Programs with Environments and Managed Resources",
);

/**
 * Simple progress tracking & projection library
 */
export const progress = mkPackage(
  nixRaw`pkgs.haskellPackages.progress`,
  "Simple progress tracking & projection library",
);

/**
 * Progressbar API
 */
export const progressbar = mkPackage(
  nixRaw`pkgs.haskellPackages.progressbar`,
  "Progressbar API",
);

/**
 * Relational Algebra Engine
 */
export const project_m36 = mkPackage(
  nixRaw`pkgs.haskellPackages.project-m36`,
  "Relational Algebra Engine",
);

/**
 * Specify Haskell project templates and generate files
 */
export const project_template = mkPackage(
  nixRaw`pkgs.haskellPackages.project-template`,
  "Specify Haskell project templates and generate files",
);

/**
 * Projection function for arbitrarily nested binary product types
 */
export const projection = mkPackage(
  nixRaw`pkgs.haskellPackages.projection`,
  "Projection function for arbitrarily nested binary product types",
);

/**
 * Bindings to the projectroot C logic
 */
export const projectroot = mkPackage(
  nixRaw`pkgs.haskellPackages.projectroot`,
  "Bindings to the projectroot C logic",
);

/**
 * A command line tool to visualize query resolution in Prolog
 */
export const prolog_graph = mkPackage(
  nixRaw`pkgs.haskellPackages.prolog-graph`,
  "A command line tool to visualize query resolution in Prolog",
);

/**
 * Generating images of resolution trees for Prolog queries
 */
export const prolog_graph_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.prolog-graph-lib`,
  "Generating images of resolution trees for Prolog queries",
);

/**
 * Better, more general Prelude exporting common utilities
 */
export const prologue = mkPackage(
  nixRaw`pkgs.haskellPackages.prologue`,
  "Better, more general Prelude exporting common utilities",
);

/**
 * ACI Learning's custom prelude
 */
export const prolude = mkPackage(
  nixRaw`pkgs.haskellPackages.prolude`,
  "ACI Learning's custom prelude",
);

/**
 * Prometheus Haskell Client
 */
export const prometheus = mkPackage(
  nixRaw`pkgs.haskellPackages.prometheus`,
  "Prometheus Haskell Client",
);

/**
 * Haskell client library for http://prometheus.io.
 */
export const prometheus_client = mkPackage(
  nixRaw`pkgs.haskellPackages.prometheus-client`,
  "Haskell client library for http://prometheus.io.",
);

/**
 * Metrics exposing GHC runtime information for use with prometheus-client
 */
export const prometheus_metrics_ghc = mkPackage(
  nixRaw`pkgs.haskellPackages.prometheus-metrics-ghc`,
  "Metrics exposing GHC runtime information for use with prometheus-client",
);

/**
 * Export metrics from /proc for the current process
 */
export const prometheus_proc = mkPackage(
  nixRaw`pkgs.haskellPackages.prometheus-proc`,
  "Export metrics from /proc for the current process",
);

/**
 * Lazy demand-driven promises
 */
export const promises = mkPackage(
  nixRaw`pkgs.haskellPackages.promises`,
  "Lazy demand-driven promises",
);

/**
 * Monad (and transformer) for deferred-effect pure prompt-response queries
 */
export const prompt = mkPackage(
  nixRaw`pkgs.haskellPackages.prompt`,
  "Monad (and transformer) for deferred-effect pure prompt-response queries",
);

/**
 * Functional synthesis of images and animations
 */
export const propane = mkPackage(
  nixRaw`pkgs.haskellPackages.propane`,
  "Functional synthesis of images and animations",
);

/**
 * A Simple Propagator Library
 */
export const propeller = mkPackage(
  nixRaw`pkgs.haskellPackages.propeller`,
  "A Simple Propagator Library",
);

/**
 * property-based host configuration management in haskell
 */
export const propellor = mkPackage(
  nixRaw`pkgs.haskellPackages.propellor`,
  "property-based host configuration management in haskell",
);

/**
 * common properties
 */
export const property = mkPackage(
  nixRaw`pkgs.haskellPackages.property`,
  "common properties",
);

/**
 * A library for functional GUI development
 */
export const proplang = mkPackage(
  nixRaw`pkgs.haskellPackages.proplang`,
  "A library for functional GUI development",
);

/**
 * Reusable quickcheck properties
 */
export const props = mkPackage(
  nixRaw`pkgs.haskellPackages.props`,
  "Reusable quickcheck properties",
);

/**
 * Proquints: Identifiers that are Readable, Spellable, and Pronounceable
 */
export const proquint = mkPackage(
  nixRaw`pkgs.haskellPackages.proquint`,
  "Proquints: Identifiers that are Readable, Spellable, and Pronounceable",
);

/**
 * A DSL for processing Prosidy documents
 */
export const prosidyc = mkPackage(
  nixRaw`pkgs.haskellPackages.prosidyc`,
  "A DSL for processing Prosidy documents",
);

/**
 * Explore continuations with trepidation
 */
export const prospect = mkPackage(
  nixRaw`pkgs.haskellPackages.prospect`,
  "Explore continuations with trepidation",
);

/**
 * Simple audio library for SDL
 */
export const proteaaudio_sdl = mkPackage(
  nixRaw`pkgs.haskellPackages.proteaaudio-sdl`,
  "Simple audio library for SDL",
);

/**
 * A higher-level API to the proto3-wire library
 */
export const proto3_suite = mkPackage(
  nixRaw`pkgs.haskellPackages.proto3-suite`,
  "A higher-level API to the proto3-wire library",
);

/**
 * A lens-based implementation of protocol buffers in Haskell
 */
export const proto_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens`,
  "A lens-based implementation of protocol buffers in Haskell",
);

/**
 * Utilities functions to proto-lens
 */
export const proto_lens_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-combinators`,
  "Utilities functions to proto-lens",
);

/**
 * Protocol buffers for describing the definitions of messages
 */
export const proto_lens_descriptors = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-descriptors`,
  "Protocol buffers for describing the definitions of messages",
);

/**
 * JSON protobuf encoding for proto-lens
 */
export const proto_lens_jsonpb = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-jsonpb`,
  "JSON protobuf encoding for proto-lens",
);

/**
 * Adapting proto-lens to optparse-applicative ReadMs
 */
export const proto_lens_optparse = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-optparse`,
  "Adapting proto-lens to optparse-applicative ReadMs",
);

/**
 * Basic protocol buffer message types
 */
export const proto_lens_protobuf_types = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-protobuf-types`,
  "Basic protocol buffer message types",
);

/**
 * Protocol buffer compiler for the proto-lens library
 */
export const proto_lens_protoc = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-protoc`,
  "Protocol buffer compiler for the proto-lens library",
);

export const proto_lens_runtime = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-runtime`,
  "",
);

/**
 * Cabal support for codegen with proto-lens
 */
export const proto_lens_setup = mkPackage(
  nixRaw`pkgs.haskellPackages.proto-lens-setup`,
  "Cabal support for codegen with proto-lens",
);

/**
 * Google Protocol Buffers via GHC.Generics
 */
export const protobuf = mkPackage(
  nixRaw`pkgs.haskellPackages.protobuf`,
  "Google Protocol Buffers via GHC.Generics",
);

/**
 * Slow protobuf implementation
 */
export const protobuf_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.protobuf-builder`,
  "Slow protobuf implementation",
);

/**
 * Protocol Buffers via C++
 */
export const protobuf_native = mkPackage(
  nixRaw`pkgs.haskellPackages.protobuf-native`,
  "Protocol Buffers via C++",
);

/**
 * Simple Protocol Buffers library (proto2)
 */
export const protobuf_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.protobuf-simple`,
  "Simple Protocol Buffers library (proto2)",
);

/**
 * Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification
 */
export const protocol_buffers_descriptor = mkPackage(
  nixRaw`pkgs.haskellPackages.protocol-buffers-descriptor`,
  "Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification",
);

/**
 * Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification
 */
export const protocol_buffers_descriptor_fork = mkPackage(
  nixRaw`pkgs.haskellPackages.protocol-buffers-descriptor-fork`,
  "Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification",
);

/**
 * parser and printer for radius protocol packet
 */
export const protocol_radius = mkPackage(
  nixRaw`pkgs.haskellPackages.protocol-radius`,
  "parser and printer for radius protocol packet",
);

/**
 * testsuit of protocol-radius haskell package
 */
export const protocol_radius_test = mkPackage(
  nixRaw`pkgs.haskellPackages.protocol-radius-test`,
  "testsuit of protocol-radius haskell package",
);

/**
 * A small prelude
 */
export const protolude = mkPackage(
  nixRaw`pkgs.haskellPackages.protolude`,
  "A small prelude",
);

export const proton = mkPackage(
  nixRaw`pkgs.haskellPackages.proton`,
  "",
);

/**
 * Make functions consume Proxy instead of undefined
 */
export const proxied = mkPackage(
  nixRaw`pkgs.haskellPackages.proxied`,
  "Make functions consume Proxy instead of undefined",
);

/**
 * proxy helpers
 */
export const proxy = mkPackage(
  nixRaw`pkgs.haskellPackages.proxy`,
  "proxy helpers",
);

/**
 * Language support for the PureScript programming language
 */
export const psc_ide = mkPackage(
  nixRaw`pkgs.haskellPackages.psc-ide`,
  "Language support for the PureScript programming language",
);

/**
 * Reading/Writing OPB/WBO files used in pseudo boolean competition
 */
export const pseudo_boolean = mkPackage(
  nixRaw`pkgs.haskellPackages.pseudo-boolean`,
  "Reading/Writing OPB/WBO files used in pseudo boolean competition",
);

/**
 * cpp-style built-in macros using Template Haskell
 */
export const pseudomacros = mkPackage(
  nixRaw`pkgs.haskellPackages.pseudomacros`,
  "cpp-style built-in macros using Template Haskell",
);

/**
 * PostgreSQL client
 */
export const psql = mkPackage(
  nixRaw`pkgs.haskellPackages.psql`,
  "PostgreSQL client",
);

/**
 * A small collection of helper functions to generate postgresql queries
 */
export const psql_helpers = mkPackage(
  nixRaw`pkgs.haskellPackages.psql-helpers`,
  "A small collection of helper functions to generate postgresql queries",
);

/**
 * PostgreSQL Simple util tools
 */
export const psql_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.psql-utils`,
  "PostgreSQL Simple util tools",
);

/**
 * Pure priority search queues
 */
export const psqueues = mkPackage(
  nixRaw`pkgs.haskellPackages.psqueues`,
  "Pure priority search queues",
);

/**
 * A parser generator
 */
export const ptera = mkPackage(
  nixRaw`pkgs.haskellPackages.ptera`,
  "A parser generator",
);

/**
 * A parser generator
 */
export const ptera_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ptera-core`,
  "A parser generator",
);

/**
 * A parser generator
 */
export const ptera_th = mkPackage(
  nixRaw`pkgs.haskellPackages.ptera-th`,
  "A parser generator",
);

/**
 * Bindings for the pthread library
 */
export const pthread = mkPackage(
  nixRaw`pkgs.haskellPackages.pthread`,
  "Bindings for the pthread library",
);

/**
 * Experimental abstractions for operations on pointers
 */
export const ptr = mkPackage(
  nixRaw`pkgs.haskellPackages.ptr`,
  "Experimental abstractions for operations on pointers",
);

/**
 * Pointer poking action construction and composition toolkit
 */
export const ptr_poker = mkPackage(
  nixRaw`pkgs.haskellPackages.ptr-poker`,
  "Pointer poking action construction and composition toolkit",
);

/**
 * Type-checked pointer diffs
 */
export const ptrdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.ptrdiff`,
  "Type-checked pointer diffs",
);

/**
 * Is a given string a domain suffix?
 */
export const publicsuffixlist = mkPackage(
  nixRaw`pkgs.haskellPackages.publicsuffixlist`,
  "Is a given string a domain suffix?",
);

/**
 * A CLI assistant
 */
export const puffytools = mkPackage(
  nixRaw`pkgs.haskellPackages.puffytools`,
  "A CLI assistant",
);

/**
 * Portable Haskell/POSIX layer for Pugs
 */
export const pugs_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.pugs-compat`,
  "Portable Haskell/POSIX layer for Pugs",
);

/**
 * Haskell PCRE binding
 */
export const pugs_hsregex = mkPackage(
  nixRaw`pkgs.haskellPackages.pugs-hsregex`,
  "Haskell PCRE binding",
);

/**
 * Synchronize actions to a time pulse
 */
export const pulse = mkPackage(
  nixRaw`pkgs.haskellPackages.pulse`,
  "Synchronize actions to a time pulse",
);

/**
 * binding to Simple API of pulseaudio
 */
export const pulse_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.pulse-simple`,
  "binding to Simple API of pulseaudio",
);

/**
 * A low-level (incomplete) wrapper around the pulseaudio client asynchronous api
 */
export const pulseaudio = mkPackage(
  nixRaw`pkgs.haskellPackages.pulseaudio`,
  "A low-level (incomplete) wrapper around the pulseaudio client asynchronous api",
);

/**
 * Multilingual unsupervised sentence tokenization with Punkt
 */
export const punkt = mkPackage(
  nixRaw`pkgs.haskellPackages.punkt`,
  "Multilingual unsupervised sentence tokenization with Punkt",
);

/**
 * Encode unicode strings to ascii forms according to RFC 3492
 */
export const punycode = mkPackage(
  nixRaw`pkgs.haskellPackages.punycode`,
  "Encode unicode strings to ascii forms according to RFC 3492",
);

/**
 * A program that displays the puppet resources associated to a node given .pp files.
 */
export const puppetresources = mkPackage(
  nixRaw`pkgs.haskellPackages.puppetresources`,
  "A program that displays the puppet resources associated to a node given .pp files.",
);

/**
 * A Haskell-only implementation of the MD5 digest (hash) algorithm
 */
export const pureMD5 = mkPackage(
  nixRaw`pkgs.haskellPackages.pureMD5`,
  "A Haskell-only implementation of the MD5 digest (hash) algorithm",
);

/**
 * Another pure-haskell CDB (Constant Database) implementation
 */
export const pure_cdb = mkPackage(
  nixRaw`pkgs.haskellPackages.pure-cdb`,
  "Another pure-haskell CDB (Constant Database) implementation",
);

/**
 * Fast Fourier Transform
 */
export const pure_fft = mkPackage(
  nixRaw`pkgs.haskellPackages.pure-fft`,
  "Fast Fourier Transform",
);

/**
 * Tests for the pure-priority-queue package
 */
export const pure_priority_queue_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.pure-priority-queue-tests`,
  "Tests for the pure-priority-queue package",
);

export const pure_shuffle = mkPackage(
  nixRaw`pkgs.haskellPackages.pure-shuffle`,
  "",
);

/**
 * types and parser for email messages (including MIME)
 */
export const purebred_email = mkPackage(
  nixRaw`pkgs.haskellPackages.purebred-email`,
  "types and parser for email messages (including MIME)",
);

/**
 * Nix backend for PureScript. Transpile PureScript code to Nix.
 */
export const purenix = mkPackage(
  nixRaw`pkgs.haskellPackages.purenix`,
  "Nix backend for PureScript. Transpile PureScript code to Nix.",
);

/**
 * Simple Routing functions for Wai Applications
 */
export const purescheme_wai_routing_core = mkPackage(
  nixRaw`pkgs.haskellPackages.purescheme-wai-routing-core`,
  "Simple Routing functions for Wai Applications",
);

/**
 * PureScript Programming Language Compiler
 */
export const purescript = mkPackage(
  nixRaw`pkgs.haskellPackages.purescript`,
  "PureScript Programming Language Compiler",
);

/**
 * Generate PureScript data types from Haskell data types
 */
export const purescript_bridge = mkPackage(
  nixRaw`pkgs.haskellPackages.purescript-bridge`,
  "Generate PureScript data types from Haskell data types",
);

/**
 * A fast alternative to Purescript's `psc-bundle` to be used during development
 */
export const purescript_bundle_fast = mkPackage(
  nixRaw`pkgs.haskellPackages.purescript-bundle-fast`,
  "A fast alternative to Purescript's `psc-bundle` to be used during development",
);

/**
 * Isomorphic trivial data type definitions over JSON
 */
export const purescript_iso = mkPackage(
  nixRaw`pkgs.haskellPackages.purescript-iso`,
  "Isomorphic trivial data type definitions over JSON",
);

/**
 * TypeScript Declaration File (.d.ts) generator for PureScript
 */
export const purescript_tsd_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.purescript-tsd-gen`,
  "TypeScript Declaration File (.d.ts) generator for PureScript",
);

/**
 * A cli client for pursuit
 */
export const pursuit_client = mkPackage(
  nixRaw`pkgs.haskellPackages.pursuit-client`,
  "A cli client for pursuit",
);

/**
 * A server-side library for sending push notifications
 */
export const push_notify = mkPackage(
  nixRaw`pkgs.haskellPackages.push-notify`,
  "A server-side library for sending push notifications",
);

/**
 * Send push notifications to mobile iOS devices
 */
export const push_notify_apn = mkPackage(
  nixRaw`pkgs.haskellPackages.push-notify-apn`,
  "Send push notifications to mobile iOS devices",
);

/**
 * A server-side library for sending/receiving push notifications through CCS (Google Cloud Messaging)
 */
export const push_notify_ccs = mkPackage(
  nixRaw`pkgs.haskellPackages.push-notify-ccs`,
  "A server-side library for sending/receiving push notifications through CCS (Google Cloud Messaging)",
);

/**
 * A general library for sending/receiving push notif. through dif. services.
 */
export const push_notify_general = mkPackage(
  nixRaw`pkgs.haskellPackages.push-notify-general`,
  "A general library for sending/receiving push notif. through dif. services.",
);

/**
 * Haskell client library for the Pusher Channels HTTP API
 */
export const pusher_http_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.pusher-http-haskell`,
  "Haskell client library for the Pusher Channels HTTP API",
);

/**
 * A Haskell Pushover API library
 */
export const pushover = mkPackage(
  nixRaw`pkgs.haskellPackages.pushover`,
  "A Haskell Pushover API library",
);

/**
 * Creating graphics for pencil puzzles, command line tools
 */
export const puzzle_draw_cmdline = mkPackage(
  nixRaw`pkgs.haskellPackages.puzzle-draw-cmdline`,
  "Creating graphics for pencil puzzles, command line tools",
);

/**
 * Mutable variable with primitive values
 */
export const pvar = mkPackage(
  nixRaw`pkgs.haskellPackages.pvar`,
  "Mutable variable with primitive values",
);

/**
 * A photo viewer daemon application with remote controlling abilities
 */
export const pvd = mkPackage(
  nixRaw`pkgs.haskellPackages.pvd`,
  "A photo viewer daemon application with remote controlling abilities",
);

/**
 * Public Verifiable Secret Sharing
 */
export const pvss = mkPackage(
  nixRaw`pkgs.haskellPackages.pvss`,
  "Public Verifiable Secret Sharing",
);

/**
 * Command line interface for the pwstore library
 */
export const pwstore_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.pwstore-cli`,
  "Command line interface for the pwstore library",
);

/**
 * Secure password storage
 */
export const pwstore_fast = mkPackage(
  nixRaw`pkgs.haskellPackages.pwstore-fast`,
  "Secure password storage",
);

/**
 * Secure password storage, in pure Haskell
 */
export const pwstore_purehaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.pwstore-purehaskell`,
  "Secure password storage, in pure Haskell",
);

/**
 * Parsimonious XML Shorthand Language--to-XML compiler
 */
export const pxsl_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.pxsl-tools`,
  "Parsimonious XML Shorthand Language--to-XML compiler",
);

/**
 * Types and prettyprinter for the IL of the QBE compiler backend
 */
export const qbe = mkPackage(
  nixRaw`pkgs.haskellPackages.qbe`,
  "Types and prettyprinter for the IL of the QBE compiler backend",
);

/**
 * A library for implementing Quantum Algorithms
 */
export const qchas = mkPackage(
  nixRaw`pkgs.haskellPackages.qchas`,
  "A library for implementing Quantum Algorithms",
);

/**
 * 'Vec' instances for 'qd' types
 */
export const qd_vec = mkPackage(
  nixRaw`pkgs.haskellPackages.qd-vec`,
  "'Vec' instances for 'qd' types",
);

/**
 * Command line tool qhs, SQL queries on CSV and TSV files
 */
export const qhs = mkPackage(
  nixRaw`pkgs.haskellPackages.qhs`,
  "Command line tool qhs, SQL queries on CSV and TSV files",
);

/**
 * Delaunay triangulation, Voronoi diagrams and convex hulls
 */
export const qhull = mkPackage(
  nixRaw`pkgs.haskellPackages.qhull`,
  "Delaunay triangulation, Voronoi diagrams and convex hulls",
);

/**
 * Implementation of interpolated multiline strings
 */
export const qm_interpolated_string = mkPackage(
  nixRaw`pkgs.haskellPackages.qm-interpolated-string`,
  "Implementation of interpolated multiline strings",
);

/**
 * Decrypt files encrypted by QNAP's Hybrid Backup Sync
 */
export const qnap_decrypt = mkPackage(
  nixRaw`pkgs.haskellPackages.qnap-decrypt`,
  "Decrypt files encrypted by QNAP's Hybrid Backup Sync",
);

/**
 * Compile-time checked literal values via QuasiQuoters
 */
export const qq_literals = mkPackage(
  nixRaw`pkgs.haskellPackages.qq-literals`,
  "Compile-time checked literal values via QuasiQuoters",
);

/**
 * Pure Haskell QR encoder library and command line tool
 */
export const qr = mkPackage(
  nixRaw`pkgs.haskellPackages.qr`,
  "Pure Haskell QR encoder library and command line tool",
);

/**
 * Library to generate QR codes from bytestrings and objects and scale image files
 */
export const qr_repa = mkPackage(
  nixRaw`pkgs.haskellPackages.qr-repa`,
  "Library to generate QR codes from bytestrings and objects and scale image files",
);

/**
 * QR code library in pure Haskell
 */
export const qrcode_core = mkPackage(
  nixRaw`pkgs.haskellPackages.qrcode-core`,
  "QR code library in pure Haskell",
);

/**
 * Converts a qrcode-core image to JuicyPixels
 */
export const qrcode_juicypixels = mkPackage(
  nixRaw`pkgs.haskellPackages.qrcode-juicypixels`,
  "Converts a qrcode-core image to JuicyPixels",
);

/**
 * quantity semaphores
 */
export const qsem = mkPackage(
  nixRaw`pkgs.haskellPackages.qsem`,
  "quantity semaphores",
);

/**
 * Qt bindings for Haskell - C++ library
 */
export const qtah_cpp_qt5 = mkPackage(
  nixRaw`pkgs.haskellPackages.qtah-cpp-qt5`,
  "Qt bindings for Haskell - C++ library",
);

/**
 * Example programs for Qtah Qt bindings
 */
export const qtah_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.qtah-examples`,
  "Example programs for Qtah Qt bindings",
);

/**
 * Generator for Qtah Qt bindings
 */
export const qtah_generator = mkPackage(
  nixRaw`pkgs.haskellPackages.qtah-generator`,
  "Generator for Qtah Qt bindings",
);

/**
 * Qt bindings for Haskell
 */
export const qtah_qt5 = mkPackage(
  nixRaw`pkgs.haskellPackages.qtah-qt5`,
  "Qt bindings for Haskell",
);

/**
 * Extremely minimal prelude
 */
export const quaalude = mkPackage(
  nixRaw`pkgs.haskellPackages.quaalude`,
  "Extremely minimal prelude",
);

/**
 * Convenience parser combinators for URI query strings
 */
export const quack = mkPackage(
  nixRaw`pkgs.haskellPackages.quack`,
  "Convenience parser combinators for URI query strings",
);

/**
 * An implementation of quadratic irrationals
 */
export const quadratic_irrational = mkPackage(
  nixRaw`pkgs.haskellPackages.quadratic-irrational`,
  "An implementation of quadratic irrationals",
);

/**
 * Quant finance library in pure Haskell
 */
export const quantfin = mkPackage(
  nixRaw`pkgs.haskellPackages.quantfin`,
  "Quant finance library in pure Haskell",
);

/**
 * Unit conversion and manipulation library
 */
export const quantities = mkPackage(
  nixRaw`pkgs.haskellPackages.quantities`,
  "Unit conversion and manipulation library",
);

/**
 * Library to provide the behaviour similar to quantum states superposition
 */
export const quantizer = mkPackage(
  nixRaw`pkgs.haskellPackages.quantizer`,
  "Library to provide the behaviour similar to quantum states superposition",
);

/**
 * Retrieve, store and manage real quantum random data
 */
export const quantum_random = mkPackage(
  nixRaw`pkgs.haskellPackages.quantum-random`,
  "Retrieve, store and manage real quantum random data",
);

/**
 * Analysis and parsing library for SQL queries
 */
export const queryparser = mkPackage(
  nixRaw`pkgs.haskellPackages.queryparser`,
  "Analysis and parsing library for SQL queries",
);

/**
 * Demo package containing queryparser examples
 */
export const queryparser_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.queryparser-demo`,
  "Demo package containing queryparser examples",
);

/**
 * Parsing for Hive SQL queries
 */
export const queryparser_hive = mkPackage(
  nixRaw`pkgs.haskellPackages.queryparser-hive`,
  "Parsing for Hive SQL queries",
);

/**
 * Parsing for Presto SQL queries
 */
export const queryparser_presto = mkPackage(
  nixRaw`pkgs.haskellPackages.queryparser-presto`,
  "Parsing for Presto SQL queries",
);

/**
 * Parsing for Vertica SQL queries
 */
export const queryparser_vertica = mkPackage(
  nixRaw`pkgs.haskellPackages.queryparser-vertica`,
  "Parsing for Vertica SQL queries",
);

/**
 * Abstraction typeclasses for queue-like things
 */
export const queue = mkPackage(
  nixRaw`pkgs.haskellPackages.queue`,
  "Abstraction typeclasses for queue-like things",
);

/**
 * queue sheet utility
 */
export const queue_sheet = mkPackage(
  nixRaw`pkgs.haskellPackages.queue-sheet`,
  "queue sheet utility",
);

/**
 * A library of queuelike data structures, both functional and stateful
 */
export const queuelike = mkPackage(
  nixRaw`pkgs.haskellPackages.queuelike`,
  "A library of queuelike data structures, both functional and stateful",
);

/**
 * Generator random test data for QuickCheck
 */
export const quick_generator = mkPackage(
  nixRaw`pkgs.haskellPackages.quick-generator`,
  "Generator random test data for QuickCheck",
);

/**
 * quick & easy benchmarking of command-line programs
 */
export const quickbench = mkPackage(
  nixRaw`pkgs.haskellPackages.quickbench`,
  "quick & easy benchmarking of command-line programs",
);

/**
 * Generic typeclasses for generating arbitrary ADTs
 */
export const quickcheck_arbitrary_adt = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-arbitrary-adt`,
  "Generic typeclasses for generating arbitrary ADTs",
);

/**
 * HUnit like assertions for QuickCheck
 */
export const quickcheck_assertions = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-assertions`,
  "HUnit like assertions for QuickCheck",
);

/**
 * QuickCheck common typeclasses
 */
export const quickcheck_classes = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-classes`,
  "QuickCheck common typeclasses",
);

/**
 * QuickCheck common typeclasses from `base`
 */
export const quickcheck_classes_base = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-classes-base`,
  "QuickCheck common typeclasses from `base`",
);

/**
 * arbitrary instances for small enum types
 */
export const quickcheck_enum_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-enum-instances`,
  "arbitrary instances for small enum types",
);

/**
 * Testing group class instances with QuickCheck
 */
export const quickcheck_groups = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-groups`,
  "Testing group class instances with QuickCheck",
);

/**
 * Testing group class instances with QuickCheck
 */
export const quickcheck_groups_0_0_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-groups_0_0_1_0`,
  "Testing group class instances with QuickCheck",
);

/**
 * QuickCheck extension for higher-order properties
 */
export const quickcheck_higherorder = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-higherorder`,
  "QuickCheck extension for higher-order properties",
);

/**
 * Common quickcheck instances
 */
export const quickcheck_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-instances`,
  "Common quickcheck instances",
);

/**
 * Common quickcheck instances
 */
export const quickcheck_instances_0_3_30 = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-instances_0_3_30`,
  "Common quickcheck instances",
);

/**
 * Use HUnit assertions as QuickCheck properties
 */
export const quickcheck_io = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-io`,
  "Use HUnit assertions as QuickCheck properties",
);

/**
 * Library for lockstep-style testing with 'quickcheck-dynamic'
 */
export const quickcheck_lockstep = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-lockstep`,
  "Library for lockstep-style testing with 'quickcheck-dynamic'",
);

/**
 * Testing monoid subclass instances with QuickCheck
 */
export const quickcheck_monoid_subclasses = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-monoid-subclasses`,
  "Testing monoid subclass instances with QuickCheck",
);

/**
 * Testing monoid subclass instances with QuickCheck
 */
export const quickcheck_monoid_subclasses_0_3_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-monoid-subclasses_0_3_0_0`,
  "Testing monoid subclass instances with QuickCheck",
);

/**
 * Automating QuickCheck for polymorphic and overlaoded properties
 */
export const quickcheck_poly = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-poly`,
  "Automating QuickCheck for polymorphic and overlaoded properties",
);

/**
 * QuickCheck properties for standard type classes
 */
export const quickcheck_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-properties`,
  "QuickCheck properties for standard type classes",
);

/**
 * Quasi-unique identifiers for QuickCheck
 */
export const quickcheck_quid = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-quid`,
  "Quasi-unique identifiers for QuickCheck",
);

/**
 * Generate regex-constrained strings for QuickCheck
 */
export const quickcheck_regex = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-regex`,
  "Generate regex-constrained strings for QuickCheck",
);

/**
 * Generate RelaxNG-constrained XML documents for QuickCheck
 */
export const quickcheck_relaxng = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-relaxng`,
  "Generate RelaxNG-constrained XML documents for QuickCheck",
);

/**
 * Automated test tool for QuickCheck
 */
export const quickcheck_script = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-script`,
  "Automated test tool for QuickCheck",
);

/**
 * Test properties and default-mains for QuickCheck
 */
export const quickcheck_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-simple`,
  "Test properties and default-mains for QuickCheck",
);

/**
 * Edge cases and special values for QuickCheck Arbitrary instances
 */
export const quickcheck_special = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-special`,
  "Edge cases and special values for QuickCheck Arbitrary instances",
);

/**
 * Test monadic programs using state machine based models
 */
export const quickcheck_state_machine = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-state-machine`,
  "Test monadic programs using state machine based models",
);

/**
 * Test monadic programs using state machine based models
 */
export const quickcheck_state_machine_distributed = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-state-machine-distributed`,
  "Test monadic programs using state machine based models",
);

/**
 * Helper to build generators with Text.StringRandom
 */
export const quickcheck_string_random = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-string-random`,
  "Helper to build generators with Text.StringRandom",
);

/**
 * Alternative arbitrary instance for Text
 */
export const quickcheck_text = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-text`,
  "Alternative arbitrary instance for Text",
);

/**
 * A GenT monad transformer for QuickCheck library
 */
export const quickcheck_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-transformer`,
  "A GenT monad transformer for QuickCheck library",
);

/**
 * Generator and shrink functions for testing Unicode-related software
 */
export const quickcheck_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-unicode`,
  "Generator and shrink functions for testing Unicode-related software",
);

/**
 * Get counterexamples from QuickCheck as Haskell values
 */
export const quickcheck_with_counterexamples = mkPackage(
  nixRaw`pkgs.haskellPackages.quickcheck-with-counterexamples`,
  "Get counterexamples from QuickCheck as Haskell values",
);

/**
 * QuickLZ compression for ByteStrings
 */
export const quicklz = mkPackage(
  nixRaw`pkgs.haskellPackages.quicklz`,
  "QuickLZ compression for ByteStrings",
);

export const quickselect = mkPackage(
  nixRaw`pkgs.haskellPackages.quickselect`,
  "",
);

/**
 * An interface for describing and executing terminal applications
 */
export const quickterm = mkPackage(
  nixRaw`pkgs.haskellPackages.quickterm`,
  "An interface for describing and executing terminal applications",
);

/**
 * A reflective batch tester for Haskell
 */
export const quicktest = mkPackage(
  nixRaw`pkgs.haskellPackages.quicktest`,
  "A reflective batch tester for Haskell",
);

/**
 * Generic deriving of Read/Show with no record labels
 */
export const quiet = mkPackage(
  nixRaw`pkgs.haskellPackages.quiet`,
  "Generic deriving of Read/Show with no record labels",
);

/**
 * Meta-package for Quipper
 */
export const quipper = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper`,
  "Meta-package for Quipper",
);

/**
 * A set of algorithms implemented in Quipper
 */
export const quipper_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-algorithms`,
  "A set of algorithms implemented in Quipper",
);

/**
 * Meta-package for Quipper
 */
export const quipper_all = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-all`,
  "Meta-package for Quipper",
);

/**
 * Some functions to aid in the creation of Cabal packages for Quipper
 */
export const quipper_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-cabal`,
  "Some functions to aid in the creation of Cabal packages for Quipper",
);

/**
 * Miscellaneous code snippets that illustrate various Quipper features
 */
export const quipper_demos = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-demos`,
  "Miscellaneous code snippets that illustrate various Quipper features",
);

/**
 * Quipper, an embedded functional programming language for quantum computation
 */
export const quipper_language = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-language`,
  "Quipper, an embedded functional programming language for quantum computation",
);

/**
 * The standard libraries for Quipper
 */
export const quipper_libraries = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-libraries`,
  "The standard libraries for Quipper",
);

/**
 * An embedded, scalable functional programming language for quantum computing
 */
export const quipper_rendering = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-rendering`,
  "An embedded, scalable functional programming language for quantum computing",
);

/**
 * Miscellaneous stand-alone tools for Quipper
 */
export const quipper_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-tools`,
  "Miscellaneous stand-alone tools for Quipper",
);

/**
 * Utility libraries for Quipper
 */
export const quipper_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.quipper-utils`,
  "Utility libraries for Quipper",
);

/**
 * Binary serialisation support for Quivers
 */
export const quiver_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-binary`,
  "Binary serialisation support for Quivers",
);

/**
 * Quiver combinators for bytestring streaming
 */
export const quiver_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-bytestring`,
  "Quiver combinators for bytestring streaming",
);

/**
 * Quiver combinators for cellular data processing
 */
export const quiver_cell = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-cell`,
  "Quiver combinators for cellular data processing",
);

/**
 * Quiver combinators for cellular CSV data processing
 */
export const quiver_csv = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-csv`,
  "Quiver combinators for cellular CSV data processing",
);

/**
 * Bridge between Quiver and Iteratee paradigms
 */
export const quiver_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-enumerator`,
  "Bridge between Quiver and Iteratee paradigms",
);

/**
 * Group and chunk values within a Quiver
 */
export const quiver_groups = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-groups`,
  "Group and chunk values within a Quiver",
);

/**
 * Adapter to stream over HTTP(s) with quiver
 */
export const quiver_http = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-http`,
  "Adapter to stream over HTTP(s) with quiver",
);

/**
 * Extra instances for Quiver
 */
export const quiver_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-instances`,
  "Extra instances for Quiver",
);

/**
 * Interleave values from multiple Quivers
 */
export const quiver_interleave = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-interleave`,
  "Interleave values from multiple Quivers",
);

/**
 * Sort the values in a quiver
 */
export const quiver_sort = mkPackage(
  nixRaw`pkgs.haskellPackages.quiver-sort`,
  "Sort the values in a quiver",
);

/**
 * Divide without division
 */
export const quote_quot = mkPackage(
  nixRaw`pkgs.haskellPackages.quote-quot`,
  "Divide without division",
);

/**
 * Monad transformer for Quote from template-haskell
 */
export const quotet = mkPackage(
  nixRaw`pkgs.haskellPackages.quotet`,
  "Monad transformer for Quote from template-haskell",
);

/**
 * Command line binary for working with the Qux language
 */
export const qux = mkPackage(
  nixRaw`pkgs.haskellPackages.qux`,
  "Command line binary for working with the Qux language",
);

export const r3x_haskell_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.r3x-haskell-sdk`,
  "",
);

/**
 * Can be used to calculate the durations of the approximations of the Ukrainian phonemes
 */
export const r_glpk_phonetic_languages_ukrainian_durations = mkPackage(
  nixRaw`pkgs.haskellPackages.r-glpk-phonetic-languages-ukrainian-durations`,
  "Can be used to calculate the durations of the approximations of the Ukrainian phonemes",
);

/**
 * Fast and type safe cryptography
 */
export const raaz = mkPackage(
  nixRaw`pkgs.haskellPackages.raaz`,
  "Fast and type safe cryptography",
);

/**
 * A library and program to create QIF files from Rabobank CSV exports
 */
export const rabocsv2qif = mkPackage(
  nixRaw`pkgs.haskellPackages.rabocsv2qif`,
  "A library and program to create QIF files from Rabobank CSV exports",
);

/**
 * Remote Authentication Dial In User Service (RADIUS)
 */
export const radius = mkPackage(
  nixRaw`pkgs.haskellPackages.radius`,
  "Remote Authentication Dial In User Service (RADIUS)",
);

/**
 * Radix tree data structive over short byte-strings
 */
export const radix_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.radix-tree`,
  "Radix tree data structive over short byte-strings",
);

export const radixtree = mkPackage(
  nixRaw`pkgs.haskellPackages.radixtree`,
  "",
);

/**
 * Compiler and editor for the esolang rail
 */
export const rail_compiler_editor = mkPackage(
  nixRaw`pkgs.haskellPackages.rail-compiler-editor`,
  "Compiler and editor for the esolang rail",
);

/**
 * Decrypt Ruby on Rails sessions in Haskell
 */
export const rails_session = mkPackage(
  nixRaw`pkgs.haskellPackages.rails-session`,
  "Decrypt Ruby on Rails sessions in Haskell",
);

/**
 * Print text to terminal with colors and effects
 */
export const rainbow = mkPackage(
  nixRaw`pkgs.haskellPackages.rainbow`,
  "Print text to terminal with colors and effects",
);

/**
 * Tests and QuickCheck generators to accompany rainbow
 */
export const rainbow_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.rainbow-tests`,
  "Tests and QuickCheck generators to accompany rainbow",
);

/**
 * Two-dimensional box pretty printing, with colors
 */
export const rainbox = mkPackage(
  nixRaw`pkgs.haskellPackages.rainbox`,
  "Two-dimensional box pretty printing, with colors",
);

/**
 * Rapid Automatic Keyword Extraction (RAKE)
 */
export const rake = mkPackage(
  nixRaw`pkgs.haskellPackages.rake`,
  "Rapid Automatic Keyword Extraction (RAKE)",
);

/**
 * distributed-process node
 */
export const raketka = mkPackage(
  nixRaw`pkgs.haskellPackages.raketka`,
  "distributed-process node",
);

/**
 * Random access lists
 */
export const ral = mkPackage(
  nixRaw`pkgs.haskellPackages.ral`,
  "Random access lists",
);

/**
 * Length-indexed random access lists: lens utilities
 */
export const ral_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.ral-lens`,
  "Length-indexed random access lists: lens utilities",
);

/**
 * Length-indexed random access lists: optics utilities
 */
export const ral_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.ral-optics`,
  "Length-indexed random access lists: optics utilities",
);

/**
 * '$' in reverse
 */
export const rallod = mkPackage(
  nixRaw`pkgs.haskellPackages.rallod`,
  "'$' in reverse",
);

/**
 * Determine how intervals relate to each other
 */
export const rampart = mkPackage(
  nixRaw`pkgs.haskellPackages.rampart`,
  "Determine how intervals relate to each other",
);

/**
 * Elm signal system for Haskell
 */
export const ramus = mkPackage(
  nixRaw`pkgs.haskellPackages.ramus`,
  "Elm signal system for Haskell",
);

/**
 * Program for picking a random file
 */
export const randfile = mkPackage(
  nixRaw`pkgs.haskellPackages.randfile`,
  "Program for picking a random file",
);

/**
 * Pseudo-random number generation
 */
export const random = mkPackage(
  nixRaw`pkgs.haskellPackages.random`,
  "Pseudo-random number generation",
);

/**
 * Random file access methods, supporting application-level page cache
 */
export const random_access_file = mkPackage(
  nixRaw`pkgs.haskellPackages.random-access-file`,
  "Random file access methods, supporting application-level page cache",
);

/**
 * Efficient generation of random bytestrings
 */
export const random_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.random-bytestring`,
  "Efficient generation of random bytestrings",
);

/**
 * Class of random value generation
 */
export const random_class = mkPackage(
  nixRaw`pkgs.haskellPackages.random-class`,
  "Class of random value generation",
);

/**
 * A simple random generator library for effin
 */
export const random_effin = mkPackage(
  nixRaw`pkgs.haskellPackages.random-effin`,
  "A simple random generator library for effin",
);

/**
 * Additional functions for random values
 */
export const random_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.random-extras`,
  "Additional functions for random values",
);

/**
 * Random number generation
 */
export const random_fu = mkPackage(
  nixRaw`pkgs.haskellPackages.random-fu`,
  "Random number generation",
);

/**
 * Multivariate distributions for random-fu
 */
export const random_fu_multivariate = mkPackage(
  nixRaw`pkgs.haskellPackages.random-fu-multivariate`,
  "Multivariate distributions for random-fu",
);

/**
 * Random variate generation from hypergeometric distributions
 */
export const random_hypergeometric = mkPackage(
  nixRaw`pkgs.haskellPackages.random-hypergeometric`,
  "Random variate generation from hypergeometric distributions",
);

/**
 * Expose Random and Arbitrary instances
 */
export const random_names = mkPackage(
  nixRaw`pkgs.haskellPackages.random-names`,
  "Expose Random and Arbitrary instances",
);

/**
 * Random shuffle implementation
 */
export const random_shuffle = mkPackage(
  nixRaw`pkgs.haskellPackages.random-shuffle`,
  "Random shuffle implementation",
);

/**
 * Generate random strings with specific qualities
 */
export const random_strings = mkPackage(
  nixRaw`pkgs.haskellPackages.random-strings`,
  "Generate random strings with specific qualities",
);

/**
 * Create random trees
 */
export const random_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.random-tree`,
  "Create random trees",
);

/**
 * "Uniform RNG => Non-Uniform RNGs"
 */
export const random_variates = mkPackage(
  nixRaw`pkgs.haskellPackages.random-variates`,
  "\"Uniform RNG => Non-Uniform RNGs\"",
);

/**
 * A fast, SMP parallel random data generator
 */
export const randomgen = mkPackage(
  nixRaw`pkgs.haskellPackages.randomgen`,
  "A fast, SMP parallel random data generator",
);

/**
 * Data structures and support functions for working with random processes
 */
export const randproc = mkPackage(
  nixRaw`pkgs.haskellPackages.randproc`,
  "Data structures and support functions for working with random processes",
);

/**
 * Set the background of your root window to a random colour
 */
export const randsolid = mkPackage(
  nixRaw`pkgs.haskellPackages.randsolid`,
  "Set the background of your root window to a random colour",
);

/**
 * An efficient and versatile range library
 */
export const range = mkPackage(
  nixRaw`pkgs.haskellPackages.range`,
  "An efficient and versatile range library",
);

/**
 * Memory efficient sets with ranges of elements
 */
export const range_set_list = mkPackage(
  nixRaw`pkgs.haskellPackages.range-set-list`,
  "Memory efficient sets with ranges of elements",
);

/**
 * A Range type with vector-space instances
 */
export const range_space = mkPackage(
  nixRaw`pkgs.haskellPackages.range-space`,
  "A Range type with vector-space instances",
);

/**
 * The list like structure whose length or range of length can be specified
 */
export const ranged_list = mkPackage(
  nixRaw`pkgs.haskellPackages.ranged-list`,
  "The list like structure whose length or range of length can be specified",
);

/**
 * Ranges and various functions on them
 */
export const ranges = mkPackage(
  nixRaw`pkgs.haskellPackages.ranges`,
  "Ranges and various functions on them",
);

/**
 * Efficient sets for semi-contiguous data
 */
export const rangeset = mkPackage(
  nixRaw`pkgs.haskellPackages.rangeset`,
  "Efficient sets for semi-contiguous data",
);

/**
 * standard type constructor class hierarchy, only with methods of rank 2 types
 */
export const rank2classes = mkPackage(
  nixRaw`pkgs.haskellPackages.rank2classes`,
  "standard type constructor class hierarchy, only with methods of rank 2 types",
);

/**
 * A modular text editor
 */
export const rasa = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa`,
  "A modular text editor",
);

/**
 * Example user config for Rasa
 */
export const rasa_example_config = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-example-config`,
  "Example user config for Rasa",
);

/**
 * Rasa Ext for useful buffer utilities
 */
export const rasa_ext_bufs = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-bufs`,
  "Rasa Ext for useful buffer utilities",
);

/**
 * Rasa Ext for running commands
 */
export const rasa_ext_cmd = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-cmd`,
  "Rasa Ext for running commands",
);

/**
 * Rasa Ext adding cursor(s)
 */
export const rasa_ext_cursors = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-cursors`,
  "Rasa Ext adding cursor(s)",
);

/**
 * Rasa Ext for filesystem actions
 */
export const rasa_ext_files = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-files`,
  "Rasa Ext for filesystem actions",
);

/**
 * Rasa Ext for logging state/actions
 */
export const rasa_ext_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-logger`,
  "Rasa Ext for logging state/actions",
);

/**
 * Rasa extension for rendering to terminal with vty
 */
export const rasa_ext_slate = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-slate`,
  "Rasa extension for rendering to terminal with vty",
);

/**
 * Rasa Ext for populating status-bar
 */
export const rasa_ext_status_bar = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-status-bar`,
  "Rasa Ext for populating status-bar",
);

/**
 * Rasa Ext managing rendering styles
 */
export const rasa_ext_style = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-style`,
  "Rasa Ext managing rendering styles",
);

/**
 * Rasa Ext managing rendering views
 */
export const rasa_ext_views = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-views`,
  "Rasa Ext managing rendering views",
);

/**
 * Rasa Ext for vim bindings
 */
export const rasa_ext_vim = mkPackage(
  nixRaw`pkgs.haskellPackages.rasa-ext-vim`,
  "Rasa Ext for vim bindings",
);

/**
 * A command-line client for Reddit
 */
export const rascal = mkPackage(
  nixRaw`pkgs.haskellPackages.rascal`,
  "A command-line client for Reddit",
);

/**
 * SVG renderer based on Rasterific
 */
export const rasterific_svg = mkPackage(
  nixRaw`pkgs.haskellPackages.rasterific-svg`,
  "SVG renderer based on Rasterific",
);

/**
 * A basic library for rate-limiting IO actions
 */
export const rate_limit = mkPackage(
  nixRaw`pkgs.haskellPackages.rate-limit`,
  "A basic library for rate-limiting IO actions",
);

/**
 * Notify Honeybadger about exceptions
 */
export const ratel = mkPackage(
  nixRaw`pkgs.haskellPackages.ratel`,
  "Notify Honeybadger about exceptions",
);

/**
 * Notify Honeybadger about exceptions via a WAI middleware
 */
export const ratel_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.ratel-wai`,
  "Notify Honeybadger about exceptions via a WAI middleware",
);

/**
 * In-memory rate limiter
 */
export const ratelimiter = mkPackage(
  nixRaw`pkgs.haskellPackages.ratelimiter`,
  "In-memory rate limiter",
);

/**
 * Implementations of several rating systems: Elo, Glicko, etc
 */
export const rating_systems = mkPackage(
  nixRaw`pkgs.haskellPackages.rating-systems`,
  "Implementations of several rating systems: Elo, Glicko, etc",
);

/**
 * Fast specialisation of Data.Ratio for Int.
 */
export const ratio_int = mkPackage(
  nixRaw`pkgs.haskellPackages.ratio-int`,
  "Fast specialisation of Data.Ratio for Int.",
);

/**
 * Haskell client for Sentry logging service
 */
export const raven_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.raven-haskell`,
  "Haskell client for Sentry logging service",
);

/**
 * Resource-Aware Feldspar
 */
export const raw_feldspar = mkPackage(
  nixRaw`pkgs.haskellPackages.raw-feldspar`,
  "Resource-Aware Feldspar",
);

/**
 * Raw string literals for Haskell
 */
export const raw_strings_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.raw-strings-qq`,
  "Raw string literals for Haskell",
);

/**
 * Use RawFilePath instead of FilePath
 */
export const rawfilepath = mkPackage(
  nixRaw`pkgs.haskellPackages.rawfilepath`,
  "Use RawFilePath instead of FilePath",
);

/**
 * Use RawFilePath instead of FilePath
 */
export const rawfilepath_1_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.rawfilepath_1_1_0`,
  "Use RawFilePath instead of FilePath",
);

/**
 * Anonymous extensible records
 */
export const rawr = mkPackage(
  nixRaw`pkgs.haskellPackages.rawr`,
  "Anonymous extensible records",
);

/**
 * Simple raw string quotation and dictionary interpolation
 */
export const rawstring_qm = mkPackage(
  nixRaw`pkgs.haskellPackages.rawstring-qm`,
  "Simple raw string quotation and dictionary interpolation",
);

/**
 * Common text/parsing tools for Razom language packages
 */
export const razom_text_util = mkPackage(
  nixRaw`pkgs.haskellPackages.razom-text-util`,
  "Common text/parsing tools for Razom language packages",
);

/**
 * Mask nucleotide (EST) sequences in Fasta format
 */
export const rbr = mkPackage(
  nixRaw`pkgs.haskellPackages.rbr`,
  "Mask nucleotide (EST) sequences in Fasta format",
);

/**
 * Reservoir Computing, fast RNNs
 */
export const rc = mkPackage(
  nixRaw`pkgs.haskellPackages.rc`,
  "Reservoir Computing, fast RNNs",
);

/**
 * Read-Copy-Update for Haskell
 */
export const rcu = mkPackage(
  nixRaw`pkgs.haskellPackages.rcu`,
  "Read-Copy-Update for Haskell",
);

/**
 * Representation and Incremental Processing of RDF Data
 */
export const rdf = mkPackage(
  nixRaw`pkgs.haskellPackages.rdf`,
  "Representation and Incremental Processing of RDF Data",
);

/**
 * A Haskell wrapper for Rdio's API
 */
export const rdioh = mkPackage(
  nixRaw`pkgs.haskellPackages.rdioh`,
  "A Haskell wrapper for Rdio's API",
);

/**
 * Binding for the rdtsc machine instruction
 */
export const rdtsc = mkPackage(
  nixRaw`pkgs.haskellPackages.rdtsc`,
  "Binding for the rdtsc machine instruction",
);

/**
 * Binding to sources of high-efficiency, high-precision, monotonically increasing relative time
 */
export const rdtsc_enolan = mkPackage(
  nixRaw`pkgs.haskellPackages.rdtsc-enolan`,
  "Binding to sources of high-efficiency, high-precision, monotonically increasing relative time",
);

/**
 * Bindings to the re2 regular expression library
 */
export const re2 = mkPackage(
  nixRaw`pkgs.haskellPackages.re2`,
  "Bindings to the re2 regular expression library",
);

/**
 * Create React components in Haskell
 */
export const react = mkPackage(
  nixRaw`pkgs.haskellPackages.react`,
  "Create React components in Haskell",
);

/**
 * Allow react-flux stores to send requests to a servant server
 */
export const react_flux_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.react-flux-servant`,
  "Allow react-flux stores to send requests to a servant server",
);

/**
 * Push-pull functional reactive programming
 */
export const reactive = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive`,
  "Push-pull functional reactive programming",
);

/**
 * Programmatically edit MIDI events via ALSA and reactive-banana
 */
export const reactive_balsa = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-balsa`,
  "Programmatically edit MIDI events via ALSA and reactive-banana",
);

/**
 * Library for functional reactive programming (FRP)
 */
export const reactive_banana = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-banana`,
  "Library for functional reactive programming (FRP)",
);

/**
 * Extend reactive-banana to multiple events per time point
 */
export const reactive_banana_bunch = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-banana-bunch`,
  "Extend reactive-banana to multiple events per time point",
);

/**
 * Reactive Banana bindings for SDL
 */
export const reactive_banana_sdl = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-banana-sdl`,
  "Reactive Banana bindings for SDL",
);

/**
 * Examples for the reactive-banana library, using wxHaskell
 */
export const reactive_banana_wx = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-banana-wx`,
  "Examples for the reactive-banana library, using wxHaskell",
);

/**
 * Connect Reactive and FieldTrip
 */
export const reactive_fieldtrip = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-fieldtrip`,
  "Connect Reactive and FieldTrip",
);

/**
 * Connects Reactive and GLUT
 */
export const reactive_glut = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-glut`,
  "Connects Reactive and GLUT",
);

/**
 * minimal fork of io-reactive
 */
export const reactive_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-haskell`,
  "minimal fork of io-reactive",
);

/**
 * IO-oriented FRP library
 */
export const reactive_io = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-io`,
  "IO-oriented FRP library",
);

/**
 * Process MIDI events via reactive-banana and JACK
 */
export const reactive_jack = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-jack`,
  "Process MIDI events via reactive-banana and JACK",
);

/**
 * Process MIDI events via reactive-banana
 */
export const reactive_midyim = mkPackage(
  nixRaw`pkgs.haskellPackages.reactive-midyim`,
  "Process MIDI events via reactive-banana",
);

/**
 * An alternate implementation of push-pull FRP
 */
export const reactivity = mkPackage(
  nixRaw`pkgs.haskellPackages.reactivity`,
  "An alternate implementation of push-pull FRP",
);

/**
 * Reactor - task parallel reactive programming
 */
export const reactor = mkPackage(
  nixRaw`pkgs.haskellPackages.reactor`,
  "Reactor - task parallel reactive programming",
);

/**
 * Opens a temporary file on the system's EDITOR and returns the resulting edits
 */
export const read_editor = mkPackage(
  nixRaw`pkgs.haskellPackages.read-editor`,
  "Opens a temporary file on the system's EDITOR and returns the resulting edits",
);

/**
 * Functions for safely reading environment variables
 */
export const read_env_var = mkPackage(
  nixRaw`pkgs.haskellPackages.read-env-var`,
  "Functions for safely reading environment variables",
);

/**
 * Reading from Text and ByteString
 */
export const readable = mkPackage(
  nixRaw`pkgs.haskellPackages.readable`,
  "Reading from Text and ByteString",
);

/**
 * Lightweight CSV parser/emitter based on ReadP
 */
export const readcsv = mkPackage(
  nixRaw`pkgs.haskellPackages.readcsv`,
  "Lightweight CSV parser/emitter based on ReadP",
);

/**
 * An interface to the GNU readline library
 */
export const readline = mkPackage(
  nixRaw`pkgs.haskellPackages.readline`,
  "An interface to the GNU readline library",
);

/**
 * Readline effect for in-other-words
 */
export const readline_in_other_words = mkPackage(
  nixRaw`pkgs.haskellPackages.readline-in-other-words`,
  "Readline effect for in-other-words",
);

/**
 * Read and pretty print Python bytecode (.pyc) files.
 */
export const readpyc = mkPackage(
  nixRaw`pkgs.haskellPackages.readpyc`,
  "Read and pretty print Python bytecode (.pyc) files.",
);

/**
 * Tiny library to calculate date considering when your day realy ends
 */
export const real_day_end = mkPackage(
  nixRaw`pkgs.haskellPackages.real-day-end`,
  "Tiny library to calculate date considering when your day realy ends",
);

/**
 * The Real World Haskell Book
 */
export const realworldhaskell = mkPackage(
  nixRaw`pkgs.haskellPackages.realworldhaskell`,
  "The Real World Haskell Book",
);

/**
 * Animation library based on SVGs
 */
export const reanimate = mkPackage(
  nixRaw`pkgs.haskellPackages.reanimate`,
  "Animation library based on SVGs",
);

/**
 * Just size Operational Monad implementation
 */
export const reasonable_operational = mkPackage(
  nixRaw`pkgs.haskellPackages.reasonable-operational`,
  "Just size Operational Monad implementation",
);

/**
 * A more progressive alternative to the "base" package
 */
export const rebase = mkPackage(
  nixRaw`pkgs.haskellPackages.rebase`,
  "A more progressive alternative to the \"base\" package",
);

/**
 * A more progressive alternative to the "base" package
 */
export const rebase_1_20 = mkPackage(
  nixRaw`pkgs.haskellPackages.rebase_1_20`,
  "A more progressive alternative to the \"base\" package",
);

/**
 * A library to facilitate rebinding of Haskell syntax
 */
export const rebindable = mkPackage(
  nixRaw`pkgs.haskellPackages.rebindable`,
  "A library to facilitate rebinding of Haskell syntax",
);

/**
 * Recursively defined values
 */
export const rec_def = mkPackage(
  nixRaw`pkgs.haskellPackages.rec-def`,
  "Recursively defined values",
);

/**
 * Functions for using the reCAPTCHA service in web applications
 */
export const recaptcha = mkPackage(
  nixRaw`pkgs.haskellPackages.recaptcha`,
  "Functions for using the reCAPTCHA service in web applications",
);

/**
 * Recommendations using alternating least squares algorithm
 */
export const recommender_als = mkPackage(
  nixRaw`pkgs.haskellPackages.recommender-als`,
  "Recommendations using alternating least squares algorithm",
);

/**
 * Instances of "aeson" classes for the "record" types
 */
export const record_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.record-aeson`,
  "Instances of \"aeson\" classes for the \"record\" types",
);

/**
 * Preprocessor to allow record.field syntax
 */
export const record_dot_preprocessor = mkPackage(
  nixRaw`pkgs.haskellPackages.record-dot-preprocessor`,
  "Preprocessor to allow record.field syntax",
);

/**
 * Utilities for working with OpenGL's GLSL shading language and Nikita Volkov's "Record"s
 */
export const record_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.record-gl`,
  "Utilities for working with OpenGL's GLSL shading language and Nikita Volkov's \"Record\"s",
);

/**
 * A version of GHC.Records as available in future GHCs.
 */
export const record_hasfield = mkPackage(
  nixRaw`pkgs.haskellPackages.record-hasfield`,
  "A version of GHC.Records as available in future GHCs.",
);

export const record_impl = mkPackage(
  nixRaw`pkgs.haskellPackages.record-impl`,
  "",
);

/**
 * polymorphic record operations
 */
export const record_operations = mkPackage(
  nixRaw`pkgs.haskellPackages.record-operations`,
  "polymorphic record operations",
);

/**
 * Compiler preprocessor introducing a syntactic extension for anonymous records
 */
export const record_preprocessor = mkPackage(
  nixRaw`pkgs.haskellPackages.record-preprocessor`,
  "Compiler preprocessor introducing a syntactic extension for anonymous records",
);

/**
 * A library for parsing and processing the Haskell syntax sprinkled with anonymous records
 */
export const record_syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.record-syntax`,
  "A library for parsing and processing the Haskell syntax sprinkled with anonymous records",
);

/**
 * Template Haskell declarations for the records package
 */
export const records_th = mkPackage(
  nixRaw`pkgs.haskellPackages.records-th`,
  "Template Haskell declarations for the records package",
);

/**
 * Recover run-time type information from the GHC heap
 */
export const recover_rtti = mkPackage(
  nixRaw`pkgs.haskellPackages.recover-rtti`,
  "Recover run-time type information from the GHC heap",
);

/**
 * A recursion schemes library for Haskell
 */
export const recursion = mkPackage(
  nixRaw`pkgs.haskellPackages.recursion`,
  "A recursion schemes library for Haskell",
);

/**
 * Representing common recursion patterns as higher-order functions
 */
export const recursion_schemes = mkPackage(
  nixRaw`pkgs.haskellPackages.recursion-schemes`,
  "Representing common recursion patterns as higher-order functions",
);

/**
 * Amateur addenda to recursion-schemes
 */
export const recursion_schemes_ext = mkPackage(
  nixRaw`pkgs.haskellPackages.recursion-schemes-ext`,
  "Amateur addenda to recursion-schemes",
);

/**
 * Recursion schemes over indexed Functors
 */
export const recursion_schemes_ix = mkPackage(
  nixRaw`pkgs.haskellPackages.recursion-schemes-ix`,
  "Recursion schemes over indexed Functors",
);

/**
 * Count lines in files and display them hierarchically
 */
export const recursive_line_count = mkPackage(
  nixRaw`pkgs.haskellPackages.recursive-line-count`,
  "Count lines in files and display them hierarchically",
);

/**
 * Zippers over recursive data structures
 */
export const recursive_zipper = mkPackage(
  nixRaw`pkgs.haskellPackages.recursive-zipper`,
  "Zippers over recursive data structures",
);

/**
 * Efficient network recv
 */
export const recv = mkPackage(
  nixRaw`pkgs.haskellPackages.recv`,
  "Efficient network recv",
);

/**
 * Monadic HTTP request handlers combinators to build a standalone web apps
 */
export const redHandlers = mkPackage(
  nixRaw`pkgs.haskellPackages.redHandlers`,
  "Monadic HTTP request handlers combinators to build a standalone web apps",
);

/**
 * Red Black Trees implemented in Haskell
 */
export const red_black_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.red-black-tree`,
  "Red Black Trees implemented in Haskell",
);

/**
 * hide secret text on the terminal
 */
export const redact = mkPackage(
  nixRaw`pkgs.haskellPackages.redact`,
  "hide secret text on the terminal",
);

/**
 * Library for interfacing with Reddit's API
 */
export const reddit = mkPackage(
  nixRaw`pkgs.haskellPackages.reddit`,
  "Library for interfacing with Reddit's API",
);

/**
 * Library for getting links from a sub-reddit
 */
export const reddit_scrape = mkPackage(
  nixRaw`pkgs.haskellPackages.reddit-scrape`,
  "Library for getting links from a sub-reddit",
);

/**
 * Package for dependency confusion
 */
export const redesigned_carnival = mkPackage(
  nixRaw`pkgs.haskellPackages.redesigned-carnival`,
  "Package for dependency confusion",
);

/**
 * A driver for Redis key-value database
 */
export const redis = mkPackage(
  nixRaw`pkgs.haskellPackages.redis`,
  "A driver for Redis key-value database",
);

/**
 * Specify valid redis globs
 */
export const redis_glob = mkPackage(
  nixRaw`pkgs.haskellPackages.redis-glob`,
  "Specify valid redis globs",
);

/**
 * Yet another redis client
 */
export const redis_io = mkPackage(
  nixRaw`pkgs.haskellPackages.redis-io`,
  "Yet another redis client",
);

/**
 * Simple priority job queue backed by Redis
 */
export const redis_job_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.redis-job-queue`,
  "Simple priority job queue backed by Redis",
);

/**
 * REdis Serialization Protocol (RESP) implementation
 */
export const redis_resp = mkPackage(
  nixRaw`pkgs.haskellPackages.redis-resp`,
  "REdis Serialization Protocol (RESP) implementation",
);

/**
 * Typed, schema-based, composable Redis library
 */
export const redis_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.redis-schema`,
  "Typed, schema-based, composable Redis library",
);

/**
 * Combine redis caching and haxl
 */
export const rediscaching_haxl = mkPackage(
  nixRaw`pkgs.haskellPackages.rediscaching-haxl`,
  "Combine redis caching and haxl",
);

/**
 * Redland RDF library bindings
 */
export const redland = mkPackage(
  nixRaw`pkgs.haskellPackages.redland`,
  "Redland RDF library bindings",
);

/**
 * software build system, make replacement, implementation of djb's redo
 */
export const redo = mkPackage(
  nixRaw`pkgs.haskellPackages.redo`,
  "software build system, make replacement, implementation of djb's redo",
);

/**
 * Simplify a set of equations by removing redundancies
 */
export const reduce_equations = mkPackage(
  nixRaw`pkgs.haskellPackages.reduce-equations`,
  "Simplify a set of equations by removing redundancies",
);

/**
 * Semigroups, specialized containers and a general map/reduce framework
 */
export const reducers = mkPackage(
  nixRaw`pkgs.haskellPackages.reducers`,
  "Semigroups, specialized containers and a general map/reduce framework",
);

export const reexport_crypto_random = mkPackage(
  nixRaw`pkgs.haskellPackages.reexport-crypto-random`,
  "",
);

/**
 * A type class for monads with references using functional dependencies
 */
export const ref_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.ref-fd`,
  "A type class for monads with references using functional dependencies",
);

/**
 * A type class for monads with references using type families
 */
export const ref_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.ref-tf`,
  "A type class for monads with references using type families",
);

/**
 * Specify refactorings to perform with apply-refact
 */
export const refact = mkPackage(
  nixRaw`pkgs.haskellPackages.refact`,
  "Specify refactorings to perform with apply-refact",
);

/**
 * A class for references in Haskell
 */
export const reference = mkPackage(
  nixRaw`pkgs.haskellPackages.reference`,
  "A class for references in Haskell",
);

/**
 * A command-line tool for pasting to https://www.refheap.com
 */
export const refh = mkPackage(
  nixRaw`pkgs.haskellPackages.refh`,
  "A command-line tool for pasting to https://www.refheap.com",
);

/**
 * Refinement types with static and runtime checking
 */
export const refined = mkPackage(
  nixRaw`pkgs.haskellPackages.refined`,
  "Refinement types with static and runtime checking",
);

/**
 * Refinement types with static and runtime checking (+ Refined1)
 */
export const refined1 = mkPackage(
  nixRaw`pkgs.haskellPackages.refined1`,
  "Refinement types with static and runtime checking (+ Refined1)",
);

/**
 * Toolkit for building proof automation systems
 */
export const refinery = mkPackage(
  nixRaw`pkgs.haskellPackages.refinery`,
  "Toolkit for building proof automation systems",
);

/**
 * Reifies arbitrary terms into types that can be reflected back into terms
 */
export const reflection = mkPackage(
  nixRaw`pkgs.haskellPackages.reflection`,
  "Reifies arbitrary terms into types that can be reflected back into terms",
);

/**
 * Efficient free and operational monads
 */
export const reflection_without_remorse = mkPackage(
  nixRaw`pkgs.haskellPackages.reflection-without-remorse`,
  "Efficient free and operational monads",
);

/**
 * Higher-order Functional Reactive Programming
 */
export const reflex = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex`,
  "Higher-order Functional Reactive Programming",
);

/**
 * Continuous animations support for reflex
 */
export const reflex_animation = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-animation`,
  "Continuous animations support for reflex",
);

/**
 * Reflex interface to `wai`
 */
export const reflex_backend_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-backend-wai`,
  "Reflex interface to `wai`",
);

/**
 * Functional Reactive Web Apps with Reflex
 */
export const reflex_dom = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom`,
  "Functional Reactive Web Apps with Reflex",
);

/**
 * Functional Reactive Web Apps with Reflex
 */
export const reflex_dom_0_6_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom_0_6_3_1`,
  "Functional Reactive Web Apps with Reflex",
);

/**
 * Use colonnade with reflex-dom
 */
export const reflex_dom_colonnade = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom-colonnade`,
  "Use colonnade with reflex-dom",
);

/**
 * Functional Reactive Web Apps with Reflex
 */
export const reflex_dom_core = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom-core`,
  "Functional Reactive Web Apps with Reflex",
);

/**
 * Compatible highlevel Wigdets for some Ionic Input Components
 */
export const reflex_dom_ionic = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom-ionic`,
  "Compatible highlevel Wigdets for some Ionic Input Components",
);

/**
 * reflex-dom-th transpiles HTML templates to haskell code for reflex-dom
 */
export const reflex_dom_th = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dom-th`,
  "reflex-dom-th transpiles HTML templates to haskell code for reflex-dom",
);

/**
 * various dynamic containers for Reflex
 */
export const reflex_dynamic_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-dynamic-containers`,
  "various dynamic containers for Reflex",
);

/**
 * Reflex FRP interface for watching files
 */
export const reflex_fsnotify = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-fsnotify`,
  "Reflex FRP interface for watching files",
);

/**
 * Interact with a GADT API in your reflex-dom application
 */
export const reflex_gadt_api = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-gadt-api`,
  "Interact with a GADT API in your reflex-dom application",
);

/**
 * A GHCi widget library for use in reflex applications
 */
export const reflex_ghci = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-ghci`,
  "A GHCi widget library for use in reflex applications",
);

/**
 * A simple scene-graph using reflex and gloss
 */
export const reflex_gloss_scene = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-gloss-scene`,
  "A simple scene-graph using reflex and gloss",
);

/**
 * Reflex bindings for libtelnet
 */
export const reflex_libtelnet = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-libtelnet`,
  "Reflex bindings for libtelnet",
);

/**
 * Localization library for reflex
 */
export const reflex_localize = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-localize`,
  "Localization library for reflex",
);

/**
 * Helper widgets for reflex-localize
 */
export const reflex_localize_dom = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-localize-dom`,
  "Helper widgets for reflex-localize",
);

/**
 * Utilities to split reflex app to authorized and not authorized contexts
 */
export const reflex_monad_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-monad-auth`,
  "Utilities to split reflex app to authorized and not authorized contexts",
);

export const reflex_potatoes = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-potatoes`,
  "",
);

/**
 * Reflex FRP interface for running system processes
 */
export const reflex_process = mkPackage(
  nixRaw`pkgs.haskellPackages.reflex-process`,
  "Reflex FRP interface for running system processes",
);

/**
 * reform is a type-safe HTML form generation and validation library
 */
export const reform = mkPackage(
  nixRaw`pkgs.haskellPackages.reform`,
  "reform is a type-safe HTML form generation and validation library",
);

/**
 * Add support for using blaze-html with Reform
 */
export const reform_blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.reform-blaze`,
  "Add support for using blaze-html with Reform",
);

/**
 * Happstack support for reform
 */
export const reform_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.reform-happstack`,
  "Happstack support for reform",
);

/**
 * See README for more info
 */
export const refractor = mkPackage(
  nixRaw`pkgs.haskellPackages.refractor`,
  "See README for more info",
);

/**
 * Tools for maintaining a database
 */
export const refurb = mkPackage(
  nixRaw`pkgs.haskellPackages.refurb`,
  "Tools for maintaining a database",
);

/**
 * Register allocation by graph colorization
 */
export const reg_alloc_graph_color = mkPackage(
  nixRaw`pkgs.haskellPackages.reg-alloc-graph-color`,
  "Register allocation by graph colorization",
);

/**
 * Types used in register allocation API
 */
export const reg_alloc_types = mkPackage(
  nixRaw`pkgs.haskellPackages.reg-alloc-types`,
  "Types used in register allocation API",
);

/**
 * Toolkit for regex-base
 */
export const regex = mkPackage(
  nixRaw`pkgs.haskellPackages.regex`,
  "Toolkit for regex-base",
);

/**
 * Regex-based parsing with applicative interface
 */
export const regex_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-applicative`,
  "Regex-based parsing with applicative interface",
);

/**
 * regex-applicative on text
 */
export const regex_applicative_text = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-applicative-text`,
  "regex-applicative on text",
);

/**
 * Common "Text.Regex.*" API for Regex matching
 */
export const regex_base = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-base`,
  "Common \"Text.Regex.*\" API for Regex matching",
);

/**
 * Replaces/enhances "Text.Regex"
 */
export const regex_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-compat`,
  "Replaces/enhances \"Text.Regex\"",
);

/**
 * Unicode Support version of Text.Regex, using regex-tdfa
 */
export const regex_compat_tdfa = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-compat-tdfa`,
  "Unicode Support version of Text.Regex, using regex-tdfa",
);

/**
 * Replaces/Enhances Text.Regex. Implementing regular expression matching using Brzozowski's Deriviatives
 */
export const regex_deriv = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-deriv`,
  "Replaces/Enhances Text.Regex. Implementing regular expression matching using Brzozowski's Deriviatives",
);

/**
 * PCRE wrapper
 */
export const regex_do = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-do`,
  "PCRE wrapper",
);

/**
 * sugar for regex-pcre
 */
export const regex_easy = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-easy`,
  "sugar for regex-pcre",
);

/**
 * Tutorial, tests and example programs for regex
 */
export const regex_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-examples`,
  "Tutorial, tests and example programs for regex",
);

/**
 * From a regex, generate all possible strings it can match
 */
export const regex_genex = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-genex`,
  "From a regex, generate all possible strings it can match",
);

/**
 * PCRE Backend for "Text.Regex" (regex-base)
 */
export const regex_pcre = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-pcre`,
  "PCRE Backend for \"Text.Regex\" (regex-base)",
);

/**
 * PCRE Backend for "Text.Regex" (regex-base)
 */
export const regex_pcre_builtin = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-pcre-builtin`,
  "PCRE Backend for \"Text.Regex\" (regex-base)",
);

/**
 * Text-based PCRE API for regex-base
 */
export const regex_pcre_text = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-pcre-text`,
  "Text-based PCRE API for regex-base",
);

/**
 * Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives.
 */
export const regex_pderiv = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-pderiv`,
  "Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives.",
);

/**
 * POSIX Backend for "Text.Regex" (regex-base)
 */
export const regex_posix = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-posix`,
  "POSIX Backend for \"Text.Regex\" (regex-base)",
);

/**
 * "Regex for Windows" C library
 */
export const regex_posix_clib = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-posix-clib`,
  "\"Regex for Windows\" C library",
);

/**
 * Bindings to Rust's regex library
 */
export const regex_rure = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-rure`,
  "Bindings to Rust's regex library",
);

/**
 * Pure Haskell Tagged DFA Backend for "Text.Regex" (regex-base)
 */
export const regex_tdfa = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-tdfa`,
  "Pure Haskell Tagged DFA Backend for \"Text.Regex\" (regex-base)",
);

/**
 * Toolkit for regex-base
 */
export const regex_with_pcre = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-with-pcre`,
  "Toolkit for regex-base",
);

/**
 * Types that can only be constructed if they match a regular expression
 */
export const regex_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-wrapper`,
  "Types that can only be constructed if they match a regular expression",
);

/**
 * A regular expression library for W3C XML Schema regular expressions
 */
export const regex_xmlschema = mkPackage(
  nixRaw`pkgs.haskellPackages.regex-xmlschema`,
  "A regular expression library for W3C XML Schema regular expressions",
);

/**
 * A POSIX, extended regex-engine
 */
export const regexchar = mkPackage(
  nixRaw`pkgs.haskellPackages.regexchar`,
  "A POSIX, extended regex-engine",
);

/**
 * Regular Expressions on Tries
 */
export const regexp_tries = mkPackage(
  nixRaw`pkgs.haskellPackages.regexp-tries`,
  "Regular Expressions on Tries",
);

/**
 * regular expression like Perl/Ruby in Haskell
 */
export const regexpr = mkPackage(
  nixRaw`pkgs.haskellPackages.regexpr`,
  "regular expression like Perl/Ruby in Haskell",
);

/**
 * Regional memory pointers
 */
export const regional_pointers = mkPackage(
  nixRaw`pkgs.haskellPackages.regional-pointers`,
  "Regional memory pointers",
);

/**
 * Monads-fd instances for the RegionT monad transformer
 */
export const regions_monadsfd = mkPackage(
  nixRaw`pkgs.haskellPackages.regions-monadsfd`,
  "Monads-fd instances for the RegionT monad transformer",
);

/**
 * Monads-tf instances for the RegionT monad transformer
 */
export const regions_monadstf = mkPackage(
  nixRaw`pkgs.haskellPackages.regions-monadstf`,
  "Monads-tf instances for the RegionT monad transformer",
);

/**
 * mtl instances for the RegionT monad transformer
 */
export const regions_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.regions-mtl`,
  "mtl instances for the RegionT monad transformer",
);

/**
 * Aeson encoders / decoders
 */
export const registry_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.registry-aeson`,
  "Aeson encoders / decoders",
);

/**
 * utilities to work with Hedgehog generators and `registry`
 */
export const registry_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.registry-hedgehog`,
  "utilities to work with Hedgehog generators and `registry`",
);

/**
 * Hedgehog generators for Aeson
 */
export const registry_hedgehog_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.registry-hedgehog-aeson`,
  "Hedgehog generators for Aeson",
);

/**
 * MessagePack encoders / decoders
 */
export const registry_messagepack = mkPackage(
  nixRaw`pkgs.haskellPackages.registry-messagepack`,
  "MessagePack encoders / decoders",
);

/**
 * application options parsing
 */
export const registry_options = mkPackage(
  nixRaw`pkgs.haskellPackages.registry-options`,
  "application options parsing",
);

/**
 * Simple linear and quadratic regression
 */
export const regression_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.regression-simple`,
  "Simple linear and quadratic regression",
);

/**
 * Additional functions for regular: arbitrary, coarbitrary, and binary get/put
 */
export const regular_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.regular-extras`,
  "Additional functions for regular: arbitrary, coarbitrary, and binary get/put",
);

/**
 * Generic programming for the web
 */
export const regular_web = mkPackage(
  nixRaw`pkgs.haskellPackages.regular-web`,
  "Generic programming for the web",
);

/**
 * Generic generation of HXT XmlPickler instances using Regular
 */
export const regular_xmlpickler = mkPackage(
  nixRaw`pkgs.haskellPackages.regular-xmlpickler`,
  "Generic generation of HXT XmlPickler instances using Regular",
);

/**
 * to make notes and reduce impact on idle time on writing other programms
 */
export const reheat = mkPackage(
  nixRaw`pkgs.haskellPackages.reheat`,
  "to make notes and reduce impact on idle time on writing other programms",
);

/**
 * Memory reinterpretation casts for Float/Double and Word32/Word64
 */
export const reinterpret_cast = mkPackage(
  nixRaw`pkgs.haskellPackages.reinterpret-cast`,
  "Memory reinterpretation casts for Float/Double and Word32/Word64",
);

/**
 * Hey! Hey! Can u rel8?
 */
export const rel8 = mkPackage(
  nixRaw`pkgs.haskellPackages.rel8`,
  "Hey! Hey! Can u rel8?",
);

/**
 * Sensible RLP encoding
 */
export const relapse = mkPackage(
  nixRaw`pkgs.haskellPackages.relapse`,
  "Sensible RLP encoding",
);

/**
 * PostgreSQL v8.x driver for haskell-relational-record
 */
export const relational_postgresql8 = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-postgresql8`,
  "PostgreSQL v8.x driver for haskell-relational-record",
);

/**
 * Typeful, Modular, Relational, algebraic query engine
 */
export const relational_query = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-query`,
  "Typeful, Modular, Relational, algebraic query engine",
);

/**
 * HDBC instance of relational-query and typed query interface for HDBC
 */
export const relational_query_HDBC = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-query-HDBC`,
  "HDBC instance of relational-query and typed query interface for HDBC",
);

/**
 * The connector of relational-record and postgresql-pure
 */
export const relational_query_postgresql_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-query-postgresql-pure`,
  "The connector of relational-record and postgresql-pure",
);

/**
 * Meta package of Relational Record
 */
export const relational_record = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-record`,
  "Meta package of Relational Record",
);

/**
 * Examples of Haskell Relationa Record
 */
export const relational_record_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-record-examples`,
  "Examples of Haskell Relationa Record",
);

/**
 * RDBMSs' schema templates for relational-query
 */
export const relational_schemas = mkPackage(
  nixRaw`pkgs.haskellPackages.relational-schemas`,
  "RDBMSs' schema templates for relational-query",
);

/**
 * Durations and generalized time parsing
 */
export const relative_date = mkPackage(
  nixRaw`pkgs.haskellPackages.relative-date`,
  "Durations and generalized time parsing",
);

/**
 * Bindings to the low-level reliable.io library.
 */
export const reliable_io = mkPackage(
  nixRaw`pkgs.haskellPackages.reliable-io`,
  "Bindings to the low-level reliable.io library.",
);

/**
 * Literal for regular expression
 */
export const relit = mkPackage(
  nixRaw`pkgs.haskellPackages.relit`,
  "Literal for regular expression",
);

/**
 * Equiprobable draw from publicly verifiable random data
 */
export const reloto = mkPackage(
  nixRaw`pkgs.haskellPackages.reloto`,
  "Equiprobable draw from publicly verifiable random data",
);

/**
 * Safe, performant, user-friendly and lightweight Haskell Standard Library
 */
export const relude = mkPackage(
  nixRaw`pkgs.haskellPackages.relude`,
  "Safe, performant, user-friendly and lightweight Haskell Standard Library",
);

/**
 * Safe, performant, user-friendly and lightweight Haskell Standard Library
 */
export const relude_1_2_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.relude_1_2_1_0`,
  "Safe, performant, user-friendly and lightweight Haskell Standard Library",
);

/**
 * A simple api for matchers
 */
export const rematch = mkPackage(
  nixRaw`pkgs.haskellPackages.rematch`,
  "A simple api for matchers",
);

/**
 * `rematch` matchers for Data.Text
 */
export const rematch_text = mkPackage(
  nixRaw`pkgs.haskellPackages.rematch-text`,
  "`rematch` matchers for Data.Text",
);

/**
 * Remote Monad implementation of the JSON RPC protocol
 */
export const remote_json = mkPackage(
  nixRaw`pkgs.haskellPackages.remote-json`,
  "Remote Monad implementation of the JSON RPC protocol",
);

/**
 * Web client wrapper for remote-json
 */
export const remote_json_client = mkPackage(
  nixRaw`pkgs.haskellPackages.remote-json-client`,
  "Web client wrapper for remote-json",
);

/**
 * Web server wrapper for remote-json
 */
export const remote_json_server = mkPackage(
  nixRaw`pkgs.haskellPackages.remote-json-server`,
  "Web server wrapper for remote-json",
);

/**
 * A library for client-server applications based on custom protocols
 */
export const remotion = mkPackage(
  nixRaw`pkgs.haskellPackages.remotion`,
  "A library for client-server applications based on custom protocols",
);

/**
 * Simple Utf8 wrapper for ByteString Builder with conversion classes
 */
export const render_utf8 = mkPackage(
  nixRaw`pkgs.haskellPackages.render-utf8`,
  "Simple Utf8 wrapper for ByteString Builder with conversion classes",
);

/**
 * An API for managing renderable resources
 */
export const renderable = mkPackage(
  nixRaw`pkgs.haskellPackages.renderable`,
  "An API for managing renderable resources",
);

/**
 * Ad-hoc Ord instances
 */
export const reord = mkPackage(
  nixRaw`pkgs.haskellPackages.reord`,
  "Ad-hoc Ord instances",
);

/**
 * Algorithms using the Repa array library
 */
export const repa_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-algorithms`,
  "Algorithms using the Repa array library",
);

/**
 * Bulk array representations and operators
 */
export const repa_array = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-array`,
  "Bulk array representations and operators",
);

/**
 * (deprecated)
 */
export const repa_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-bytestring`,
  "(deprecated)",
);

/**
 * Packing and unpacking flat tables
 */
export const repa_convert = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-convert`,
  "Packing and unpacking flat tables",
);

/**
 * Support for image reading and writing of Repa arrays using in-place FFI calls
 */
export const repa_devil = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-devil`,
  "Support for image reading and writing of Repa arrays using in-place FFI calls",
);

/**
 * Examples using the Repa array library
 */
export const repa_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-examples`,
  "Examples using the Repa array library",
);

/**
 * Perform fft with repa via FFTW
 */
export const repa_fftw = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-fftw`,
  "Perform fft with repa via FFTW",
);

/**
 * Data-parallel data flows
 */
export const repa_flow = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-flow`,
  "Data-parallel data flows",
);

/**
 * Read and write Repa arrays in various formats
 */
export const repa_io = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-io`,
  "Read and write Repa arrays in various formats",
);

/**
 * HMatrix operations for Repa
 */
export const repa_linear_algebra = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-linear-algebra`,
  "HMatrix operations for Repa",
);

/**
 * Data Flow Fusion GHC Plugin
 */
export const repa_plugin = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-plugin`,
  "Data Flow Fusion GHC Plugin",
);

/**
 * Reading and writing sound files with repa arrays
 */
export const repa_sndfile = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-sndfile`,
  "Reading and writing sound files with repa arrays",
);

/**
 * Stream functions not present in the vector library
 */
export const repa_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-stream`,
  "Stream functions not present in the vector library",
);

/**
 * Provides high-level access to webcams
 */
export const repa_v4l2 = mkPackage(
  nixRaw`pkgs.haskellPackages.repa-v4l2`,
  "Provides high-level access to webcams",
);

/**
 * Find, replace, split string patterns with Attoparsec parsers (instead of regex)
 */
export const replace_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.replace-attoparsec`,
  "Find, replace, split string patterns with Attoparsec parsers (instead of regex)",
);

/**
 * Find, replace, split string patterns with Megaparsec parsers (instead of regex)
 */
export const replace_megaparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.replace-megaparsec`,
  "Find, replace, split string patterns with Megaparsec parsers (instead of regex)",
);

/**
 * Initial project template from stack
 */
export const replicant = mkPackage(
  nixRaw`pkgs.haskellPackages.replicant`,
  "Initial project template from stack",
);

/**
 * Haskeline wrapper for GHCi-like REPL interfaces
 */
export const repline = mkPackage(
  nixRaw`pkgs.haskellPackages.repline`,
  "Haskeline wrapper for GHCi-like REPL interfaces",
);

/**
 * Blogging module using blaze html for markup
 */
export const repo_based_blog = mkPackage(
  nixRaw`pkgs.haskellPackages.repo-based-blog`,
  "Blogging module using blaze html for markup",
);

/**
 * Render overloaded expressions to their textual representation
 */
export const repr = mkPackage(
  nixRaw`pkgs.haskellPackages.repr`,
  "Render overloaded expressions to their textual representation",
);

/**
 * Tree representation and pretty-printing of data structures based on SYB
 */
export const repr_tree_syb = mkPackage(
  nixRaw`pkgs.haskellPackages.repr-tree-syb`,
  "Tree representation and pretty-printing of data structures based on SYB",
);

/**
 * This package has been absorbed into profunctor-extras
 */
export const representable_profunctors = mkPackage(
  nixRaw`pkgs.haskellPackages.representable-profunctors`,
  "This package has been absorbed into profunctor-extras",
);

/**
 * Tries from representations of polynomial functors
 */
export const representable_tries = mkPackage(
  nixRaw`pkgs.haskellPackages.representable-tries`,
  "Tries from representations of polynomial functors",
);

/**
 * HTTP client library
 */
export const req = mkPackage(
  nixRaw`pkgs.haskellPackages.req`,
  "HTTP client library",
);

/**
 * HTTP client library
 */
export const req_3_13_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.req_3_13_1`,
  "HTTP client library",
);

/**
 * Provides OAuth2 authentication for use with Req
 */
export const req_oauth2 = mkPackage(
  nixRaw`pkgs.haskellPackages.req-oauth2`,
  "Provides OAuth2 authentication for use with Req",
);

/**
 * A local http server to catch the HTTP redirect
 */
export const reqcatcher = mkPackage(
  nixRaw`pkgs.haskellPackages.reqcatcher`,
  "A local http server to catch the HTTP redirect",
);

/**
 * Propagate HasCallStack with constraints
 */
export const require_callstack = mkPackage(
  nixRaw`pkgs.haskellPackages.require-callstack`,
  "Propagate HasCallStack with constraints",
);

/**
 * Abstraction to manage user defined Type Errors
 */
export const requirements = mkPackage(
  nixRaw`pkgs.haskellPackages.requirements`,
  "Abstraction to manage user defined Type Errors",
);

/**
 * Regular-expressions extended with fixpoints for context-free powers
 */
export const rere = mkPackage(
  nixRaw`pkgs.haskellPackages.rere`,
  "Regular-expressions extended with fixpoints for context-free powers",
);

/**
 * Reexports from "base" with a bunch of other standard libraries
 */
export const rerebase = mkPackage(
  nixRaw`pkgs.haskellPackages.rerebase`,
  "Reexports from \"base\" with a bunch of other standard libraries",
);

/**
 * Reexports from "base" with a bunch of other standard libraries
 */
export const rerebase_1_20 = mkPackage(
  nixRaw`pkgs.haskellPackages.rerebase_1_20`,
  "Reexports from \"base\" with a bunch of other standard libraries",
);

/**
 * abstract implementation of typed and untyped web routing
 */
export const reroute = mkPackage(
  nixRaw`pkgs.haskellPackages.reroute`,
  "abstract implementation of typed and untyped web routing",
);

/**
 * Reserve reloads web applications
 */
export const reserve = mkPackage(
  nixRaw`pkgs.haskellPackages.reserve`,
  "Reserve reloads web applications",
);

/**
 * High performance variable binders
 */
export const resin = mkPackage(
  nixRaw`pkgs.haskellPackages.resin`,
  "High performance variable binders",
);

/**
 * Compute total resistance of a cube of resistors
 */
export const resistor_cube = mkPackage(
  nixRaw`pkgs.haskellPackages.resistor-cube`,
  "Compute total resistance of a cube of resistors",
);

/**
 * Domain Name Service (DNS) lookup via the libresolv standard library routines
 */
export const resolv = mkPackage(
  nixRaw`pkgs.haskellPackages.resolv`,
  "Domain Name Service (DNS) lookup via the libresolv standard library routines",
);

/**
 * Domain Name Service (DNS) lookup via the libresolv standard library routines
 */
export const resolv_0_1_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.resolv_0_1_2_0`,
  "Domain Name Service (DNS) lookup via the libresolv standard library routines",
);

/**
 * A region-based resource effect for the effectful ecosystem
 */
export const resource_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.resource-effectful`,
  "A region-based resource effect for the effectful ecosystem",
);

/**
 * A high-performance striped resource pooling implementation
 */
export const resource_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.resource-pool`,
  "A high-performance striped resource pooling implementation",
);

/**
 * Fork of resource-pool, with a MonadCatchIO constraint
 */
export const resource_pool_catchio = mkPackage(
  nixRaw`pkgs.haskellPackages.resource-pool-catchio`,
  "Fork of resource-pool, with a MonadCatchIO constraint",
);

/**
 * A high-performance striped resource pooling implementation
 */
export const resource_pool_fork_avanov = mkPackage(
  nixRaw`pkgs.haskellPackages.resource-pool-fork-avanov`,
  "A high-performance striped resource pooling implementation",
);

/**
 * Allocate resources which are guaranteed to be released
 */
export const resource_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.resource-simple`,
  "Allocate resources which are guaranteed to be released",
);

/**
 * Deterministic allocation and freeing of scarce resources
 */
export const resourcet = mkPackage(
  nixRaw`pkgs.haskellPackages.resourcet`,
  "Deterministic allocation and freeing of scarce resources",
);

/**
 * Deterministic allocation and freeing of scarce resources
 */
export const resourcet_1_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.resourcet_1_3_0`,
  "Deterministic allocation and freeing of scarce resources",
);

/**
 * Adaptation of the resourcet library for the effectful ecosystem
 */
export const resourcet_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.resourcet-effectful`,
  "Adaptation of the resourcet library for the effectful ecosystem",
);

/**
 * process and route HTTP requests and generate responses on top of WAI
 */
export const respond = mkPackage(
  nixRaw`pkgs.haskellPackages.respond`,
  "process and route HTTP requests and generate responses on top of WAI",
);

/**
 * Utility library for use in generated API client libraries
 */
export const rest_client = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-client`,
  "Utility library for use in generated API client libraries",
);

/**
 * Rest API library
 */
export const rest_core = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-core`,
  "Rest API library",
);

/**
 * Example project for rest
 */
export const rest_example = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-example`,
  "Example project for rest",
);

/**
 * Documentation and client generation from rest definition
 */
export const rest_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-gen`,
  "Documentation and client generation from rest definition",
);

/**
 * Rest driver for Happstack
 */
export const rest_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-happstack`,
  "Rest driver for Happstack",
);

/**
 * Rewriting library with online termination checking
 */
export const rest_rewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-rewrite`,
  "Rewriting library with online termination checking",
);

/**
 * Rest driver for Snap
 */
export const rest_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-snap`,
  "Rest driver for Snap",
);

/**
 * Maps with stringy keys that can be transcoded to JSON and XML
 */
export const rest_stringmap = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-stringmap`,
  "Maps with stringy keys that can be transcoded to JSON and XML",
);

/**
 * Silk Rest Framework Types
 */
export const rest_types = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-types`,
  "Silk Rest Framework Types",
);

/**
 * Rest driver for WAI applications
 */
export const rest_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.rest-wai`,
  "Rest driver for WAI applications",
);

export const restful_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.restful-snap`,
  "",
);

/**
 * Easy Git repository serialization
 */
export const restless_git = mkPackage(
  nixRaw`pkgs.haskellPackages.restless-git`,
  "Easy Git repository serialization",
);

/**
 * Running worker processes under system resource restrictions
 */
export const restricted_workers = mkPackage(
  nixRaw`pkgs.haskellPackages.restricted-workers`,
  "Running worker processes under system resource restrictions",
);

/**
 * Encode success or at least one error
 */
export const result = mkPackage(
  nixRaw`pkgs.haskellPackages.result`,
  "Encode success or at least one error",
);

/**
 * A tool that returns to a landmark parent directory
 */
export const ret = mkPackage(
  nixRaw`pkgs.haskellPackages.ret`,
  "A tool that returns to a landmark parent directory",
);

/**
 * Useful tools for modeling data with rethinkdb
 */
export const rethinkdb_model = mkPackage(
  nixRaw`pkgs.haskellPackages.rethinkdb-model`,
  "Useful tools for modeling data with rethinkdb",
);

/**
 * RethinkDB driver for Haskell
 */
export const rethinkdb_wereHamster = mkPackage(
  nixRaw`pkgs.haskellPackages.rethinkdb-wereHamster`,
  "RethinkDB driver for Haskell",
);

/**
 * A powerful, easy-to-use codemodding tool for Haskell
 */
export const retrie = mkPackage(
  nixRaw`pkgs.haskellPackages.retrie`,
  "A powerful, easy-to-use codemodding tool for Haskell",
);

/**
 * A powerful, easy-to-use codemodding tool for Haskell
 */
export const retrie_1_1_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.retrie_1_1_0_0`,
  "A powerful, easy-to-use codemodding tool for Haskell",
);

/**
 * Code shared across the code samples in the book "Retrocomputing with Clash"
 */
export const retroclash_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.retroclash-lib`,
  "Code shared across the code samples in the book \"Retrocomputing with Clash\"",
);

/**
 * High-level simulators from the book "Retrocomputing with Clash"
 */
export const retroclash_sim = mkPackage(
  nixRaw`pkgs.haskellPackages.retroclash-sim`,
  "High-level simulators from the book \"Retrocomputing with Clash\"",
);

/**
 * Retry combinators for monadic actions that may fail
 */
export const retry = mkPackage(
  nixRaw`pkgs.haskellPackages.retry`,
  "Retry combinators for monadic actions that may fail",
);

/**
 * Adaptation of the retry library for the effectful ecosystem
 */
export const retry_effectful = mkPackage(
  nixRaw`pkgs.haskellPackages.retry-effectful`,
  "Adaptation of the retry library for the effectful ecosystem",
);

/**
 * A library to provide special kind of big numbers writing
 */
export const rev_scientific = mkPackage(
  nixRaw`pkgs.haskellPackages.rev-scientific`,
  "A library to provide special kind of big numbers writing",
);

/**
 * Reverse State monad transformer
 */
export const rev_state = mkPackage(
  nixRaw`pkgs.haskellPackages.rev-state`,
  "Reverse State monad transformer",
);

/**
 * A French revolutionary decimal time (metric) clock
 */
export const revdectime = mkPackage(
  nixRaw`pkgs.haskellPackages.revdectime`,
  "A French revolutionary decimal time (metric) clock",
);

/**
 * Standard version of the reverse apply operator
 */
export const reverse_apply = mkPackage(
  nixRaw`pkgs.haskellPackages.reverse-apply`,
  "Standard version of the reverse apply operator",
);

/**
 * Reverse the arguments of arbitrary functions
 */
export const reverse_arguments = mkPackage(
  nixRaw`pkgs.haskellPackages.reverse-arguments`,
  "Reverse the arguments of arbitrary functions",
);

/**
 * open file and rewrite it with new contents
 */
export const rewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.rewrite`,
  "open file and rewrite it with new contents",
);

/**
 * Generic rewriting library for regular datatypes
 */
export const rewriting = mkPackage(
  nixRaw`pkgs.haskellPackages.rewriting`,
  "Generic rewriting library for regular datatypes",
);

/**
 * A quasi-quoter for typeful results of regex captures
 */
export const rex = mkPackage(
  nixRaw`pkgs.haskellPackages.rex`,
  "A quasi-quoter for typeful results of regex captures",
);

/**
 * Github resume generator
 */
export const rezoom = mkPackage(
  nixRaw`pkgs.haskellPackages.rezoom`,
  "Github resume generator",
);

/**
 * rfc1413 server
 */
export const rfc1413_server = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc1413-server`,
  "rfc1413 server",
);

/**
 * An rfc1413 parser and response renderer
 */
export const rfc1413_types = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc1413-types`,
  "An rfc1413 parser and response renderer",
);

/**
 * RFC-1751 library for Haskell
 */
export const rfc1751 = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc1751`,
  "RFC-1751 library for Haskell",
);

/**
 * Parse and display time according to RFC3339 (deprecated)
 */
export const rfc3339 = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc3339`,
  "Parse and display time according to RFC3339 (deprecated)",
);

/**
 * Simple unicode collation as per RFC5051
 */
export const rfc5051 = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc5051`,
  "Simple unicode collation as per RFC5051",
);

/**
 * Environment variable support from the Robert Fischer Commons
 */
export const rfc_env = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc-env`,
  "Environment variable support from the Robert Fischer Commons",
);

/**
 * The HTTP client extensions from the Robert Fischer Commons
 */
export const rfc_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc-http-client`,
  "The HTTP client extensions from the Robert Fischer Commons",
);

/**
 * The PostgreSQL extensions from the Robert Fischer Commons
 */
export const rfc_psql = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc-psql`,
  "The PostgreSQL extensions from the Robert Fischer Commons",
);

/**
 * The Redis extensions from the Robert Fischer Commons
 */
export const rfc_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc-redis`,
  "The Redis extensions from the Robert Fischer Commons",
);

/**
 * The Servant extensions from the Robert Fischer Commons
 */
export const rfc_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.rfc-servant`,
  "The Servant extensions from the Robert Fischer Commons",
);

/**
 * A dynamic/unbounded alternative to Bounded Enum
 */
export const rg = mkPackage(
  nixRaw`pkgs.haskellPackages.rg`,
  "A dynamic/unbounded alternative to Bounded Enum",
);

/**
 * Haskell types for working with RGB colors
 */
export const rgb_color_model = mkPackage(
  nixRaw`pkgs.haskellPackages.rgb-color-model`,
  "Haskell types for working with RGB colors",
);

/**
 * monad-bayes backend for Rhine
 */
export const rhine_bayes = mkPackage(
  nixRaw`pkgs.haskellPackages.rhine-bayes`,
  "monad-bayes backend for Rhine",
);

/**
 * Gloss backend for Rhine
 */
export const rhine_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.rhine-gloss`,
  "Gloss backend for Rhine",
);

/**
 * Terminal backend for Rhine
 */
export const rhine_terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.rhine-terminal`,
  "Terminal backend for Rhine",
);

/**
 * Haskell rhythm game tutorial
 */
export const rhythm_game_tutorial = mkPackage(
  nixRaw`pkgs.haskellPackages.rhythm-game-tutorial`,
  "Haskell rhythm game tutorial",
);

/**
 * Improved library to deal with rhythmicity of short sequences
 */
export const rhythmic_sequences = mkPackage(
  nixRaw`pkgs.haskellPackages.rhythmic-sequences`,
  "Improved library to deal with rhythmicity of short sequences",
);

/**
 * Haskell types for the Riak protocol buffer API
 */
export const riak_protobuf = mkPackage(
  nixRaw`pkgs.haskellPackages.riak-protobuf`,
  "Haskell types for the Riak protocol buffer API",
);

/**
 * Static site generator based on Shake
 */
export const rib = mkPackage(
  nixRaw`pkgs.haskellPackages.rib`,
  "Static site generator based on Shake",
);

/**
 * Neovim plugin framework for Polysemy
 */
export const ribosome = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome`,
  "Neovim plugin framework for Polysemy",
);

/**
 * CLI for Ribosome
 */
export const ribosome_app = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome-app`,
  "CLI for Ribosome",
);

/**
 * Neovim plugin host for Polysemy
 */
export const ribosome_host = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome-host`,
  "Neovim plugin host for Polysemy",
);

/**
 * Test tools for Ribosome
 */
export const ribosome_host_test = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome-host-test`,
  "Test tools for Ribosome",
);

/**
 * api extensions for nvim-hs
 */
export const ribosome_root = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome-root`,
  "api extensions for nvim-hs",
);

/**
 * Test tools for Ribosome
 */
export const ribosome_test = mkPackage(
  nixRaw`pkgs.haskellPackages.ribosome-test`,
  "Test tools for Ribosome",
);

/**
 * Rich environment variable setup for Haskell
 */
export const richenv = mkPackage(
  nixRaw`pkgs.haskellPackages.richenv`,
  "Rich environment variable setup for Haskell",
);

/**
 * Integrated pretty-printing and error/static analysis reporting
 */
export const richreports = mkPackage(
  nixRaw`pkgs.haskellPackages.richreports`,
  "Integrated pretty-printing and error/static analysis reporting",
);

/**
 * Quick metrics to grow your app strong
 */
export const ridley = mkPackage(
  nixRaw`pkgs.haskellPackages.ridley`,
  "Quick metrics to grow your app strong",
);

/**
 * Handy metrics that don't belong to ridley
 */
export const ridley_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.ridley-extras`,
  "Handy metrics that don't belong to ridley",
);

/**
 * Ring-like objects
 */
export const rings = mkPackage(
  nixRaw`pkgs.haskellPackages.rings`,
  "Ring-like objects",
);

/**
 * A standard library for Haskell
 */
export const rio = mkPackage(
  nixRaw`pkgs.haskellPackages.rio`,
  "A standard library for Haskell",
);

/**
 * Generic App type for rio
 */
export const rio_app = mkPackage(
  nixRaw`pkgs.haskellPackages.rio-app`,
  "Generic App type for rio",
);

/**
 * Orphan instances for the RIO type in the rio package
 */
export const rio_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.rio-orphans`,
  "Orphan instances for the RIO type in the rio package",
);

/**
 * Pretty-printing for RIO
 */
export const rio_prettyprint = mkPackage(
  nixRaw`pkgs.haskellPackages.rio-prettyprint`,
  "Pretty-printing for RIO",
);

/**
 * A library for process pools coupled with asynchronous message queues
 */
export const rio_process_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.rio-process-pool`,
  "A library for process pools coupled with asynchronous message queues",
);

/**
 * Riot is an Information Organisation Tool
 */
export const riot = mkPackage(
  nixRaw`pkgs.haskellPackages.riot`,
  "Riot is an Information Organisation Tool",
);

/**
 * Ripple payment system library
 */
export const ripple = mkPackage(
  nixRaw`pkgs.haskellPackages.ripple`,
  "Ripple payment system library",
);

/**
 * Utilities and types to work with the Ripple federation protocol
 */
export const ripple_federation = mkPackage(
  nixRaw`pkgs.haskellPackages.ripple-federation`,
  "Utilities and types to work with the Ripple federation protocol",
);

/**
 * Reduced instruction set i386 simulator
 */
export const risc386 = mkPackage(
  nixRaw`pkgs.haskellPackages.risc386`,
  "Reduced instruction set i386 simulator",
);

/**
 * RISC-V
 */
export const risc_v = mkPackage(
  nixRaw`pkgs.haskellPackages.risc-v`,
  "RISC-V",
);

/**
 * A project management tool for Haskell applications
 */
export const rivet = mkPackage(
  nixRaw`pkgs.haskellPackages.rivet`,
  "A project management tool for Haskell applications",
);

/**
 * Rivet migration library postgresql backend
 */
export const rivet_adaptor_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.rivet-adaptor-postgresql`,
  "Rivet migration library postgresql backend",
);

/**
 * Database migration library; automatic importer
 */
export const rivet_autoimporter = mkPackage(
  nixRaw`pkgs.haskellPackages.rivet-autoimporter`,
  "Database migration library; automatic importer",
);

/**
 * Database migration library; core functionality
 */
export const rivet_core = mkPackage(
  nixRaw`pkgs.haskellPackages.rivet-core`,
  "Database migration library; core functionality",
);

/**
 * Lists with cheap snocs
 */
export const rlist = mkPackage(
  nixRaw`pkgs.haskellPackages.rlist`,
  "Lists with cheap snocs",
);

/**
 * Ring-LWE/LWR challenges using Lol
 */
export const rlwe_challenges = mkPackage(
  nixRaw`pkgs.haskellPackages.rlwe-challenges`,
  "Ring-LWE/LWR challenges using Lol",
);

/**
 * Restricted monad library
 */
export const rmonad = mkPackage(
  nixRaw`pkgs.haskellPackages.rmonad`,
  "Restricted monad library",
);

/**
 * Haskell implementation of the RNCryptor file format
 */
export const rncryptor = mkPackage(
  nixRaw`pkgs.haskellPackages.rncryptor`,
  "Haskell implementation of the RNCryptor file format",
);

/**
 * RNG within an IORef for convenient concurrent use
 */
export const rng_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.rng-utils`,
  "RNG within an IORef for convenient concurrent use",
);

/**
 * Simple projects generator
 */
export const rob = mkPackage(
  nixRaw`pkgs.haskellPackages.rob`,
  "Simple projects generator",
);

/**
 * Automatic session-aware servant testing
 */
export const roboservant = mkPackage(
  nixRaw`pkgs.haskellPackages.roboservant`,
  "Automatic session-aware servant testing",
);

/**
 * Simulate keyboard and mouse events
 */
export const robot = mkPackage(
  nixRaw`pkgs.haskellPackages.robot`,
  "Simulate keyboard and mouse events",
);

/**
 * Gloss interactive demo for roc-cluster package
 */
export const roc_cluster_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.roc-cluster-demo`,
  "Gloss interactive demo for roc-cluster package",
);

/**
 * Implementation of the ROC (Taiwan) National ID standard
 */
export const roc_id = mkPackage(
  nixRaw`pkgs.haskellPackages.roc-id`,
  "Implementation of the ROC (Taiwan) National ID standard",
);

/**
 * A build system for incremental, parallel, and demand-driven computations
 */
export const rock = mkPackage(
  nixRaw`pkgs.haskellPackages.rock`,
  "A build system for incremental, parallel, and demand-driven computations",
);

/**
 * Haskell bindings to RocksDB
 */
export const rocksdb_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.rocksdb-haskell`,
  "Haskell bindings to RocksDB",
);

/**
 * Haskell bindings for RocksDB
 */
export const rocksdb_haskell_jprupp = mkPackage(
  nixRaw`pkgs.haskellPackages.rocksdb-haskell-jprupp`,
  "Haskell bindings for RocksDB",
);

/**
 * RocksDB database querying library for Haskell
 */
export const rocksdb_query = mkPackage(
  nixRaw`pkgs.haskellPackages.rocksdb-query`,
  "RocksDB database querying library for Haskell",
);

/**
 * Sci-fi roguelike game. Backend.
 */
export const roguestar_engine = mkPackage(
  nixRaw`pkgs.haskellPackages.roguestar-engine`,
  "Sci-fi roguelike game. Backend.",
);

/**
 * Sci-fi roguelike game. Client library.
 */
export const roguestar_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.roguestar-gl`,
  "Sci-fi roguelike game. Client library.",
);

/**
 * Sci-fi roguelike game. GLUT front-end.
 */
export const roguestar_glut = mkPackage(
  nixRaw`pkgs.haskellPackages.roguestar-glut`,
  "Sci-fi roguelike game. GLUT front-end.",
);

/**
 * Composable class-based roles
 */
export const roles = mkPackage(
  nixRaw`pkgs.haskellPackages.roles`,
  "Composable class-based roles",
);

/**
 * error tracking through rollbar.com
 */
export const rollbar = mkPackage(
  nixRaw`pkgs.haskellPackages.rollbar`,
  "error tracking through rollbar.com",
);

/**
 * Simple CLI tool to perform commons tasks such as tracking deploys
 */
export const rollbar_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.rollbar-cli`,
  "Simple CLI tool to perform commons tasks such as tracking deploys",
);

/**
 * Provides error reporting capabilities to WAI based applications through Rollbar API
 */
export const rollbar_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.rollbar-wai`,
  "Provides error reporting capabilities to WAI based applications through Rollbar API",
);

/**
 * Provides error reporting capabilities to Yesod applications through Rollbar API
 */
export const rollbar_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.rollbar-yesod`,
  "Provides error reporting capabilities to Yesod applications through Rollbar API",
);

/**
 * Bounded channel for STM that discards old entries when full
 */
export const rolling_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.rolling-queue`,
  "Bounded channel for STM that discards old entries when full",
);

/**
 * Japanese Romaji <-> Japanese Kana conversion library
 */
export const romkan = mkPackage(
  nixRaw`pkgs.haskellPackages.romkan`,
  "Japanese Romaji <-> Japanese Kana conversion library",
);

/**
 * Replicated Data Types (RON-RDT)
 */
export const ron_rdt = mkPackage(
  nixRaw`pkgs.haskellPackages.ron-rdt`,
  "Replicated Data Types (RON-RDT)",
);

/**
 * RON-Schema
 */
export const ron_schema = mkPackage(
  nixRaw`pkgs.haskellPackages.ron-schema`,
  "RON-Schema",
);

/**
 * RON Storage
 */
export const ron_storage = mkPackage(
  nixRaw`pkgs.haskellPackages.ron-storage`,
  "RON Storage",
);

/**
 * Root-finding algorithms (1-dimensional)
 */
export const roots = mkPackage(
  nixRaw`pkgs.haskellPackages.roots`,
  "Root-finding algorithms (1-dimensional)",
);

/**
 * Ropes optimised for updating using UTF-16 code units and row/column pairs
 */
export const rope_utf16_splay = mkPackage(
  nixRaw`pkgs.haskellPackages.rope-utf16-splay`,
  "Ropes optimised for updating using UTF-16 code units and row/column pairs",
);

/**
 * Query the namecoin blockchain
 */
export const rosa = mkPackage(
  nixRaw`pkgs.haskellPackages.rosa`,
  "Query the namecoin blockchain",
);

/**
 * rose trees
 */
export const rose = mkPackage(
  nixRaw`pkgs.haskellPackages.rose`,
  "rose trees",
);

/**
 * Various trie implementations in Haskell
 */
export const rose_trees = mkPackage(
  nixRaw`pkgs.haskellPackages.rose-trees`,
  "Various trie implementations in Haskell",
);

/**
 * Trees with polymorphic paths to nodes, combining properties of Rose Trees and Tries
 */
export const rose_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.rose-trie`,
  "Trees with polymorphic paths to nodes, combining properties of Rose Trees and Tries",
);

/**
 * Generic zipper implementation for Data.Tree
 */
export const rosezipper = mkPackage(
  nixRaw`pkgs.haskellPackages.rosezipper`,
  "Generic zipper implementation for Data.Tree",
);

/**
 * Haskell support for the ROS robotics framework
 */
export const roshask = mkPackage(
  nixRaw`pkgs.haskellPackages.roshask`,
  "Haskell support for the ROS robotics framework",
);

/**
 * ROS message management tools
 */
export const rosmsg_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.rosmsg-bin`,
  "ROS message management tools",
);

/**
 * Fast ROT13 cipher for Haskell
 */
export const rot13 = mkPackage(
  nixRaw`pkgs.haskellPackages.rot13`,
  "Fast ROT13 cipher for Haskell",
);

/**
 * A simple round-robin data type
 */
export const roundRobin = mkPackage(
  nixRaw`pkgs.haskellPackages.roundRobin`,
  "A simple round-robin data type",
);

/**
 * Correctly-rounded arbitrary-precision floating-point arithmetic
 */
export const rounded = mkPackage(
  nixRaw`pkgs.haskellPackages.rounded`,
  "Correctly-rounded arbitrary-precision floating-point arithmetic",
);

/**
 * Directed rounding for built-in floating types
 */
export const rounded_hw = mkPackage(
  nixRaw`pkgs.haskellPackages.rounded-hw`,
  "Directed rounding for built-in floating types",
);

/**
 * Bidirectional (de-)serialization
 */
export const roundtrip = mkPackage(
  nixRaw`pkgs.haskellPackages.roundtrip`,
  "Bidirectional (de-)serialization",
);

/**
 * Bidirectional (de-)serialization
 */
export const roundtrip_string = mkPackage(
  nixRaw`pkgs.haskellPackages.roundtrip-string`,
  "Bidirectional (de-)serialization",
);

/**
 * Bidirectional (de-)serialization for XML
 */
export const roundtrip_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.roundtrip-xml`,
  "Bidirectional (de-)serialization for XML",
);

/**
 * Utility to generate routes for use with yesod-routes
 */
export const route_generator = mkPackage(
  nixRaw`pkgs.haskellPackages.route-generator`,
  "Utility to generate routes for use with yesod-routes",
);

/**
 * A library and utilities for creating a route
 */
export const route_planning = mkPackage(
  nixRaw`pkgs.haskellPackages.route-planning`,
  "A library and utilities for creating a route",
);

/**
 * Row types
 */
export const row = mkPackage(
  nixRaw`pkgs.haskellPackages.row`,
  "Row types",
);

/**
 * Open Records and Variants
 */
export const row_types = mkPackage(
  nixRaw`pkgs.haskellPackages.row-types`,
  "Open Records and Variants",
);

/**
 * aeson instances for Open Records and Variants
 */
export const row_types_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.row-types-aeson`,
  "aeson instances for Open Records and Variants",
);

/**
 * barbies instances for Open Records and Variants
 */
export const row_types_barbies = mkPackage(
  nixRaw`pkgs.haskellPackages.row-types-barbies`,
  "barbies instances for Open Records and Variants",
);

/**
 * An EDSL for web application routes
 */
export const rowdy = mkPackage(
  nixRaw`pkgs.haskellPackages.rowdy`,
  "An EDSL for web application routes",
);

/**
 * An EDSL for web application routes
 */
export const rowdy_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.rowdy-yesod`,
  "An EDSL for web application routes",
);

/**
 * Random projection trees
 */
export const rp_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.rp-tree`,
  "Random projection trees",
);

/**
 * type safe rpcs provided as basic IO actions
 */
export const rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.rpc`,
  "type safe rpcs provided as basic IO actions",
);

/**
 * Receiver Policy Framework
 */
export const rpf = mkPackage(
  nixRaw`pkgs.haskellPackages.rpf`,
  "Receiver Policy Framework",
);

/**
 * RPM package name-version-release data types
 */
export const rpm_nvr = mkPackage(
  nixRaw`pkgs.haskellPackages.rpm-nvr`,
  "RPM package name-version-release data types",
);

/**
 * Efficient RRB-Vectors
 */
export const rrb_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.rrb-vector`,
  "Efficient RRB-Vectors",
);

/**
 * The RogueStar Animation and Graphics Library
 */
export const rsagl = mkPackage(
  nixRaw`pkgs.haskellPackages.rsagl`,
  "The RogueStar Animation and Graphics Library",
);

/**
 * The RogueStar Animation and Graphics Library: Functional Reactive Programming
 */
export const rsagl_frp = mkPackage(
  nixRaw`pkgs.haskellPackages.rsagl-frp`,
  "The RogueStar Animation and Graphics Library: Functional Reactive Programming",
);

/**
 * The RogueStar Animation and Graphics Library: Mathematics
 */
export const rsagl_math = mkPackage(
  nixRaw`pkgs.haskellPackages.rsagl-math`,
  "The RogueStar Animation and Graphics Library: Mathematics",
);

/**
 * Range set
 */
export const rset = mkPackage(
  nixRaw`pkgs.haskellPackages.rset`,
  "Range set",
);

/**
 * A library for generating RSS 2.0 feeds.
 */
export const rss = mkPackage(
  nixRaw`pkgs.haskellPackages.rss`,
  "A library for generating RSS 2.0 feeds.",
);

/**
 * Streaming parser/renderer for the RSS standard
 */
export const rss_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.rss-conduit`,
  "Streaming parser/renderer for the RSS standard",
);

/**
 * Haskell bindings for RTCM
 */
export const rtcm = mkPackage(
  nixRaw`pkgs.haskellPackages.rtcm`,
  "Haskell bindings for RTCM",
);

/**
 * dynamic linker tools for Haskell
 */
export const rtld = mkPackage(
  nixRaw`pkgs.haskellPackages.rtld`,
  "dynamic linker tools for Haskell",
);

/**
 * Bindings to librtlsdr
 */
export const rtlsdr = mkPackage(
  nixRaw`pkgs.haskellPackages.rtlsdr`,
  "Bindings to librtlsdr",
);

/**
 * Ruler tool for UHC
 */
export const ruler = mkPackage(
  nixRaw`pkgs.haskellPackages.ruler`,
  "Ruler tool for UHC",
);

export const ruler_core = mkPackage(
  nixRaw`pkgs.haskellPackages.ruler-core`,
  "",
);

/**
 * Running newly generated Haskell source module
 */
export const run_haskell_module = mkPackage(
  nixRaw`pkgs.haskellPackages.run-haskell-module`,
  "Running newly generated Haskell source module",
);

/**
 * runST without boxing penalty
 */
export const run_st = mkPackage(
  nixRaw`pkgs.haskellPackages.run-st`,
  "runST without boxing penalty",
);

/**
 * runST without boxing penalty
 */
export const run_st_0_1_3_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.run-st_0_1_3_2`,
  "runST without boxing penalty",
);

/**
 * A collection of explicit Runge-Kutta methods of various orders
 */
export const rungekutta = mkPackage(
  nixRaw`pkgs.haskellPackages.rungekutta`,
  "A collection of explicit Runge-Kutta methods of various orders",
);

/**
 * Explicit Runge-Kutta methods of various orders (fork of 'rungekutta')
 */
export const rungekutta2 = mkPackage(
  nixRaw`pkgs.haskellPackages.rungekutta2`,
  "Explicit Runge-Kutta methods of various orders (fork of 'rungekutta')",
);

/**
 * runghc replacement for fast repeated runs
 */
export const runghc = mkPackage(
  nixRaw`pkgs.haskellPackages.runghc`,
  "runghc replacement for fast repeated runs",
);

/**
 * A simple memoization helper library
 */
export const runmemo = mkPackage(
  nixRaw`pkgs.haskellPackages.runmemo`,
  "A simple memoization helper library",
);

/**
 * Runtime generation of Arbitrary values
 */
export const runtime_arbitrary = mkPackage(
  nixRaw`pkgs.haskellPackages.runtime-arbitrary`,
  "Runtime generation of Arbitrary values",
);

/**
 * RISC-V
 */
export const rv = mkPackage(
  nixRaw`pkgs.haskellPackages.rv`,
  "RISC-V",
);

/**
 * Random Variables
 */
export const rvar = mkPackage(
  nixRaw`pkgs.haskellPackages.rvar`,
  "Random Variables",
);

/**
 * Multiple-read / single-write locks
 */
export const rwlock = mkPackage(
  nixRaw`pkgs.haskellPackages.rwlock`,
  "Multiple-read / single-write locks",
);

/**
 * An experimental proof assistant for synthetic -categories
 */
export const rzk = mkPackage(
  nixRaw`pkgs.haskellPackages.rzk`,
  "An experimental proof assistant for synthetic -categories",
);

/**
 * Pre-signed Amazon S3 URLs
 */
export const s3_signer = mkPackage(
  nixRaw`pkgs.haskellPackages.s3-signer`,
  "Pre-signed Amazon S3 URLs",
);

/**
 * A flexible, extensible s-expression library
 */
export const s_cargot = mkPackage(
  nixRaw`pkgs.haskellPackages.s-cargot`,
  "A flexible, extensible s-expression library",
);

/**
 * Enables let-binding and let-expansion for s-cargot defined S-expressions
 */
export const s_cargot_letbind = mkPackage(
  nixRaw`pkgs.haskellPackages.s-cargot-letbind`,
  "Enables let-binding and let-expansion for s-cargot defined S-expressions",
);

/**
 * simple general-purpose s-expressions
 */
export const s_expression = mkPackage(
  nixRaw`pkgs.haskellPackages.s-expression`,
  "simple general-purpose s-expressions",
);

/**
 * Library of safe (exception free) functions
 */
export const safe = mkPackage(
  nixRaw`pkgs.haskellPackages.safe`,
  "Library of safe (exception free) functions",
);

/**
 * A simple environment to control access to data
 */
export const safe_access = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-access`,
  "A simple environment to control access to data",
);

/**
 * Safely output coloured text
 */
export const safe_coloured_text = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-coloured-text`,
  "Safely output coloured text",
);

export const safe_coloured_text_layout_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-coloured-text-layout-gen`,
  "",
);

/**
 * Safely output coloured text
 */
export const safe_coloured_text_terminfo = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-coloured-text-terminfo`,
  "Safely output coloured text",
);

/**
 * Relational proof system for probabilistic algorithms
 */
export const safe_coupling = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-coupling`,
  "Relational proof system for probabilistic algorithms",
);

/**
 * Safe and very efficient arithmetic operations on fixed decimal point numbers
 */
export const safe_decimal = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-decimal`,
  "Safe and very efficient arithmetic operations on fixed decimal point numbers",
);

/**
 * Safe, consistent, and easy exception handling
 */
export const safe_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-exceptions`,
  "Safe, consistent, and easy exception handling",
);

/**
 * Safe, checked exceptions
 */
export const safe_exceptions_checked = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-exceptions-checked`,
  "Safe, checked exceptions",
);

/**
 * Library for safe functions (deprecated)
 */
export const safe_failure = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-failure`,
  "Library for safe functions (deprecated)",
);

/**
 * control-monad-exception Instances for safe-failure
 */
export const safe_failure_cme = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-failure-cme`,
  "control-monad-exception Instances for safe-failure",
);

/**
 * Safe wrappers for null-partial Foldable operations
 */
export const safe_foldable = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-foldable`,
  "Safe wrappers for null-partial Foldable operations",
);

/**
 * Recursive Arbitrary instances without headaches
 */
export const safe_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-gen`,
  "Recursive Arbitrary instances without headaches",
);

/**
 * Automatic JSON format versioning
 */
export const safe_json = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-json`,
  "Automatic JSON format versioning",
);

/**
 * Automatic JSON format versioning
 */
export const safe_json_1_2_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-json_1_2_0_0`,
  "Automatic JSON format versioning",
);

/**
 * Type-safe and lossless encoding and manipulation of money, fiat currencies, crypto currencies and precious metals
 */
export const safe_money = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-money`,
  "Type-safe and lossless encoding and manipulation of money, fiat currencies, crypto currencies and precious metals",
);

/**
 * Instances from the aeson library for the safe-money library
 */
export const safe_money_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-money-aeson`,
  "Instances from the aeson library for the safe-money library",
);

/**
 * Instances from the cereal library for the safe-money library
 */
export const safe_money_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-money-cereal`,
  "Instances from the cereal library for the safe-money library",
);

/**
 * Instances from the serialise library for the safe-money library
 */
export const safe_money_serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-money-serialise`,
  "Instances from the serialise library for the safe-money library",
);

/**
 * Instances from the store library for the safe-money library
 */
export const safe_money_store = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-money-store`,
  "Instances from the store library for the safe-money library",
);

/**
 * Safe arithmetic operations
 */
export const safe_numeric = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-numeric`,
  "Safe arithmetic operations",
);

/**
 * A small wrapper over hs-plugins to allow loading safe plugins
 */
export const safe_plugins = mkPackage(
  nixRaw`pkgs.haskellPackages.safe-plugins`,
  "A small wrapper over hs-plugins to allow loading safe plugins",
);

/**
 * Binary serialization with version control
 */
export const safecopy = mkPackage(
  nixRaw`pkgs.haskellPackages.safecopy`,
  "Binary serialization with version control",
);

/**
 * Type-safe file handling
 */
export const safer_file_handles = mkPackage(
  nixRaw`pkgs.haskellPackages.safer-file-handles`,
  "Type-safe file handling",
);

/**
 * Extends safer-file-handles with ByteString operations
 */
export const safer_file_handles_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.safer-file-handles-bytestring`,
  "Extends safer-file-handles with ByteString operations",
);

/**
 * Extends safer-file-handles with Text operations
 */
export const safer_file_handles_text = mkPackage(
  nixRaw`pkgs.haskellPackages.safer-file-handles-text`,
  "Extends safer-file-handles with Text operations",
);

/**
 * Obtain homogeneous values from arbitrary values, transforming or culling data
 */
export const sai_shape_syb = mkPackage(
  nixRaw`pkgs.haskellPackages.sai-shape-syb`,
  "Obtain homogeneous values from arbitrary values, transforming or culling data",
);

/**
 * Compression command-line tool
 */
export const sak = mkPackage(
  nixRaw`pkgs.haskellPackages.sak`,
  "Compression command-line tool",
);

/**
 * Configuration Loader for toml
 */
export const salak_toml = mkPackage(
  nixRaw`pkgs.haskellPackages.salak-toml`,
  "Configuration Loader for toml",
);

/**
 * Configuration Loader for yaml
 */
export const salak_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.salak-yaml`,
  "Configuration Loader for yaml",
);

/**
 * Cryptography that's easy to digest (NaCl/libsodium bindings)
 */
export const saltine = mkPackage(
  nixRaw`pkgs.haskellPackages.saltine`,
  "Cryptography that's easy to digest (NaCl/libsodium bindings)",
);

/**
 * Quickcheck implementations for some NaCl data
 */
export const saltine_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.saltine-quickcheck`,
  "Quickcheck implementations for some NaCl data",
);

/**
 * Semantic version numbers and constraints
 */
export const salve = mkPackage(
  nixRaw`pkgs.haskellPackages.salve`,
  "Semantic version numbers and constraints",
);

/**
 * Modular web application framework
 */
export const salvia = mkPackage(
  nixRaw`pkgs.haskellPackages.salvia`,
  "Modular web application framework",
);

/**
 * Demo Salvia servers
 */
export const salvia_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.salvia-demo`,
  "Demo Salvia servers",
);

/**
 * Collection of non-fundamental handlers for the Salvia web server
 */
export const salvia_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.salvia-extras`,
  "Collection of non-fundamental handlers for the Salvia web server",
);

/**
 * Session support for the Salvia webserver
 */
export const salvia_sessions = mkPackage(
  nixRaw`pkgs.haskellPackages.salvia-sessions`,
  "Session support for the Salvia webserver",
);

/**
 * Websocket implementation for the Salvia Webserver
 */
export const salvia_websocket = mkPackage(
  nixRaw`pkgs.haskellPackages.salvia-websocket`,
  "Websocket implementation for the Salvia Webserver",
);

/**
 * Handling of samples in an (audio) signal
 */
export const sample_frame = mkPackage(
  nixRaw`pkgs.haskellPackages.sample-frame`,
  "Handling of samples in an (audio) signal",
);

/**
 * Orphan instances for types from sample-frame and numericprelude
 */
export const sample_frame_np = mkPackage(
  nixRaw`pkgs.haskellPackages.sample-frame-np`,
  "Orphan instances for types from sample-frame and numericprelude",
);

/**
 * Sample values from collections
 */
export const sampling = mkPackage(
  nixRaw`pkgs.haskellPackages.sampling`,
  "Sample values from collections",
);

/**
 * Binding to the C samtools library
 */
export const samtools = mkPackage(
  nixRaw`pkgs.haskellPackages.samtools`,
  "Binding to the C samtools library",
);

/**
 * Conduit interface to SAM/BAM format files through samtools
 */
export const samtools_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.samtools-conduit`,
  "Conduit interface to SAM/BAM format files through samtools",
);

/**
 * Enumerator interface to SamTools library
 */
export const samtools_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.samtools-enumerator`,
  "Enumerator interface to SamTools library",
);

/**
 * Iteratee interface to SamTools library
 */
export const samtools_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.samtools-iteratee`,
  "Iteratee interface to SamTools library",
);

/**
 * Data encoding library
 */
export const sandi = mkPackage(
  nixRaw`pkgs.haskellPackages.sandi`,
  "Data encoding library",
);

/**
 * Yet another test framework for Haskell
 */
export const sandwich = mkPackage(
  nixRaw`pkgs.haskellPackages.sandwich`,
  "Yet another test framework for Haskell",
);

/**
 * Sandwich integration with Hedgehog
 */
export const sandwich_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.sandwich-hedgehog`,
  "Sandwich integration with Hedgehog",
);

/**
 * Sandwich integration with QuickCheck
 */
export const sandwich_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.sandwich-quickcheck`,
  "Sandwich integration with QuickCheck",
);

/**
 * Sandwich integration with Slack
 */
export const sandwich_slack = mkPackage(
  nixRaw`pkgs.haskellPackages.sandwich-slack`,
  "Sandwich integration with Slack",
);

/**
 * Sandwich integration with Selenium WebDriver
 */
export const sandwich_webdriver = mkPackage(
  nixRaw`pkgs.haskellPackages.sandwich-webdriver`,
  "Sandwich integration with Selenium WebDriver",
);

/**
 * SARIF implementation for Haskell
 */
export const sarif = mkPackage(
  nixRaw`pkgs.haskellPackages.sarif`,
  "SARIF implementation for Haskell",
);

/**
 * A universal quickfix toolkit and his protocol
 */
export const sarsi = mkPackage(
  nixRaw`pkgs.haskellPackages.sarsi`,
  "A universal quickfix toolkit and his protocol",
);

/**
 * A staged lexer generator
 */
export const sasha = mkPackage(
  nixRaw`pkgs.haskellPackages.sasha`,
  "A staged lexer generator",
);

/**
 * SASL implementation using simple-pipe
 */
export const sasl = mkPackage(
  nixRaw`pkgs.haskellPackages.sasl`,
  "SASL implementation using simple-pipe",
);

/**
 * A minimal SAT solver
 */
export const sat_micro_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.sat-micro-hs`,
  "A minimal SAT solver",
);

/**
 * SAT encoding monad
 */
export const satchmo = mkPackage(
  nixRaw`pkgs.haskellPackages.satchmo`,
  "SAT encoding monad",
);

/**
 * examples that show how to use satchmo
 */
export const satchmo_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.satchmo-examples`,
  "examples that show how to use satchmo",
);

/**
 * funsat driver as backend for satchmo
 */
export const satchmo_funsat = mkPackage(
  nixRaw`pkgs.haskellPackages.satchmo-funsat`,
  "funsat driver as backend for satchmo",
);

/**
 * toysat driver as backend for satchmo
 */
export const satchmo_toysat = mkPackage(
  nixRaw`pkgs.haskellPackages.satchmo-toysat`,
  "toysat driver as backend for satchmo",
);

/**
 * Handle POSIX cron schedules
 */
export const saturn = mkPackage(
  nixRaw`pkgs.haskellPackages.saturn`,
  "Handle POSIX cron schedules",
);

/**
 * The eye that watches everything you did on Twitter
 */
export const sauron = mkPackage(
  nixRaw`pkgs.haskellPackages.sauron`,
  "The eye that watches everything you did on Twitter",
);

/**
 * Send textual messages to a Handle in a thread-friendly way
 */
export const say = mkPackage(
  nixRaw`pkgs.haskellPackages.say`,
  "Send textual messages to a Handle in a thread-friendly way",
);

/**
 * Require explicit type application for some type variables
 */
export const say_my_name = mkPackage(
  nixRaw`pkgs.haskellPackages.say-my-name`,
  "Require explicit type application for some type variables",
);

/**
 * Data structures, classes and operators for constructing context-adjusted pretty output
 */
export const sayable = mkPackage(
  nixRaw`pkgs.haskellPackages.sayable`,
  "Data structures, classes and operators for constructing context-adjusted pretty output",
);

/**
 * SwiftNav's SBP Library
 */
export const sbp = mkPackage(
  nixRaw`pkgs.haskellPackages.sbp`,
  "SwiftNav's SBP Library",
);

/**
 * SBP to UDP
 */
export const sbp2udp = mkPackage(
  nixRaw`pkgs.haskellPackages.sbp2udp`,
  "SBP to UDP",
);

/**
 * SwiftNav's SBP Library
 */
export const sbp_5_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.sbp_5_0_1`,
  "SwiftNav's SBP Library",
);

/**
 * Formally prove properties of Haskell programs using SBV/SMT
 */
export const sbvPlugin = mkPackage(
  nixRaw`pkgs.haskellPackages.sbvPlugin`,
  "Formally prove properties of Haskell programs using SBV/SMT",
);

/**
 * Component-based program synthesis using SBV
 */
export const sbv_program = mkPackage(
  nixRaw`pkgs.haskellPackages.sbv-program`,
  "Component-based program synthesis using SBV",
);

/**
 * Low-level Starcraft II API
 */
export const sc2_lowlevel = mkPackage(
  nixRaw`pkgs.haskellPackages.sc2-lowlevel`,
  "Low-level Starcraft II API",
);

/**
 * A protocol buffer model for the Starcraft II bot API
 */
export const sc2_proto = mkPackage(
  nixRaw`pkgs.haskellPackages.sc2-proto`,
  "A protocol buffer model for the Starcraft II bot API",
);

/**
 * Support and utility library for sc2hs
 */
export const sc2_support = mkPackage(
  nixRaw`pkgs.haskellPackages.sc2-support`,
  "Support and utility library for sc2hs",
);

/**
 * An interface to the Starcraft II bot API
 */
export const sc2hs = mkPackage(
  nixRaw`pkgs.haskellPackages.sc2hs`,
  "An interface to the Starcraft II bot API",
);

/**
 * Haskell bindings to sc3-rdu (sc3 rd ugens)
 */
export const sc3_rdu = mkPackage(
  nixRaw`pkgs.haskellPackages.sc3-rdu`,
  "Haskell bindings to sc3-rdu (sc3 rd ugens)",
);

/**
 * Library for writing fast/scalable TCP-based services
 */
export const scalable_server = mkPackage(
  nixRaw`pkgs.haskellPackages.scalable-server`,
  "Library for writing fast/scalable TCP-based services",
);

/**
 * Test webhooks locally
 */
export const scalp_webhooks = mkPackage(
  nixRaw`pkgs.haskellPackages.scalp-webhooks`,
  "Test webhooks locally",
);

/**
 * A high level web scraping library for Haskell
 */
export const scalpel = mkPackage(
  nixRaw`pkgs.haskellPackages.scalpel`,
  "A high level web scraping library for Haskell",
);

/**
 * A high level web scraping library for Haskell
 */
export const scalpel_core = mkPackage(
  nixRaw`pkgs.haskellPackages.scalpel-core`,
  "A high level web scraping library for Haskell",
);

/**
 * scalpel scrapers for search engines
 */
export const scalpel_search = mkPackage(
  nixRaw`pkgs.haskellPackages.scalpel-search`,
  "scalpel scrapers for search engines",
);

/**
 * lexical style suggestions for source code
 */
export const scan = mkPackage(
  nixRaw`pkgs.haskellPackages.scan`,
  "lexical style suggestions for source code",
);

/**
 * Metadata types for Albedo Scanners
 */
export const scan_metadata = mkPackage(
  nixRaw`pkgs.haskellPackages.scan-metadata`,
  "Metadata types for Albedo Scanners",
);

/**
 * An implementation of the Scan Vector Machine instruction set in Haskell
 */
export const scan_vector_machine = mkPackage(
  nixRaw`pkgs.haskellPackages.scan-vector-machine`,
  "An implementation of the Scan Vector Machine instruction set in Haskell",
);

/**
 * Easy and type-safe format strings for parsing and printing
 */
export const scanf = mkPackage(
  nixRaw`pkgs.haskellPackages.scanf`,
  "Easy and type-safe format strings for parsing and printing",
);

/**
 * Fast non-backtracking incremental combinator parsing for bytestrings
 */
export const scanner = mkPackage(
  nixRaw`pkgs.haskellPackages.scanner`,
  "Fast non-backtracking incremental combinator parsing for bytestrings",
);

/**
 * Inject attoparsec parser with backtracking into non-backtracking scanner
 */
export const scanner_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.scanner-attoparsec`,
  "Inject attoparsec parser with backtracking into non-backtracking scanner",
);

/**
 * Scene Graph
 */
export const scenegraph = mkPackage(
  nixRaw`pkgs.haskellPackages.scenegraph`,
  "Scene Graph",
);

/**
 * Pure deterministic scheduled computations
 */
export const schedule = mkPackage(
  nixRaw`pkgs.haskellPackages.schedule`,
  "Pure deterministic scheduled computations",
);

/**
 * Work stealing scheduler
 */
export const scheduler = mkPackage(
  nixRaw`pkgs.haskellPackages.scheduler`,
  "Work stealing scheduler",
);

/**
 * An interview scheduler using constraint satisfaction and Google Sheets
 */
export const scheduling = mkPackage(
  nixRaw`pkgs.haskellPackages.scheduling`,
  "An interview scheduler using constraint satisfaction and Google Sheets",
);

/**
 * Encoding-independent schemas for Haskell data types
 */
export const schema = mkPackage(
  nixRaw`pkgs.haskellPackages.schema`,
  "Encoding-independent schemas for Haskell data types",
);

/**
 * JSON-biased spec and validation tool
 */
export const schematic = mkPackage(
  nixRaw`pkgs.haskellPackages.schematic`,
  "JSON-biased spec and validation tool",
);

/**
 * Converts ScholarlyMarkdown documents to HTML5/LaTeX/Docx format
 */
export const scholdoc = mkPackage(
  nixRaw`pkgs.haskellPackages.scholdoc`,
  "Converts ScholarlyMarkdown documents to HTML5/LaTeX/Docx format",
);

/**
 * Scholdoc fork of pandoc-citeproc
 */
export const scholdoc_citeproc = mkPackage(
  nixRaw`pkgs.haskellPackages.scholdoc-citeproc`,
  "Scholdoc fork of pandoc-citeproc",
);

/**
 * Scholdoc fork of texmath
 */
export const scholdoc_texmath = mkPackage(
  nixRaw`pkgs.haskellPackages.scholdoc-texmath`,
  "Scholdoc fork of texmath",
);

/**
 * Transformation of n-ary functions to unary functions
 */
export const schonfinkeling = mkPackage(
  nixRaw`pkgs.haskellPackages.schonfinkeling`,
  "Transformation of n-ary functions to unary functions",
);

/**
 * Mathematical/physical/chemical constants
 */
export const science_constants = mkPackage(
  nixRaw`pkgs.haskellPackages.science-constants`,
  "Mathematical/physical/chemical constants",
);

/**
 * Mathematical/physical/chemical constants
 */
export const science_constants_dimensional = mkPackage(
  nixRaw`pkgs.haskellPackages.science-constants-dimensional`,
  "Mathematical/physical/chemical constants",
);

/**
 * Numbers represented using scientific notation
 */
export const scientific = mkPackage(
  nixRaw`pkgs.haskellPackages.scientific`,
  "Numbers represented using scientific notation",
);

/**
 * Scientific notation intended for tokenization
 */
export const scientific_notation = mkPackage(
  nixRaw`pkgs.haskellPackages.scientific-notation`,
  "Scientific notation intended for tokenization",
);

/**
 * A Haskell library for carefully refactoring critical paths
 */
export const scientist = mkPackage(
  nixRaw`pkgs.haskellPackages.scientist`,
  "A Haskell library for carefully refactoring critical paths",
);

/**
 * Haskell IDE library
 */
export const scion = mkPackage(
  nixRaw`pkgs.haskellPackages.scion`,
  "Haskell IDE library",
);

/**
 * Command-line interface for browsing and searching packages documentation
 */
export const scion_browser = mkPackage(
  nixRaw`pkgs.haskellPackages.scion-browser`,
  "Command-line interface for browsing and searching packages documentation",
);

/**
 * An interactive renderer for plotting time-series data
 */
export const scope = mkPackage(
  nixRaw`pkgs.haskellPackages.scope`,
  "An interactive renderer for plotting time-series data",
);

/**
 * An interactive renderer for plotting time-series data
 */
export const scope_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.scope-cairo`,
  "An interactive renderer for plotting time-series data",
);

/**
 * Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp
 */
export const scotty = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty`,
  "Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp",
);

/**
 * Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp
 */
export const scotty_0_20_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty_0_20_1`,
  "Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp",
);

/**
 * Cookie management helper functions for Scotty framework
 */
export const scotty_cookie = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-cookie`,
  "Cookie management helper functions for Scotty framework",
);

/**
 * Fay integration for Scotty
 */
export const scotty_fay = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-fay`,
  "Fay integration for Scotty",
);

/**
 * Html form validation using `ditto`
 */
export const scotty_form = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-form`,
  "Html form validation using `ditto`",
);

/**
 * Easy Mustache templating support for Scotty
 */
export const scotty_hastache = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-hastache`,
  "Easy Mustache templating support for Scotty",
);

/**
 * Combine scotty and haxl
 */
export const scotty_haxl = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-haxl`,
  "Combine scotty and haxl",
);

/**
 * HTTP-request's query parameters parser abstraction for "scotty"
 */
export const scotty_params_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-params-parser`,
  "HTTP-request's query parameters parser abstraction for \"scotty\"",
);

/**
 * Redirect to a normalized path
 */
export const scotty_path_normalizer = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-path-normalizer`,
  "Redirect to a normalized path",
);

/**
 * Scotty utils library
 */
export const scotty_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.scotty-utils`,
  "Scotty utils library",
);

/**
 * An SCP protocol implementation
 */
export const scp_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.scp-streams`,
  "An SCP protocol implementation",
);

/**
 * Scrabble play generation
 */
export const scrabble_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.scrabble-bot`,
  "Scrabble play generation",
);

/**
 * collect posts of site that is wrote in config yaml using feed or scraping
 */
export const scrapbook = mkPackage(
  nixRaw`pkgs.haskellPackages.scrapbook`,
  "collect posts of site that is wrote in config yaml using feed or scraping",
);

/**
 * Take screenshot and copy it to the system clipboard
 */
export const screenshot_to_clipboard = mkPackage(
  nixRaw`pkgs.haskellPackages.screenshot-to-clipboard`,
  "Take screenshot and copy it to the system clipboard",
);

/**
 * scroll(6), a roguelike game
 */
export const scroll = mkPackage(
  nixRaw`pkgs.haskellPackages.scroll`,
  "scroll(6), a roguelike game",
);

/**
 * Stronger password hashing via sequential memory-hard functions
 */
export const scrypt = mkPackage(
  nixRaw`pkgs.haskellPackages.scrypt`,
  "Stronger password hashing via sequential memory-hard functions",
);

/**
 * Multidimensional integration over simplices
 */
export const scubature = mkPackage(
  nixRaw`pkgs.haskellPackages.scubature`,
  "Multidimensional integration over simplices",
);

/**
 * generic types for Secure Scuttlebutt
 */
export const scuttlebutt_types = mkPackage(
  nixRaw`pkgs.haskellPackages.scuttlebutt-types`,
  "generic types for Secure Scuttlebutt",
);

/**
 * A parser for SDF version 2.1 using Parsec
 */
export const sdf2p1_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.sdf2p1-parser`,
  "A parser for SDF version 2.1 using Parsec",
);

/**
 * Both high- and low-level bindings to the SDL library (version 2.0.6+).
 */
export const sdl2 = mkPackage(
  nixRaw`pkgs.haskellPackages.sdl2`,
  "Both high- and low-level bindings to the SDL library (version 2.0.6+).",
);

/**
 * Render with Cairo on SDL textures
 */
export const sdl2_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.sdl2-cairo`,
  "Render with Cairo on SDL textures",
);

/**
 * Sprite previewer/animator
 */
export const sdl2_sprite = mkPackage(
  nixRaw`pkgs.haskellPackages.sdl2-sprite`,
  "Sprite previewer/animator",
);

/**
 * small testing tool for sdl2 and accelerated drivers
 */
export const sdl_try_drivers = mkPackage(
  nixRaw`pkgs.haskellPackages.sdl-try-drivers`,
  "small testing tool for sdl2 and accelerated drivers",
);

/**
 * Self-delimiting numeric values encoding library
 */
export const sdnv = mkPackage(
  nixRaw`pkgs.haskellPackages.sdnv`,
  "Self-delimiting numeric values encoding library",
);

/**
 * SDP wrapper for ByteString
 */
export const sdp4bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp4bytestring`,
  "SDP wrapper for ByteString",
);

/**
 * SDP wrapper for Text
 */
export const sdp4text = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp4text`,
  "SDP wrapper for Text",
);

/**
 * SDP classes for unordered containers
 */
export const sdp4unordered = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp4unordered`,
  "SDP classes for unordered containers",
);

/**
 * SDP wrapper for Vector
 */
export const sdp4vector = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp4vector`,
  "SDP wrapper for Vector",
);

/**
 * Binary instances for SDP
 */
export const sdp_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp-binary`,
  "Binary instances for SDP",
);

/**
 * DeepSeq SDP extension
 */
export const sdp_deepseq = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp-deepseq`,
  "DeepSeq SDP extension",
);

/**
 * Hashable instances for SDP
 */
export const sdp_hashable = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp-hashable`,
  "Hashable instances for SDP",
);

/**
 * SDP IO extension
 */
export const sdp_io = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp-io`,
  "SDP IO extension",
);

/**
 * SDP QuickCheck support
 */
export const sdp_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.sdp-quickcheck`,
  "SDP QuickCheck support",
);

/**
 * A software defined radio library
 */
export const sdr = mkPackage(
  nixRaw`pkgs.haskellPackages.sdr`,
  "A software defined radio library",
);

/**
 * PostgreSQL backend for Seakale
 */
export const seakale_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.seakale-postgresql`,
  "PostgreSQL backend for Seakale",
);

/**
 * Helpers to test code using Seakale
 */
export const seakale_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.seakale-tests`,
  "Helpers to test code using Seakale",
);

/**
 * Template Haskell support for global configuration data
 */
export const seal_module = mkPackage(
  nixRaw`pkgs.haskellPackages.seal-module`,
  "Template Haskell support for global configuration data",
);

/**
 * Infinite search in finite time with Hilbert's epsilon
 */
export const search = mkPackage(
  nixRaw`pkgs.haskellPackages.search`,
  "Infinite search in finite time with Hilbert's epsilon",
);

/**
 * Common graph search algorithms
 */
export const search_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.search-algorithms`,
  "Common graph search algorithms",
);

/**
 * A Haskell implementation of the SECD abstract machine
 */
export const secd = mkPackage(
  nixRaw`pkgs.haskellPackages.secd`,
  "A Haskell implementation of the SECD abstract machine",
);

/**
 * Bindings for secp256k1
 */
export const secp256k1_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.secp256k1-haskell`,
  "Bindings for secp256k1",
);

/**
 * Bindings for secp256k1
 */
export const secp256k1_haskell_1_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.secp256k1-haskell_1_0_1`,
  "Bindings for secp256k1",
);

/**
 * Information-theoretic secure secret sharing
 */
export const secret_sharing = mkPackage(
  nixRaw`pkgs.haskellPackages.secret-sharing`,
  "Information-theoretic secure secret sharing",
);

/**
 * Example of writing "secure" file removal in Haskell rather than C
 */
export const secrm = mkPackage(
  nixRaw`pkgs.haskellPackages.secrm`,
  "Example of writing \"secure\" file removal in Haskell rather than C",
);

/**
 * abstraction to an auto scrubbing and const time eq, memory chunk
 */
export const securemem = mkPackage(
  nixRaw`pkgs.haskellPackages.securemem`,
  "abstraction to an auto scrubbing and const time eq, memory chunk",
);

/**
 * Sedna C API XML Binding
 */
export const sednaDBXML = mkPackage(
  nixRaw`pkgs.haskellPackages.sednaDBXML`,
  "Sedna C API XML Binding",
);

/**
 * Read and Display Seitz Symbol
 */
export const seitz_symbol = mkPackage(
  nixRaw`pkgs.haskellPackages.seitz-symbol`,
  "Read and Display Seitz Symbol",
);

/**
 * JSON support for the Selda database library
 */
export const selda_json = mkPackage(
  nixRaw`pkgs.haskellPackages.selda-json`,
  "JSON support for the Selda database library",
);

/**
 * PostgreSQL backend for the Selda database EDSL
 */
export const selda_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.selda-postgresql`,
  "PostgreSQL backend for the Selda database EDSL",
);

/**
 * SQLite backend for the Selda database EDSL
 */
export const selda_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.selda-sqlite`,
  "SQLite backend for the Selda database EDSL",
);

/**
 * Wrap the select(2) POSIX function
 */
export const select = mkPackage(
  nixRaw`pkgs.haskellPackages.select`,
  "Wrap the select(2) POSIX function",
);

/**
 * Combinators for operating with selections over an underlying functor
 */
export const selections = mkPackage(
  nixRaw`pkgs.haskellPackages.selections`,
  "Combinators for operating with selections over an underlying functor",
);

/**
 * Selective applicative functors
 */
export const selective = mkPackage(
  nixRaw`pkgs.haskellPackages.selective`,
  "Selective applicative functors",
);

/**
 * Run the selenium standalone server for usage with webdriver
 */
export const selenium_server = mkPackage(
  nixRaw`pkgs.haskellPackages.selenium-server`,
  "Run the selenium standalone server for usage with webdriver",
);

/**
 * A Haskell library to make self-extracting executables
 */
export const self_extract = mkPackage(
  nixRaw`pkgs.haskellPackages.self-extract`,
  "A Haskell library to make self-extracting executables",
);

/**
 * Restarts the current executable (on binary change)
 */
export const selfrestart = mkPackage(
  nixRaw`pkgs.haskellPackages.selfrestart`,
  "Restarts the current executable (on binary change)",
);

/**
 * Framework and service for analyzing and diffing untrusted code
 */
export const semantic = mkPackage(
  nixRaw`pkgs.haskellPackages.semantic`,
  "Framework and service for analyzing and diffing untrusted code",
);

/**
 * Types and functionality for working with source code
 */
export const semantic_source = mkPackage(
  nixRaw`pkgs.haskellPackages.semantic-source`,
  "Types and functionality for working with source code",
);

/**
 * Various concurrency abstractions built on top of semaphores
 */
export const semaphore_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.semaphore-plus`,
  "Various concurrency abstractions built on top of semaphores",
);

/**
 * Weakened partial isomorphisms, reversible computations
 */
export const semi_iso = mkPackage(
  nixRaw`pkgs.haskellPackages.semi-iso`,
  "Weakened partial isomorphisms, reversible computations",
);

/**
 * Align and Zip type-classes from the common Semialign ancestor
 */
export const semialign = mkPackage(
  nixRaw`pkgs.haskellPackages.semialign`,
  "Align and Zip type-classes from the common Semialign ancestor",
);

/**
 * Extra functions for working with Semialigns
 */
export const semialign_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.semialign-extras`,
  "Extra functions for working with Semialigns",
);

/**
 * Semigroupoids that depend on PolyKinds
 */
export const semigroupoid_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.semigroupoid-extras`,
  "Semigroupoids that depend on PolyKinds",
);

/**
 * Semigroupoids: Category sans id
 */
export const semigroupoids = mkPackage(
  nixRaw`pkgs.haskellPackages.semigroupoids`,
  "Semigroupoids: Category sans id",
);

/**
 * Semigroupoids: Category sans id
 */
export const semigroupoids_6_0_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.semigroupoids_6_0_0_1`,
  "Semigroupoids: Category sans id",
);

/**
 * Support for QualifiedDo with semigroupoids classes
 */
export const semigroupoids_do = mkPackage(
  nixRaw`pkgs.haskellPackages.semigroupoids-do`,
  "Support for QualifiedDo with semigroupoids classes",
);

/**
 * Anything that associates
 */
export const semigroups = mkPackage(
  nixRaw`pkgs.haskellPackages.semigroups`,
  "Anything that associates",
);

/**
 * Semirings, ring-like structures used for dynamic programming applications
 */
export const semiring = mkPackage(
  nixRaw`pkgs.haskellPackages.semiring`,
  "Semirings, ring-like structures used for dynamic programming applications",
);

/**
 * Basic semiring class and instances
 */
export const semiring_num = mkPackage(
  nixRaw`pkgs.haskellPackages.semiring-num`,
  "Basic semiring class and instances",
);

/**
 * A module for dealing with semirings
 */
export const semiring_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.semiring-simple`,
  "A module for dealing with semirings",
);

/**
 * two monoids as one, in holy haskimony
 */
export const semirings = mkPackage(
  nixRaw`pkgs.haskellPackages.semirings`,
  "two monoids as one, in holy haskimony",
);

/**
 * Representation, manipulation, and de/serialisation of Semantic Versions
 */
export const semver = mkPackage(
  nixRaw`pkgs.haskellPackages.semver`,
  "Representation, manipulation, and de/serialisation of Semantic Versions",
);

/**
 * An implementation of semver and semantic version ranges
 */
export const semver_range = mkPackage(
  nixRaw`pkgs.haskellPackages.semver-range`,
  "An implementation of semver and semantic version ranges",
);

/**
 * A portable sendfile library
 */
export const sendfile = mkPackage(
  nixRaw`pkgs.haskellPackages.sendfile`,
  "A portable sendfile library",
);

/**
 * Automatically run Hspec tests on file modifications
 */
export const sensei = mkPackage(
  nixRaw`pkgs.haskellPackages.sensei`,
  "Automatically run Hspec tests on file modifications",
);

/**
 * Distributed sensor network for the raspberry pi
 */
export const sensenet = mkPackage(
  nixRaw`pkgs.haskellPackages.sensenet`,
  "Distributed sensor network for the raspberry pi",
);

/**
 * Easily generating message of japanese natural language
 */
export const sentence_jp = mkPackage(
  nixRaw`pkgs.haskellPackages.sentence-jp`,
  "Easily generating message of japanese natural language",
);

/**
 * Parser for the SentiWordNet tab-separated file
 */
export const sentiwordnet_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.sentiwordnet-parser`,
  "Parser for the SentiWordNet tab-separated file",
);

/**
 * None
 */
export const senza = mkPackage(
  nixRaw`pkgs.haskellPackages.senza`,
  "None",
);

/**
 * Check for common SEO mistakes on CI
 */
export const seocheck = mkPackage(
  nixRaw`pkgs.haskellPackages.seocheck`,
  "Check for common SEO mistakes on CI",
);

/**
 * Dynamic strictness control, including space leak repair
 */
export const seqaid = mkPackage(
  nixRaw`pkgs.haskellPackages.seqaid`,
  "Dynamic strictness control, including space leak repair",
);

/**
 * Sequence Alignment
 */
export const seqalign = mkPackage(
  nixRaw`pkgs.haskellPackages.seqalign`,
  "Sequence Alignment",
);

/**
 * Sequence ID production and consumption
 */
export const seqid = mkPackage(
  nixRaw`pkgs.haskellPackages.seqid`,
  "Sequence ID production and consumption",
);

/**
 * Sequence ID IO-Streams
 */
export const seqid_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.seqid-streams`,
  "Sequence ID IO-Streams",
);

/**
 * Handle sequence locations for bioinformatics
 */
export const seqloc = mkPackage(
  nixRaw`pkgs.haskellPackages.seqloc`,
  "Handle sequence locations for bioinformatics",
);

/**
 * Read and write BED and GTF format genome annotations
 */
export const seqloc_datafiles = mkPackage(
  nixRaw`pkgs.haskellPackages.seqloc-datafiles`,
  "Read and write BED and GTF format genome annotations",
);

/**
 * A type class for sequences and various sequence data structures
 */
export const sequence = mkPackage(
  nixRaw`pkgs.haskellPackages.sequence`,
  "A type class for sequences and various sequence data structures",
);

/**
 * A package with tools for processing DNA sequencing data
 */
export const sequenceTools = mkPackage(
  nixRaw`pkgs.haskellPackages.sequenceTools`,
  "A package with tools for processing DNA sequencing data",
);

/**
 * A package with basic parsing utilities for several Bioinformatic data formats
 */
export const sequence_formats = mkPackage(
  nixRaw`pkgs.haskellPackages.sequence-formats`,
  "A package with basic parsing utilities for several Bioinformatic data formats",
);

/**
 * A sequence labeler based on Collins's sequence perceptron
 */
export const sequor = mkPackage(
  nixRaw`pkgs.haskellPackages.sequor`,
  "A sequence labeler based on Collins's sequence perceptron",
);

/**
 * POSIX serial port wrapper
 */
export const serial = mkPackage(
  nixRaw`pkgs.haskellPackages.serial`,
  "POSIX serial port wrapper",
);

/**
 * Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time
 */
export const serial_test_generators = mkPackage(
  nixRaw`pkgs.haskellPackages.serial-test-generators`,
  "Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time",
);

/**
 * A binary serialisation library for Haskell values
 */
export const serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.serialise`,
  "A binary serialisation library for Haskell values",
);

/**
 * Encode and decode UUID values in CBOR using uuid-types, cborg and serialise
 */
export const serialise_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.serialise-uuid`,
  "Encode and decode UUID values in CBOR using uuid-types, cborg and serialise",
);

/**
 * Simple project template from stack
 */
export const serpentine = mkPackage(
  nixRaw`pkgs.haskellPackages.serpentine`,
  "Simple project template from stack",
);

/**
 * Dependently typed API framework
 */
export const serv = mkPackage(
  nixRaw`pkgs.haskellPackages.serv`,
  "Dependently typed API framework",
);

/**
 * Dependently typed API servers with Serv
 */
export const serv_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.serv-wai`,
  "Dependently typed API servers with Serv",
);

/**
 * A family of combinators for defining webservices APIs
 */
export const servant = mkPackage(
  nixRaw`pkgs.haskellPackages.servant`,
  "A family of combinators for defining webservices APIs",
);

/**
 * A family of combinators for defining webservices APIs
 */
export const servant_0_20_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant_0_20_1`,
  "A family of combinators for defining webservices APIs",
);

/**
 * Authentication combinators for servant
 */
export const servant_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth`,
  "Authentication combinators for servant",
);

/**
 * servant-client/servant-auth compatibility
 */
export const servant_auth_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-client`,
  "servant-client/servant-auth compatibility",
);

/**
 * servant-docs/servant-auth compatibility
 */
export const servant_auth_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-docs`,
  "servant-docs/servant-auth compatibility",
);

/**
 * servant-docs/servant-auth compatibility
 */
export const servant_auth_docs_0_2_10_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-docs_0_2_10_1`,
  "servant-docs/servant-auth compatibility",
);

/**
 * Authentication via HMAC
 */
export const servant_auth_hmac = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-hmac`,
  "Authentication via HMAC",
);

/**
 * servant-swagger/servant-auth compatibility
 */
export const servant_auth_swagger = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-swagger`,
  "servant-swagger/servant-auth compatibility",
);

/**
 * Servant based API and server for token based authorisation
 */
export const servant_auth_token = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token`,
  "Servant based API and server for token based authorisation",
);

/**
 * Acid-state backend for servant-auth-token server
 */
export const servant_auth_token_acid = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token-acid`,
  "Acid-state backend for servant-auth-token server",
);

/**
 * Servant based API for token based authorisation
 */
export const servant_auth_token_api = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token-api`,
  "Servant based API for token based authorisation",
);

/**
 * Leveldb backend for servant-auth-token server
 */
export const servant_auth_token_leveldb = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token-leveldb`,
  "Leveldb backend for servant-auth-token server",
);

/**
 * Persistent backend for servant-auth-token server
 */
export const servant_auth_token_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token-persistent`,
  "Persistent backend for servant-auth-token server",
);

/**
 * RocksDB backend for servant-auth-token server
 */
export const servant_auth_token_rocksdb = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-token-rocksdb`,
  "RocksDB backend for servant-auth-token server",
);

/**
 * Authenticate Routes Using Wordpress Cookies
 */
export const servant_auth_wordpress = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-auth-wordpress`,
  "Authenticate Routes Using Wordpress Cookies",
);

/**
 * Blaze-html support for servant
 */
export const servant_blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-blaze`,
  "Blaze-html support for servant",
);

/**
 * Servant CSV content-type for cassava
 */
export const servant_cassava = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-cassava`,
  "Servant CSV content-type for cassava",
);

/**
 * Checked exceptions for Servant APIs
 */
export const servant_checked_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-checked-exceptions`,
  "Checked exceptions for Servant APIs",
);

/**
 * Checked exceptions for Servant APIs
 */
export const servant_checked_exceptions_core = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-checked-exceptions-core`,
  "Checked exceptions for Servant APIs",
);

/**
 * Automatic derivation of querying functions for servant
 */
export const servant_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-client`,
  "Automatic derivation of querying functions for servant",
);

/**
 * Automatic derivation of querying functions for servant
 */
export const servant_client_0_20 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-client_0_20`,
  "Automatic derivation of querying functions for servant",
);

/**
 * Core functionality and class for client function generation for servant APIs
 */
export const servant_client_core = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-client-core`,
  "Core functionality and class for client function generation for servant APIs",
);

/**
 * Core functionality and class for client function generation for servant APIs
 */
export const servant_client_core_0_20 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-client-core_0_20`,
  "Core functionality and class for client function generation for servant APIs",
);

/**
 * Automatically derive API client functions with named and optional parameters
 */
export const servant_client_namedargs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-client-namedargs`,
  "Automatically derive API client functions with named and optional parameters",
);

/**
 * Servant Stream support for conduit
 */
export const servant_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-conduit`,
  "Servant Stream support for conduit",
);

/**
 * Servant Stream support for conduit
 */
export const servant_conduit_0_16 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-conduit_0_16`,
  "Servant Stream support for conduit",
);

/**
 * Generate servant client library for C#
 */
export const servant_csharp = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-csharp`,
  "Generate servant client library for C#",
);

/**
 * Derive a postgres client to database API specified by servant-db
 */
export const servant_db_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-db-postgresql`,
  "Derive a postgres client to database API specified by servant-db",
);

/**
 * generate API docs for your servant webservice
 */
export const servant_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-docs`,
  "generate API docs for your servant webservice",
);

/**
 * generate API docs for your servant webservice
 */
export const servant_docs_0_13 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-docs_0_13`,
  "generate API docs for your servant webservice",
);

/**
 * Combinators for rendering EDE templates in servant web applications
 */
export const servant_ede = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-ede`,
  "Combinators for rendering EDE templates in servant web applications",
);

/**
 * Helpers for using ekg with servant
 */
export const servant_ekg = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-ekg`,
  "Helpers for using ekg with servant",
);

/**
 * Automatically derive Elm functions to query servant webservices
 */
export const servant_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-elm`,
  "Automatically derive Elm functions to query servant webservices",
);

/**
 * Example programs for servant
 */
export const servant_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-examples`,
  "Example programs for servant",
);

/**
 * Extensible exceptions for servant APIs
 */
export const servant_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-exceptions`,
  "Extensible exceptions for servant APIs",
);

/**
 * Extensible exceptions for servant API servers
 */
export const servant_exceptions_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-exceptions-server`,
  "Extensible exceptions for servant API servers",
);

/**
 * Fiat content types
 */
export const servant_fiat_content = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-fiat-content`,
  "Fiat content types",
);

/**
 * Utilities for flattening servant API types
 */
export const servant_flatten = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-flatten`,
  "Utilities for flattening servant API types",
);

/**
 * Helpers for generating clients for servant APIs in any programming language
 */
export const servant_foreign = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-foreign`,
  "Helpers for generating clients for servant APIs in any programming language",
);

/**
 * Helpers for generating clients for servant APIs in any programming language
 */
export const servant_foreign_0_16 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-foreign_0_16`,
  "Helpers for generating clients for servant APIs in any programming language",
);

/**
 * automatical derivation of querying functions for servant webservices
 */
export const servant_haxl_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-haxl-client`,
  "automatical derivation of querying functions for servant webservices",
);

/**
 * Servant authentication with HMAC
 */
export const servant_hmac_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-hmac-auth`,
  "Servant authentication with HMAC",
);

/**
 * Generate HTTP2 clients from Servant API descriptions
 */
export const servant_http2_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-http2-client`,
  "Generate HTTP2 clients from Servant API descriptions",
);

/**
 * Automatically derive javascript functions to query servant webservices
 */
export const servant_js = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-js`,
  "Automatically derive javascript functions to query servant webservices",
);

/**
 * JSON-RPC messages and endpoints
 */
export const servant_jsonrpc = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-jsonrpc`,
  "JSON-RPC messages and endpoints",
);

/**
 * Generate JSON-RPC servant clients
 */
export const servant_jsonrpc_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-jsonrpc-client`,
  "Generate JSON-RPC servant clients",
);

/**
 * JSON-RPC servant servers
 */
export const servant_jsonrpc_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-jsonrpc-server`,
  "JSON-RPC servant servers",
);

/**
 * Servant support for lucid
 */
export const servant_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-lucid`,
  "Servant support for lucid",
);

/**
 * Servant Stream support for machines
 */
export const servant_machines = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-machines`,
  "Servant Stream support for machines",
);

/**
 * Servant Stream support for machines
 */
export const servant_machines_0_16 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-machines_0_16`,
  "Servant Stream support for machines",
);

/**
 * Standalone implementation of servants dispatching mechanism
 */
export const servant_match = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-match`,
  "Standalone implementation of servants dispatching mechanism",
);

/**
 * Matrix parameter combinator for servant
 */
export const servant_matrix_param = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-matrix-param`,
  "Matrix parameter combinator for servant",
);

/**
 * Derive a mock server for free from your servant API types
 */
export const servant_mock = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-mock`,
  "Derive a mock server for free from your servant API types",
);

/**
 * multipart/form-data (e.g file upload) support for servant
 */
export const servant_multipart = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-multipart`,
  "multipart/form-data (e.g file upload) support for servant",
);

/**
 * multipart/form-data (e.g file upload) support for servant
 */
export const servant_multipart_api = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-multipart-api`,
  "multipart/form-data (e.g file upload) support for servant",
);

/**
 * multipart/form-data (e.g file upload) support for servant
 */
export const servant_multipart_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-multipart-client`,
  "multipart/form-data (e.g file upload) support for servant",
);

/**
 * Add named endpoints to servant
 */
export const servant_named = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-named`,
  "Add named endpoints to servant",
);

/**
 * A library for OAuth2 authentication in servant
 */
export const servant_oauth2 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-oauth2`,
  "A library for OAuth2 authentication in servant",
);

/**
 * Example applications using this library in three ways
 */
export const servant_oauth2_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-oauth2-examples`,
  "Example applications using this library in three ways",
);

/**
 * Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.
 */
export const servant_openapi3 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-openapi3`,
  "Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.",
);

/**
 * Provide responses to OPTIONS requests for Servant applications
 */
export const servant_options = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-options`,
  "Provide responses to OPTIONS requests for Servant applications",
);

/**
 * Type-safe pagination for Servant APIs
 */
export const servant_pagination = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-pagination`,
  "Type-safe pagination for Servant APIs",
);

/**
 * Servant Stream support for pipes
 */
export const servant_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-pipes`,
  "Servant Stream support for pipes",
);

/**
 * Servant Stream support for pipes
 */
export const servant_pipes_0_16 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-pipes_0_16`,
  "Servant Stream support for pipes",
);

/**
 * Useful functions and instances for using servant with a PostgreSQL context
 */
export const servant_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-postgresql`,
  "Useful functions and instances for using servant with a PostgreSQL context",
);

/**
 * Servant Content-Type for proto-lens protobuf modules
 */
export const servant_proto_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-proto-lens`,
  "Servant Content-Type for proto-lens protobuf modules",
);

/**
 * Bindings to the Pushbullet API using servant-client
 */
export const servant_pushbullet_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-pushbullet-client`,
  "Bindings to the Pushbullet API using servant-client",
);

/**
 * Client support for servant-queryparam-core
 */
export const servant_queryparam_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-queryparam-client`,
  "Client support for servant-queryparam-core",
);

/**
 * Use records for query parameters in servant APIs
 */
export const servant_queryparam_core = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-queryparam-core`,
  "Use records for query parameters in servant APIs",
);

/**
 * Instances of classes from openapi3 for servant-queryparam-core
 */
export const servant_queryparam_openapi3 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-queryparam-openapi3`,
  "Instances of classes from openapi3 for servant-queryparam-core",
);

/**
 * Server support for servant-queryparam-core
 */
export const servant_queryparam_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-queryparam-server`,
  "Server support for servant-queryparam-core",
);

/**
 * Rate limiting for Servant
 */
export const servant_rate_limit = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-rate-limit`,
  "Rate limiting for Servant",
);

/**
 * Embed a raw 'Application' in a Servant API
 */
export const servant_rawm = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-rawm`,
  "Embed a raw 'Application' in a Servant API",
);

/**
 * The client implementation of servant-rawm
 */
export const servant_rawm_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-rawm-client`,
  "The client implementation of servant-rawm",
);

/**
 * Documentation generator for 'RawM' endpoints
 */
export const servant_rawm_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-rawm-docs`,
  "Documentation generator for 'RawM' endpoints",
);

/**
 * The server implementation of servant-rawm
 */
export const servant_rawm_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-rawm-server`,
  "The server implementation of servant-rawm",
);

/**
 * Derive Reason types to interact with a Haskell backend
 */
export const servant_reason = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-reason`,
  "Derive Reason types to interact with a Haskell backend",
);

/**
 * Machinery to express how servant should turn results of database operations into proper JSON-encodable response types
 */
export const servant_response = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-response`,
  "Machinery to express how servant should turn results of database operations into proper JSON-encodable response types",
);

/**
 * Automatically generate Servant API modules
 */
export const servant_serf = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-serf`,
  "Automatically generate Servant API modules",
);

export const servant_serialization = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-serialization`,
  "",
);

/**
 * A family of combinators for defining webservices APIs and serving them
 */
export const servant_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-server`,
  "A family of combinators for defining webservices APIs and serving them",
);

/**
 * A family of combinators for defining webservices APIs and serving them
 */
export const servant_server_0_20 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-server_0_20`,
  "A family of combinators for defining webservices APIs and serving them",
);

/**
 * Automatically derive API server functions with named and optional parameters
 */
export const servant_server_namedargs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-server-namedargs`,
  "Automatically derive API server functions with named and optional parameters",
);

/**
 * A family of combinators for defining webservices APIs and serving them
 */
export const servant_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-snap`,
  "A family of combinators for defining webservices APIs and serving them",
);

/**
 * Client instances for the 'servant-streaming' package
 */
export const servant_streaming_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-streaming-client`,
  "Client instances for the 'servant-streaming' package",
);

/**
 * Client instances for the 'servant-docs' package
 */
export const servant_streaming_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-streaming-docs`,
  "Client instances for the 'servant-docs' package",
);

/**
 * Server instances for the 'servant-streaming' package
 */
export const servant_streaming_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-streaming-server`,
  "Server instances for the 'servant-streaming' package",
);

/**
 * When REST is not enough ...
 */
export const servant_subscriber = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-subscriber`,
  "When REST is not enough ...",
);

/**
 * Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.
 */
export const servant_swagger = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger`,
  "Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.",
);

/**
 * Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.
 */
export const servant_swagger_1_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger_1_2`,
  "Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.",
);

/**
 * Swagger Tags for Servant
 */
export const servant_swagger_tags = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger-tags`,
  "Swagger Tags for Servant",
);

/**
 * Servant swagger ui
 */
export const servant_swagger_ui = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger-ui`,
  "Servant swagger ui",
);

/**
 * Servant swagger ui core components
 */
export const servant_swagger_ui_core = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger-ui-core`,
  "Servant swagger ui core components",
);

/**
 * Servant swagger ui: Jens-Ole Graulund theme
 */
export const servant_swagger_ui_jensoleg = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger-ui-jensoleg`,
  "Servant swagger ui: Jens-Ole Graulund theme",
);

/**
 * Servant swagger ui: ReDoc theme
 */
export const servant_swagger_ui_redoc = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-swagger-ui-redoc`,
  "Servant swagger ui: ReDoc theme",
);

/**
 * Automatically generate Elm clients for Servant APIs
 */
export const servant_to_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-to-elm`,
  "Automatically generate Elm clients for Servant APIs",
);

/**
 * Typed error wrapper for Servant
 */
export const servant_typed_error = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-typed-error`,
  "Typed error wrapper for Servant",
);

/**
 * TypeScript client generation for Servant
 */
export const servant_typescript = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-typescript`,
  "TypeScript client generation for Servant",
);

/**
 * Servant servers utilities
 */
export const servant_util = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-util`,
  "Servant servers utilities",
);

/**
 * Implementation of servant-util primitives for beam-postgres
 */
export const servant_util_beam_pg = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-util-beam-pg`,
  "Implementation of servant-util primitives for beam-postgres",
);

/**
 * Chekc static properties of servant APIs
 */
export const servant_validate = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-validate`,
  "Chekc static properties of servant APIs",
);

/**
 * Servant Integration for Waargonaut JSON Package
 */
export const servant_waargonaut = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-waargonaut`,
  "Servant Integration for Waargonaut JSON Package",
);

/**
 * Small library providing WebSocket endpoints for servant
 */
export const servant_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-websockets`,
  "Small library providing WebSocket endpoints for servant",
);

/**
 * Servant support for the XML Content-Type
 */
export const servant_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-xml`,
  "Servant support for the XML Content-Type",
);

/**
 * XStatic adapter for servant
 */
export const servant_xstatic = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-xstatic`,
  "XStatic adapter for servant",
);

/**
 * Client library for servant-zeppelin combinators
 */
export const servant_zeppelin_client = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-zeppelin-client`,
  "Client library for servant-zeppelin combinators",
);

/**
 * Server library for servant-zeppelin combinators
 */
export const servant_zeppelin_server = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-zeppelin-server`,
  "Server library for servant-zeppelin combinators",
);

/**
 * Swagger instances for servant-zeppelin combinators
 */
export const servant_zeppelin_swagger = mkPackage(
  nixRaw`pkgs.haskellPackages.servant-zeppelin-swagger`,
  "Swagger instances for servant-zeppelin combinators",
);

/**
 * Secure, modular server-side sessions
 */
export const serversession = mkPackage(
  nixRaw`pkgs.haskellPackages.serversession`,
  "Secure, modular server-side sessions",
);

/**
 * Storage backend for serversession using Redis
 */
export const serversession_backend_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.serversession-backend-redis`,
  "Storage backend for serversession using Redis",
);

/**
 * Snap bindings for serversession
 */
export const serversession_frontend_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.serversession-frontend-snap`,
  "Snap bindings for serversession",
);

/**
 * wai-session bindings for serversession
 */
export const serversession_frontend_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.serversession-frontend-wai`,
  "wai-session bindings for serversession",
);

/**
 * Yesod bindings for serversession
 */
export const serversession_frontend_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.serversession-frontend-yesod`,
  "Yesod bindings for serversession",
);

/**
 * Warp web server with template rendering
 */
export const servius = mkPackage(
  nixRaw`pkgs.haskellPackages.servius`,
  "Warp web server with template rendering",
);

/**
 * Send HTML formatted emails using Amazon's SES REST API with blaze
 */
export const ses_html = mkPackage(
  nixRaw`pkgs.haskellPackages.ses-html`,
  "Send HTML formatted emails using Amazon's SES REST API with blaze",
);

/**
 * Snaplet for the ses-html package
 */
export const ses_html_snaplet = mkPackage(
  nixRaw`pkgs.haskellPackages.ses-html-snaplet`,
  "Snaplet for the ses-html package",
);

/**
 * Session types distributed
 */
export const sessiontypes_distributed = mkPackage(
  nixRaw`pkgs.haskellPackages.sessiontypes-distributed`,
  "Session types distributed",
);

/**
 * Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube
 */
export const set_cover = mkPackage(
  nixRaw`pkgs.haskellPackages.set-cover`,
  "Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube",
);

/**
 * Functions that could be added to Data.Set.
 */
export const set_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.set-extra`,
  "Functions that could be added to Data.Set.",
);

/**
 * Set monad
 */
export const set_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.set-monad`,
  "Set monad",
);

/**
 * Treating files as sets to perform rapid set manipulation
 */
export const setdown = mkPackage(
  nixRaw`pkgs.haskellPackages.setdown`,
  "Treating files as sets to perform rapid set manipulation",
);

/**
 * A cross-platform library for setting environment variables
 */
export const setenv = mkPackage(
  nixRaw`pkgs.haskellPackages.setenv`,
  "A cross-platform library for setting environment variables",
);

/**
 * Haskell bindings to setlocale
 */
export const setlocale = mkPackage(
  nixRaw`pkgs.haskellPackages.setlocale`,
  "Haskell bindings to setlocale",
);

/**
 * Perform set operations on files
 */
export const setop = mkPackage(
  nixRaw`pkgs.haskellPackages.setop`,
  "Perform set operations on files",
);

/**
 * Uniform names (and Unicode operators) for set operations on data structures
 */
export const setops = mkPackage(
  nixRaw`pkgs.haskellPackages.setops`,
  "Uniform names (and Unicode operators) for set operations on data structures",
);

/**
 * Ducktyped set interface for Haskell containers
 */
export const sets = mkPackage(
  nixRaw`pkgs.haskellPackages.sets`,
  "Ducktyped set interface for Haskell containers",
);

/**
 * Runtime-editable program settings
 */
export const settings = mkPackage(
  nixRaw`pkgs.haskellPackages.settings`,
  "Runtime-editable program settings",
);

/**
 * Invertible grammar combinators for S-expressions
 */
export const sexp_grammar = mkPackage(
  nixRaw`pkgs.haskellPackages.sexp-grammar`,
  "Invertible grammar combinators for S-expressions",
);

/**
 * Produce a s-expression representation of Show values
 */
export const sexp_show = mkPackage(
  nixRaw`pkgs.haskellPackages.sexp-show`,
  "Produce a s-expression representation of Show values",
);

/**
 * S-expression printer and parser
 */
export const sexpr = mkPackage(
  nixRaw`pkgs.haskellPackages.sexpr`,
  "S-expression printer and parser",
);

/**
 * A flexible library for parsing and printing S-expression
 */
export const sexpresso = mkPackage(
  nixRaw`pkgs.haskellPackages.sexpresso`,
  "A flexible library for parsing and printing S-expression",
);

/**
 * A command line tool to convert TrueType/OpenType fonts to WOFF format
 */
export const sfnt2woff = mkPackage(
  nixRaw`pkgs.haskellPackages.sfnt2woff`,
  "A command line tool to convert TrueType/OpenType fonts to WOFF format",
);

/**
 * SGF (Smart Game Format) parser
 */
export const sgf = mkPackage(
  nixRaw`pkgs.haskellPackages.sgf`,
  "SGF (Smart Game Format) parser",
);

/**
 * Sgrep - grep Fasta files for sequences matching a regular expression
 */
export const sgrep = mkPackage(
  nixRaw`pkgs.haskellPackages.sgrep`,
  "Sgrep - grep Fasta files for sequences matching a regular expression",
);

/**
 * SHA-1 Hash
 */
export const sha1 = mkPackage(
  nixRaw`pkgs.haskellPackages.sha1`,
  "SHA-1 Hash",
);

/**
 * Validation SHA Implementations
 */
export const sha_validation = mkPackage(
  nixRaw`pkgs.haskellPackages.sha-validation`,
  "Validation SHA Implementations",
);

/**
 * A fast SOCKS5 proxy that help you get through firewalls
 */
export const shadowsocks = mkPackage(
  nixRaw`pkgs.haskellPackages.shadowsocks`,
  "A fast SOCKS5 proxy that help you get through firewalls",
);

/**
 * Functional GPU programming - DSEL & compiler
 */
export const shady_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.shady-gen`,
  "Functional GPU programming - DSEL & compiler",
);

/**
 * Functional GPU programming - DSEL & compiler
 */
export const shady_graphics = mkPackage(
  nixRaw`pkgs.haskellPackages.shady-graphics`,
  "Functional GPU programming - DSEL & compiler",
);

/**
 * Build system library, like Make, but more accurate dependencies
 */
export const shake = mkPackage(
  nixRaw`pkgs.haskellPackages.shake`,
  "Build system library, like Make, but more accurate dependencies",
);

/**
 * Utilities for building ATS projects with shake
 */
export const shake_ats = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-ats`,
  "Utilities for building ATS projects with shake",
);

/**
 * Build rules for historical benchmarking
 */
export const shake_bench = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-bench`,
  "Build rules for historical benchmarking",
);

/**
 * Rules for binary distributions
 */
export const shake_bindist = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-bindist`,
  "Rules for binary distributions",
);

/**
 * Library for building C code with shake
 */
export const shake_c = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-c`,
  "Library for building C code with shake",
);

/**
 * Shake library for use with cabal
 */
export const shake_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-cabal`,
  "Shake library for use with cabal",
);

/**
 * Shake library for use with cabal
 */
export const shake_cabal_0_2_2_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-cabal_0_2_2_2`,
  "Shake library for use with cabal",
);

/**
 * Shake rules for CCJS
 */
export const shake_ccjs = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-ccjs`,
  "Shake rules for CCJS",
);

/**
 * Elm builds in shake
 */
export const shake_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-elm`,
  "Elm builds in shake",
);

/**
 * Helper functions for linting with shake
 */
export const shake_ext = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-ext`,
  "Helper functions for linting with shake",
);

/**
 * Dependency tracking for Futhark
 */
export const shake_futhark = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-futhark`,
  "Dependency tracking for Futhark",
);

/**
 * Shake rules for the Google closure compiler
 */
export const shake_google_closure_compiler = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-google-closure-compiler`,
  "Shake rules for the Google closure compiler",
);

/**
 * Utilities for cross-compiling with Shake
 */
export const shake_language_c = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-language-c`,
  "Utilities for cross-compiling with Shake",
);

/**
 * Rules for building literate programs in shake
 */
export const shake_literate = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-literate`,
  "Rules for building literate programs in shake",
);

/**
 * Shake rules for CSS
 */
export const shake_minify_css = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-minify-css`,
  "Shake rules for CSS",
);

/**
 * Re-export of Shake using well-typed paths and ReaderT
 */
export const shake_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-plus`,
  "Re-export of Shake using well-typed paths and ReaderT",
);

/**
 * Experimental extensions to shake-plus
 */
export const shake_plus_extended = mkPackage(
  nixRaw`pkgs.haskellPackages.shake-plus-extended`,
  "Experimental extensions to shake-plus",
);

/**
 * Shake-based technical documentation generator; HTML & PDF
 */
export const shakebook = mkPackage(
  nixRaw`pkgs.haskellPackages.shakebook`,
  "Shake-based technical documentation generator; HTML & PDF",
);

/**
 * simple and interactive command-line build tool
 */
export const shaker = mkPackage(
  nixRaw`pkgs.haskellPackages.shaker`,
  "simple and interactive command-line build tool",
);

/**
 * Shake helpers
 */
export const shakers = mkPackage(
  nixRaw`pkgs.haskellPackages.shakers`,
  "Shake helpers",
);

/**
 * A toolkit for making compile-time interpolated templates
 */
export const shakespeare = mkPackage(
  nixRaw`pkgs.haskellPackages.shakespeare`,
  "A toolkit for making compile-time interpolated templates",
);

/**
 * Stick your haskell variables into css at compile time. (deprecated)
 */
export const shakespeare_css = mkPackage(
  nixRaw`pkgs.haskellPackages.shakespeare-css`,
  "Stick your haskell variables into css at compile time. (deprecated)",
);

/**
 * A type-based approach to internationalization. (deprecated)
 */
export const shakespeare_i18n = mkPackage(
  nixRaw`pkgs.haskellPackages.shakespeare-i18n`,
  "A type-based approach to internationalization. (deprecated)",
);

/**
 * Stick your haskell variables into javascript/coffeescript at compile time. (deprecated)
 */
export const shakespeare_js = mkPackage(
  nixRaw`pkgs.haskellPackages.shakespeare-js`,
  "Stick your haskell variables into javascript/coffeescript at compile time. (deprecated)",
);

/**
 * Interpolation with quasi-quotation: put variables strings (deprecated)
 */
export const shakespeare_text = mkPackage(
  nixRaw`pkgs.haskellPackages.shakespeare-text`,
  "Interpolation with quasi-quotation: put variables strings (deprecated)",
);

/**
 * treat haskell functions as unix pipes
 */
export const shana = mkPackage(
  nixRaw`pkgs.haskellPackages.shana`,
  "treat haskell functions as unix pipes",
);

/**
 * Shannon-fano compression algorithm in Haskell
 */
export const shannon_fano = mkPackage(
  nixRaw`pkgs.haskellPackages.shannon-fano`,
  "Shannon-fano compression algorithm in Haskell",
);

/**
 * Parser and related tools for ESRI shapefile format
 */
export const shapefile = mkPackage(
  nixRaw`pkgs.haskellPackages.shapefile`,
  "Parser and related tools for ESRI shapefile format",
);

/**
 * Generics using @(,)@ and @Either@, with algebraic operations and typed conversions
 */
export const shapely_data = mkPackage(
  nixRaw`pkgs.haskellPackages.shapely-data`,
  "Generics using @(,)@ and @Either@, with algebraic operations and typed conversions",
);

/**
 * physics engine and other tools for 2D shapes
 */
export const shapes = mkPackage(
  nixRaw`pkgs.haskellPackages.shapes`,
  "physics engine and other tools for 2D shapes",
);

/**
 * demos for the 'shapes' package
 */
export const shapes_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.shapes-demo`,
  "demos for the 'shapes' package",
);

/**
 * faster vector/matrix math using unboxed numbers and Template Haskell
 */
export const shapes_math = mkPackage(
  nixRaw`pkgs.haskellPackages.shapes-math`,
  "faster vector/matrix math using unboxed numbers and Template Haskell",
);

/**
 * Sandell Harmonic Archive. A collection of stable phases for all instruments in the orchestra.
 */
export const sharc_timbre = mkPackage(
  nixRaw`pkgs.haskellPackages.sharc-timbre`,
  "Sandell Harmonic Archive. A collection of stable phases for all instruments in the orchestra.",
);

/**
 * POSIX shared memory
 */
export const shared_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.shared-memory`,
  "POSIX shared memory",
);

/**
 * Bundles shared calls to IO functions to perform them only once
 */
export const sharedio = mkPackage(
  nixRaw`pkgs.haskellPackages.sharedio`,
  "Bundles shared calls to IO functions to perform them only once",
);

/**
 * Spreadsheet type for composite
 */
export const sheets = mkPackage(
  nixRaw`pkgs.haskellPackages.sheets`,
  "Spreadsheet type for composite",
);

/**
 * Test webhooks locally
 */
export const shelduck = mkPackage(
  nixRaw`pkgs.haskellPackages.shelduck`,
  "Test webhooks locally",
);

/**
 * Write shell scripts with Conduit
 */
export const shell_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.shell-conduit`,
  "Write shell scripts with Conduit",
);

/**
 * Shell escaping library
 */
export const shell_escape = mkPackage(
  nixRaw`pkgs.haskellPackages.shell-escape`,
  "Shell escaping library",
);

/**
 * shell monad
 */
export const shell_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.shell-monad`,
  "shell monad",
);

/**
 * Utility functions for writing command-line programs
 */
export const shell_utility = mkPackage(
  nixRaw`pkgs.haskellPackages.shell-utility`,
  "Utility functions for writing command-line programs",
);

/**
 * A tool for generating shell.nix files
 */
export const shellify = mkPackage(
  nixRaw`pkgs.haskellPackages.shellify`,
  "A tool for generating shell.nix files",
);

/**
 * Extra functionality for shellmate
 */
export const shellmate_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.shellmate-extras`,
  "Extra functionality for shellmate",
);

/**
 * Out of the shell solution for scripting in Haskell
 */
export const shellmet = mkPackage(
  nixRaw`pkgs.haskellPackages.shellmet`,
  "Out of the shell solution for scripting in Haskell",
);

/**
 * A threaded manager for Haskell that can run and stream external process output/err/exits
 */
export const shellout = mkPackage(
  nixRaw`pkgs.haskellPackages.shellout`,
  "A threaded manager for Haskell that can run and stream external process output/err/exits",
);

/**
 * Easy, repeatable testing of CLI programs/commands
 */
export const shelltestrunner = mkPackage(
  nixRaw`pkgs.haskellPackages.shelltestrunner`,
  "Easy, repeatable testing of CLI programs/commands",
);

/**
 * Easy, repeatable testing of CLI programs/commands
 */
export const shelltestrunner_1_10 = mkPackage(
  nixRaw`pkgs.haskellPackages.shelltestrunner_1_10`,
  "Easy, repeatable testing of CLI programs/commands",
);

/**
 * Parse strings into words, like a shell would
 */
export const shellwords = mkPackage(
  nixRaw`pkgs.haskellPackages.shellwords`,
  "Parse strings into words, like a shell would",
);

/**
 * shell-like (systems) programming in Haskell
 */
export const shelly = mkPackage(
  nixRaw`pkgs.haskellPackages.shelly`,
  "shell-like (systems) programming in Haskell",
);

/**
 * shelly features that require extra dependencies
 */
export const shelly_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.shelly-extra`,
  "shelly features that require extra dependencies",
);

/**
 * A Haskell implementation of the Shen programming language
 */
export const shentong = mkPackage(
  nixRaw`pkgs.haskellPackages.shentong`,
  "A Haskell implementation of the Shen programming language",
);

/**
 * Simple shell scripting from Haskell
 */
export const shh = mkPackage(
  nixRaw`pkgs.haskellPackages.shh`,
  "Simple shell scripting from Haskell",
);

/**
 * Utility functions for using shh
 */
export const shh_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.shh-extras`,
  "Utility functions for using shh",
);

/**
 * A tool to quickly switch between directories
 */
export const shift = mkPackage(
  nixRaw`pkgs.haskellPackages.shift`,
  "A tool to quickly switch between directories",
);

/**
 * FRP interface for shine using the varying package
 */
export const shine_varying = mkPackage(
  nixRaw`pkgs.haskellPackages.shine-varying`,
  "FRP interface for shine using the varying package",
);

/**
 * Length-indexed vectors using SmallArray#
 */
export const short_vec = mkPackage(
  nixRaw`pkgs.haskellPackages.short-vec`,
  "Length-indexed vectors using SmallArray#",
);

/**
 * Lenses and related functionality for the `short-vec` package
 */
export const short_vec_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.short-vec-lens`,
  "Lenses and related functionality for the `short-vec` package",
);

/**
 * Short-circuit values and expressions
 */
export const shortcircuit = mkPackage(
  nixRaw`pkgs.haskellPackages.shortcircuit`,
  "Short-circuit values and expressions",
);

export const shortcut = mkPackage(
  nixRaw`pkgs.haskellPackages.shortcut`,
  "",
);

/**
 * A HUnit/hspec assertion library to verify that an expression does not typecheck
 */
export const should_not_typecheck = mkPackage(
  nixRaw`pkgs.haskellPackages.should-not-typecheck`,
  "A HUnit/hspec assertion library to verify that an expression does not typecheck",
);

/**
 * 'Show' instances for Lambdabot
 */
export const show = mkPackage(
  nixRaw`pkgs.haskellPackages.show`,
  "'Show' instances for Lambdabot",
);

/**
 * Combinators to write Show instances
 */
export const show_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.show-combinators`,
  "Combinators to write Show instances",
);

/**
 * A wrapper type V with improved Show instances
 */
export const show_please = mkPackage(
  nixRaw`pkgs.haskellPackages.show-please`,
  "A wrapper type V with improved Show instances",
);

/**
 * A simple gtk based Russian Roulette game
 */
export const showdown = mkPackage(
  nixRaw`pkgs.haskellPackages.showdown`,
  "A simple gtk based Russian Roulette game",
);

/**
 * Clean up the formatting of 'show' output
 */
export const shower = mkPackage(
  nixRaw`pkgs.haskellPackages.shower`,
  "Clean up the formatting of 'show' output",
);

/**
 * Web automation library in Haskell
 */
export const shpider = mkPackage(
  nixRaw`pkgs.haskellPackages.shpider`,
  "Web automation library in Haskell",
);

/**
 * A Haskell pattern splitter with emacs attachments
 */
export const shplit = mkPackage(
  nixRaw`pkgs.haskellPackages.shplit`,
  "A Haskell pattern splitter with emacs attachments",
);

/**
 * Embed shell commands with interpolated Haskell variables, and capture output
 */
export const shqq = mkPackage(
  nixRaw`pkgs.haskellPackages.shqq`,
  "Embed shell commands with interpolated Haskell variables, and capture output",
);

/**
 * Shuffle tool for UHC
 */
export const shuffle = mkPackage(
  nixRaw`pkgs.haskellPackages.shuffle`,
  "Shuffle tool for UHC",
);

/**
 * Initial project template from stack
 */
export const shunya_library = mkPackage(
  nixRaw`pkgs.haskellPackages.shunya-library`,
  "Initial project template from stack",
);

/**
 * Initial project template from stack
 */
export const shunyalib = mkPackage(
  nixRaw`pkgs.haskellPackages.shunyalib`,
  "Initial project template from stack",
);

/**
 * An interface to the Silicon Labs Si5351 clock chip
 */
export const si_clock = mkPackage(
  nixRaw`pkgs.haskellPackages.si-clock`,
  "An interface to the Silicon Labs Si5351 clock chip",
);

/**
 * timers using SI units (seconds)
 */
export const si_timers = mkPackage(
  nixRaw`pkgs.haskellPackages.si-timers`,
  "timers using SI units (seconds)",
);

/**
 * Machine Learning algorithms
 */
export const sibe = mkPackage(
  nixRaw`pkgs.haskellPackages.sibe`,
  "Machine Learning algorithms",
);

/**
 * Sieve is an implementation of the Sieve abstract data type
 */
export const sieve = mkPackage(
  nixRaw`pkgs.haskellPackages.sieve`,
  "Sieve is an implementation of the Sieve abstract data type",
);

/**
 * Rounding rationals to significant digits and decimal places
 */
export const siggy_chardust = mkPackage(
  nixRaw`pkgs.haskellPackages.siggy-chardust`,
  "Rounding rationals to significant digits and decimal places",
);

/**
 * Thom polynomials of second order Thom-Boardman singularities
 */
export const sigma_ij = mkPackage(
  nixRaw`pkgs.haskellPackages.sigma-ij`,
  "Thom polynomials of second order Thom-Boardman singularities",
);

/**
 * Arithmetic over signs and sets of signs
 */
export const sign = mkPackage(
  nixRaw`pkgs.haskellPackages.sign`,
  "Arithmetic over signs and sets of signs",
);

/**
 * Deterministic serialisation and signatures with proto-lens support
 */
export const signable = mkPackage(
  nixRaw`pkgs.haskellPackages.signable`,
  "Deterministic serialisation and signatures with proto-lens support",
);

/**
 * Deterministic serialisation and signatures with proto-lens support
 */
export const signable_haskell_protoc = mkPackage(
  nixRaw`pkgs.haskellPackages.signable-haskell-protoc`,
  "Deterministic serialisation and signatures with proto-lens support",
);

/**
 * Multiplatform signal support for Haskell
 */
export const signal = mkPackage(
  nixRaw`pkgs.haskellPackages.signal`,
  "Multiplatform signal support for Haskell",
);

/**
 * Bindings for signal-cli's DBus interface
 */
export const signal_messaging_dbus = mkPackage(
  nixRaw`pkgs.haskellPackages.signal-messaging-dbus`,
  "Bindings for signal-cli's DBus interface",
);

/**
 * Synchronous signal processing for DSLs
 */
export const signals = mkPackage(
  nixRaw`pkgs.haskellPackages.signals`,
  "Synchronous signal processing for DSLs",
);

/**
 * Hmac sha256 signature json and http payload
 */
export const signature = mkPackage(
  nixRaw`pkgs.haskellPackages.signature`,
  "Hmac sha256 signature json and http payload",
);

/**
 * Multisets with negative membership
 */
export const signed_multiset = mkPackage(
  nixRaw`pkgs.haskellPackages.signed-multiset`,
  "Multisets with negative membership",
);

/**
 * Calculate expressions involving significant figures
 */
export const significant_figures = mkPackage(
  nixRaw`pkgs.haskellPackages.significant-figures`,
  "Calculate expressions involving significant figures",
);

/**
 * A Haskell clone of OpenBSD signify
 */
export const signify_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.signify-hs`,
  "A Haskell clone of OpenBSD signify",
);

/**
 * Prevent or capture writing to stdout and other handles
 */
export const silently = mkPackage(
  nixRaw`pkgs.haskellPackages.silently`,
  "Prevent or capture writing to stdout and other handles",
);

/**
 * Prettyprinting transformers
 */
export const silkscreen = mkPackage(
  nixRaw`pkgs.haskellPackages.silkscreen`,
  "Prettyprinting transformers",
);

/**
 * A generator for different kinds of data
 */
export const silvi = mkPackage(
  nixRaw`pkgs.haskellPackages.silvi`,
  "A generator for different kinds of data",
);

/**
 * stochastic simulation engine
 */
export const simgi = mkPackage(
  nixRaw`pkgs.haskellPackages.simgi`,
  "stochastic simulation engine",
);

/**
 * A minimalist web framework for the WAI server interface
 */
export const simple = mkPackage(
  nixRaw`pkgs.haskellPackages.simple`,
  "A minimalist web framework for the WAI server interface",
);

/**
 * A simple library for affine and vector spaces
 */
export const simple_affine_space = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-affine-space`,
  "A simple library for affine and vector spaces",
);

export const simple_amount = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-amount`,
  "",
);

/**
 * A simple C value type
 */
export const simple_c_value = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-c-value`,
  "A simple C value type",
);

/**
 * Cabal file wrapper library
 */
export const simple_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-cabal`,
  "Cabal file wrapper library",
);

/**
 * Simple String-based process commands
 */
export const simple_cmd = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-cmd`,
  "Simple String-based process commands",
);

/**
 * Simple command args parsing and execution
 */
export const simple_cmd_args = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-cmd-args`,
  "Simple command args parsing and execution",
);

/**
 * Finite or countably infinite sequences of values
 */
export const simple_enumeration = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-enumeration`,
  "Finite or countably infinite sequences of values",
);

/**
 * Minimalistic toolkit for simple mathematical expression
 */
export const simple_expr = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-expr`,
  "Minimalistic toolkit for simple mathematical expression",
);

/**
 * Simplified interface for firewire cameras
 */
export const simple_firewire = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-firewire`,
  "Simplified interface for firewire cameras",
);

/**
 * Simple parallel genetic algorithm implementation
 */
export const simple_genetic_algorithm_mr = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-genetic-algorithm-mr`,
  "Simple parallel genetic algorithm implementation",
);

/**
 * A simple library for processing command-line options
 */
export const simple_get_opt = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-get-opt`,
  "A simple library for processing command-line options",
);

/**
 * Syslog backend for simple-log
 */
export const simple_log_syslog = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-log-syslog`,
  "Syslog backend for simple-log",
);

/**
 * A very simple but efficient logging framework
 */
export const simple_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-logger`,
  "A very simple but efficient logging framework",
);

/**
 * Logging effect to plug into the simple-effects framework
 */
export const simple_logging = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-logging`,
  "Logging effect to plug into the simple-effects framework",
);

/**
 * A simple LTL checker
 */
export const simple_ltl = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-ltl`,
  "A simple LTL checker",
);

/**
 * A very simple timestamp type
 */
export const simple_media_timestamp = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-media-timestamp`,
  "A very simple timestamp type",
);

/**
 * Attoparsec parser for simple-media-timestamp
 */
export const simple_media_timestamp_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-media-timestamp-attoparsec`,
  "Attoparsec parser for simple-media-timestamp",
);

/**
 * Simple parsing/pretty printing for Nix expressions
 */
export const simple_nix = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-nix`,
  "Simple parsing/pretty printing for Nix expressions",
);

/**
 * The Observer pattern
 */
export const simple_observer = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-observer`,
  "The Observer pattern",
);

/**
 * Simplified Pascal language to SSVM compiler
 */
export const simple_pascal = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-pascal`,
  "Simplified Pascal language to SSVM compiler",
);

/**
 * Connector package for integrating postgresql-orm with the Simple web framework
 */
export const simple_postgresql_orm = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-postgresql-orm`,
  "Connector package for integrating postgresql-orm with the Simple web framework",
);

/**
 * Simple commandline text prompt functions
 */
export const simple_prompt = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-prompt`,
  "Simple commandline text prompt functions",
);

/**
 * Simple reflection of expressions containing variables
 */
export const simple_reflect = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-reflect`,
  "Simple reflection of expressions containing variables",
);

/**
 * Cross platform library for the sendfile system call
 */
export const simple_sendfile = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-sendfile`,
  "Cross platform library for the sendfile system call",
);

/**
 * Cookie-based session management for the Simple web framework
 */
export const simple_session = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-session`,
  "Cookie-based session management for the Simple web framework",
);

/**
 * A simple implementation of session types
 */
export const simple_sessions = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-sessions`,
  "A simple implementation of session types",
);

/**
 * A simple way to interact with an SMT solver process
 */
export const simple_smt = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-smt`,
  "A simple way to interact with an SMT solver process",
);

/**
 * source code editing utilities
 */
export const simple_src_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-src-utils`,
  "source code editing utilities",
);

/**
 * A basic template language for the Simple web framework
 */
export const simple_templates = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-templates`,
  "A basic template language for the Simple web framework",
);

/**
 * Simple text based format strings with named identifiers
 */
export const simple_text_format = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-text-format`,
  "Simple text based format strings with named identifiers",
);

/**
 * Three-dimensional vectors of doubles with basic operations
 */
export const simple_vec3 = mkPackage(
  nixRaw`pkgs.haskellPackages.simple-vec3`,
  "Three-dimensional vectors of doubles with basic operations",
);

/**
 * Lenses for simpleirc types
 */
export const simpleirc_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.simpleirc-lens`,
  "Lenses for simpleirc types",
);

export const simplelru = mkPackage(
  nixRaw`pkgs.haskellPackages.simplelru`,
  "",
);

/**
 * Generators for primitive meshes
 */
export const simplemesh = mkPackage(
  nixRaw`pkgs.haskellPackages.simplemesh`,
  "Generators for primitive meshes",
);

/**
 * Simple wrapper around libssh2
 */
export const simplessh = mkPackage(
  nixRaw`pkgs.haskellPackages.simplessh`,
  "Simple wrapper around libssh2",
);

/**
 * A simple markup language that translates to LaTeX
 */
export const simplex = mkPackage(
  nixRaw`pkgs.haskellPackages.simplex`,
  "A simple markup language that translates to LaTeX",
);

/**
 * Very basic simplex implementation
 */
export const simplex_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.simplex-basic`,
  "Very basic simplex implementation",
);

/**
 * Implementation of the two-phase simplex method in exact rational arithmetic
 */
export const simplex_method = mkPackage(
  nixRaw`pkgs.haskellPackages.simplex-method`,
  "Implementation of the two-phase simplex method in exact rational arithmetic",
);

/**
 * Simple pool
 */
export const simpoole = mkPackage(
  nixRaw`pkgs.haskellPackages.simpoole`,
  "Simple pool",
);

/**
 * Simulate sequencing with different models for priming and errors
 */
export const simseq = mkPackage(
  nixRaw`pkgs.haskellPackages.simseq`,
  "Simulate sequencing with different models for priming and errors",
);

/**
 * Load data organized in a tree
 */
export const simtreelo = mkPackage(
  nixRaw`pkgs.haskellPackages.simtreelo`,
  "Load data organized in a tree",
);

/**
 * Get the number of seconds since the last invocation
 */
export const since = mkPackage(
  nixRaw`pkgs.haskellPackages.since`,
  "Get the number of seconds since the last invocation",
);

/**
 * Type level booleans
 */
export const singleton_bool = mkPackage(
  nixRaw`pkgs.haskellPackages.singleton-bool`,
  "Type level booleans",
);

/**
 * Type level booleans
 */
export const singleton_bool_0_1_7 = mkPackage(
  nixRaw`pkgs.haskellPackages.singleton-bool_0_1_7`,
  "Type level booleans",
);

/**
 * Unary natural numbers relying on the singletons infrastructure
 */
export const singleton_nats = mkPackage(
  nixRaw`pkgs.haskellPackages.singleton-nats`,
  "Unary natural numbers relying on the singletons infrastructure",
);

/**
 * Basic singleton types and definitions
 */
export const singletons = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons`,
  "Basic singleton types and definitions",
);

/**
 * A promoted and singled version of the base library
 */
export const singletons_base = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons-base`,
  "A promoted and singled version of the base library",
);

/**
 * A promoted and singled version of the base library
 */
export const singletons_base_3_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons-base_3_2`,
  "A promoted and singled version of the base library",
);

/**
 * Presburger Arithmetic Solver for GHC Type-level natural numbers with Singletons package
 */
export const singletons_presburger = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons-presburger`,
  "Presburger Arithmetic Solver for GHC Type-level natural numbers with Singletons package",
);

/**
 * A framework for generating singleton types
 */
export const singletons_th = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons-th`,
  "A framework for generating singleton types",
);

/**
 * A framework for generating singleton types
 */
export const singletons_th_3_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.singletons-th_3_2`,
  "A framework for generating singleton types",
);

/**
 * Encode and decode CSV files
 */
export const siphon = mkPackage(
  nixRaw`pkgs.haskellPackages.siphon`,
  "Encode and decode CSV files",
);

/**
 * Siren Tools for Haskell
 */
export const siren_json = mkPackage(
  nixRaw`pkgs.haskellPackages.siren-json`,
  "Siren Tools for Haskell",
);

/**
 * Sirkel, a Chord DHT
 */
export const sirkel = mkPackage(
  nixRaw`pkgs.haskellPackages.sirkel`,
  "Sirkel, a Chord DHT",
);

/**
 * Sitemap parser
 */
export const sitemap = mkPackage(
  nixRaw`pkgs.haskellPackages.sitemap`,
  "Sitemap parser",
);

/**
 * Generate XML Sitemaps & Sitemap Indexes
 */
export const sitemap_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.sitemap-gen`,
  "Generate XML Sitemaps & Sitemap Indexes",
);

/**
 * Sixel library to show images in a terminal emulator
 */
export const sixel = mkPackage(
  nixRaw`pkgs.haskellPackages.sixel`,
  "Sixel library to show images in a terminal emulator",
);

/**
 * An eDSL for writing 65(C)02 bytecode
 */
export const sixty_five_oh_two = mkPackage(
  nixRaw`pkgs.haskellPackages.sixty-five-oh-two`,
  "An eDSL for writing 65(C)02 bytecode",
);

/**
 * Sized functors, for size-based enumerations
 */
export const size_based = mkPackage(
  nixRaw`pkgs.haskellPackages.size-based`,
  "Sized functors, for size-based enumerations",
);

/**
 * Sized sequence data-types
 */
export const sized = mkPackage(
  nixRaw`pkgs.haskellPackages.sized`,
  "Sized sequence data-types",
);

/**
 * Create a Sized version of any container
 */
export const sized_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.sized-wrapper`,
  "Create a Sized version of any container",
);

/**
 * aeson instances for 'Sized'
 */
export const sized_wrapper_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.sized-wrapper-aeson`,
  "aeson instances for 'Sized'",
);

/**
 * QuickCheck instance for 'Sized'
 */
export const sized_wrapper_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.sized-wrapper-quickcheck`,
  "QuickCheck instance for 'Sized'",
);

/**
 * 'Sized' wrappers for text
 */
export const sized_wrapper_text = mkPackage(
  nixRaw`pkgs.haskellPackages.sized-wrapper-text`,
  "'Sized' wrappers for text",
);

/**
 * Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.
 */
export const skein = mkPackage(
  nixRaw`pkgs.haskellPackages.skein`,
  "Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.",
);

/**
 * a tool to access the OSX keychain
 */
export const skeleton = mkPackage(
  nixRaw`pkgs.haskellPackages.skeleton`,
  "a tool to access the OSX keychain",
);

/**
 * Manage project skeletons
 */
export const skeletons = mkPackage(
  nixRaw`pkgs.haskellPackages.skeletons`,
  "Manage project skeletons",
);

/**
 * Sketch programming with Copilot
 */
export const sketch_frp_copilot = mkPackage(
  nixRaw`pkgs.haskellPackages.sketch-frp-copilot`,
  "Sketch programming with Copilot",
);

/**
 * Random access lists: skew binary
 */
export const skew_list = mkPackage(
  nixRaw`pkgs.haskellPackages.skew-list`,
  "Random access lists: skew binary",
);

/**
 * A very quick-and-dirty WebSocket server
 */
export const skews = mkPackage(
  nixRaw`pkgs.haskellPackages.skews`,
  "A very quick-and-dirty WebSocket server",
);

/**
 * An implementation of pure skip lists
 */
export const skip_list = mkPackage(
  nixRaw`pkgs.haskellPackages.skip-list`,
  "An implementation of pure skip lists",
);

/**
 * Skip variables
 */
export const skip_var = mkPackage(
  nixRaw`pkgs.haskellPackages.skip-var`,
  "Skip variables",
);

/**
 * Skylark client
 */
export const skylark_client = mkPackage(
  nixRaw`pkgs.haskellPackages.skylark-client`,
  "Skylark client",
);

/**
 * syntax highlighting library
 */
export const skylighting = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting`,
  "syntax highlighting library",
);

/**
 * syntax highlighting library
 */
export const skylighting_0_14 = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting_0_14`,
  "syntax highlighting library",
);

/**
 * syntax highlighting library
 */
export const skylighting_core = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-core`,
  "syntax highlighting library",
);

/**
 * syntax highlighting library
 */
export const skylighting_core_0_14 = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-core_0_14`,
  "syntax highlighting library",
);

/**
 * ANSI formatter for skylighting syntax highlighting library
 */
export const skylighting_format_ansi = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-format-ansi`,
  "ANSI formatter for skylighting syntax highlighting library",
);

/**
 * HTML formatter for skylighting syntax highlighting library
 */
export const skylighting_format_blaze_html = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-format-blaze-html`,
  "HTML formatter for skylighting syntax highlighting library",
);

/**
 * ConTeXt formatter for skylighting syntax highlighting library
 */
export const skylighting_format_context = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-format-context`,
  "ConTeXt formatter for skylighting syntax highlighting library",
);

/**
 * LaTeX formatter for skylighting syntax highlighting library
 */
export const skylighting_format_latex = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-format-latex`,
  "LaTeX formatter for skylighting syntax highlighting library",
);

/**
 * Lucid support for Skylighting
 */
export const skylighting_lucid = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-lucid`,
  "Lucid support for Skylighting",
);

/**
 * Utilities for modifying Skylighting syntaxes
 */
export const skylighting_modding = mkPackage(
  nixRaw`pkgs.haskellPackages.skylighting-modding`,
  "Utilities for modifying Skylighting syntaxes",
);

export const slack_progressbar = mkPackage(
  nixRaw`pkgs.haskellPackages.slack-progressbar`,
  "",
);

/**
 * Bindings for the Slack web API
 */
export const slack_web = mkPackage(
  nixRaw`pkgs.haskellPackages.slack-web`,
  "Bindings for the Slack web API",
);

/**
 * A note taking CLI tool
 */
export const slate = mkPackage(
  nixRaw`pkgs.haskellPackages.slate`,
  "A note taking CLI tool",
);

/**
 * A fundamental solution to ghost threads and silent exceptions
 */
export const slave_thread = mkPackage(
  nixRaw`pkgs.haskellPackages.slave-thread`,
  "A fundamental solution to ghost threads and silent exceptions",
);

/**
 * zZzzZz
 */
export const sleep = mkPackage(
  nixRaw`pkgs.haskellPackages.sleep`,
  "zZzzZz",
);

/**
 * Generate C++ skeletons from slice files
 */
export const slice_cpp_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.slice-cpp-gen`,
  "Generate C++ skeletons from slice files",
);

/**
 * A quick & easy static site builder built with shake and pandoc
 */
export const slick = mkPackage(
  nixRaw`pkgs.haskellPackages.slick`,
  "A quick & easy static site builder built with shake and pandoc",
);

/**
 * SLIP-0032: Extended serialization format for BIP-32 wallets
 */
export const slip32 = mkPackage(
  nixRaw`pkgs.haskellPackages.slip32`,
  "SLIP-0032: Extended serialization format for BIP-32 wallets",
);

/**
 * Sized list
 */
export const slist = mkPackage(
  nixRaw`pkgs.haskellPackages.slist`,
  "Sized list",
);

/**
 * Visualize mathematical function's slope fields
 */
export const slope_field = mkPackage(
  nixRaw`pkgs.haskellPackages.slope-field`,
  "Visualize mathematical function's slope fields",
);

/**
 * Pure Haskell slotmap implementation over ST or IO
 */
export const slotmap = mkPackage(
  nixRaw`pkgs.haskellPackages.slotmap`,
  "Pure Haskell slotmap implementation over ST or IO",
);

/**
 * Clean URI slugs for Haskell
 */
export const slugger = mkPackage(
  nixRaw`pkgs.haskellPackages.slugger`,
  "Clean URI slugs for Haskell",
);

/**
 * Handle molecular sequences
 */
export const slynx = mkPackage(
  nixRaw`pkgs.haskellPackages.slynx`,
  "Handle molecular sequences",
);

/**
 * A property-based testing library
 */
export const smallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.smallcheck`,
  "A property-based testing library",
);

/**
 * SmallCheck properties for common laws
 */
export const smallcheck_laws = mkPackage(
  nixRaw`pkgs.haskellPackages.smallcheck-laws`,
  "SmallCheck properties for common laws",
);

/**
 * SmallCheck properties for lens
 */
export const smallcheck_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.smallcheck-lens`,
  "SmallCheck properties for lens",
);

/**
 * A Unicode text type, optimized for low memory overhead
 */
export const smallstring = mkPackage(
  nixRaw`pkgs.haskellPackages.smallstring`,
  "A Unicode text type, optimized for low memory overhead",
);

/**
 * Utilities for the Smaoin semantic information model
 */
export const smaoin = mkPackage(
  nixRaw`pkgs.haskellPackages.smaoin`,
  "Utilities for the Smaoin semantic information model",
);

/**
 * Haskell Behavior Tree Library
 */
export const smarties = mkPackage(
  nixRaw`pkgs.haskellPackages.smarties`,
  "Haskell Behavior Tree Library",
);

/**
 * Web based flash card for Word Smart I and II vocabularies
 */
export const smartword = mkPackage(
  nixRaw`pkgs.haskellPackages.smartword`,
  "Web based flash card for Word Smart I and II vocabularies",
);

/**
 * Aeson support for the smash library
 */
export const smash_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.smash-aeson`,
  "Aeson support for the smash library",
);

/**
 * Optics for the `smash` library
 */
export const smash_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.smash-lens`,
  "Optics for the `smash` library",
);

/**
 * Optics for the `smash` library
 */
export const smash_microlens = mkPackage(
  nixRaw`pkgs.haskellPackages.smash-microlens`,
  "Optics for the `smash` library",
);

/**
 * Optics for the `smash` library using `optics-core`
 */
export const smash_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.smash-optics`,
  "Optics for the `smash` library using `optics-core`",
);

/**
 * Symbolic Model Checking for Dynamic Epistemic Logic
 */
export const smcdel = mkPackage(
  nixRaw`pkgs.haskellPackages.smcdel`,
  "Symbolic Model Checking for Dynamic Epistemic Logic",
);

/**
 * Parse arrays of tokens
 */
export const smith = mkPackage(
  nixRaw`pkgs.haskellPackages.smith`,
  "Parse arrays of tokens",
);

/**
 * Command line tool for <https://smith.st/ Smith>.
 */
export const smith_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.smith-cli`,
  "Command line tool for <https://smith.st/ Smith>.",
);

/**
 * API client for <https://smith.st/ Smith>.
 */
export const smith_client = mkPackage(
  nixRaw`pkgs.haskellPackages.smith-client`,
  "API client for <https://smith.st/ Smith>.",
);

/**
 * Interface to Satisfiability Modulo Theories solvers
 */
export const smt = mkPackage(
  nixRaw`pkgs.haskellPackages.smt`,
  "Interface to Satisfiability Modulo Theories solvers",
);

/**
 * A Haskell parser for SMT-LIB version 2.6
 */
export const smt2_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.smt2-parser`,
  "A Haskell parser for SMT-LIB version 2.6",
);

/**
 * A library for working with the SMTLIB format
 */
export const smtLib = mkPackage(
  nixRaw`pkgs.haskellPackages.smtLib`,
  "A library for working with the SMTLIB format",
);

/**
 * Dump the communication with an SMT solver for debugging purposes
 */
export const smtlib2_debug = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib2-debug`,
  "Dump the communication with an SMT solver for debugging purposes",
);

/**
 * A type-safe interface to communicate with an SMT solver
 */
export const smtlib2_pipe = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib2-pipe`,
  "A type-safe interface to communicate with an SMT solver",
);

/**
 * Helper functions to create SMTLib expressions in QuickCheck
 */
export const smtlib2_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib2-quickcheck`,
  "Helper functions to create SMTLib expressions in QuickCheck",
);

/**
 * Get timing informations for SMT queries
 */
export const smtlib2_timing = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib2-timing`,
  "Get timing informations for SMT queries",
);

/**
 * Low-level functions for SMT-LIB-based interaction with SMT solvers
 */
export const smtlib_backends = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib-backends`,
  "Low-level functions for SMT-LIB-based interaction with SMT solvers",
);

/**
 * Testing SMT-LIB backends
 */
export const smtlib_backends_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib-backends-tests`,
  "Testing SMT-LIB backends",
);

/**
 * An SMT-LIB backend implemented using Z3's C API
 */
export const smtlib_backends_z3 = mkPackage(
  nixRaw`pkgs.haskellPackages.smtlib-backends-z3`,
  "An SMT-LIB backend implemented using Z3's C API",
);

/**
 * Listen for SMTP traffic and send it to an MTA script
 */
export const smtp2mta = mkPackage(
  nixRaw`pkgs.haskellPackages.smtp2mta`,
  "Listen for SMTP traffic and send it to an MTA script",
);

/**
 * Simple email sending via SMTP
 */
export const smtp_mail = mkPackage(
  nixRaw`pkgs.haskellPackages.smtp-mail`,
  "Simple email sending via SMTP",
);

/**
 * Unofficial API client for smtp.bz
 */
export const smtpbz = mkPackage(
  nixRaw`pkgs.haskellPackages.smtpbz`,
  "Unofficial API client for smtp.bz",
);

/**
 * Strict ByteString Parser Combinator
 */
export const snack = mkPackage(
  nixRaw`pkgs.haskellPackages.snack`,
  "Strict ByteString Parser Combinator",
);

/**
 * A programming language with no semantics
 */
export const snail = mkPackage(
  nixRaw`pkgs.haskellPackages.snail`,
  "A programming language with no semantics",
);

/**
 * Top-level package for the Snap Web Framework
 */
export const snap = mkPackage(
  nixRaw`pkgs.haskellPackages.snap`,
  "Top-level package for the Snap Web Framework",
);

/**
 * None
 */
export const snap_app = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-app`,
  "None",
);

/**
 * Command-line tool to manage Snap AuthManager database
 */
export const snap_auth_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-auth-cli`,
  "Command-line tool to manage Snap AuthManager database",
);

/**
 * blaze-html integration for Snap
 */
export const snap_blaze = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-blaze`,
  "blaze-html integration for Snap",
);

/**
 * Snap: A Haskell Web Framework (core interfaces and types)
 */
export const snap_core = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-core`,
  "Snap: A Haskell Web Framework (core interfaces and types)",
);

/**
 * Add CORS headers to Snap applications
 */
export const snap_cors = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-cors`,
  "Add CORS headers to Snap applications",
);

/**
 * Serve Elm files through the Snap web framework
 */
export const snap_elm = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-elm`,
  "Serve Elm files through the Snap web framework",
);

/**
 * Collect errors in batches and dispatch them
 */
export const snap_error_collector = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-error-collector`,
  "Collect errors in batches and dispatch them",
);

/**
 * A collection of useful helpers and utilities for Snap web applications
 */
export const snap_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-extras`,
  "A collection of useful helpers and utilities for Snap web applications",
);

/**
 * Snap static loader
 */
export const snap_loader_static = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-loader-static`,
  "Snap static loader",
);

/**
 * Typesafe URLs for Snap applications
 */
export const snap_routes = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-routes`,
  "Typesafe URLs for Snap applications",
);

/**
 * A web server for the Snap Framework
 */
export const snap_server = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-server`,
  "A web server for the Snap Framework",
);

/**
 * Scaffolding CLI for the Snap Framework
 */
export const snap_templates = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-templates`,
  "Scaffolding CLI for the Snap Framework",
);

/**
 * A library for BDD-style testing with the Snap Web Framework
 */
export const snap_testing = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-testing`,
  "A library for BDD-style testing with the Snap Web Framework",
);

/**
 * Snap Framework utilities
 */
export const snap_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-utils`,
  "Snap Framework utilities",
);

/**
 * Type safe URLs for Snap
 */
export const snap_web_routes = mkPackage(
  nixRaw`pkgs.haskellPackages.snap-web-routes`,
  "Type safe URLs for Snap",
);

/**
 * acid-state snaplet for Snap Framework
 */
export const snaplet_acid_state = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-acid-state`,
  "acid-state snaplet for Snap Framework",
);

/**
 * Generic action log snaplet for the Snap Framework
 */
export const snaplet_actionlog = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-actionlog`,
  "Generic action log snaplet for the Snap Framework",
);

/**
 * Snap framework snaplet for the AMQP library
 */
export const snaplet_amqp = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-amqp`,
  "Snap framework snaplet for the AMQP library",
);

/**
 * Provides an Acid-State backend for the Auth Snaplet
 */
export const snaplet_auth_acid = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-auth-acid`,
  "Provides an Acid-State backend for the Auth Snaplet",
);

/**
 * CoffeeScript for Snap, auto-compilation and pre-compilation
 */
export const snaplet_coffee = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-coffee`,
  "CoffeeScript for Snap, auto-compilation and pre-compilation",
);

/**
 * A Snaplet for CSS minification
 */
export const snaplet_css_min = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-css-min`,
  "A Snaplet for CSS minification",
);

/**
 * Alternate authentication snaplet
 */
export const snaplet_customauth = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-customauth`,
  "Alternate authentication snaplet",
);

/**
 * DEPRECATED! You should use standard Snap >= 0.9 "environments" functionality. It provided ability to easly read configuration based on given app environment given at command line, envs are defined in app configuration file
 */
export const snaplet_environments = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-environments`,
  "DEPRECATED! You should use standard Snap >= 0.9 \"environments\" functionality. It provided ability to easly read configuration based on given app environment given at command line, envs are defined in app configuration file",
);

/**
 * Fay integration for Snap with request- and pre-compilation
 */
export const snaplet_fay = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-fay`,
  "Fay integration for Snap with request- and pre-compilation",
);

/**
 * Serve javascript files compiled with GHCJS
 */
export const snaplet_ghcjs = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-ghcjs`,
  "Serve javascript files compiled with GHCJS",
);

/**
 * A Hasql snaplet
 */
export const snaplet_hasql = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-hasql`,
  "A Hasql snaplet",
);

/**
 * Snaplet for Facebook's Haxl
 */
export const snaplet_haxl = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-haxl`,
  "Snaplet for Facebook's Haxl",
);

/**
 * HDBC snaplet for Snap Framework
 */
export const snaplet_hdbc = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-hdbc`,
  "HDBC snaplet for Snap Framework",
);

/**
 * Snap framework snaplet for the Logger API library
 */
export const snaplet_hslogger = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-hslogger`,
  "Snap framework snaplet for the Logger API library",
);

/**
 * snaplet-i18n
 */
export const snaplet_i18n = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-i18n`,
  "snaplet-i18n",
);

/**
 * Snap framework snaplet for the InfluxDB library
 */
export const snaplet_influxdb = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-influxdb`,
  "Snap framework snaplet for the InfluxDB library",
);

/**
 * Lexical Style Sheets - Snap Web Framework adaptor
 */
export const snaplet_lss = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-lss`,
  "Lexical Style Sheets - Snap Web Framework adaptor",
);

/**
 * Snap framework snaplet for the Mandrill API library
 */
export const snaplet_mandrill = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-mandrill`,
  "Snap framework snaplet for the Mandrill API library",
);

/**
 * Snap Framework MongoDB support as Snaplet
 */
export const snaplet_mongoDB = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-mongoDB`,
  "Snap Framework MongoDB support as Snaplet",
);

/**
 * Minimalistic MongoDB Snaplet
 */
export const snaplet_mongodb_minimalistic = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-mongodb-minimalistic`,
  "Minimalistic MongoDB Snaplet",
);

/**
 * mysql-simple snaplet for the Snap Framework
 */
export const snaplet_mysql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-mysql-simple`,
  "mysql-simple snaplet for the Snap Framework",
);

/**
 * snaplet-oauth
 */
export const snaplet_oauth = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-oauth`,
  "snaplet-oauth",
);

/**
 * persistent snaplet for the Snap Framework
 */
export const snaplet_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-persistent`,
  "persistent snaplet for the Snap Framework",
);

/**
 * postgresql-simple snaplet for the Snap Framework
 */
export const snaplet_postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-postgresql-simple`,
  "postgresql-simple snaplet for the Snap Framework",
);

/**
 * Postmark snaplet for the Snap Framework
 */
export const snaplet_postmark = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-postmark`,
  "Postmark snaplet for the Snap Framework",
);

/**
 * Automatic (re)compilation of purescript projects
 */
export const snaplet_purescript = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-purescript`,
  "Automatic (re)compilation of purescript projects",
);

/**
 * A ReCAPTCHA verification snaplet with Heist integration and connection sharing
 */
export const snaplet_recaptcha = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-recaptcha`,
  "A ReCAPTCHA verification snaplet with Heist integration and connection sharing",
);

/**
 * Redis support for Snap Framework
 */
export const snaplet_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-redis`,
  "Redis support for Snap Framework",
);

/**
 * CRUD for JSON data with Redis storage
 */
export const snaplet_redson = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-redson`,
  "CRUD for JSON data with Redis storage",
);

/**
 * REST resources for the Snap web framework
 */
export const snaplet_rest = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-rest`,
  "REST resources for the Snap web framework",
);

/**
 * A Snaplet for the Riak database
 */
export const snaplet_riak = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-riak`,
  "A Snaplet for the Riak database",
);

/**
 * Sass integration for Snap with request- and pre-compilation
 */
export const snaplet_sass = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-sass`,
  "Sass integration for Snap with request- and pre-compilation",
);

/**
 * Modularised session state for Snaplets, in a Snaplet
 */
export const snaplet_scoped_session = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-scoped-session`,
  "Modularised session state for Snaplets, in a Snaplet",
);

/**
 * Snaplet for Sedna Bindings. Essentailly a rip of snaplet-hdbc.
 */
export const snaplet_sedna = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-sedna`,
  "Snaplet for Sedna Bindings. Essentailly a rip of snaplet-hdbc.",
);

/**
 * Snaplet for the ses-html package
 */
export const snaplet_ses_html = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-ses-html`,
  "Snaplet for the ses-html package",
);

/**
 * sqlite-simple snaplet for the Snap Framework
 */
export const snaplet_sqlite_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-sqlite-simple`,
  "sqlite-simple snaplet for the Snap Framework",
);

/**
 * Snaplet for JWT authentication with snaplet-sqlite-simple
 */
export const snaplet_sqlite_simple_jwt_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-sqlite-simple-jwt-auth`,
  "Snaplet for JWT authentication with snaplet-sqlite-simple",
);

/**
 * Stripe snaplet for the Snap Framework
 */
export const snaplet_stripe = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-stripe`,
  "Stripe snaplet for the Snap Framework",
);

/**
 * Snaplet for Snap Framework enabling developers to administrative tasks akin to Rake tasks from Ruby On Rails framework
 */
export const snaplet_tasks = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-tasks`,
  "Snaplet for Snap Framework enabling developers to administrative tasks akin to Rake tasks from Ruby On Rails framework",
);

/**
 * Typed session snaplets and continuation-based programming for the Snap web framework
 */
export const snaplet_typed_sessions = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-typed-sessions`,
  "Typed session snaplets and continuation-based programming for the Snap web framework",
);

/**
 * A snaplet that communicates with wordpress over its api
 */
export const snaplet_wordpress = mkPackage(
  nixRaw`pkgs.haskellPackages.snaplet-wordpress`,
  "A snaplet that communicates with wordpress over its api",
);

/**
 * Bindings to the Google Snappy library for fast compression/decompression
 */
export const snappy = mkPackage(
  nixRaw`pkgs.haskellPackages.snappy`,
  "Bindings to the Google Snappy library for fast compression/decompression",
);

/**
 * Snappy Framing Format in Haskell
 */
export const snappy_framing = mkPackage(
  nixRaw`pkgs.haskellPackages.snappy-framing`,
  "Snappy Framing Format in Haskell",
);

/**
 * An enumeratee that uses Google's snappy compression library
 */
export const snappy_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.snappy-iteratee`,
  "An enumeratee that uses Google's snappy compression library",
);

/**
 * Lazy bytestring compression and decompression
 */
export const snappy_lazy = mkPackage(
  nixRaw`pkgs.haskellPackages.snappy-lazy`,
  "Lazy bytestring compression and decompression",
);

/**
 * Audio file reading/writing
 */
export const sndfile_enumerators = mkPackage(
  nixRaw`pkgs.haskellPackages.sndfile-enumerators`,
  "Audio file reading/writing",
);

/**
 * Tiny, declarative wrapper around ncurses
 */
export const sneakyterm = mkPackage(
  nixRaw`pkgs.haskellPackages.sneakyterm`,
  "Tiny, declarative wrapper around ncurses",
);

/**
 * A compositional web UI library, which draws to a Canvas element
 */
export const sneathlane_haste = mkPackage(
  nixRaw`pkgs.haskellPackages.sneathlane-haste`,
  "A compositional web UI library, which draws to a Canvas element",
);

/**
 * Extracts labeled snippets of code to files
 */
export const snippet_extractor = mkPackage(
  nixRaw`pkgs.haskellPackages.snippet-extractor`,
  "Extracts labeled snippets of code to files",
);

/**
 * The Simple Nice-Looking Manual Generator
 */
export const snm = mkPackage(
  nixRaw`pkgs.haskellPackages.snm`,
  "The Simple Nice-Looking Manual Generator",
);

/**
 * SNMP protocol library
 */
export const snmp = mkPackage(
  nixRaw`pkgs.haskellPackages.snmp`,
  "SNMP protocol library",
);

/**
 * encode any binary instance to white space
 */
export const snow_white = mkPackage(
  nixRaw`pkgs.haskellPackages.snow-white`,
  "encode any binary instance to white space",
);

/**
 * Bindings to the Snowball library
 */
export const snowball = mkPackage(
  nixRaw`pkgs.haskellPackages.snowball`,
  "Bindings to the Snowball library",
);

/**
 * A loose port of Twitter Snowflake to Haskell. Generates arbitrary precision, unique, time-sortable identifiers.
 */
export const snowflake = mkPackage(
  nixRaw`pkgs.haskellPackages.snowflake`,
  "A loose port of Twitter Snowflake to Haskell. Generates arbitrary precision, unique, time-sortable identifiers.",
);

/**
 * twitter's snowflake
 */
export const snowflake_core = mkPackage(
  nixRaw`pkgs.haskellPackages.snowflake-core`,
  "twitter's snowflake",
);

/**
 * snowflake http server
 */
export const snowflake_server = mkPackage(
  nixRaw`pkgs.haskellPackages.snowflake-server`,
  "snowflake http server",
);

/**
 * randomized fractal snowflakes demo
 */
export const snowglobe = mkPackage(
  nixRaw`pkgs.haskellPackages.snowglobe`,
  "randomized fractal snowflakes demo",
);

/**
 * Integer singletons with flexible representation
 */
export const snumber = mkPackage(
  nixRaw`pkgs.haskellPackages.snumber`,
  "Integer singletons with flexible representation",
);

/**
 * SOAP client tools
 */
export const soap = mkPackage(
  nixRaw`pkgs.haskellPackages.soap`,
  "SOAP client tools",
);

/**
 * TLS-enabled SOAP transport (using openssl bindings)
 */
export const soap_openssl = mkPackage(
  nixRaw`pkgs.haskellPackages.soap-openssl`,
  "TLS-enabled SOAP transport (using openssl bindings)",
);

/**
 * TLS-enabled SOAP transport (using tls package)
 */
export const soap_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.soap-tls`,
  "TLS-enabled SOAP transport (using tls package)",
);

/**
 * Tunnel a socket over a single datastream (stdin/stdout)
 */
export const sock2stream = mkPackage(
  nixRaw`pkgs.haskellPackages.sock2stream`,
  "Tunnel a socket over a single datastream (stdin/stdout)",
);

/**
 * Printing SockAddr
 */
export const sockaddr = mkPackage(
  nixRaw`pkgs.haskellPackages.sockaddr`,
  "Printing SockAddr",
);

/**
 * An extensible socket library
 */
export const socket = mkPackage(
  nixRaw`pkgs.haskellPackages.socket`,
  "An extensible socket library",
);

/**
 * Definitions for using ICMP with the `socket` library
 */
export const socket_icmp = mkPackage(
  nixRaw`pkgs.haskellPackages.socket-icmp`,
  "Definitions for using ICMP with the `socket` library",
);

export const socket_io = mkPackage(
  nixRaw`pkgs.haskellPackages.socket-io`,
  "",
);

/**
 * High-level network sockets
 */
export const sockets = mkPackage(
  nixRaw`pkgs.haskellPackages.sockets`,
  "High-level network sockets",
);

/**
 * Support for the Sockets and Pipes book
 */
export const sockets_and_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.sockets-and-pipes`,
  "Support for the Sockets and Pipes book",
);

/**
 * A small websocket backend provider
 */
export const socketson = mkPackage(
  nixRaw`pkgs.haskellPackages.socketson`,
  "A small websocket backend provider",
);

/**
 * Socks proxy (ver 5)
 */
export const socks = mkPackage(
  nixRaw`pkgs.haskellPackages.socks`,
  "Socks proxy (ver 5)",
);

/**
 * Generate CSV Exports of your Solana Staking Rewards
 */
export const solana_staking_csvs = mkPackage(
  nixRaw`pkgs.haskellPackages.solana-staking-csvs`,
  "Generate CSV Exports of your Solana Staking Rewards",
);

/**
 * Swagger generation for Solga
 */
export const solga_swagger = mkPackage(
  nixRaw`pkgs.haskellPackages.solga-swagger`,
  "Swagger generation for Solga",
);

/**
 * A minimal Solr client library
 */
export const solr = mkPackage(
  nixRaw`pkgs.haskellPackages.solr`,
  "A minimal Solr client library",
);

/**
 * Solving simple games
 */
export const solve = mkPackage(
  nixRaw`pkgs.haskellPackages.solve`,
  "Solving simple games",
);

/**
 * Existential type: Some
 */
export const some = mkPackage(
  nixRaw`pkgs.haskellPackages.some`,
  "Existential type: Some",
);

/**
 * Existential type: Some
 */
export const some_1_0_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.some_1_0_5`,
  "Existential type: Some",
);

/**
 * Carry evidence of constraints around
 */
export const some_dict_of = mkPackage(
  nixRaw`pkgs.haskellPackages.some-dict-of`,
  "Carry evidence of constraints around",
);

/**
 * True Sums of Products
 */
export const sop_core = mkPackage(
  nixRaw`pkgs.haskellPackages.sop-core`,
  "True Sums of Products",
);

/**
 * Bindings to Sophia library
 */
export const sophia = mkPackage(
  nixRaw`pkgs.haskellPackages.sophia`,
  "Bindings to Sophia library",
);

/**
 * A Haskell sorting toolkit
 */
export const sort = mkPackage(
  nixRaw`pkgs.haskellPackages.sort`,
  "A Haskell sorting toolkit",
);

/**
 * sort by pinyin
 */
export const sort_by_pinyin = mkPackage(
  nixRaw`pkgs.haskellPackages.sort-by-pinyin`,
  "sort by pinyin",
);

/**
 * Type-enforced sorted lists and related functions
 */
export const sorted_list = mkPackage(
  nixRaw`pkgs.haskellPackages.sorted-list`,
  "Type-enforced sorted lists and related functions",
);

/**
 * Generate string for sort key
 */
export const sortee = mkPackage(
  nixRaw`pkgs.haskellPackages.sortee`,
  "Generate string for sort key",
);

/**
 * Sort small lists with sorting network
 */
export const sorting_network = mkPackage(
  nixRaw`pkgs.haskellPackages.sorting-network`,
  "Sort small lists with sorting network",
);

/**
 * Haskell EDSL for Souffle
 */
export const souffle_dsl = mkPackage(
  nixRaw`pkgs.haskellPackages.souffle-dsl`,
  "Haskell EDSL for Souffle",
);

/**
 * Approximate a song from other pieces of sound
 */
export const sound_collage = mkPackage(
  nixRaw`pkgs.haskellPackages.sound-collage`,
  "Approximate a song from other pieces of sound",
);

/**
 * Audio delay line
 */
export const sounddelay = mkPackage(
  nixRaw`pkgs.haskellPackages.sounddelay`,
  "Audio delay line",
);

/**
 * sound generator
 */
export const soundgen = mkPackage(
  nixRaw`pkgs.haskellPackages.soundgen`,
  "sound generator",
);

/**
 * The server backend for the source code iPhone app
 */
export const source_code_server = mkPackage(
  nixRaw`pkgs.haskellPackages.source-code-server`,
  "The server backend for the source code iPhone app",
);

/**
 * Implementation of source maps as proposed by Google and Mozilla
 */
export const sourcemap = mkPackage(
  nixRaw`pkgs.haskellPackages.sourcemap`,
  "Implementation of source maps as proposed by Google and Mozilla",
);

/**
 * Play, write, read, convert audio signals using Sox
 */
export const sox = mkPackage(
  nixRaw`pkgs.haskellPackages.sox`,
  "Play, write, read, convert audio signals using Sox",
);

/**
 * Write, read, convert audio signals using libsox
 */
export const soxlib = mkPackage(
  nixRaw`pkgs.haskellPackages.soxlib`,
  "Write, read, convert audio signals using libsox",
);

/**
 * Experimental library
 */
export const space = mkPackage(
  nixRaw`pkgs.haskellPackages.space`,
  "Experimental library",
);

/**
 * Space Character
 */
export const spacechar = mkPackage(
  nixRaw`pkgs.haskellPackages.spacechar`,
  "Space Character",
);

/**
 * Gopher server library and daemon
 */
export const spacecookie = mkPackage(
  nixRaw`pkgs.haskellPackages.spacecookie`,
  "Gopher server library and daemon",
);

/**
 * Generators for space-filling curves
 */
export const spacefill = mkPackage(
  nixRaw`pkgs.haskellPackages.spacefill`,
  "Generators for space-filling curves",
);

/**
 * Optimization over arbitrary search spaces
 */
export const spaceprobe = mkPackage(
  nixRaw`pkgs.haskellPackages.spaceprobe`,
  "Optimization over arbitrary search spaces",
);

/**
 * A simple programming and debugging environment
 */
export const spade = mkPackage(
  nixRaw`pkgs.haskellPackages.spade`,
  "A simple programming and debugging environment",
);

/**
 * Distributed Apache Spark applications in Haskell
 */
export const sparkle = mkPackage(
  nixRaw`pkgs.haskellPackages.sparkle`,
  "Distributed Apache Spark applications in Haskell",
);

/**
 * An SPARQL 1.1 Protocol client library.
 */
export const sparql_protocol = mkPackage(
  nixRaw`pkgs.haskellPackages.sparql-protocol`,
  "An SPARQL 1.1 Protocol client library.",
);

/**
 * Unified streaming data-dependency framework for web apps
 */
export const sparrow = mkPackage(
  nixRaw`pkgs.haskellPackages.sparrow`,
  "Unified streaming data-dependency framework for web apps",
);

/**
 * Sparse bitmaps for pattern match coverage
 */
export const sparsebit = mkPackage(
  nixRaw`pkgs.haskellPackages.sparsebit`,
  "Sparse bitmaps for pattern match coverage",
);

/**
 * Lightweight parsing library based on partial functions
 */
export const sparser = mkPackage(
  nixRaw`pkgs.haskellPackages.sparser`,
  "Lightweight parsing library based on partial functions",
);

/**
 * A unix-style (read from stdin, write to stdout) global hotkey daemon
 */
export const spartacon = mkPackage(
  nixRaw`pkgs.haskellPackages.spartacon`,
  "A unix-style (read from stdin, write to stdout) global hotkey daemon",
);

/**
 * brainless form validation
 */
export const spata = mkPackage(
  nixRaw`pkgs.haskellPackages.spata`,
  "brainless form validation",
);

/**
 * 3d math including quaternions/euler angles/dcms and utility functions
 */
export const spatial_math = mkPackage(
  nixRaw`pkgs.haskellPackages.spatial-math`,
  "3d math including quaternions/euler angles/dcms and utility functions",
);

/**
 * 3d math including quaternions/euler angles/dcms and utility functions
 */
export const spatial_math_0_5_0_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.spatial-math_0_5_0_1`,
  "3d math including quaternions/euler angles/dcms and utility functions",
);

/**
 * Rotate about any suitable axis
 */
export const spatial_rotations = mkPackage(
  nixRaw`pkgs.haskellPackages.spatial-rotations`,
  "Rotate about any suitable axis",
);

/**
 * Tiny library for concurrent computations
 */
export const spawn = mkPackage(
  nixRaw`pkgs.haskellPackages.spawn`,
  "Tiny library for concurrent computations",
);

/**
 * SPDX license expression language, Extras
 */
export const spdx = mkPackage(
  nixRaw`pkgs.haskellPackages.spdx`,
  "SPDX license expression language, Extras",
);

/**
 * SPDX license templates
 */
export const spdx_license = mkPackage(
  nixRaw`pkgs.haskellPackages.spdx-license`,
  "SPDX license templates",
);

/**
 * Combinatorial species lite
 */
export const spe = mkPackage(
  nixRaw`pkgs.haskellPackages.spe`,
  "Combinatorial species lite",
);

/**
 * Typeclass providing special values
 */
export const special_values = mkPackage(
  nixRaw`pkgs.haskellPackages.special-values`,
  "Typeclass providing special values",
);

/**
 * Create specialized types from polymorphic ones using TH
 */
export const specialize_th = mkPackage(
  nixRaw`pkgs.haskellPackages.specialize-th`,
  "Create specialized types from polymorphic ones using TH",
);

/**
 * Computational combinatorial species
 */
export const species = mkPackage(
  nixRaw`pkgs.haskellPackages.species`,
  "Computational combinatorial species",
);

/**
 * Library for spectral clustering
 */
export const spectral_clustering = mkPackage(
  nixRaw`pkgs.haskellPackages.spectral-clustering`,
  "Library for spectral clustering",
);

/**
 * discovery of properties about Haskell functions
 */
export const speculate = mkPackage(
  nixRaw`pkgs.haskellPackages.speculate`,
  "discovery of properties about Haskell functions",
);

/**
 * Merged into 'speculation'. Use that instead.
 */
export const speculation_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.speculation-transformers`,
  "Merged into 'speculation'. Use that instead.",
);

/**
 * Speechmatics api client
 */
export const speechmatics = mkPackage(
  nixRaw`pkgs.haskellPackages.speechmatics`,
  "Speechmatics api client",
);

/**
 * Speedy slice sampling
 */
export const speedy_slice = mkPackage(
  nixRaw`pkgs.haskellPackages.speedy-slice`,
  "Speedy slice sampling",
);

/**
 * Spelling suggestion tool with library and command-line interfaces
 */
export const spelling_suggest = mkPackage(
  nixRaw`pkgs.haskellPackages.spelling-suggest`,
  "Spelling suggestion tool with library and command-line interfaces",
);

/**
 * Geometry on a sphere
 */
export const spherical = mkPackage(
  nixRaw`pkgs.haskellPackages.spherical`,
  "Geometry on a sphere",
);

/**
 * Orbotix Sphero client library
 */
export const sphero = mkPackage(
  nixRaw`pkgs.haskellPackages.sphero`,
  "Orbotix Sphero client library",
);

/**
 * Sphinx CLI and demo of Haskell Sphinx library
 */
export const sphinx_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.sphinx-cli`,
  "Sphinx CLI and demo of Haskell Sphinx library",
);

/**
 * An FRP-based game engine written in Haskell
 */
export const spice = mkPackage(
  nixRaw`pkgs.haskellPackages.spice`,
  "An FRP-based game engine written in Haskell",
);

/**
 * Experimental web browser
 */
export const spike = mkPackage(
  nixRaw`pkgs.haskellPackages.spike`,
  "Experimental web browser",
);

/**
 * Simple implementation of the generic spine view
 */
export const spine = mkPackage(
  nixRaw`pkgs.haskellPackages.spine`,
  "Simple implementation of the generic spine view",
);

/**
 * C-library loader for spirv-reflect tool
 */
export const spirv_reflect_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.spirv-reflect-ffi`,
  "C-library loader for spirv-reflect tool",
);

/**
 * Data types from spirv-reflect tool
 */
export const spirv_reflect_types = mkPackage(
  nixRaw`pkgs.haskellPackages.spirv-reflect-types`,
  "Data types from spirv-reflect tool",
);

/**
 * YAML loader for spirv-reflect tool
 */
export const spirv_reflect_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.spirv-reflect-yaml`,
  "YAML loader for spirv-reflect tool",
);

/**
 * Cross-platform Socket to Socket Data Splicing
 */
export const splice = mkPackage(
  nixRaw`pkgs.haskellPackages.splice`,
  "Cross-platform Socket to Socket Data Splicing",
);

/**
 * A parallel implementation of the Sorokina/Zeilfelder spline scheme
 */
export const spline3 = mkPackage(
  nixRaw`pkgs.haskellPackages.spline3`,
  "A parallel implementation of the Sorokina/Zeilfelder spline scheme",
);

/**
 * B-Splines, other splines, and NURBS
 */
export const splines = mkPackage(
  nixRaw`pkgs.haskellPackages.splines`,
  "B-Splines, other splines, and NURBS",
);

/**
 * Combinator library for splitting lists
 */
export const split = mkPackage(
  nixRaw`pkgs.haskellPackages.split`,
  "Combinator library for splitting lists",
);

/**
 * Control.Concurrent.Chan split into sending and receiving halves.
 */
export const split_channel = mkPackage(
  nixRaw`pkgs.haskellPackages.split-channel`,
  "Control.Concurrent.Chan split into sending and receiving halves.",
);

/**
 * Split a big audio file into pieces at positions of silence
 */
export const split_record = mkPackage(
  nixRaw`pkgs.haskellPackages.split-record`,
  "Split a big audio file into pieces at positions of silence",
);

/**
 * STM's TChan split into sending and receiving halves
 */
export const split_tchan = mkPackage(
  nixRaw`pkgs.haskellPackages.split-tchan`,
  "STM's TChan split into sending and receiving halves",
);

/**
 * Fast Splittable PRNG
 */
export const splitmix = mkPackage(
  nixRaw`pkgs.haskellPackages.splitmix`,
  "Fast Splittable PRNG",
);

/**
 * Fast Splittable PRNG
 */
export const splitmix_0_1_0_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.splitmix_0_1_0_5`,
  "Fast Splittable PRNG",
);

/**
 * Random samplers for some common distributions, based on splitmix
 */
export const splitmix_distributions = mkPackage(
  nixRaw`pkgs.haskellPackages.splitmix-distributions`,
  "Random samplers for some common distributions, based on splitmix",
);

/**
 * A tool for visualizing the lifecycle of many concurrent multi-staged processes
 */
export const splot = mkPackage(
  nixRaw`pkgs.haskellPackages.splot`,
  "A tool for visualizing the lifecycle of many concurrent multi-staged processes",
);

/**
 * Unified API for phantom typed newtypes and type aliases
 */
export const spooky = mkPackage(
  nixRaw`pkgs.haskellPackages.spooky`,
  "Unified API for phantom typed newtypes and type aliases",
);

/**
 * Convert between ByteString and Vector.Storable without copying
 */
export const spool = mkPackage(
  nixRaw`pkgs.haskellPackages.spool`,
  "Convert between ByteString and Vector.Storable without copying",
);

/**
 * Catch errors thrown from pure computations
 */
export const spoon = mkPackage(
  nixRaw`pkgs.haskellPackages.spoon`,
  "Catch errors thrown from pure computations",
);

/**
 * Catch errors from pure computations in a Maybe/Either
 */
export const spork = mkPackage(
  nixRaw`pkgs.haskellPackages.spork`,
  "Catch errors from pure computations in a Maybe/Either",
);

/**
 * Read and write spreadsheets from and to CSV files in a lazy way
 */
export const spreadsheet = mkPackage(
  nixRaw`pkgs.haskellPackages.spreadsheet`,
  "Read and write spreadsheets from and to CSV files in a lazy way",
);

/**
 * JSON API to HTML website wrapper
 */
export const sprinkles = mkPackage(
  nixRaw`pkgs.haskellPackages.sprinkles`,
  "JSON API to HTML website wrapper",
);

/**
 * HTTP proxy for authenticating users via OAuth2
 */
export const sproxy = mkPackage(
  nixRaw`pkgs.haskellPackages.sproxy`,
  "HTTP proxy for authenticating users via OAuth2",
);

/**
 * Secure HTTP proxy for authenticating users via OAuth2
 */
export const sproxy2 = mkPackage(
  nixRaw`pkgs.haskellPackages.sproxy2`,
  "Secure HTTP proxy for authenticating users via OAuth2",
);

/**
 * Web interface to sproxy database
 */
export const sproxy_web = mkPackage(
  nixRaw`pkgs.haskellPackages.sproxy-web`,
  "Web interface to sproxy database",
);

/**
 * mysql backend for sql-simple
 */
export const sql_simple_mysql = mkPackage(
  nixRaw`pkgs.haskellPackages.sql-simple-mysql`,
  "mysql backend for sql-simple",
);

/**
 * conection pool for sql-simple
 */
export const sql_simple_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.sql-simple-pool`,
  "conection pool for sql-simple",
);

/**
 * postgresql backend for sql-simple
 */
export const sql_simple_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.sql-simple-postgresql`,
  "postgresql backend for sql-simple",
);

/**
 * sqlite backend for sql-simple
 */
export const sql_simple_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.sql-simple-sqlite`,
  "sqlite backend for sql-simple",
);

/**
 * SQL keywords data constructors into OverloadedString
 */
export const sql_words = mkPackage(
  nixRaw`pkgs.haskellPackages.sql-words`,
  "SQL keywords data constructors into OverloadedString",
);

/**
 * Bindings for SQL/CLI (ODBC) C API
 */
export const sqlcli = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlcli`,
  "Bindings for SQL/CLI (ODBC) C API",
);

/**
 * ODBC specific definitions to be used by SQL CLI clients
 */
export const sqlcli_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlcli-odbc`,
  "ODBC specific definitions to be used by SQL CLI clients",
);

/**
 * A primitive yet easy to use sqlite library
 */
export const sqlite_easy = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlite-easy`,
  "A primitive yet easy to use sqlite library",
);

/**
 * Mid-Level SQLite client library
 */
export const sqlite_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlite-simple`,
  "Mid-Level SQLite client library",
);

/**
 * Interpolated SQLite queries via quasiquotation
 */
export const sqlite_simple_interpolate = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlite-simple-interpolate`,
  "Interpolated SQLite queries via quasiquotation",
);

/**
 * Typed extension to sqlite simple
 */
export const sqlite_simple_typed = mkPackage(
  nixRaw`pkgs.haskellPackages.sqlite-simple-typed`,
  "Typed extension to sqlite simple",
);

/**
 * The double category of Hask functors and profunctors
 */
export const squares = mkPackage(
  nixRaw`pkgs.haskellPackages.squares`,
  "The double category of Hask functors and profunctors",
);

/**
 * Squeal PostgreSQL Library
 */
export const squeal_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.squeal-postgresql`,
  "Squeal PostgreSQL Library",
);

/**
 * LTree extension for Squeal
 */
export const squeal_postgresql_ltree = mkPackage(
  nixRaw`pkgs.haskellPackages.squeal-postgresql-ltree`,
  "LTree extension for Squeal",
);

/**
 * UUID OSSP extension for Squeal
 */
export const squeal_postgresql_uuid_ossp = mkPackage(
  nixRaw`pkgs.haskellPackages.squeal-postgresql-uuid-ossp`,
  "UUID OSSP extension for Squeal",
);

/**
 * Use databases with the version 3 series of the SQLite C library
 */
export const squeather = mkPackage(
  nixRaw`pkgs.haskellPackages.squeather`,
  "Use databases with the version 3 series of the SQLite C library",
);

/**
 * A file-packing application
 */
export const squeeze = mkPackage(
  nixRaw`pkgs.haskellPackages.squeeze`,
  "A file-packing application",
);

/**
 * Module limbo
 */
export const sr_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.sr-extra`,
  "Module limbo",
);

/**
 * Data types for managing source code locations
 */
export const srcloc = mkPackage(
  nixRaw`pkgs.haskellPackages.srcloc`,
  "Data types for managing source code locations",
);

/**
 * Parsing and processing s-records
 */
export const srec = mkPackage(
  nixRaw`pkgs.haskellPackages.srec`,
  "Parsing and processing s-records",
);

/**
 * The data type for SRT files
 */
export const srt = mkPackage(
  nixRaw`pkgs.haskellPackages.srt`,
  "The data type for SRT files",
);

/**
 * Dhall Encoder/Decoder for SRT
 */
export const srt_dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.srt-dhall`,
  "Dhall Encoder/Decoder for SRT",
);

/**
 * Format an SRT
 */
export const srt_formatting = mkPackage(
  nixRaw`pkgs.haskellPackages.srt-formatting`,
  "Format an SRT",
);

/**
 * A general framework to work with Symbolic Regression expression trees
 */
export const srtree = mkPackage(
  nixRaw`pkgs.haskellPackages.srtree`,
  "A general framework to work with Symbolic Regression expression trees",
);

/**
 * A simple web server for local usage
 */
export const srv = mkPackage(
  nixRaw`pkgs.haskellPackages.srv`,
  "A simple web server for local usage",
);

/**
 * Simple SCGI Library
 */
export const sscgi = mkPackage(
  nixRaw`pkgs.haskellPackages.sscgi`,
  "Simple SCGI Library",
);

/**
 * Formats Strings with subscript or superscript characters
 */
export const sscript = mkPackage(
  nixRaw`pkgs.haskellPackages.sscript`,
  "Formats Strings with subscript or superscript characters",
);

/**
 * Read and interpret the SSH known-hosts file
 */
export const ssh_known_hosts = mkPackage(
  nixRaw`pkgs.haskellPackages.ssh-known-hosts`,
  "Read and interpret the SSH known-hosts file",
);

/**
 * Check sshd configuration for adherence to best practices
 */
export const sshd_lint = mkPackage(
  nixRaw`pkgs.haskellPackages.sshd-lint`,
  "Check sshd configuration for adherence to best practices",
);

/**
 * Wrapper daemon to manage an ssh tunnel
 */
export const sshtun = mkPackage(
  nixRaw`pkgs.haskellPackages.sshtun`,
  "Wrapper daemon to manage an ssh tunnel",
);

/**
 * HTTP proxy for S3
 */
export const sssp = mkPackage(
  nixRaw`pkgs.haskellPackages.sssp`,
  "HTTP proxy for S3",
);

/**
 * SSTables in Haskell
 */
export const sstable = mkPackage(
  nixRaw`pkgs.haskellPackages.sstable`,
  "SSTables in Haskell",
);

/**
 * Comma-separated-value (CSV) read, show and write routines
 */
export const ssv = mkPackage(
  nixRaw`pkgs.haskellPackages.ssv`,
  "Comma-separated-value (CSV) read, show and write routines",
);

/**
 * Purely functional stable heaps (fair priority queues)
 */
export const stable_heap = mkPackage(
  nixRaw`pkgs.haskellPackages.stable-heap`,
  "Purely functional stable heaps (fair priority queues)",
);

/**
 * algorithms around stable marriage
 */
export const stable_marriage = mkPackage(
  nixRaw`pkgs.haskellPackages.stable-marriage`,
  "algorithms around stable marriage",
);

/**
 * Memoization based on argument identity
 */
export const stable_memo = mkPackage(
  nixRaw`pkgs.haskellPackages.stable-memo`,
  "Memoization based on argument identity",
);

/**
 * Trees whose branches are resistant to change
 */
export const stable_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.stable-tree`,
  "Trees whose branches are resistant to change",
);

/**
 * Mustache templates for Haskell
 */
export const stache = mkPackage(
  nixRaw`pkgs.haskellPackages.stache`,
  "Mustache templates for Haskell",
);

/**
 * The Haskell Tool Stack
 */
export const stack = mkPackage(
  nixRaw`pkgs.haskellPackages.stack`,
  "The Haskell Tool Stack",
);

/**
 * CLI tool for building across Stackage major versions
 */
export const stack_all = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-all`,
  "CLI tool for building across Stackage major versions",
);

/**
 * Clean away old stack build artifacts
 */
export const stack_clean_old = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-clean-old`,
  "Clean away old stack build artifacts",
);

/**
 * Clean away old stack build artifacts
 */
export const stack_clean_old_0_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-clean-old_0_5`,
  "Clean away old stack build artifacts",
);

/**
 * Initial project template from stack
 */
export const stack_hpc_coveralls = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-hpc-coveralls`,
  "Initial project template from stack",
);

/**
 * A program for extending Stack to add distributed capabilities
 */
export const stack_network = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-network`,
  "A program for extending Stack to add distributed capabilities",
);

/**
 * Initial project template from stack
 */
export const stack_run_auto = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-run-auto`,
  "Initial project template from stack",
);

/**
 * Create etags for Haskell projects based on Stack snapshots
 */
export const stack_tag = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-tag`,
  "Create etags for Haskell projects based on Stack snapshots",
);

/**
 * Generate a stack template from a folder
 */
export const stack_templatizer = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-templatizer`,
  "Generate a stack template from a folder",
);

/**
 * Parse a stack.yaml file
 */
export const stack_yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.stack-yaml`,
  "Parse a stack.yaml file",
);

/**
 * Dummy package forcing installation of other Stackage packages
 */
export const stackage = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage`,
  "Dummy package forcing installation of other Stackage packages",
);

/**
 * Convert Stack files into Nix build instructions
 */
export const stackage2nix = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage2nix`,
  "Convert Stack files into Nix build instructions",
);

/**
 * Calculate and print (in different formats) Stackage build plans
 */
export const stackage_build_plan = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-build-plan`,
  "Calculate and print (in different formats) Stackage build plans",
);

/**
 * A CLI executable for cabal-based stackage commands
 */
export const stackage_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-cabal`,
  "A CLI executable for cabal-based stackage commands",
);

/**
 * Secure download of packages for cabal-install
 */
export const stackage_install = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-install`,
  "Secure download of packages for cabal-install",
);

/**
 * Tool for querying Stackage
 */
export const stackage_query = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-query`,
  "Tool for querying Stackage",
);

/**
 * Work with shared stackage sandboxes
 */
export const stackage_sandbox = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-sandbox`,
  "Work with shared stackage sandboxes",
);

/**
 * An executable for downloading a Haskell setup
 */
export const stackage_setup = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-setup`,
  "An executable for downloading a Haskell setup",
);

/**
 * Update your package index incrementally (requires git)
 */
export const stackage_update = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-update`,
  "Update your package index incrementally (requires git)",
);

/**
 * A more secure version of cabal upload which uses HTTPS
 */
export const stackage_upload = mkPackage(
  nixRaw`pkgs.haskellPackages.stackage-upload`,
  "A more secure version of cabal upload which uses HTTPS",
);

export const stackctl = mkPackage(
  nixRaw`pkgs.haskellPackages.stackctl`,
  "",
);

/**
 * Ascii DAG(Directed acyclic graph) for visualization of dataflow
 */
export const stacked_dag = mkPackage(
  nixRaw`pkgs.haskellPackages.stacked-dag`,
  "Ascii DAG(Directed acyclic graph) for visualization of dataflow",
);

/**
 * Numerical statistics for Foldable containers
 */
export const staf = mkPackage(
  nixRaw`pkgs.haskellPackages.staf`,
  "Numerical statistics for Foldable containers",
);

/**
 * Static site generator
 */
export const stagen = mkPackage(
  nixRaw`pkgs.haskellPackages.stagen`,
  "Static site generator",
);

/**
 * *-semirings
 */
export const star = mkPackage(
  nixRaw`pkgs.haskellPackages.star`,
  "*-semirings",
);

/**
 * the * -> * types, operators, and covariant instances
 */
export const star_to_star = mkPackage(
  nixRaw`pkgs.haskellPackages.star-to-star`,
  "the * -> * types, operators, and covariant instances",
);

/**
 * contravariant instances for * -> * types and operators
 */
export const star_to_star_contra = mkPackage(
  nixRaw`pkgs.haskellPackages.star-to-star-contra`,
  "contravariant instances for * -> * types and operators",
);

/**
 * Space simulation game
 */
export const starrover2 = mkPackage(
  nixRaw`pkgs.haskellPackages.starrover2`,
  "Space simulation game",
);

/**
 * A faster variant of the RWS monad transformers
 */
export const stateWriter = mkPackage(
  nixRaw`pkgs.haskellPackages.stateWriter`,
  "A faster variant of the RWS monad transformers",
);

/**
 * ISO 3166-2:US state codes and i18n names
 */
export const state_codes = mkPackage(
  nixRaw`pkgs.haskellPackages.state-codes`,
  "ISO 3166-2:US state codes and i18n names",
);

/**
 * Compiles Rhapsody statecharts to C
 */
export const statechart = mkPackage(
  nixRaw`pkgs.haskellPackages.statechart`,
  "Compiles Rhapsody statecharts to C",
);

/**
 * Typeclass instances for monad transformer stacks with an ST thread at the bottom
 */
export const stateful_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.stateful-mtl`,
  "Typeclass instances for monad transformer stacks with an ST thread at the bottom",
);

/**
 * Abstraction for things that work like IORef
 */
export const stateref = mkPackage(
  nixRaw`pkgs.haskellPackages.stateref`,
  "Abstraction for things that work like IORef",
);

/**
 * Simple State-like monad transformer with saveable and restorable state
 */
export const statestack = mkPackage(
  nixRaw`pkgs.haskellPackages.statestack`,
  "Simple State-like monad transformer with saveable and restorable state",
);

/**
 * Collect system level metrics and statistics
 */
export const statgrab = mkPackage(
  nixRaw`pkgs.haskellPackages.statgrab`,
  "Collect system level metrics and statistics",
);

/**
 * A Haskell library providing types representing 8, 16, 32, 64 or 128 bytes of data
 */
export const static_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.static-bytes`,
  "A Haskell library providing types representing 8, 16, 32, 64 or 128 bytes of data",
);

/**
 * DSL to generate HTML5 Canvas javascript
 */
export const static_canvas = mkPackage(
  nixRaw`pkgs.haskellPackages.static-canvas`,
  "DSL to generate HTML5 Canvas javascript",
);

/**
 * Serialisable static pointers to functions
 */
export const static_closure = mkPackage(
  nixRaw`pkgs.haskellPackages.static-closure`,
  "Serialisable static pointers to functions",
);

/**
 * Immutable hash
 */
export const static_hash = mkPackage(
  nixRaw`pkgs.haskellPackages.static-hash`,
  "Immutable hash",
);

/**
 * JavaScript and Css files concat for http optimization. Now with LESS support.
 */
export const static_resources = mkPackage(
  nixRaw`pkgs.haskellPackages.static-resources`,
  "JavaScript and Css files concat for http optimization. Now with LESS support.",
);

/**
 * Lists, Texts, ByteStrings and Vectors of statically known length
 */
export const static_text = mkPackage(
  nixRaw`pkgs.haskellPackages.static-text`,
  "Lists, Texts, ByteStrings and Vectors of statically known length",
);

/**
 * Reusable static analysis interfaces and modules
 */
export const staticanalysis = mkPackage(
  nixRaw`pkgs.haskellPackages.staticanalysis`,
  "Reusable static analysis interfaces and modules",
);

/**
 * A library of statistical types, data, and functions
 */
export const statistics = mkPackage(
  nixRaw`pkgs.haskellPackages.statistics`,
  "A library of statistical types, data, and functions",
);

/**
 * Functions for working with Dirichlet densities and mixtures on vectors
 */
export const statistics_dirichlet = mkPackage(
  nixRaw`pkgs.haskellPackages.statistics-dirichlet`,
  "Functions for working with Dirichlet densities and mixtures on vectors",
);

/**
 * Linear regression between two samples, based on the 'statistics' package
 */
export const statistics_linreg = mkPackage(
  nixRaw`pkgs.haskellPackages.statistics-linreg`,
  "Linear regression between two samples, based on the 'statistics' package",
);

/**
 * Statsd UDP client
 */
export const statsd_client = mkPackage(
  nixRaw`pkgs.haskellPackages.statsd-client`,
  "Statsd UDP client",
);

/**
 * DataDog-flavored StatsD client
 */
export const statsd_datadog = mkPackage(
  nixRaw`pkgs.haskellPackages.statsd-datadog`,
  "DataDog-flavored StatsD client",
);

/**
 * Simple StatsD Client
 */
export const statsd_rupp = mkPackage(
  nixRaw`pkgs.haskellPackages.statsd-rupp`,
  "Simple StatsD Client",
);

/**
 * A lovely [Dog]StatsD implementation
 */
export const statsdi = mkPackage(
  nixRaw`pkgs.haskellPackages.statsdi`,
  "A lovely [Dog]StatsD implementation",
);

/**
 * A wrapper over the StatusNotifierItem/libappindicator dbus specification
 */
export const status_notifier_item = mkPackage(
  nixRaw`pkgs.haskellPackages.status-notifier-item`,
  "A wrapper over the StatusNotifierItem/libappindicator dbus specification",
);

/**
 * What version is the package X in stackage lts-Y.ZZ?
 */
export const staversion = mkPackage(
  nixRaw`pkgs.haskellPackages.staversion`,
  "What version is the package X in stackage lts-Y.ZZ?",
);

/**
 * A wrapper around Sean Barrett's JPEG/PNG decoder
 */
export const stb_image = mkPackage(
  nixRaw`pkgs.haskellPackages.stb-image`,
  "A wrapper around Sean Barrett's JPEG/PNG decoder",
);

/**
 * A wrapper around Sean Barrett's TrueType rasterizer library
 */
export const stb_truetype = mkPackage(
  nixRaw`pkgs.haskellPackages.stb-truetype`,
  "A wrapper around Sean Barrett's TrueType rasterizer library",
);

/**
 * TBA
 */
export const std = mkPackage(
  nixRaw`pkgs.haskellPackages.std`,
  "TBA",
);

/**
 * Binding to Standard Template Library C++
 */
export const stdcxx = mkPackage(
  nixRaw`pkgs.haskellPackages.stdcxx`,
  "Binding to Standard Template Library C++",
);

/**
 * A file watcher and development tool
 */
export const steeloverseer = mkPackage(
  nixRaw`pkgs.haskellPackages.steeloverseer`,
  "A file watcher and development tool",
);

/**
 * Staircase functions or piecewise constant functions
 */
export const step_function = mkPackage(
  nixRaw`pkgs.haskellPackages.step-function`,
  "Staircase functions or piecewise constant functions",
);

/**
 * Positive rational numbers represented as paths in the Stern-Brocot tree
 */
export const stern_brocot = mkPackage(
  nixRaw`pkgs.haskellPackages.stern-brocot`,
  "Positive rational numbers represented as paths in the Stern-Brocot tree",
);

/**
 * get and set STICKYKEYS.SKF_HOTKEYACTIVE
 */
export const stickyKeysHotKey = mkPackage(
  nixRaw`pkgs.haskellPackages.stickyKeysHotKey`,
  "get and set STICKYKEYS.SKF_HOTKEYACTIVE",
);

/**
 * lightweight CSS DSL
 */
export const stitch = mkPackage(
  nixRaw`pkgs.haskellPackages.stitch`,
  "lightweight CSS DSL",
);

/**
 * Software Transactional Memory
 */
export const stm_2_5_1_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.stm_2_5_1_0`,
  "Software Transactional Memory",
);

/**
 * A simplistic actor model based on STM
 */
export const stm_actor = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-actor`,
  "A simplistic actor model based on STM",
);

/**
 * Transactional I/O for duplex streams
 */
export const stm_channelize = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-channelize`,
  "Transactional I/O for duplex streams",
);

/**
 * Additional types of channels for STM
 */
export const stm_chans = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-chans`,
  "Additional types of channels for STM",
);

/**
 * Introduces conduits to channels, and promotes using conduits concurrently
 */
export const stm_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-conduit`,
  "Introduces conduits to channels, and promotes using conduits concurrently",
);

/**
 * Containers for STM
 */
export const stm_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-containers`,
  "Containers for STM",
);

/**
 * Updatable one-shot timer polled with STM
 */
export const stm_delay = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-delay`,
  "Updatable one-shot timer polled with STM",
);

/**
 * Extra STM functions
 */
export const stm_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-extras`,
  "Extra STM functions",
);

/**
 * STM-specialised Hash Array Mapped Trie
 */
export const stm_hamt = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-hamt`,
  "STM-specialised Hash Array Mapped Trie",
);

/**
 * A library for constructing incremental computations
 */
export const stm_incremental = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-incremental`,
  "A library for constructing incremental computations",
);

/**
 * Launch your IO-actions from within the STM monad
 */
export const stm_io_hooks = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-io-hooks`,
  "Launch your IO-actions from within the STM monad",
);

/**
 * Software Transactional Memory lifted to MonadIO
 */
export const stm_lifted = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-lifted`,
  "Software Transactional Memory lifted to MonadIO",
);

/**
 * Mutable, doubly linked lists for STM
 */
export const stm_linkedlist = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-linkedlist`,
  "Mutable, doubly linked lists for STM",
);

/**
 * Choose between the return value of an STM operation and an IO action
 */
export const stm_orelse_io = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-orelse-io`,
  "Choose between the return value of an STM operation and an IO action",
);

/**
 * An implementation of a real-time concurrent queue
 */
export const stm_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-queue`,
  "An implementation of a real-time concurrent queue",
);

/**
 * Extra queue utilities for STM
 */
export const stm_queue_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-queue-extras`,
  "Extra queue utilities for STM",
);

/**
 * Bounded channel for STM where item sizes can vary
 */
export const stm_sbchan = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-sbchan`,
  "Bounded channel for STM where item sizes can vary",
);

/**
 * TMVars, TVars and TChans with distinguished input and output side
 */
export const stm_split = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-split`,
  "TMVars, TVars and TChans with distinguished input and output side",
);

/**
 * STM wrapper around Control.Concurrent.Supply.
 */
export const stm_supply = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-supply`,
  "STM wrapper around Control.Concurrent.Supply.",
);

/**
 * Mutable, singly-linked list in STM
 */
export const stm_tlist = mkPackage(
  nixRaw`pkgs.haskellPackages.stm-tlist`,
  "Mutable, singly-linked list in STM",
);

/**
 * Control communication among retrying transactions
 */
export const stmcontrol = mkPackage(
  nixRaw`pkgs.haskellPackages.stmcontrol`,
  "Control communication among retrying transactions",
);

/**
 * Library for the IEX Trading API
 */
export const stocks = mkPackage(
  nixRaw`pkgs.haskellPackages.stocks`,
  "Library for the IEX Trading API",
);

/**
 * Stompl Conduit Client
 */
export const stomp_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.stomp-conduit`,
  "Stompl Conduit Client",
);

/**
 * Stompl MOM Stomp Patterns
 */
export const stomp_patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.stomp-patterns`,
  "Stompl MOM Stomp Patterns",
);

/**
 * Stompl Client Library
 */
export const stomp_queue = mkPackage(
  nixRaw`pkgs.haskellPackages.stomp-queue`,
  "Stompl Client Library",
);

/**
 * Stomp Parser and Utilities
 */
export const stompl = mkPackage(
  nixRaw`pkgs.haskellPackages.stompl`,
  "Stomp Parser and Utilities",
);

/**
 * A simple stopwatch utility
 */
export const stopwatch = mkPackage(
  nixRaw`pkgs.haskellPackages.stopwatch`,
  "A simple stopwatch utility",
);

/**
 * Storable instance for Complex
 */
export const storable_complex = mkPackage(
  nixRaw`pkgs.haskellPackages.storable-complex`,
  "Storable instance for Complex",
);

/**
 * Storable instances with endianness
 */
export const storable_endian = mkPackage(
  nixRaw`pkgs.haskellPackages.storable-endian`,
  "Storable instances with endianness",
);

/**
 * Wrapper that makes any Enum type Storable
 */
export const storable_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.storable-enum`,
  "Wrapper that makes any Enum type Storable",
);

/**
 * Elegant definition of Storable instances for records
 */
export const storable_record = mkPackage(
  nixRaw`pkgs.haskellPackages.storable-record`,
  "Elegant definition of Storable instances for records",
);

/**
 * Storable instance for pairs and triples
 */
export const storable_tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.storable-tuple`,
  "Storable instance for pairs and triples",
);

/**
 * Fast, packed, strict storable arrays with a list interface like ByteString
 */
export const storablevector = mkPackage(
  nixRaw`pkgs.haskellPackages.storablevector`,
  "Fast, packed, strict storable arrays with a list interface like ByteString",
);

/**
 * Conversion between storablevector and carray
 */
export const storablevector_carray = mkPackage(
  nixRaw`pkgs.haskellPackages.storablevector-carray`,
  "Conversion between storablevector and carray",
);

/**
 * Conversion between storablevector and stream-fusion lists with fusion
 */
export const storablevector_streamfusion = mkPackage(
  nixRaw`pkgs.haskellPackages.storablevector-streamfusion`,
  "Conversion between storablevector and stream-fusion lists with fusion",
);

/**
 * Fast binary serialization
 */
export const store = mkPackage(
  nixRaw`pkgs.haskellPackages.store`,
  "Fast binary serialization",
);

/**
 * Fast and lightweight binary serialization
 */
export const store_core = mkPackage(
  nixRaw`pkgs.haskellPackages.store-core`,
  "Fast and lightweight binary serialization",
);

/**
 * Streaming interfaces for `store`
 */
export const store_streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.store-streaming`,
  "Streaming interfaces for `store`",
);

/**
 * EDSL for AWS CloudFormation
 */
export const stratosphere = mkPackage(
  nixRaw`pkgs.haskellPackages.stratosphere`,
  "EDSL for AWS CloudFormation",
);

/**
 * Client for Stratum protocol
 */
export const stratum_tool = mkPackage(
  nixRaw`pkgs.haskellPackages.stratum-tool`,
  "Client for Stratum protocol",
);

/**
 * A library for stratux
 */
export const stratux = mkPackage(
  nixRaw`pkgs.haskellPackages.stratux`,
  "A library for stratux",
);

/**
 * A demonstration of the stratux library
 */
export const stratux_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.stratux-demo`,
  "A demonstration of the stratux library",
);

/**
 * A library for using HTTP with stratux
 */
export const stratux_http = mkPackage(
  nixRaw`pkgs.haskellPackages.stratux-http`,
  "A library for using HTTP with stratux",
);

/**
 * A library for using websockets with stratux
 */
export const stratux_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.stratux-websockets`,
  "A library for using websockets with stratux",
);

/**
 * an elementary streaming prelude and general stream type
 */
export const streaming = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming`,
  "an elementary streaming prelude and general stream type",
);

/**
 * Attoparsec integration for the streaming ecosystem
 */
export const streaming_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-attoparsec`,
  "Attoparsec integration for the streaming ecosystem",
);

/**
 * Streaming conversion from/to base64
 */
export const streaming_base64 = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-base64`,
  "Streaming conversion from/to base64",
);

/**
 * Streaming interface to binary
 */
export const streaming_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-binary`,
  "Streaming interface to binary",
);

/**
 * A resource management decorator for "streaming"
 */
export const streaming_bracketed = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-bracketed`,
  "A resource management decorator for \"streaming\"",
);

/**
 * Fast, effectful byte streams
 */
export const streaming_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-bytestring`,
  "Fast, effectful byte streams",
);

/**
 * Common lower-level functions needed by various streaming data libraries
 */
export const streaming_commons = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-commons`,
  "Common lower-level functions needed by various streaming data libraries",
);

/**
 * Concurrency support for the streaming ecosystem
 */
export const streaming_concurrency = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-concurrency`,
  "Concurrency support for the streaming ecosystem",
);

/**
 * Translate pull-based stream folds into push-based iteratees
 */
export const streaming_eversion = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-eversion`,
  "Translate pull-based stream folds into push-based iteratees",
);

/**
 * online streaming fft
 */
export const streaming_fft = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-fft`,
  "online streaming fft",
);

export const streaming_histogram = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-histogram`,
  "",
);

/**
 * Add support for non empty streams to Streaming lib
 */
export const streaming_nonempty = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-nonempty`,
  "Add support for non empty streams to Streaming lib",
);

/**
 * Stream packets via libpcap
 */
export const streaming_pcap = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-pcap`,
  "Stream packets via libpcap",
);

/**
 * Streaming support for running system process
 */
export const streaming_process = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-process`,
  "Streaming support for running system process",
);

/**
 * Sorting streams
 */
export const streaming_sort = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-sort`,
  "Sorting streams",
);

/**
 * http, attoparsec, pipes and other utilities for the streaming libraries
 */
export const streaming_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-utils`,
  "http, attoparsec, pipes and other utilities for the streaming libraries",
);

/**
 * Streaming Wai utilities
 */
export const streaming_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.streaming-wai`,
  "Streaming Wai utilities",
);

/**
 * Streaming, dataflow programming and declarative concurrency
 */
export const streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly`,
  "Streaming, dataflow programming and declarative concurrency",
);

/**
 * Stream data from archives using the streamly library
 */
export const streamly_archive = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-archive`,
  "Stream data from archives using the streamly library",
);

/**
 * Library for streamly and bytestring interoperation
 */
export const streamly_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-bytestring`,
  "Library for streamly and bytestring interoperation",
);

/**
 * Streaming, parsers, arrays and more
 */
export const streamly_core = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-core`,
  "Streaming, parsers, arrays and more",
);

/**
 * Examples for Streamly
 */
export const streamly_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-examples`,
  "Examples for Streamly",
);

/**
 * Stream data to or from LMDB databases using the streamly library
 */
export const streamly_lmdb = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-lmdb`,
  "Stream data to or from LMDB databases using the streamly library",
);

/**
 * Use OS processes as stream transformation functions
 */
export const streamly_process = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-process`,
  "Use OS processes as stream transformation functions",
);

/**
 * Statistical measures for finite or infinite data streams
 */
export const streamly_statistics = mkPackage(
  nixRaw`pkgs.haskellPackages.streamly-statistics`,
  "Statistical measures for finite or infinite data streams",
);

/**
 * Various Haskell 2010 stream comonads
 */
export const streams = mkPackage(
  nixRaw`pkgs.haskellPackages.streams`,
  "Various Haskell 2010 stream comonads",
);

/**
 * Simple, Fair and Terminating Backtracking Monad Transformer
 */
export const streamt = mkPackage(
  nixRaw`pkgs.haskellPackages.streamt`,
  "Simple, Fair and Terminating Backtracking Monad Transformer",
);

/**
 * A simple, flexible and composable web-router
 */
export const strelka = mkPackage(
  nixRaw`pkgs.haskellPackages.strelka`,
  "A simple, flexible and composable web-router",
);

/**
 * WAI compatibility layer for "strelka"
 */
export const strelka_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.strelka-wai`,
  "WAI compatibility layer for \"strelka\"",
);

/**
 * Strict data types and String IO
 */
export const strict = mkPackage(
  nixRaw`pkgs.haskellPackages.strict`,
  "Strict data types and String IO",
);

/**
 * Strict versions of base data types
 */
export const strict_base = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-base`,
  "Strict versions of base data types",
);

/**
 * Strict variants of the types provided in base
 */
export const strict_base_types = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-base-types`,
  "Strict variants of the types provided in base",
);

/**
 * Strict concurrency abstractions
 */
export const strict_concurrency = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-concurrency`,
  "Strict concurrency abstractions",
);

/**
 * Strict containers - Lens instances
 */
export const strict_containers_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-containers-lens`,
  "Strict containers - Lens instances",
);

/**
 * Strict containers - Serialise instances
 */
export const strict_containers_serialise = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-containers-serialise`,
  "Strict containers - Serialise instances",
);

/**
 * A collection of commonly used strict data structures
 */
export const strict_data = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-data`,
  "A collection of commonly used strict data structures",
);

/**
 * Strict Identity Monad, handy for writing fast code!
 */
export const strict_identity = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-identity`,
  "Strict Identity Monad, handy for writing fast code!",
);

/**
 * Plugin for making top-level implicit parameters strict
 */
export const strict_impl_params = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-impl-params`,
  "Plugin for making top-level implicit parameters strict",
);

/**
 * A library wrapping standard IO modules to provide strict IO
 */
export const strict_io = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-io`,
  "A library wrapping standard IO modules to provide strict IO",
);

/**
 * Lenses for types in strict package
 */
export const strict_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-lens`,
  "Lenses for types in strict package",
);

/**
 * Strict linked list
 */
export const strict_list = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-list`,
  "Strict linked list",
);

/**
 * Strict MVars for IO and IOSim
 */
export const strict_mvar = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-mvar`,
  "Strict MVars for IO and IOSim",
);

/**
 * Optics for types in strict package
 */
export const strict_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-optics`,
  "Optics for types in strict package",
);

/**
 * Strict STM interface polymorphic over stm implementation
 */
export const strict_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-stm`,
  "Strict STM interface polymorphic over stm implementation",
);

/**
 * Strict tuples
 */
export const strict_tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-tuple`,
  "Strict tuples",
);

/**
 * A type level predicate ranging over strict types
 */
export const strict_types = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-types`,
  "A type level predicate ranging over strict types",
);

/**
 * Lightweight strict types
 */
export const strict_wrapper = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-wrapper`,
  "Lightweight strict types",
);

/**
 * A stricter writer, which uses StateT in order to avoid space leaks
 */
export const strict_writer = mkPackage(
  nixRaw`pkgs.haskellPackages.strict-writer`,
  "A stricter writer, which uses StateT in order to avoid space leaks",
);

/**
 * Find a local optimum of strictness annotations
 */
export const strictify = mkPackage(
  nixRaw`pkgs.haskellPackages.strictify`,
  "Find a local optimum of strictness annotations",
);

/**
 * None
 */
export const string = mkPackage(
  nixRaw`pkgs.haskellPackages.string`,
  "None",
);

/**
 * Polymorphic functions to build and combine stringlike values
 */
export const string_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.string-combinators`,
  "Polymorphic functions to build and combine stringlike values",
);

/**
 * Standardized conversion between string types
 */
export const string_conv = mkPackage(
  nixRaw`pkgs.haskellPackages.string-conv`,
  "Standardized conversion between string types",
);

/**
 * Simplifies dealing with different types for strings
 */
export const string_conversions = mkPackage(
  nixRaw`pkgs.haskellPackages.string-conversions`,
  "Simplifies dealing with different types for strings",
);

/**
 * Universal string conversions
 */
export const string_convert = mkPackage(
  nixRaw`pkgs.haskellPackages.string-convert`,
  "Universal string conversions",
);

/**
 * Haskell string/text/bytestring interpolation that just works
 */
export const string_interpolate = mkPackage(
  nixRaw`pkgs.haskellPackages.string-interpolate`,
  "Haskell string/text/bytestring interpolation that just works",
);

/**
 * Is used in the phonetic languages approach (e. g. in the recursive mode).
 */
export const string_interpreter = mkPackage(
  nixRaw`pkgs.haskellPackages.string-interpreter`,
  "Is used in the phonetic languages approach (e. g. in the recursive mode).",
);

/**
 * A package that aims to provide a uniform interface to string-like types
 */
export const string_like = mkPackage(
  nixRaw`pkgs.haskellPackages.string-like`,
  "A package that aims to provide a uniform interface to string-like types",
);

/**
 * QuasiQuoter for non-interpolated strings, texts and bytestrings
 */
export const string_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.string-qq`,
  "QuasiQuoter for non-interpolated strings, texts and bytestrings",
);

/**
 * A library for generating random string from a regular experession
 */
export const string_random = mkPackage(
  nixRaw`pkgs.haskellPackages.string-random`,
  "A library for generating random string from a regular experession",
);

/**
 * longest common substring
 */
export const string_similarity = mkPackage(
  nixRaw`pkgs.haskellPackages.string-similarity`,
  "longest common substring",
);

/**
 * simple and easy haskell string transform wrapper
 */
export const string_transform = mkPackage(
  nixRaw`pkgs.haskellPackages.string-transform`,
  "simple and easy haskell string transform wrapper",
);

/**
 * Type-level Chars and Strings, with decidable equality
 */
export const string_typelits = mkPackage(
  nixRaw`pkgs.haskellPackages.string-typelits`,
  "Type-level Chars and Strings, with decidable equality",
);

/**
 * Constrained text newtypes
 */
export const string_variants = mkPackage(
  nixRaw`pkgs.haskellPackages.string-variants`,
  "Constrained text newtypes",
);

/**
 * A Stringable type class, in the spirit of Foldable and Traversable
 */
export const stringable = mkPackage(
  nixRaw`pkgs.haskellPackages.stringable`,
  "A Stringable type class, in the spirit of Foldable and Traversable",
);

/**
 * A writer monad for multi-line string literals
 */
export const stringbuilder = mkPackage(
  nixRaw`pkgs.haskellPackages.stringbuilder`,
  "A writer monad for multi-line string literals",
);

/**
 * Implements the "StringPrep" algorithm
 */
export const stringprep = mkPackage(
  nixRaw`pkgs.haskellPackages.stringprep`,
  "Implements the \"StringPrep\" algorithm",
);

/**
 * Functions for working with strings, including Text, ByteString, etc
 */
export const strings = mkPackage(
  nixRaw`pkgs.haskellPackages.strings`,
  "Functions for working with strings, including Text, ByteString, etc",
);

/**
 * Fast searching, splitting and replacing of ByteStrings
 */
export const stringsearch = mkPackage(
  nixRaw`pkgs.haskellPackages.stringsearch`,
  "Fast searching, splitting and replacing of ByteStrings",
);

/**
 * Initial project template from stack
 */
export const strio = mkPackage(
  nixRaw`pkgs.haskellPackages.strio`,
  "Initial project template from stack",
);

/**
 * Strip ANSI escape code from string
 */
export const strip_ansi_escape = mkPackage(
  nixRaw`pkgs.haskellPackages.strip-ansi-escape`,
  "Strip ANSI escape code from string",
);

/**
 * Types for the Stripe API
 */
export const stripe_concepts = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-concepts`,
  "Types for the Stripe API",
);

/**
 * Stripe API for Haskell
 */
export const stripe_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-haskell`,
  "Stripe API for Haskell",
);

/**
 * Stripe API for Haskell - http-client backend
 */
export const stripe_http_client = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-http-client`,
  "Stripe API for Haskell - http-client backend",
);

/**
 * Stripe API for Haskell - http-streams backend
 */
export const stripe_http_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-http-streams`,
  "Stripe API for Haskell - http-streams backend",
);

/**
 * Listen for Stripe webhook events with Scotty
 */
export const stripe_scotty = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-scotty`,
  "Listen for Stripe webhook events with Scotty",
);

/**
 * Unofficial Stripe servant types
 */
export const stripe_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-servant`,
  "Unofficial Stripe servant types",
);

/**
 * Verification of Stripe webhook signatures
 */
export const stripe_signature = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-signature`,
  "Verification of Stripe webhook signatures",
);

/**
 * Tests for Stripe API bindings for Haskell
 */
export const stripe_tests = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-tests`,
  "Tests for Stripe API bindings for Haskell",
);

/**
 * Use the Stripe API via Wreq
 */
export const stripe_wreq = mkPackage(
  nixRaw`pkgs.haskellPackages.stripe-wreq`,
  "Use the Stripe API via Wreq",
);

/**
 * Stripe-Library
 */
export const stripeapi = mkPackage(
  nixRaw`pkgs.haskellPackages.stripeapi`,
  "Stripe-Library",
);

/**
 * resolver using strips algorithm
 */
export const strips = mkPackage(
  nixRaw`pkgs.haskellPackages.strips`,
  "resolver using strips algorithm",
);

/**
 * A client for the Strava V3 API
 */
export const strive = mkPackage(
  nixRaw`pkgs.haskellPackages.strive`,
  "A client for the Strava V3 API",
);

/**
 * Interface library for strongSwan SQL backend
 */
export const strongswan_sql = mkPackage(
  nixRaw`pkgs.haskellPackages.strongswan-sql`,
  "Interface library for strongSwan SQL backend",
);

/**
 * Convert between strong and weak representations of types
 */
export const strongweak = mkPackage(
  nixRaw`pkgs.haskellPackages.strongweak`,
  "Convert between strong and weak representations of types",
);

/**
 * Efficient parsing of LocalTime using a binding to C's strptime, with some extra features (i.e. fractional seconds)
 */
export const strptime = mkPackage(
  nixRaw`pkgs.haskellPackages.strptime`,
  "Efficient parsing of LocalTime using a binding to C's strptime, with some extra features (i.e. fractional seconds)",
);

/**
 * Inspect the padding and size of C data declarations and their fields
 */
export const struct_inspector = mkPackage(
  nixRaw`pkgs.haskellPackages.struct-inspector`,
  "Inspect the padding and size of C data declarations and their fields",
);

/**
 * Strict GC'd imperative object-oriented programming with cheap pointers
 */
export const structs = mkPackage(
  nixRaw`pkgs.haskellPackages.structs`,
  "Strict GC'd imperative object-oriented programming with cheap pointers",
);

/**
 * Instantiate structural induction schemas for algebraic data types
 */
export const structural_induction = mkPackage(
  nixRaw`pkgs.haskellPackages.structural-induction`,
  "Instantiate structural induction schemas for algebraic data types",
);

/**
 * Structure (hash) of your data types
 */
export const structured = mkPackage(
  nixRaw`pkgs.haskellPackages.structured`,
  "Structure (hash) of your data types",
);

/**
 * Application library for building interactive console CLIs
 */
export const structured_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.structured-cli`,
  "Application library for building interactive console CLIs",
);

/**
 * Structured editing Emacs mode for Haskell
 */
export const structured_haskell_mode = mkPackage(
  nixRaw`pkgs.haskellPackages.structured-haskell-mode`,
  "Structured editing Emacs mode for Haskell",
);

/**
 * Structured MongoDB interface
 */
export const structured_mongoDB = mkPackage(
  nixRaw`pkgs.haskellPackages.structured-mongoDB`,
  "Structured MongoDB interface",
);

/**
 * A revival of the classic game Stunts (LambdaCube tech demo)
 */
export const stunts = mkPackage(
  nixRaw`pkgs.haskellPackages.stunts`,
  "A revival of the classic game Stunts (LambdaCube tech demo)",
);

/**
 * (Stutter Text|String)-Utterer
 */
export const stutter = mkPackage(
  nixRaw`pkgs.haskellPackages.stutter`,
  "(Stutter Text|String)-Utterer",
);

/**
 * Haskell code prettifier
 */
export const stylish_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.stylish-haskell`,
  "Haskell code prettifier",
);

/**
 * Haskell code prettifier
 */
export const stylish_haskell_0_14_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.stylish-haskell_0_14_4_0`,
  "Haskell code prettifier",
);

/**
 * Traits, datatypes, & parsers for Haskell Stylist
 */
export const stylist_traits = mkPackage(
  nixRaw`pkgs.haskellPackages.stylist-traits`,
  "Traits, datatypes, & parsers for Haskell Stylist",
);

/**
 * A generator of nix files
 */
export const styx = mkPackage(
  nixRaw`pkgs.haskellPackages.styx`,
  "A generator of nix files",
);

/**
 * An applicative functor that seamlessly talks to HTML inputs
 */
export const suavemente = mkPackage(
  nixRaw`pkgs.haskellPackages.suavemente`,
  "An applicative functor that seamlessly talks to HTML inputs",
);

/**
 * Some extension to the Foldable and Monoid classes
 */
export const subG = mkPackage(
  nixRaw`pkgs.haskellPackages.subG`,
  "Some extension to the Foldable and Monoid classes",
);

/**
 * Subcategories induced by class constraints
 */
export const subcategories = mkPackage(
  nixRaw`pkgs.haskellPackages.subcategories`,
  "Subcategories induced by class constraints",
);

/**
 * Type safe interface for programming in subcategories of Hask
 */
export const subhask = mkPackage(
  nixRaw`pkgs.haskellPackages.subhask`,
  "Type safe interface for programming in subcategories of Hask",
);

/**
 * Allows to split lists into sublists with some patterns by quantity
 */
export const sublists = mkPackage(
  nixRaw`pkgs.haskellPackages.sublists`,
  "Allows to split lists into sublists with some patterns by quantity",
);

/**
 * subnetting calculator
 */
export const subnet = mkPackage(
  nixRaw`pkgs.haskellPackages.subnet`,
  "subnetting calculator",
);

/**
 * Match / replace substrings with a parser combinators
 */
export const substring_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.substring-parser`,
  "Match / replace substrings with a parser combinators",
);

/**
 * A parser for .srt and .sub files
 */
export const subtitleParser = mkPackage(
  nixRaw`pkgs.haskellPackages.subtitleParser`,
  "A parser for .srt and .sub files",
);

/**
 * Modify SRT subtitle files
 */
export const subtitles = mkPackage(
  nixRaw`pkgs.haskellPackages.subtitles`,
  "Modify SRT subtitle files",
);

/**
 * Helps when going "seed values" -> alternatives and optional -> answers
 */
export const subzero = mkPackage(
  nixRaw`pkgs.haskellPackages.subzero`,
  "Helps when going \"seed values\" -> alternatives and optional -> answers",
);

/**
 * A version of Either specialised for encoding of success or failure
 */
export const success = mkPackage(
  nixRaw`pkgs.haskellPackages.success`,
  "A version of Either specialised for encoding of success or failure",
);

/**
 * An applicative functor to manage successors
 */
export const successors = mkPackage(
  nixRaw`pkgs.haskellPackages.successors`,
  "An applicative functor to manage successors",
);

/**
 * Efficient, lazy suffix tree implementation
 */
export const suffixtree = mkPackage(
  nixRaw`pkgs.haskellPackages.suffixtree`,
  "Efficient, lazy suffix tree implementation",
);

/**
 * Convert sugar to common data types for code generation
 */
export const sugar_data = mkPackage(
  nixRaw`pkgs.haskellPackages.sugar-data`,
  "Convert sugar to common data types for code generation",
);

/**
 * Sugar with JSON
 */
export const sugar_json = mkPackage(
  nixRaw`pkgs.haskellPackages.sugar-json`,
  "Sugar with JSON",
);

/**
 * Sugar with Scheme
 */
export const sugar_scheme = mkPackage(
  nixRaw`pkgs.haskellPackages.sugar-scheme`,
  "Sugar with Scheme",
);

/**
 * An implementation of extensible products and sums
 */
export const summer = mkPackage(
  nixRaw`pkgs.haskellPackages.summer`,
  "An implementation of extensible products and sums",
);

/**
 * Tool for scaffolding fully configured batteries-included production-level Haskell projects using TUI
 */
export const summoner_tui = mkPackage(
  nixRaw`pkgs.haskellPackages.summoner-tui`,
  "Tool for scaffolding fully configured batteries-included production-level Haskell projects using TUI",
);

/**
 * A Haskell interface to SUMP-compatible logic analyzers
 */
export const sump = mkPackage(
  nixRaw`pkgs.haskellPackages.sump`,
  "A Haskell interface to SUMP-compatible logic analyzers",
);

/**
 * Bindings to the sundown markdown library
 */
export const sundown = mkPackage(
  nixRaw`pkgs.haskellPackages.sundown`,
  "Bindings to the sundown markdown library",
);

/**
 * Tests for Sunroof
 */
export const sunroof_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.sunroof-examples`,
  "Tests for Sunroof",
);

/**
 * Monadic Javascript Compiler - Server Utilities
 */
export const sunroof_server = mkPackage(
  nixRaw`pkgs.haskellPackages.sunroof-server`,
  "Monadic Javascript Compiler - Server Utilities",
);

/**
 * Efficiently build a bytestring from smaller chunks
 */
export const superbuffer = mkPackage(
  nixRaw`pkgs.haskellPackages.superbuffer`,
  "Efficiently build a bytestring from smaller chunks",
);

/**
 * Haskell SuperCollider utilities
 */
export const supercollider_ht = mkPackage(
  nixRaw`pkgs.haskellPackages.supercollider-ht`,
  "Haskell SuperCollider utilities",
);

/**
 * Demonstrate how to control SuperCollider via ALSA-MIDI
 */
export const supercollider_midi = mkPackage(
  nixRaw`pkgs.haskellPackages.supercollider-midi`,
  "Demonstrate how to control SuperCollider via ALSA-MIDI",
);

/**
 * Access an instance's constraints
 */
export const superconstraints = mkPackage(
  nixRaw`pkgs.haskellPackages.superconstraints`,
  "Access an instance's constraints",
);

/**
 * Additional documentation markup and Unicode support
 */
export const superdoc = mkPackage(
  nixRaw`pkgs.haskellPackages.superdoc`,
  "Additional documentation markup and Unicode support",
);

/**
 * Apache Pulsar client for Haskell
 */
export const supernova = mkPackage(
  nixRaw`pkgs.haskellPackages.supernova`,
  "Apache Pulsar client for Haskell",
);

/**
 * Composable request-response pipelines
 */
export const supply_chain = mkPackage(
  nixRaw`pkgs.haskellPackages.supply-chain`,
  "Composable request-response pipelines",
);

/**
 * Composable request-response pipelines
 */
export const supply_chain_core = mkPackage(
  nixRaw`pkgs.haskellPackages.supply-chain-core`,
  "Composable request-response pipelines",
);

/**
 * Supply-chain interface for basic streaming
 */
export const supply_next = mkPackage(
  nixRaw`pkgs.haskellPackages.supply-next`,
  "Supply-chain interface for basic streaming",
);

/**
 * Simple package that allows for long thread suspensions
 */
export const suspend = mkPackage(
  nixRaw`pkgs.haskellPackages.suspend`,
  "Simple package that allows for long thread suspensions",
);

/**
 * Encode and decode separated values (CSV, PSV, ...)
 */
export const sv = mkPackage(
  nixRaw`pkgs.haskellPackages.sv`,
  "Encode and decode separated values (CSV, PSV, ...)",
);

/**
 * Integration to use sv with cassava's parser
 */
export const sv_cassava = mkPackage(
  nixRaw`pkgs.haskellPackages.sv-cassava`,
  "Integration to use sv with cassava's parser",
);

/**
 * sv-core + svfactor
 */
export const sv_svfactor = mkPackage(
  nixRaw`pkgs.haskellPackages.sv-svfactor`,
  "sv-core + svfactor",
);

/**
 * Code generation tool for Quartz code from a SVG
 */
export const svg2q = mkPackage(
  nixRaw`pkgs.haskellPackages.svg2q`,
  "Code generation tool for Quartz code from a SVG",
);

/**
 * DSL for building SVG
 */
export const svg_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.svg-builder`,
  "DSL for building SVG",
);

/**
 * Svg Icons and more
 */
export const svg_icons = mkPackage(
  nixRaw`pkgs.haskellPackages.svg-icons`,
  "Svg Icons and more",
);

/**
 * SVG file loader and serializer
 */
export const svg_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.svg-tree`,
  "SVG file loader and serializer",
);

/**
 * Binding to the libsvg-cairo library
 */
export const svgcairo = mkPackage(
  nixRaw`pkgs.haskellPackages.svgcairo`,
  "Binding to the libsvg-cairo library",
);

/**
 * Optimise SVGs
 */
export const svgone = mkPackage(
  nixRaw`pkgs.haskellPackages.svgone`,
  "Optimise SVGs",
);

/**
 * A support vector machine written in Haskell
 */
export const svm = mkPackage(
  nixRaw`pkgs.haskellPackages.svm`,
  "A support vector machine written in Haskell",
);

/**
 * Swagger 2.0 data model
 */
export const swagger2 = mkPackage(
  nixRaw`pkgs.haskellPackages.swagger2`,
  "Swagger 2.0 data model",
);

/**
 * Transparently swapping data from in-memory structures to disk
 */
export const swapper = mkPackage(
  nixRaw`pkgs.haskellPackages.swapper`,
  "Transparently swapping data from in-memory structures to disk",
);

/**
 * Shallow embedding implementation of non-linear pattern matching
 */
export const sweet_egison = mkPackage(
  nixRaw`pkgs.haskellPackages.sweet-egison`,
  "Shallow embedding implementation of non-linear pattern matching",
);

/**
 * A semantic web toolkit
 */
export const swish = mkPackage(
  nixRaw`pkgs.haskellPackages.swish`,
  "A semantic web toolkit",
);

/**
 * SwissTable hash map
 */
export const swisstable = mkPackage(
  nixRaw`pkgs.haskellPackages.swisstable`,
  "SwissTable hash map",
);

/**
 * Nintendo Switch Controller Library
 */
export const switch_ = mkPackage(
  nixRaw`pkgs.haskellPackages.switch`,
  "Nintendo Switch Controller Library",
);

/**
 * A SXML-parser
 */
export const sxml = mkPackage(
  nixRaw`pkgs.haskellPackages.sxml`,
  "A SXML-parser",
);

/**
 * Scrap Your Boilerplate
 */
export const syb = mkPackage(
  nixRaw`pkgs.haskellPackages.syb`,
  "Scrap Your Boilerplate",
);

/**
 * Scrap Your Boilerplate With Class Text instance
 */
export const syb_with_class_instances_text = mkPackage(
  nixRaw`pkgs.haskellPackages.syb-with-class-instances-text`,
  "Scrap Your Boilerplate With Class Text instance",
);

/**
 * A modern testing framework for Haskell with good defaults and advanced testing features
 */
export const sydtest = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest`,
  "A modern testing framework for Haskell with good defaults and advanced testing features",
);

/**
 * A modern testing framework for Haskell with good defaults and advanced testing features
 */
export const sydtest_0_15_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest_0_15_1_1`,
  "A modern testing framework for Haskell with good defaults and advanced testing features",
);

/**
 * An aeson companion library for sydtest
 */
export const sydtest_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-aeson`,
  "An aeson companion library for sydtest",
);

/**
 * An amqp companion library for sydtest
 */
export const sydtest_amqp = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-amqp`,
  "An amqp companion library for sydtest",
);

/**
 * An autodocodec companion library for sydtest
 */
export const sydtest_autodocodec = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-autodocodec`,
  "An autodocodec companion library for sydtest",
);

/**
 * Automatic test suite discovery for sydtest
 */
export const sydtest_discover = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-discover`,
  "Automatic test suite discovery for sydtest",
);

/**
 * Automatic test suite discovery for sydtest
 */
export const sydtest_discover_0_0_0_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-discover_0_0_0_4`,
  "Automatic test suite discovery for sydtest",
);

/**
 * A Hedgehog companion library for sydtest
 */
export const sydtest_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-hedgehog`,
  "A Hedgehog companion library for sydtest",
);

/**
 * A persistent companion library for sydtest
 */
export const sydtest_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-persistent`,
  "A persistent companion library for sydtest",
);

/**
 * A typed-process companion library for sydtest
 */
export const sydtest_process = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-process`,
  "A typed-process companion library for sydtest",
);

/**
 * A servant companion library for sydtest
 */
export const sydtest_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-servant`,
  "A servant companion library for sydtest",
);

/**
 * A typed-process companion library for sydtest
 */
export const sydtest_typed_process = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-typed-process`,
  "A typed-process companion library for sydtest",
);

/**
 * A wai companion library for sydtest
 */
export const sydtest_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-wai`,
  "A wai companion library for sydtest",
);

/**
 * A webdriver screenshot companion library for sydtest
 */
export const sydtest_webdriver_screenshot = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-webdriver-screenshot`,
  "A webdriver screenshot companion library for sydtest",
);

/**
 * A webdriver+yesod companion library for sydtest
 */
export const sydtest_webdriver_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-webdriver-yesod`,
  "A webdriver+yesod companion library for sydtest",
);

/**
 * A yesod companion library for sydtest
 */
export const sydtest_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.sydtest-yesod`,
  "A yesod companion library for sydtest",
);

/**
 * Lambda calculus visualization
 */
export const sylvia = mkPackage(
  nixRaw`pkgs.haskellPackages.sylvia`,
  "Lambda calculus visualization",
);

/**
 * Permutations, patterns, and statistics
 */
export const sym = mkPackage(
  nixRaw`pkgs.haskellPackages.sym`,
  "Permutations, patterns, and statistics",
);

/**
 * Plot permutations; an addition to the sym package
 */
export const sym_plot = mkPackage(
  nixRaw`pkgs.haskellPackages.sym-plot`,
  "Plot permutations; an addition to the sym package",
);

/**
 * Library for reading and writing Atom
 */
export const symantic_atom = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-atom`,
  "Library for reading and writing Atom",
);

/**
 * Basic symantic combinators for Embedded Domain-Specific Languages (EDSL)
 */
export const symantic_base = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-base`,
  "Basic symantic combinators for Embedded Domain-Specific Languages (EDSL)",
);

/**
 * Symantics combinators for generating documents
 */
export const symantic_document = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-document`,
  "Symantics combinators for generating documents",
);

/**
 * Library for symantic grammars
 */
export const symantic_grammar = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-grammar`,
  "Library for symantic grammars",
);

/**
 * Symantic combinators for deriving clients or a server from an HTTP API
 */
export const symantic_http = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-http`,
  "Symantic combinators for deriving clients or a server from an HTTP API",
);

/**
 * Demo for symantic-http and its companion libraries
 */
export const symantic_http_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-http-demo`,
  "Demo for symantic-http and its companion libraries",
);

/**
 * Streaming support through pipes for symantic-http
 */
export const symantic_http_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-http-pipes`,
  "Streaming support through pipes for symantic-http",
);

/**
 * symantic-http applied to the derivation of HTTP servers
 */
export const symantic_http_server = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-http-server`,
  "symantic-http applied to the derivation of HTTP servers",
);

/**
 * Test symantic-http and its companion libraries
 */
export const symantic_http_test = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-http-test`,
  "Test symantic-http and its companion libraries",
);

/**
 * Symantics for common types
 */
export const symantic_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.symantic-lib`,
  "Symantics for common types",
);

/**
 * Data serialization, communication, and operation verification implementation
 */
export const symbiote = mkPackage(
  nixRaw`pkgs.haskellPackages.symbiote`,
  "Data serialization, communication, and operation verification implementation",
);

/**
 * A 'Symbol' type for fast symbol comparison
 */
export const symbol = mkPackage(
  nixRaw`pkgs.haskellPackages.symbol`,
  "A 'Symbol' type for fast symbol comparison",
);

/**
 * Symbol manipulation
 */
export const symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.symbols`,
  "Symbol manipulation",
);

/**
 * SymEngine symbolic mathematics engine for Haskell
 */
export const symengine_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.symengine-hs`,
  "SymEngine symbolic mathematics engine for Haskell",
);

/**
 * Monoids for sameness and uniqueness
 */
export const symmetric_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.symmetric-properties`,
  "Monoids for sameness and uniqueness",
);

/**
 * Derivation of symbols and coordinate triplets Library
 */
export const symmetry_operations_symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.symmetry-operations-symbols`,
  "Derivation of symbols and coordinate triplets Library",
);

/**
 * Minimal implementation(s) of the classic electronic memory game
 */
export const symon = mkPackage(
  nixRaw`pkgs.haskellPackages.symon`,
  "Minimal implementation(s) of the classic electronic memory game",
);

/**
 * Synchronous communication channels
 */
export const synchronous_channels = mkPackage(
  nixRaw`pkgs.haskellPackages.synchronous-channels`,
  "Synchronous communication channels",
);

/**
 * Haskell bindings for the Syncthing REST API
 */
export const syncthing_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.syncthing-hs`,
  "Haskell bindings for the Syncthing REST API",
);

/**
 * Distfix expression parsing library
 */
export const syntactical = mkPackage(
  nixRaw`pkgs.haskellPackages.syntactical`,
  "Distfix expression parsing library",
);

/**
 * Reversible parsing and pretty-printing
 */
export const syntax = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax`,
  "Reversible parsing and pretty-printing",
);

/**
 * Syntax instances for Attoparsec
 */
export const syntax_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax-attoparsec`,
  "Syntax instances for Attoparsec",
);

/**
 * Example application using syntax, a library for abstract syntax descriptions
 */
export const syntax_example = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax-example`,
  "Example application using syntax, a library for abstract syntax descriptions",
);

/**
 * Example JSON parser/pretty-printer
 */
export const syntax_example_json = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax-example-json`,
  "Example JSON parser/pretty-printer",
);

/**
 * Syntax instance for pretty, the pretty printing library
 */
export const syntax_pretty = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax-pretty`,
  "Syntax instance for pretty, the pretty printing library",
);

/**
 * Text and ByteString printers for 'syntax'
 */
export const syntax_printer = mkPackage(
  nixRaw`pkgs.haskellPackages.syntax-printer`,
  "Text and ByteString printers for 'syntax'",
);

/**
 * Working with Google's SyntaxNet output files - CoNLL, Tree
 */
export const syntaxnet_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.syntaxnet-haskell`,
  "Working with Google's SyntaxNet output files - CoNLL, Tree",
);

/**
 * Control synthesizer effects via ALSA/MIDI
 */
export const synthesizer_alsa = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-alsa`,
  "Control synthesizer effects via ALSA/MIDI",
);

/**
 * Audio signal processing coded in Haskell: Low level part
 */
export const synthesizer_core = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-core`,
  "Audio signal processing coded in Haskell: Low level part",
);

/**
 * Audio signal processing with static physical dimensions
 */
export const synthesizer_dimensional = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-dimensional`,
  "Audio signal processing with static physical dimensions",
);

/**
 * Audio signal processing coded in Haskell: Filter networks
 */
export const synthesizer_filter = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-filter`,
  "Audio signal processing coded in Haskell: Filter networks",
);

/**
 * Efficient signal processing using runtime compilation
 */
export const synthesizer_llvm = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-llvm`,
  "Efficient signal processing using runtime compilation",
);

/**
 * Render audio signals from MIDI files or realtime messages
 */
export const synthesizer_midi = mkPackage(
  nixRaw`pkgs.haskellPackages.synthesizer-midi`,
  "Render audio signals from MIDI files or realtime messages",
);

/**
 * Auth with smbclient command
 */
export const sys_auth_smbclient = mkPackage(
  nixRaw`pkgs.haskellPackages.sys-auth-smbclient`,
  "Auth with smbclient command",
);

/**
 * A replacement for System.Exit and System.Process.
 */
export const sys_process = mkPackage(
  nixRaw`pkgs.haskellPackages.sys-process`,
  "A replacement for System.Exit and System.Process.",
);

/**
 * Haskell Interface for getting overall system statistics
 */
export const sysinfo = mkPackage(
  nixRaw`pkgs.haskellPackages.sysinfo`,
  "Haskell Interface for getting overall system statistics",
);

/**
 * Get argv[0] as a FilePath
 */
export const system_argv0 = mkPackage(
  nixRaw`pkgs.haskellPackages.system-argv0`,
  "Get argv[0] as a FilePath",
);

/**
 * Error reporting functions
 */
export const system_error = mkPackage(
  nixRaw`pkgs.haskellPackages.system-error`,
  "Error reporting functions",
);

/**
 * Consistent filesystem interaction across GHC versions (deprecated)
 */
export const system_fileio = mkPackage(
  nixRaw`pkgs.haskellPackages.system-fileio`,
  "Consistent filesystem interaction across GHC versions (deprecated)",
);

/**
 * High-level, byte-based file and directory path manipulations (deprecated)
 */
export const system_filepath = mkPackage(
  nixRaw`pkgs.haskellPackages.system-filepath`,
  "High-level, byte-based file and directory path manipulations (deprecated)",
);

/**
 * GPIO wrapper libary for Raspberry Pi
 */
export const system_gpio = mkPackage(
  nixRaw`pkgs.haskellPackages.system-gpio`,
  "GPIO wrapper libary for Raspberry Pi",
);

/**
 * Get the name of the operating system
 */
export const system_info = mkPackage(
  nixRaw`pkgs.haskellPackages.system-info`,
  "Get the name of the operating system",
);

/**
 * A toy module to temporarily redirect a program's stdout
 */
export const system_posix_redirect = mkPackage(
  nixRaw`pkgs.haskellPackages.system-posix-redirect`,
  "A toy module to temporarily redirect a program's stdout",
);

/**
 * Simple library for using the system's monotonic clock
 */
export const system_time_monotonic = mkPackage(
  nixRaw`pkgs.haskellPackages.system-time-monotonic`,
  "Simple library for using the system's monotonic clock",
);

/**
 * Bindings to system UUID functions
 */
export const system_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.system-uuid`,
  "Bindings to system UUID functions",
);

/**
 * Systemd facilities (Socket activation, Notify)
 */
export const systemd = mkPackage(
  nixRaw`pkgs.haskellPackages.systemd`,
  "Systemd facilities (Socket activation, Notify)",
);

/**
 * systemd bindings
 */
export const systemd_api = mkPackage(
  nixRaw`pkgs.haskellPackages.systemd-api`,
  "systemd bindings",
);

/**
 * Let systemd bind the server's socket for you
 */
export const systemd_socket_activation = mkPackage(
  nixRaw`pkgs.haskellPackages.systemd-socket-activation`,
  "Let systemd bind the server's socket for you",
);

/**
 * An application that regularly logs system stats for later analysis
 */
export const systemstats = mkPackage(
  nixRaw`pkgs.haskellPackages.systemstats`,
  "An application that regularly logs system stats for later analysis",
);

/**
 * Scrap Your Zippers
 */
export const syz = mkPackage(
  nixRaw`pkgs.haskellPackages.syz`,
  "Scrap Your Zippers",
);

/**
 * tic-tac-toe Rexports for client
 */
export const t3_client = mkPackage(
  nixRaw`pkgs.haskellPackages.t3-client`,
  "tic-tac-toe Rexports for client",
);

/**
 * tic-tac-toe core
 */
export const t3_game = mkPackage(
  nixRaw`pkgs.haskellPackages.t3-game`,
  "tic-tac-toe core",
);

/**
 * Transito Abierto: convenience library when using Takusen and Oracle
 */
export const ta = mkPackage(
  nixRaw`pkgs.haskellPackages.ta`,
  "Transito Abierto: convenience library when using Takusen and Oracle",
);

/**
 * Table layout
 */
export const tabl = mkPackage(
  nixRaw`pkgs.haskellPackages.tabl`,
  "Table layout",
);

/**
 * Format tabular data as grid or table
 */
export const table_layout = mkPackage(
  nixRaw`pkgs.haskellPackages.table-layout`,
  "Format tabular data as grid or table",
);

/**
 * Pretty-printing of CSV files
 */
export const tablize = mkPackage(
  nixRaw`pkgs.haskellPackages.tablize`,
  "Pretty-printing of CSV files",
);

/**
 * Two-dimensional data tables with rendering functions
 */
export const tabular = mkPackage(
  nixRaw`pkgs.haskellPackages.tabular`,
  "Two-dimensional data tables with rendering functions",
);

/**
 * A desktop bar similar to xmobar, but with more GUI
 */
export const taffybar = mkPackage(
  nixRaw`pkgs.haskellPackages.taffybar`,
  "A desktop bar similar to xmobar, but with more GUI",
);

/**
 * streamlined html tag parser
 */
export const tag_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.tag-stream`,
  "streamlined html tag parser",
);

/**
 * alternative package for processing of tag soups
 */
export const tagchup = mkPackage(
  nixRaw`pkgs.haskellPackages.tagchup`,
  "alternative package for processing of tag soups",
);

/**
 * Haskell 98 phantom types to avoid unsafely passing dummy arguments
 */
export const tagged = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged`,
  "Haskell 98 phantom types to avoid unsafely passing dummy arguments",
);

/**
 * Haskell 98 phantom types to avoid unsafely passing dummy arguments
 */
export const tagged_0_8_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged_0_8_8`,
  "Haskell 98 phantom types to avoid unsafely passing dummy arguments",
);

/**
 * Provides tools for serializing data tagged with type information
 */
export const tagged_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged-binary`,
  "Provides tools for serializing data tagged with type information",
);

/**
 * Trivial monad transformer that allows identical monad stacks to have different types
 */
export const tagged_identity = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged-identity`,
  "Trivial monad transformer that allows identical monad stacks to have different types",
);

/**
 * Lists tagged with a type-level natural number representing their length
 */
export const tagged_list = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged-list`,
  "Lists tagged with a type-level natural number representing their length",
);

/**
 * QuasiQuoter and Template Haskell splices for creating proxies at higher-kinds
 */
export const tagged_th = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged-th`,
  "QuasiQuoter and Template Haskell splices for creating proxies at higher-kinds",
);

/**
 * Monad transformer carrying an extra phantom type tag
 */
export const tagged_transformer = mkPackage(
  nixRaw`pkgs.haskellPackages.tagged-transformer`,
  "Monad transformer carrying an extra phantom type tag",
);

/**
 * Library for tagging data
 */
export const tagging = mkPackage(
  nixRaw`pkgs.haskellPackages.tagging`,
  "Library for tagging data",
);

/**
 * Efficient and simple HTML/XML parsing library
 */
export const taggy = mkPackage(
  nixRaw`pkgs.haskellPackages.taggy`,
  "Efficient and simple HTML/XML parsing library",
);

/**
 * Binding to TagLib (ID3 tag library)
 */
export const taglib = mkPackage(
  nixRaw`pkgs.haskellPackages.taglib`,
  "Binding to TagLib (ID3 tag library)",
);

/**
 * Positional tags and tagsets
 */
export const tagset_positional = mkPackage(
  nixRaw`pkgs.haskellPackages.tagset-positional`,
  "Positional tags and tagsets",
);

/**
 * TagShare - explicit sharing with tags
 */
export const tagshare = mkPackage(
  nixRaw`pkgs.haskellPackages.tagshare`,
  "TagShare - explicit sharing with tags",
);

/**
 * Parsing and extracting information from (possibly malformed) HTML/XML documents
 */
export const tagsoup = mkPackage(
  nixRaw`pkgs.haskellPackages.tagsoup`,
  "Parsing and extracting information from (possibly malformed) HTML/XML documents",
);

/**
 * Tagsoup Navigate
 */
export const tagsoup_navigate = mkPackage(
  nixRaw`pkgs.haskellPackages.tagsoup-navigate`,
  "Tagsoup Navigate",
);

/**
 * Black magic tagsoup
 */
export const tagstew = mkPackage(
  nixRaw`pkgs.haskellPackages.tagstew`,
  "Black magic tagsoup",
);

/**
 * streamlined html tag parser
 */
export const tagstream_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.tagstream-conduit`,
  "streamlined html tag parser",
);

/**
 * Tahoe-LAFS directory-like abstraction for collections of data objects
 */
export const tahoe_directory = mkPackage(
  nixRaw`pkgs.haskellPackages.tahoe-directory`,
  "Tahoe-LAFS directory-like abstraction for collections of data objects",
);

/**
 * An implementation of the "Great Black Swamp" LAFS protocol
 */
export const tahoe_great_black_swamp = mkPackage(
  nixRaw`pkgs.haskellPackages.tahoe-great-black-swamp`,
  "An implementation of the \"Great Black Swamp\" LAFS protocol",
);

/**
 * An implementation of the Tahoe-LAFS SSK cryptographic protocols
 */
export const tahoe_ssk = mkPackage(
  nixRaw`pkgs.haskellPackages.tahoe-ssk`,
  "An implementation of the Tahoe-LAFS SSK cryptographic protocols",
);

/**
 * Tail files in Unix, using hinotify
 */
export const tailfile_hinotify = mkPackage(
  nixRaw`pkgs.haskellPackages.tailfile-hinotify`,
  "Tail files in Unix, using hinotify",
);

/**
 * AI(s) for playing Tak on playtak.com
 */
export const tak_ai = mkPackage(
  nixRaw`pkgs.haskellPackages.tak-ai`,
  "AI(s) for playing Tak on playtak.com",
);

/**
 * create slide for presentation
 */
export const takahashi = mkPackage(
  nixRaw`pkgs.haskellPackages.takahashi`,
  "create slide for presentation",
);

/**
 * duplicate file finder
 */
export const takedouble = mkPackage(
  nixRaw`pkgs.haskellPackages.takedouble`,
  "duplicate file finder",
);

/**
 * An implementation of Typed Assembly Language (Morrisett, Walker, Crary, Glew)
 */
export const tal = mkPackage(
  nixRaw`pkgs.haskellPackages.tal`,
  "An implementation of Typed Assembly Language (Morrisett, Walker, Crary, Glew)",
);

/**
 * Line oriented fast enough text search
 */
export const talash = mkPackage(
  nixRaw`pkgs.haskellPackages.talash`,
  "Line oriented fast enough text search",
);

/**
 * The Tamarin prover for security protocol analysis
 */
export const tamarin_prover = mkPackage(
  nixRaw`pkgs.haskellPackages.tamarin-prover`,
  "The Tamarin prover for security protocol analysis",
);

/**
 * Term manipulation library for the tamarin prover
 */
export const tamarin_prover_term = mkPackage(
  nixRaw`pkgs.haskellPackages.tamarin-prover-term`,
  "Term manipulation library for the tamarin prover",
);

/**
 * Term manipulation library for the tamarin prover
 */
export const tamarin_prover_theory = mkPackage(
  nixRaw`pkgs.haskellPackages.tamarin-prover-theory`,
  "Term manipulation library for the tamarin prover",
);

/**
 * Blaze-style HTML templates as a Monad Transformer
 */
export const tamper = mkPackage(
  nixRaw`pkgs.haskellPackages.tamper`,
  "Blaze-style HTML templates as a Monad Transformer",
);

/**
 * Heterogenous memoisation monad
 */
export const tangle = mkPackage(
  nixRaw`pkgs.haskellPackages.tangle`,
  "Heterogenous memoisation monad",
);

/**
 * Type-level assertion operators
 */
export const tao = mkPackage(
  nixRaw`pkgs.haskellPackages.tao`,
  "Type-level assertion operators",
);

/**
 * Example usage of the tao package
 */
export const tao_example = mkPackage(
  nixRaw`pkgs.haskellPackages.tao-example`,
  "Example usage of the tao package",
);

/**
 * Reading, writing and manipulating ".tar" archive files.
 */
export const tar = mkPackage(
  nixRaw`pkgs.haskellPackages.tar`,
  "Reading, writing and manipulating \".tar\" archive files.",
);

/**
 * Reading, writing and manipulating ".tar" archive files.
 */
export const tar_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.tar-bytestring`,
  "Reading, writing and manipulating \".tar\" archive files.",
);

/**
 * Extract and create tar files using conduit for streaming
 */
export const tar_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.tar-conduit`,
  "Extract and create tar files using conduit for streaming",
);

/**
 * Extract and create tar files using conduit for streaming
 */
export const tar_conduit_0_4_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.tar-conduit_0_4_0`,
  "Extract and create tar files using conduit for streaming",
);

/**
 * Bidirectional state monad transformer
 */
export const tardis = mkPackage(
  nixRaw`pkgs.haskellPackages.tardis`,
  "Bidirectional state monad transformer",
);

/**
 * Generate test-suites from refinement types
 */
export const target = mkPackage(
  nixRaw`pkgs.haskellPackages.target`,
  "Generate test-suites from refinement types",
);

/**
 * Terminal Art
 */
export const tart = mkPackage(
  nixRaw`pkgs.haskellPackages.tart`,
  "Terminal Art",
);

/**
 * A command line tool for keeping track of tasks you worked on
 */
export const task = mkPackage(
  nixRaw`pkgs.haskellPackages.task`,
  "A command line tool for keeping track of tasks you worked on",
);

/**
 * Distributed processing of changing tasks
 */
export const task_distribution = mkPackage(
  nixRaw`pkgs.haskellPackages.task-distribution`,
  "Distributed processing of changing tasks",
);

/**
 * A command-line kanban board/task manager
 */
export const taskell = mkPackage(
  nixRaw`pkgs.haskellPackages.taskell`,
  "A command-line kanban board/task manager",
);

/**
 * Manage pools of possibly interdependent tasks using STM and async
 */
export const taskpool = mkPackage(
  nixRaw`pkgs.haskellPackages.taskpool`,
  "Manage pools of possibly interdependent tasks using STM and async",
);

/**
 * Types and aeson instances for taskwarrior tasks
 */
export const taskwarrior = mkPackage(
  nixRaw`pkgs.haskellPackages.taskwarrior`,
  "Types and aeson instances for taskwarrior tasks",
);

/**
 * Modern and extensible testing framework
 */
export const tasty = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty`,
  "Modern and extensible testing framework",
);

/**
 * Modern and extensible testing framework
 */
export const tasty_1_5 = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty_1_5`,
  "Modern and extensible testing framework",
);

/**
 * Render tasty output to XML for Jenkins
 */
export const tasty_ant_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-ant-xml`,
  "Render tasty output to XML for Jenkins",
);

/**
 * BDD tests language and tasty provider
 */
export const tasty_bdd = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-bdd`,
  "BDD tests language and tasty provider",
);

/**
 * Featherlight benchmark framework
 */
export const tasty_bench = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-bench`,
  "Featherlight benchmark framework",
);

/**
 * Determine time complexity of a given function
 */
export const tasty_bench_fit = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-bench-fit`,
  "Determine time complexity of a given function",
);

/**
 * Check multiple items during a tasty test
 */
export const tasty_checklist = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-checklist`,
  "Check multiple items during a tasty test",
);

/**
 * Ingredient for tasty which generates per-test coverage reports
 */
export const tasty_coverage = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-coverage`,
  "Ingredient for tasty which generates per-test coverage reports",
);

/**
 * Deja Fu support for the Tasty test framework
 */
export const tasty_dejafu = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-dejafu`,
  "Deja Fu support for the Tasty test framework",
);

/**
 * Test discovery for the tasty framework
 */
export const tasty_discover = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-discover`,
  "Test discovery for the tasty framework",
);

/**
 * Mark tasty tests as failure expected
 */
export const tasty_expected_failure = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-expected-failure`,
  "Mark tasty tests as failure expected",
);

/**
 * Simple focus mechanism for tasty
 */
export const tasty_focus = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-focus`,
  "Simple focus mechanism for tasty",
);

/**
 * Golden tests support for tasty
 */
export const tasty_golden = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-golden`,
  "Golden tests support for tasty",
);

/**
 * Tasty Tests for groundhog converters
 */
export const tasty_groundhog_converters = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-groundhog-converters`,
  "Tasty Tests for groundhog converters",
);

/**
 * Integration for tasty and hedgehog
 */
export const tasty_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hedgehog`,
  "Integration for tasty and hedgehog",
);

/**
 * Integration for tasty and hedgehog
 */
export const tasty_hedgehog_1_4_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hedgehog_1_4_0_2`,
  "Integration for tasty and hedgehog",
);

/**
 * Tasty helpers to test HsLua
 */
export const tasty_hslua = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hslua`,
  "Tasty helpers to test HsLua",
);

/**
 * Hspec support for the Tasty test framework
 */
export const tasty_hspec = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hspec`,
  "Hspec support for the Tasty test framework",
);

/**
 * Hspec support for the Tasty test framework
 */
export const tasty_hspec_1_1_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hspec_1_1_6`,
  "Hspec support for the Tasty test framework",
);

/**
 * Hspec support for the Tasty test framework
 */
export const tasty_hspec_1_2_0_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hspec_1_2_0_4`,
  "Hspec support for the Tasty test framework",
);

/**
 * Render tasty output to HTML
 */
export const tasty_html = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-html`,
  "Render tasty output to HTML",
);

/**
 * HUnit support for the Tasty test framework
 */
export const tasty_hunit = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hunit`,
  "HUnit support for the Tasty test framework",
);

/**
 * Use existing HUnit tests with tasty
 */
export const tasty_hunit_adapter = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hunit-adapter`,
  "Use existing HUnit tests with tasty",
);

/**
 * Integration of `HUnit` with `tasty`
 */
export const tasty_hunit_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-hunit-compat`,
  "Integration of `HUnit` with `tasty`",
);

/**
 * Inspection testing support for tasty
 */
export const tasty_inspection_testing = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-inspection-testing`,
  "Inspection testing support for tasty",
);

/**
 * automated integration of QuickCheck properties into tasty suites
 */
export const tasty_integrate = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-integrate`,
  "automated integration of QuickCheck properties into tasty suites",
);

/**
 * Render tasty output to both console and XML for Jenkins
 */
export const tasty_jenkins_xml = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-jenkins-xml`,
  "Render tasty output to both console and XML for Jenkins",
);

/**
 * JSON reporter for the tasty testing framework
 */
export const tasty_json = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-json`,
  "JSON reporter for the tasty testing framework",
);

/**
 * Known Answer Tests (KAT) framework for tasty
 */
export const tasty_kat = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-kat`,
  "Known Answer Tests (KAT) framework for tasty",
);

/**
 * Test common laws
 */
export const tasty_laws = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-laws`,
  "Test common laws",
);

/**
 * LeanCheck support for the Tasty test framework
 */
export const tasty_leancheck = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-leancheck`,
  "LeanCheck support for the Tasty test framework",
);

/**
 * Tasty TestTrees for Lens validation
 */
export const tasty_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-lens`,
  "Tasty TestTrees for Lens validation",
);

/**
 * Write tests in Lua, integrate into tasty
 */
export const tasty_lua = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-lua`,
  "Write tests in Lua, integrate into tasty",
);

/**
 * Bencmarking using instruction counting
 */
export const tasty_papi = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-papi`,
  "Bencmarking using instruction counting",
);

/**
 * Unopinionated top-level entry point to tasty ecosystem
 */
export const tasty_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-prelude`,
  "Unopinionated top-level entry point to tasty ecosystem",
);

/**
 * Use tasty framework to test whether a program executes correctly
 */
export const tasty_program = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-program`,
  "Use tasty framework to test whether a program executes correctly",
);

/**
 * QuickCheck support for the Tasty test framework
 */
export const tasty_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-quickcheck`,
  "QuickCheck support for the Tasty test framework",
);

/**
 * QuickCheck support for the Tasty test framework
 */
export const tasty_quickcheck_0_10_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-quickcheck_0_10_3`,
  "QuickCheck support for the Tasty test framework",
);

/**
 * Pre-built tasty trees for checking lawful class properties using QuickCheck
 */
export const tasty_quickcheck_laws = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-quickcheck-laws`,
  "Pre-built tasty trees for checking lawful class properties using QuickCheck",
);

/**
 * Rerun only tests which failed in a previous test run
 */
export const tasty_rerun = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-rerun`,
  "Rerun only tests which failed in a previous test run",
);

/**
 * A fancy test runner, including support for golden tests
 */
export const tasty_silver = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-silver`,
  "A fancy test runner, including support for golden tests",
);

/**
 * SmallCheck support for the Tasty test framework
 */
export const tasty_smallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-smallcheck`,
  "SmallCheck support for the Tasty test framework",
);

/**
 * Tests defined by Search Using Golden Answer References
 */
export const tasty_sugar = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-sugar`,
  "Tests defined by Search Using Golden Answer References",
);

/**
 * TAP (Test Anything Protocol) Version 13 formatter for tasty
 */
export const tasty_tap = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-tap`,
  "TAP (Test Anything Protocol) Version 13 formatter for tasty",
);

/**
 * Automatic tasty test case discovery using TH
 */
export const tasty_th = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-th`,
  "Automatic tasty test case discovery using TH",
);

/**
 * Terminal user acceptance testing (UAT) via tmux
 */
export const tasty_tmux = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-tmux`,
  "Terminal user acceptance testing (UAT) via tmux",
);

/**
 * Fancy Travis CI output for tasty tests
 */
export const tasty_travis = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-travis`,
  "Fancy Travis CI output for tasty tests",
);

/**
 * Test 'wai' endpoints via Test.Tasty
 */
export const tasty_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.tasty-wai`,
  "Test 'wai' endpoints via Test.Tasty",
);

/**
 * Meta tic-tac-toe ncurses game
 */
export const tateti_tateti = mkPackage(
  nixRaw`pkgs.haskellPackages.tateti-tateti`,
  "Meta tic-tac-toe ncurses game",
);

/**
 * Tau, the ratio between any circle's circumference and radius
 */
export const tau = mkPackage(
  nixRaw`pkgs.haskellPackages.tau`,
  "Tau, the ratio between any circle's circumference and radius",
);

/**
 * Types and combinators for taxes
 */
export const tax = mkPackage(
  nixRaw`pkgs.haskellPackages.tax`,
  "Types and combinators for taxes",
);

/**
 * Tax types and computations for Australia
 */
export const tax_ato = mkPackage(
  nixRaw`pkgs.haskellPackages.tax-ato`,
  "Tax types and computations for Australia",
);

/**
 * Transactional variables and data structures with IO hooks
 */
export const tbox = mkPackage(
  nixRaw`pkgs.haskellPackages.tbox`,
  "Transactional variables and data structures with IO hooks",
);

/**
 * TokyoCabinet CLI interface
 */
export const tccli = mkPackage(
  nixRaw`pkgs.haskellPackages.tccli`,
  "TokyoCabinet CLI interface",
);

/**
 * Very simple config file reading
 */
export const tce_conf = mkPackage(
  nixRaw`pkgs.haskellPackages.tce-conf`,
  "Very simple config file reading",
);

/**
 * Bindings to libtcod roguelike engine
 */
export const tcod_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.tcod-haskell`,
  "Bindings to libtcod roguelike engine",
);

/**
 * Simple text configuration file parser library
 */
export const tconfig = mkPackage(
  nixRaw`pkgs.haskellPackages.tconfig`,
  "Simple text configuration file parser library",
);

/**
 * One stop solution for tcp client and server with tls support
 */
export const tcp_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.tcp-streams`,
  "One stop solution for tcp client and server with tls support",
);

/**
 * Test framework wrapper
 */
export const tdd_util = mkPackage(
  nixRaw`pkgs.haskellPackages.tdd-util`,
  "Test framework wrapper",
);

/**
 * On-line accumulation of rank-based statistics
 */
export const tdigest = mkPackage(
  nixRaw`pkgs.haskellPackages.tdigest`,
  "On-line accumulation of rank-based statistics",
);

/**
 * complete binding to the Telegram Database Library
 */
export const tdlib = mkPackage(
  nixRaw`pkgs.haskellPackages.tdlib`,
  "complete binding to the Telegram Database Library",
);

/**
 * Codegen for TDLib
 */
export const tdlib_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.tdlib-gen`,
  "Codegen for TDLib",
);

/**
 * Types and Functions generated from tdlib api spec
 */
export const tdlib_types = mkPackage(
  nixRaw`pkgs.haskellPackages.tdlib-types`,
  "Types and Functions generated from tdlib api spec",
);

/**
 * Build safe and composable teardown sub-routines for resources
 */
export const teardown = mkPackage(
  nixRaw`pkgs.haskellPackages.teardown`,
  "Build safe and composable teardown sub-routines for resources",
);

/**
 * Bleeding edge prelude
 */
export const techlab = mkPackage(
  nixRaw`pkgs.haskellPackages.techlab`,
  "Bleeding edge prelude",
);

/**
 * Telegram Bot microframework for Haskell
 */
export const telegram_bot = mkPackage(
  nixRaw`pkgs.haskellPackages.telegram-bot`,
  "Telegram Bot microframework for Haskell",
);

/**
 * Easy to use library for building Telegram bots. Exports Telegram Bot API.
 */
export const telegram_bot_api = mkPackage(
  nixRaw`pkgs.haskellPackages.telegram-bot-api`,
  "Easy to use library for building Telegram bots. Exports Telegram Bot API.",
);

/**
 * Easy to use library for building Telegram bots
 */
export const telegram_bot_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.telegram-bot-simple`,
  "Easy to use library for building Telegram bots",
);

/**
 * Servant bindings to the Telegram bot API
 */
export const telegram_raw_api = mkPackage(
  nixRaw`pkgs.haskellPackages.telegram-raw-api`,
  "Servant bindings to the Telegram bot API",
);

/**
 * The MonadTell class and related monad transformers
 */
export const tell = mkPackage(
  nixRaw`pkgs.haskellPackages.tell`,
  "The MonadTell class and related monad transformers",
);

/**
 * A dead-simple shell interpolation templating utility
 */
export const tempered = mkPackage(
  nixRaw`pkgs.haskellPackages.tempered`,
  "A dead-simple shell interpolation templating utility",
);

/**
 * For representing musical tempi
 */
export const tempi = mkPackage(
  nixRaw`pkgs.haskellPackages.tempi`,
  "For representing musical tempi",
);

/**
 * Support library for Template Haskell
 */
export const template_haskell_2_20_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.template-haskell_2_20_0_0`,
  "Support library for Template Haskell",
);

/**
 * A backwards compatibility layer for Template Haskell newer than 2.8
 */
export const template_haskell_compat_v0208 = mkPackage(
  nixRaw`pkgs.haskellPackages.template-haskell-compat-v0208`,
  "A backwards compatibility layer for Template Haskell newer than 2.8",
);

/**
 * Simple string templater
 */
export const templater = mkPackage(
  nixRaw`pkgs.haskellPackages.templater`,
  "Simple string templater",
);

/**
 * Command-line tool to log time-tracking information into JIRA Tempo plugin
 */
export const tempo = mkPackage(
  nixRaw`pkgs.haskellPackages.tempo`,
  "Command-line tool to log time-tracking information into JIRA Tempo plugin",
);

/**
 * library to make electronic music, brings together temporal-music-notation and csound-expression packages
 */
export const temporal_csound = mkPackage(
  nixRaw`pkgs.haskellPackages.temporal-csound`,
  "library to make electronic music, brings together temporal-music-notation and csound-expression packages",
);

/**
 * data types for temporal media
 */
export const temporal_media = mkPackage(
  nixRaw`pkgs.haskellPackages.temporal-media`,
  "data types for temporal media",
);

/**
 * music notation
 */
export const temporal_music_notation = mkPackage(
  nixRaw`pkgs.haskellPackages.temporal-music-notation`,
  "music notation",
);

/**
 * generates midi from score notation
 */
export const temporal_music_notation_demo = mkPackage(
  nixRaw`pkgs.haskellPackages.temporal-music-notation-demo`,
  "generates midi from score notation",
);

/**
 * western music notation
 */
export const temporal_music_notation_western = mkPackage(
  nixRaw`pkgs.haskellPackages.temporal-music-notation-western`,
  "western music notation",
);

/**
 * Portable temporary file and directory support
 */
export const temporary = mkPackage(
  nixRaw`pkgs.haskellPackages.temporary`,
  "Portable temporary file and directory support",
);

/**
 * Portable temporary file and directory support for Windows and Unix, based on code from Cabal
 */
export const temporary_rc = mkPackage(
  nixRaw`pkgs.haskellPackages.temporary-rc`,
  "Portable temporary file and directory support for Windows and Unix, based on code from Cabal",
);

/**
 * Portable temporary files and directories with automatic deletion
 */
export const temporary_resourcet = mkPackage(
  nixRaw`pkgs.haskellPackages.temporary-resourcet`,
  "Portable temporary files and directories with automatic deletion",
);

/**
 * Programmers' time tracker
 */
export const tempus_fugit = mkPackage(
  nixRaw`pkgs.haskellPackages.tempus-fugit`,
  "Programmers' time tracker",
);

/**
 * Lenses for the types in the ten package
 */
export const ten_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.ten-lens`,
  "Lenses for the types in the ten package",
);

/**
 * Higher-kinded hash containers
 */
export const ten_unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.ten-unordered-containers`,
  "Higher-kinded hash containers",
);

/**
 * Code generation for TensorFlow operations
 */
export const tensorflow_opgen = mkPackage(
  nixRaw`pkgs.haskellPackages.tensorflow-opgen`,
  "Code generation for TensorFlow operations",
);

/**
 * TensorFlow protocol buffers
 */
export const tensorflow_proto = mkPackage(
  nixRaw`pkgs.haskellPackages.tensorflow-proto`,
  "TensorFlow protocol buffers",
);

/**
 * Encoder and decoder for the TensorFlow "TFRecords" format
 */
export const tensorflow_records = mkPackage(
  nixRaw`pkgs.haskellPackages.tensorflow-records`,
  "Encoder and decoder for the TensorFlow \"TFRecords\" format",
);

/**
 * Conduit wrappers for TensorFlow.Records.
 */
export const tensorflow_records_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.tensorflow-records-conduit`,
  "Conduit wrappers for TensorFlow.Records.",
);

/**
 * Some common functions for test suites
 */
export const tensorflow_test = mkPackage(
  nixRaw`pkgs.haskellPackages.tensorflow-test`,
  "Some common functions for test suites",
);

/**
 * Tensor in Haskell
 */
export const tensors = mkPackage(
  nixRaw`pkgs.haskellPackages.tensors`,
  "Tensor in Haskell",
);

/**
 * Term Rewriting Library
 */
export const term_rewriting = mkPackage(
  nixRaw`pkgs.haskellPackages.term-rewriting`,
  "Term Rewriting Library",
);

/**
 * termbox
 */
export const termbox = mkPackage(
  nixRaw`pkgs.haskellPackages.termbox`,
  "termbox",
);

/**
 * termbox + reactive-banana
 */
export const termbox_banana = mkPackage(
  nixRaw`pkgs.haskellPackages.termbox-banana`,
  "termbox + reactive-banana",
);

/**
 * termbox bindings
 */
export const termbox_bindings_c = mkPackage(
  nixRaw`pkgs.haskellPackages.termbox-bindings-c`,
  "termbox bindings",
);

/**
 * termbox bindings
 */
export const termbox_bindings_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.termbox-bindings-hs`,
  "termbox bindings",
);

/**
 * termbox + The Elm Architecture
 */
export const termbox_tea = mkPackage(
  nixRaw`pkgs.haskellPackages.termbox-tea`,
  "termbox + The Elm Architecture",
);

/**
 * Composable terminal colors
 */
export const termcolor = mkPackage(
  nixRaw`pkgs.haskellPackages.termcolor`,
  "Composable terminal colors",
);

/**
 * Portable terminal interaction library
 */
export const terminal = mkPackage(
  nixRaw`pkgs.haskellPackages.terminal`,
  "Portable terminal interaction library",
);

/**
 * A progress bar in the terminal
 */
export const terminal_progress_bar = mkPackage(
  nixRaw`pkgs.haskellPackages.terminal-progress-bar`,
  "A progress bar in the terminal",
);

/**
 * Simple terminal-based time tracker
 */
export const terminal_punch = mkPackage(
  nixRaw`pkgs.haskellPackages.terminal-punch`,
  "Simple terminal-based time tracker",
);

/**
 * Get terminal window height and width
 */
export const terminal_size = mkPackage(
  nixRaw`pkgs.haskellPackages.terminal-size`,
  "Get terminal window height and width",
);

/**
 * Text data type for styled terminal output, including all standard ANSI effects (bold, italic, blinking) and ANSI / 256 / truecolor colors support for Unix and Windows (whenever possible)
 */
export const terminal_text = mkPackage(
  nixRaw`pkgs.haskellPackages.terminal-text`,
  "Text data type for styled terminal output, including all standard ANSI effects (bold, italic, blinking) and ANSI / 256 / truecolor colors support for Unix and Windows (whenever possible)",
);

/**
 * Haskell bindings to the terminfo library
 */
export const terminfo_0_4_1_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.terminfo_0_4_1_6`,
  "Haskell bindings to the terminfo library",
);

/**
 * A pure-Haskell (no FFI) module for accessing terminfo databases
 */
export const terminfo_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.terminfo-hs`,
  "A pure-Haskell (no FFI) module for accessing terminfo databases",
);

/**
 * Terminal emulator configurable in Haskell
 */
export const termonad = mkPackage(
  nixRaw`pkgs.haskellPackages.termonad`,
  "Terminal emulator configurable in Haskell",
);

/**
 * HTTP backend to store terraform state using pass and git
 */
export const terraform_http_backend_pass = mkPackage(
  nixRaw`pkgs.haskellPackages.terraform-http-backend-pass`,
  "HTTP backend to store terraform state using pass and git",
);

/**
 * A Haskell GIS Programming Environment
 */
export const terrahs = mkPackage(
  nixRaw`pkgs.haskellPackages.terrahs`,
  "A Haskell GIS Programming Environment",
);

/**
 * Tesla API client
 */
export const tesla = mkPackage(
  nixRaw`pkgs.haskellPackages.tesla`,
  "Tesla API client",
);

/**
 * Framework for running and organising tests, with HUnit and QuickCheck support
 */
export const test_framework = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework`,
  "Framework for running and organising tests, with HUnit and QuickCheck support",
);

/**
 * Golden tests support for test-framework
 */
export const test_framework_golden = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-golden`,
  "Golden tests support for test-framework",
);

/**
 * HUnit support for the test-framework package
 */
export const test_framework_hunit = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-hunit`,
  "HUnit support for the test-framework package",
);

/**
 * LeanCheck support for test-framework
 */
export const test_framework_leancheck = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-leancheck`,
  "LeanCheck support for test-framework",
);

/**
 * Test framework support for running simple test programs
 */
export const test_framework_program = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-program`,
  "Test framework support for running simple test programs",
);

/**
 * QuickCheck-2 support for the test-framework package
 */
export const test_framework_quickcheck2 = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-quickcheck2`,
  "QuickCheck-2 support for the test-framework package",
);

/**
 * test-sandbox support for the test-framework package
 */
export const test_framework_sandbox = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-sandbox`,
  "test-sandbox support for the test-framework package",
);

/**
 * Support for SmallCheck tests in test-framework
 */
export const test_framework_smallcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-smallcheck`,
  "Support for SmallCheck tests in test-framework",
);

/**
 * Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell
 */
export const test_framework_th = mkPackage(
  nixRaw`pkgs.haskellPackages.test-framework-th`,
  "Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell",
);

/**
 * Testable functions
 */
export const test_fun = mkPackage(
  nixRaw`pkgs.haskellPackages.test-fun`,
  "Testable functions",
);

/**
 * Provide common invariants to be checked with QuickCheck
 */
export const test_invariant = mkPackage(
  nixRaw`pkgs.haskellPackages.test-invariant`,
  "Provide common invariants to be checked with QuickCheck",
);

/**
 * Testing framework
 */
export const test_karya = mkPackage(
  nixRaw`pkgs.haskellPackages.test-karya`,
  "Testing framework",
);

/**
 * Laws for mtl classes as QuickCheck properties
 */
export const test_monad_laws = mkPackage(
  nixRaw`pkgs.haskellPackages.test-monad-laws`,
  "Laws for mtl classes as QuickCheck properties",
);

/**
 * Sandbox for system tests
 */
export const test_sandbox = mkPackage(
  nixRaw`pkgs.haskellPackages.test-sandbox`,
  "Sandbox for system tests",
);

/**
 * Lightweight development enviroments using test-sandbox
 */
export const test_sandbox_compose = mkPackage(
  nixRaw`pkgs.haskellPackages.test-sandbox-compose`,
  "Lightweight development enviroments using test-sandbox",
);

/**
 * HUnit convenience functions for use with test-sandbox
 */
export const test_sandbox_hunit = mkPackage(
  nixRaw`pkgs.haskellPackages.test-sandbox-hunit`,
  "HUnit convenience functions for use with test-sandbox",
);

/**
 * QuickCheck convenience functions for use with test-sandbox
 */
export const test_sandbox_quickcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.test-sandbox-quickcheck`,
  "QuickCheck convenience functions for use with test-sandbox",
);

/**
 * Simple Perl inspired testing
 */
export const test_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.test-simple`,
  "Simple Perl inspired testing",
);

/**
 * Create tests and benchmarks together
 */
export const testbench = mkPackage(
  nixRaw`pkgs.haskellPackages.testbench`,
  "Create tests and benchmarks together",
);

/**
 * Functional Enumeration of Algebraic Types
 */
export const testing_feat = mkPackage(
  nixRaw`pkgs.haskellPackages.testing-feat`,
  "Functional Enumeration of Algebraic Types",
);

/**
 * Data type modifiers for property based testing
 */
export const testing_type_modifiers = mkPackage(
  nixRaw`pkgs.haskellPackages.testing-type-modifiers`,
  "Data type modifiers for property based testing",
);

/**
 * A 2-D clone of Tetris
 */
export const tetris = mkPackage(
  nixRaw`pkgs.haskellPackages.tetris`,
  "A 2-D clone of Tetris",
);

/**
 * Conversion between math formats
 */
export const texmath = mkPackage(
  nixRaw`pkgs.haskellPackages.texmath`,
  "Conversion between math formats",
);

/**
 * Functions for running Tex from Haskell
 */
export const texrunner = mkPackage(
  nixRaw`pkgs.haskellPackages.texrunner`,
  "Functions for running Tex from Haskell",
);

/**
 * Plot functions in text
 */
export const textPlot = mkPackage(
  nixRaw`pkgs.haskellPackages.textPlot`,
  "Plot functions in text",
);

/**
 * An efficient packed Unicode text type
 */
export const text_2_0_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.text_2_0_2`,
  "An efficient packed Unicode text type",
);

/**
 * An efficient packed Unicode text type
 */
export const text_2_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.text_2_1`,
  "An efficient packed Unicode text type",
);

/**
 * Text styling for ANSI terminals
 */
export const text_ansi = mkPackage(
  nixRaw`pkgs.haskellPackages.text-ansi`,
  "Text styling for ANSI terminals",
);

/**
 * Text styling for ANSI terminals
 */
export const text_ansi_0_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.text-ansi_0_3_0`,
  "Text styling for ANSI terminals",
);

/**
 * Binary instances for text types
 */
export const text_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.text-binary`,
  "Binary instances for text types",
);

/**
 * An efficient strict text builder
 */
export const text_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.text-builder`,
  "An efficient strict text builder",
);

/**
 * Edge of developments for "text-builder"
 */
export const text_builder_dev = mkPackage(
  nixRaw`pkgs.haskellPackages.text-builder-dev`,
  "Edge of developments for \"text-builder\"",
);

/**
 * Builder for Text and ByteString based on linear types
 */
export const text_builder_linear = mkPackage(
  nixRaw`pkgs.haskellPackages.text-builder-linear`,
  "Builder for Text and ByteString based on linear types",
);

/**
 * Safe conversions between textual types
 */
export const text_conversions = mkPackage(
  nixRaw`pkgs.haskellPackages.text-conversions`,
  "Safe conversions between textual types",
);

/**
 * Conversion of Text to and from CP437
 */
export const text_cp437 = mkPackage(
  nixRaw`pkgs.haskellPackages.text-cp437`,
  "Conversion of Text to and from CP437",
);

/**
 * A typeclass for user-facing output
 */
export const text_display = mkPackage(
  nixRaw`pkgs.haskellPackages.text-display`,
  "A typeclass for user-facing output",
);

/**
 * Text formatting
 */
export const text_format = mkPackage(
  nixRaw`pkgs.haskellPackages.text-format`,
  "Text formatting",
);

/**
 * Simple text formatting library
 */
export const text_format_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.text-format-simple`,
  "Simple text formatting library",
);

/**
 * Bindings to the ICU library
 */
export const text_icu = mkPackage(
  nixRaw`pkgs.haskellPackages.text-icu`,
  "Bindings to the ICU library",
);

/**
 * Converting time to and from ISO 8601 text
 */
export const text_iso8601 = mkPackage(
  nixRaw`pkgs.haskellPackages.text-iso8601`,
  "Converting time to and from ISO 8601 text",
);

/**
 * Json Quasiquatation for Haskell
 */
export const text_json_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.text-json-qq`,
  "Json Quasiquatation for Haskell",
);

/**
 * Latin-1 (including ASCII) utility functions
 */
export const text_latin1 = mkPackage(
  nixRaw`pkgs.haskellPackages.text-latin1`,
  "Latin-1 (including ASCII) utility functions",
);

/**
 * Parser and Printer for LDAP text data stream
 */
export const text_ldap = mkPackage(
  nixRaw`pkgs.haskellPackages.text-ldap`,
  "Parser and Printer for LDAP text data stream",
);

/**
 * Monadic parsing combinator library with attention to locations
 */
export const text_lips = mkPackage(
  nixRaw`pkgs.haskellPackages.text-lips`,
  "Monadic parsing combinator library with attention to locations",
);

/**
 * Line-column locations within a text
 */
export const text_loc = mkPackage(
  nixRaw`pkgs.haskellPackages.text-loc`,
  "Line-column locations within a text",
);

/**
 * Encode and decode Text to/from ByteString using TextEncoding
 */
export const text_locale_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.text-locale-encoding`,
  "Encode and decode Text to/from ByteString using TextEncoding",
);

/**
 * Case conversion, word boundary manipulation, and textual subjugation
 */
export const text_manipulate = mkPackage(
  nixRaw`pkgs.haskellPackages.text-manipulate`,
  "Case conversion, word boundary manipulation, and textual subjugation",
);

/**
 * Calculate various string metrics efficiently
 */
export const text_metrics = mkPackage(
  nixRaw`pkgs.haskellPackages.text-metrics`,
  "Calculate various string metrics efficiently",
);

/**
 * Utils for text
 */
export const text_plus = mkPackage(
  nixRaw`pkgs.haskellPackages.text-plus`,
  "Utils for text",
);

/**
 * Parser and Printer of PostgreSQL extended types
 */
export const text_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.text-postgresql`,
  "Parser and Printer of PostgreSQL extended types",
);

/**
 * Abstract interface for text builders/printers
 */
export const text_printer = mkPackage(
  nixRaw`pkgs.haskellPackages.text-printer`,
  "Abstract interface for text builders/printers",
);

/**
 * Easy replacement when using text-icu regexes
 */
export const text_regex_replace = mkPackage(
  nixRaw`pkgs.haskellPackages.text-regex-replace`,
  "Easy replacement when using text-icu regexes",
);

/**
 * Marking text regions
 */
export const text_region = mkPackage(
  nixRaw`pkgs.haskellPackages.text-region`,
  "Marking text regions",
);

/**
 * A type class for rendering objects as text, pretty-printing, etc
 */
export const text_render = mkPackage(
  nixRaw`pkgs.haskellPackages.text-render`,
  "A type class for rendering objects as text, pretty-printing, etc",
);

/**
 * Simple text replacements from a list of search/replace pairs
 */
export const text_replace = mkPackage(
  nixRaw`pkgs.haskellPackages.text-replace`,
  "Simple text replacements from a list of search/replace pairs",
);

/**
 * Text lines and ropes
 */
export const text_rope = mkPackage(
  nixRaw`pkgs.haskellPackages.text-rope`,
  "Text lines and ropes",
);

/**
 * Memory-efficient representation of Unicode text strings
 */
export const text_short = mkPackage(
  nixRaw`pkgs.haskellPackages.text-short`,
  "Memory-efficient representation of Unicode text strings",
);

/**
 * Efficient conversion of values into Text
 */
export const text_show = mkPackage(
  nixRaw`pkgs.haskellPackages.text-show`,
  "Efficient conversion of values into Text",
);

/**
 * Additional instances for text-show
 */
export const text_show_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.text-show-instances`,
  "Additional instances for text-show",
);

/**
 * Library for Time parsing from Text into UTCTime
 */
export const text_time = mkPackage(
  nixRaw`pkgs.haskellPackages.text-time`,
  "Library for Time parsing from Text into UTCTime",
);

/**
 * Various text utilities
 */
export const text_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.text-utils`,
  "Various text utilities",
);

/**
 * Serialize Data to XML (strings)
 */
export const text_xml_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.text-xml-generic`,
  "Serialize Data to XML (strings)",
);

/**
 * A text editor zipper library
 */
export const text_zipper = mkPackage(
  nixRaw`pkgs.haskellPackages.text-zipper`,
  "A text editor zipper library",
);

/**
 * Haskell wrapper for textlocal SMS gateway
 */
export const textlocal = mkPackage(
  nixRaw`pkgs.haskellPackages.textlocal`,
  "Haskell wrapper for textlocal SMS gateway",
);

/**
 * A simple Haskell program to provide tags for Haskell code completion in TextMate
 */
export const textmatetags = mkPackage(
  nixRaw`pkgs.haskellPackages.textmatetags`,
  "A simple Haskell program to provide tags for Haskell code completion in TextMate",
);

/**
 * None
 */
export const texts = mkPackage(
  nixRaw`pkgs.haskellPackages.texts`,
  "None",
);

/**
 * High-quality splittable pseudorandom number generator
 */
export const tf_random = mkPackage(
  nixRaw`pkgs.haskellPackages.tf-random`,
  "High-quality splittable pseudorandom number generator",
);

/**
 * Type-level integers, booleans, lists using type families
 */
export const tfp = mkPackage(
  nixRaw`pkgs.haskellPackages.tfp`,
  "Type-level integers, booleans, lists using type families",
);

/**
 * Nicer interface for reified information about data types
 */
export const th_abstraction = mkPackage(
  nixRaw`pkgs.haskellPackages.th-abstraction`,
  "Nicer interface for reified information about data types",
);

/**
 * Nicer interface for reified information about data types
 */
export const th_abstraction_0_5_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.th-abstraction_0_5_0_0`,
  "Nicer interface for reified information about data types",
);

/**
 * Nicer interface for reified information about data types
 */
export const th_abstraction_0_6_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.th-abstraction_0_6_0_0`,
  "Nicer interface for reified information about data types",
);

/**
 * Alpha equivalence for TH Exp
 */
export const th_alpha = mkPackage(
  nixRaw`pkgs.haskellPackages.th-alpha`,
  "Alpha equivalence for TH Exp",
);

/**
 * Compatibility for bang-type template
 */
export const th_bang_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-bang-compat`,
  "Compatibility for bang-type template",
);

/**
 * Compile-time CAS(Computer Algebra System)
 */
export const th_cas = mkPackage(
  nixRaw`pkgs.haskellPackages.th-cas`,
  "Compile-time CAS(Computer Algebra System)",
);

/**
 * Backward- (and forward-)compatible Quote and Code types
 */
export const th_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-compat`,
  "Backward- (and forward-)compatible Quote and Code types",
);

/**
 * Compatibility for type constraint template
 */
export const th_constraint_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-constraint-compat`,
  "Compatibility for type constraint template",
);

/**
 * Test instance context
 */
export const th_context = mkPackage(
  nixRaw`pkgs.haskellPackages.th-context`,
  "Test instance context",
);

/**
 * Compatibility for data definition template of TH
 */
export const th_data_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-data-compat`,
  "Compatibility for data definition template of TH",
);

/**
 * Compatibility for data definition template of TH
 */
export const th_data_compat_0_1_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.th-data-compat_0_1_1_1`,
  "Compatibility for data definition template of TH",
);

/**
 * Functions to desugar Template Haskell
 */
export const th_desugar = mkPackage(
  nixRaw`pkgs.haskellPackages.th-desugar`,
  "Functions to desugar Template Haskell",
);

/**
 * Functions to desugar Template Haskell
 */
export const th_desugar_1_15 = mkPackage(
  nixRaw`pkgs.haskellPackages.th-desugar_1_15`,
  "Functions to desugar Template Haskell",
);

/**
 * Template Haskell splices that expand to an environment variable
 */
export const th_env = mkPackage(
  nixRaw`pkgs.haskellPackages.th-env`,
  "Template Haskell splices that expand to an environment variable",
);

/**
 * Expands type synonyms in Template Haskell ASTs
 */
export const th_expand_syns = mkPackage(
  nixRaw`pkgs.haskellPackages.th-expand-syns`,
  "Expands type synonyms in Template Haskell ASTs",
);

/**
 * A grab bag of functions for use with Template Haskell
 */
export const th_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.th-extras`,
  "A grab bag of functions for use with Template Haskell",
);

/**
 * A place to collect orphan instances for Template Haskell
 */
export const th_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.th-instances`,
  "A place to collect orphan instances for Template Haskell",
);

/**
 * Template Haskell construction utilities
 */
export const th_lego = mkPackage(
  nixRaw`pkgs.haskellPackages.th-lego`,
  "Template Haskell construction utilities",
);

/**
 * Implicit (recursive) let insertion
 */
export const th_letrec = mkPackage(
  nixRaw`pkgs.haskellPackages.th-letrec`,
  "Implicit (recursive) let insertion",
);

/**
 * Derive Template Haskell's Lift class for datatypes
 */
export const th_lift = mkPackage(
  nixRaw`pkgs.haskellPackages.th-lift`,
  "Derive Template Haskell's Lift class for datatypes",
);

/**
 * Lift instances for template-haskell for common data types
 */
export const th_lift_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.th-lift-instances`,
  "Lift instances for template-haskell for common data types",
);

/**
 * Template Haskell splice that expands to current time
 */
export const th_nowq = mkPackage(
  nixRaw`pkgs.haskellPackages.th-nowq`,
  "Template Haskell splice that expands to current time",
);

/**
 * Orphan instances for TH datatypes
 */
export const th_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.th-orphans`,
  "Orphan instances for TH datatypes",
);

/**
 * Quasiquoters for printf
 */
export const th_printf = mkPackage(
  nixRaw`pkgs.haskellPackages.th-printf`,
  "Quasiquoters for printf",
);

/**
 * Quasiquoters for printf
 */
export const th_printf_0_8 = mkPackage(
  nixRaw`pkgs.haskellPackages.th-printf_0_8`,
  "Quasiquoters for printf",
);

/**
 * Compatibility for the result type of TH reify
 */
export const th_reify_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-reify-compat`,
  "Compatibility for the result type of TH reify",
);

/**
 * Recurseively reify template haskell datatype info
 */
export const th_reify_many = mkPackage(
  nixRaw`pkgs.haskellPackages.th-reify-many`,
  "Recurseively reify template haskell datatype info",
);

/**
 * Compatibility shim for Bang and Strict in Template Haskell
 */
export const th_strict_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.th-strict-compat`,
  "Compatibility shim for Bang and Strict in Template Haskell",
);

/**
 * Utility functions for testing Template Haskell code
 */
export const th_test_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.th-test-utils`,
  "Utility functions for testing Template Haskell code",
);

/**
 * Graph of the subtype relation
 */
export const th_typegraph = mkPackage(
  nixRaw`pkgs.haskellPackages.th-typegraph`,
  "Graph of the subtype relation",
);

/**
 * Collection of useful functions for use with Template Haskell
 */
export const th_utilities = mkPackage(
  nixRaw`pkgs.haskellPackages.th-utilities`,
  "Collection of useful functions for use with Template Haskell",
);

/**
 * Command line tool for extracting demarcated snippets from text files
 */
export const the_snip = mkPackage(
  nixRaw`pkgs.haskellPackages.the-snip`,
  "Command line tool for extracting demarcated snippets from text files",
);

/**
 * Minimalistic actor library
 */
export const theatre = mkPackage(
  nixRaw`pkgs.haskellPackages.theatre`,
  "Minimalistic actor library",
);

/**
 * Project templating tool
 */
export const themplate = mkPackage(
  nixRaw`pkgs.haskellPackages.themplate`,
  "Project templating tool",
);

/**
 * A simple client for the TheoremQuest theorem proving game
 */
export const theoremquest_client = mkPackage(
  nixRaw`pkgs.haskellPackages.theoremquest-client`,
  "A simple client for the TheoremQuest theorem proving game",
);

/**
 * An either-or-both data type
 */
export const these = mkPackage(
  nixRaw`pkgs.haskellPackages.these`,
  "An either-or-both data type",
);

/**
 * Lenses for These
 */
export const these_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.these-lens`,
  "Lenses for These",
);

/**
 * Optics for These
 */
export const these_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.these-optics`,
  "Optics for These",
);

/**
 * A fork of the 'these' package without the dependency bloat
 */
export const these_skinny = mkPackage(
  nixRaw`pkgs.haskellPackages.these-skinny`,
  "A fork of the 'these' package without the dependency bloat",
);

/**
 * Lightweight Erlang-style actors for Haskell
 */
export const thespian = mkPackage(
  nixRaw`pkgs.haskellPackages.thespian`,
  "Lightweight Erlang-style actors for Haskell",
);

/**
 * Theta-functions implemented as trigonometric series
 */
export const theta_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.theta-functions`,
  "Theta-functions implemented as trigonometric series",
);

/**
 * Command-line spelling word suggestion tool
 */
export const thimk = mkPackage(
  nixRaw`pkgs.haskellPackages.thimk`,
  "Command-line spelling word suggestion tool",
);

/**
 * Runs other programs in the manner of a thread pool
 */
export const threadPool = mkPackage(
  nixRaw`pkgs.haskellPackages.threadPool`,
  "Runs other programs in the manner of a thread pool",
);

/**
 * Simple Haskell thread management in hierarchical manner
 */
export const thread_hierarchy = mkPackage(
  nixRaw`pkgs.haskellPackages.thread-hierarchy`,
  "Simple Haskell thread management in hierarchical manner",
);

/**
 * Several options for thread-local-storage (TLS) in Haskell
 */
export const thread_local_storage = mkPackage(
  nixRaw`pkgs.haskellPackages.thread-local-storage`,
  "Several options for thread-local-storage (TLS) in Haskell",
);

/**
 * A simplified implementation of Erlang/OTP like supervisor over thread
 */
export const thread_supervisor = mkPackage(
  nixRaw`pkgs.haskellPackages.thread-supervisor`,
  "A simplified implementation of Erlang/OTP like supervisor over thread",
);

/**
 * Garbage-collected thread local storage
 */
export const thread_utils_context = mkPackage(
  nixRaw`pkgs.haskellPackages.thread-utils-context`,
  "Garbage-collected thread local storage",
);

/**
 * Perform finalization for threads
 */
export const thread_utils_finalizers = mkPackage(
  nixRaw`pkgs.haskellPackages.thread-utils-finalizers`,
  "Perform finalization for threads",
);

/**
 * Manage concurrently operating threads without having to spark them
 */
export const threaded = mkPackage(
  nixRaw`pkgs.haskellPackages.threaded`,
  "Manage concurrently operating threads without having to spark them",
);

/**
 * Fork threads and wait for their result
 */
export const threads = mkPackage(
  nixRaw`pkgs.haskellPackages.threads`,
  "Fork threads and wait for their result",
);

/**
 * Extends the threads package with a bounded thread group
 */
export const threads_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.threads-extras`,
  "Extends the threads package with a bounded thread group",
);

/**
 * A library to operate with pool of haskell's IO threads
 */
export const threads_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.threads-pool`,
  "A library to operate with pool of haskell's IO threads",
);

/**
 * Simple, IO-based library for Erlang-style thread supervision
 */
export const threads_supervisor = mkPackage(
  nixRaw`pkgs.haskellPackages.threads-supervisor`,
  "Simple, IO-based library for Erlang-style thread supervision",
);

/**
 * A graphical tool for profiling parallel Haskell programs
 */
export const threadscope = mkPackage(
  nixRaw`pkgs.haskellPackages.threadscope`,
  "A graphical tool for profiling parallel Haskell programs",
);

/**
 * The Threefish block cipher and the Skein hash function for Haskell
 */
export const threefish = mkPackage(
  nixRaw`pkgs.haskellPackages.threefish`,
  "The Threefish block cipher and the Skein hash function for Haskell",
);

/**
 * GUI framework that uses the web browser as a display
 */
export const threepenny_gui = mkPackage(
  nixRaw`pkgs.haskellPackages.threepenny-gui`,
  "GUI framework that uses the web browser as a display",
);

/**
 * Type-threaded list
 */
export const thrist = mkPackage(
  nixRaw`pkgs.haskellPackages.thrist`,
  "Type-threaded list",
);

/**
 * None
 */
export const throttle = mkPackage(
  nixRaw`pkgs.haskellPackages.throttle`,
  "None",
);

/**
 * Concurrent processing of a Foldable, throttled by CPU count
 */
export const throttled = mkPackage(
  nixRaw`pkgs.haskellPackages.throttled`,
  "Concurrent processing of a Foldable, throttled by CPU count",
);

/**
 * Image thumbnail creation
 */
export const thumbnail_polish = mkPackage(
  nixRaw`pkgs.haskellPackages.thumbnail-polish`,
  "Image thumbnail creation",
);

/**
 * A faster time library
 */
export const thyme = mkPackage(
  nixRaw`pkgs.haskellPackages.thyme`,
  "A faster time library",
);

/**
 * Parse and display tibetan numerals
 */
export const tibetan_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.tibetan-utils`,
  "Parse and display tibetan numerals",
);

/**
 * Useful if reading "Why FP matters" by John Hughes
 */
export const tic_tac_toe = mkPackage(
  nixRaw`pkgs.haskellPackages.tic-tac-toe`,
  "Useful if reading \"Why FP matters\" by John Hughes",
);

/**
 * A concurrent utility inspired by Ticker in golang
 */
export const ticker = mkPackage(
  nixRaw`pkgs.haskellPackages.ticker`,
  "A concurrent utility inspired by Ticker in golang",
);

/**
 * A port of @Data.Binary@
 */
export const tickle = mkPackage(
  nixRaw`pkgs.haskellPackages.tickle`,
  "A port of @Data.Binary@",
);

/**
 * Pattern language for improvised music
 */
export const tidal = mkPackage(
  nixRaw`pkgs.haskellPackages.tidal`,
  "Pattern language for improvised music",
);

/**
 * Ableton Link integration for Tidal
 */
export const tidal_link = mkPackage(
  nixRaw`pkgs.haskellPackages.tidal-link`,
  "Ableton Link integration for Tidal",
);

/**
 * Serial support for tidal
 */
export const tidal_serial = mkPackage(
  nixRaw`pkgs.haskellPackages.tidal-serial`,
  "Serial support for tidal",
);

/**
 * Tightly binding infix function application
 */
export const tight_apply = mkPackage(
  nixRaw`pkgs.haskellPackages.tight-apply`,
  "Tightly binding infix function application",
);

/**
 * Tiny and Incrementally-Growing HTTP library
 */
export const tighttp = mkPackage(
  nixRaw`pkgs.haskellPackages.tighttp`,
  "Tiny and Incrementally-Growing HTTP library",
);

/**
 * Slippy map tile functionality
 */
export const tile = mkPackage(
  nixRaw`pkgs.haskellPackages.tile`,
  "Slippy map tile functionality",
);

/**
 * substitution tilings
 */
export const tilings = mkPackage(
  nixRaw`pkgs.haskellPackages.tilings`,
  "substitution tilings",
);

/**
 * The Timber Compiler
 */
export const timberc = mkPackage(
  nixRaw`pkgs.haskellPackages.timberc`,
  "The Timber Compiler",
);

/**
 * A time library
 */
export const time_1_12_2 = mkPackage(
  nixRaw`pkgs.haskellPackages.time_1_12_2`,
  "A time library",
);

/**
 * Cache current time and formatted time text
 */
export const time_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.time-cache`,
  "Cache current time and formatted time text",
);

/**
 * Compatibility package for time
 */
export const time_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.time-compat`,
  "Compatibility package for time",
);

/**
 * A library for time domains and durations
 */
export const time_domain = mkPackage(
  nixRaw`pkgs.haskellPackages.time-domain`,
  "A library for time domains and durations",
);

/**
 * Yet another time library
 */
export const time_exts = mkPackage(
  nixRaw`pkgs.haskellPackages.time-exts`,
  "Yet another time library",
);

/**
 * Parse and format HTTP/1.1 Date and Time strings
 */
export const time_http = mkPackage(
  nixRaw`pkgs.haskellPackages.time-http`,
  "Parse and format HTTP/1.1 Date and Time strings",
);

/**
 * Use a time unit class, but hold a concrete time type
 */
export const time_interval = mkPackage(
  nixRaw`pkgs.haskellPackages.time-interval`,
  "Use a time unit class, but hold a concrete time type",
);

/**
 * IO Access for time
 */
export const time_io_access = mkPackage(
  nixRaw`pkgs.haskellPackages.time-io-access`,
  "IO Access for time",
);

/**
 * Lens-based interface to Data.Time data structures
 */
export const time_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.time-lens`,
  "Lens-based interface to Data.Time data structures",
);

/**
 * Compatibile module for time-format locale
 */
export const time_locale_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.time-locale-compat`,
  "Compatibile module for time-format locale",
);

/**
 * Vietnamese locale for date and time format
 */
export const time_locale_vietnamese = mkPackage(
  nixRaw`pkgs.haskellPackages.time-locale-vietnamese`,
  "Vietnamese locale for date and time format",
);

/**
 * Scalable timer
 */
export const time_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.time-manager`,
  "Scalable timer",
);

/**
 * Timers, timeouts, alarms, monadic wrappers
 */
export const time_out = mkPackage(
  nixRaw`pkgs.haskellPackages.time-out`,
  "Timers, timeouts, alarms, monadic wrappers",
);

/**
 * Parsers for types in `time`
 */
export const time_parsers = mkPackage(
  nixRaw`pkgs.haskellPackages.time-parsers`,
  "Parsers for types in `time`",
);

/**
 * Patterns for recurring events
 */
export const time_patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.time-patterns`,
  "Patterns for recurring events",
);

/**
 * A basic library for defining units of time as types
 */
export const time_units = mkPackage(
  nixRaw`pkgs.haskellPackages.time-units`,
  "A basic library for defining units of time as types",
);

/**
 * Type-level representations of time durations
 */
export const time_units_types = mkPackage(
  nixRaw`pkgs.haskellPackages.time-units-types`,
  "Type-level representations of time durations",
);

/**
 * Distributed systems execution emulation
 */
export const time_warp = mkPackage(
  nixRaw`pkgs.haskellPackages.time-warp`,
  "Distributed systems execution emulation",
);

/**
 * time each line of terminal output
 */
export const timeconsole = mkPackage(
  nixRaw`pkgs.haskellPackages.timeconsole`,
  "time each line of terminal output",
);

/**
 * Time monadic computations with an IO base
 */
export const timeit = mkPackage(
  nixRaw`pkgs.haskellPackages.timeit`,
  "Time monadic computations with an IO base",
);

/**
 * Lenses for the time package
 */
export const timelens = mkPackage(
  nixRaw`pkgs.haskellPackages.timelens`,
  "Lenses for the time package",
);

/**
 * An Arrow based Functional Reactive Programming library
 */
export const timeless = mkPackage(
  nixRaw`pkgs.haskellPackages.timeless`,
  "An Arrow based Functional Reactive Programming library",
);

/**
 * Initial project template from stack
 */
export const timeless_tutorials = mkPackage(
  nixRaw`pkgs.haskellPackages.timeless-tutorials`,
  "Initial project template from stack",
);

/**
 * Type classes for types representing time
 */
export const timelike = mkPackage(
  nixRaw`pkgs.haskellPackages.timelike`,
  "Type classes for types representing time",
);

/**
 * Timelike interface for the clock library
 */
export const timelike_clock = mkPackage(
  nixRaw`pkgs.haskellPackages.timelike-clock`,
  "Timelike interface for the clock library",
);

/**
 * Timelike interface for the time library
 */
export const timelike_time = mkPackage(
  nixRaw`pkgs.haskellPackages.timelike-time`,
  "Timelike interface for the time library",
);

/**
 * Data type representing a piecewise-constant function over time
 */
export const timeline = mkPackage(
  nixRaw`pkgs.haskellPackages.timeline`,
  "Data type representing a piecewise-constant function over time",
);

/**
 * Updatable timeouts as a Monad transformer
 */
export const timeout_control = mkPackage(
  nixRaw`pkgs.haskellPackages.timeout-control`,
  "Updatable timeouts as a Monad transformer",
);

/**
 * Prints timestamps after each line evaluated
 */
export const timeprint = mkPackage(
  nixRaw`pkgs.haskellPackages.timeprint`,
  "Prints timestamps after each line evaluated",
);

/**
 * A timer wheel
 */
export const timer_wheel = mkPackage(
  nixRaw`pkgs.haskellPackages.timer-wheel`,
  "A timer wheel",
);

/**
 * Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)
 */
export const timerep = mkPackage(
  nixRaw`pkgs.haskellPackages.timerep`,
  "Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)",
);

/**
 * Simple package that implements timers
 */
export const timers = mkPackage(
  nixRaw`pkgs.haskellPackages.timers`,
  "Simple package that implements timers",
);

/**
 * tick based timers
 */
export const timers_tick = mkPackage(
  nixRaw`pkgs.haskellPackages.timers-tick`,
  "tick based timers",
);

/**
 * timers which are updatable in the remaining time
 */
export const timers_updatable = mkPackage(
  nixRaw`pkgs.haskellPackages.timers-updatable`,
  "timers which are updatable in the remaining time",
);

/**
 * Useful timespan datatype and functions
 */
export const timespan = mkPackage(
  nixRaw`pkgs.haskellPackages.timespan`,
  "Useful timespan datatype and functions",
);

/**
 * Space-efficient Unix timestamp and utilities
 */
export const timestamp = mkPackage(
  nixRaw`pkgs.haskellPackages.timestamp`,
  "Space-efficient Unix timestamp and utilities",
);

/**
 * Run a command and timestamp its stdout/stderr lines
 */
export const timestamp_subprocess_lines = mkPackage(
  nixRaw`pkgs.haskellPackages.timestamp-subprocess-lines`,
  "Run a command and timestamp its stdout/stderr lines",
);

/**
 * Read standard input and prepend each line with a timestamp
 */
export const timestamper = mkPackage(
  nixRaw`pkgs.haskellPackages.timestamper`,
  "Read standard input and prepend each line with a timestamp",
);

/**
 * A library for profiling time in Haskell applications
 */
export const timestats = mkPackage(
  nixRaw`pkgs.haskellPackages.timestats`,
  "A library for profiling time in Haskell applications",
);

/**
 * A pure Haskell parser and renderer for binary Olson timezone files
 */
export const timezone_olson = mkPackage(
  nixRaw`pkgs.haskellPackages.timezone-olson`,
  "A pure Haskell parser and renderer for binary Olson timezone files",
);

/**
 * Load TimeZoneSeries from an Olson file at compile time
 */
export const timezone_olson_th = mkPackage(
  nixRaw`pkgs.haskellPackages.timezone-olson-th`,
  "Load TimeZoneSeries from an Olson file at compile time",
);

/**
 * Enhanced timezone handling for Data.Time
 */
export const timezone_series = mkPackage(
  nixRaw`pkgs.haskellPackages.timezone-series`,
  "Enhanced timezone handling for Data.Time",
);

export const timezone_unix = mkPackage(
  nixRaw`pkgs.haskellPackages.timezone-unix`,
  "",
);

/**
 * Convenient functions for getting times
 */
export const timing_convenience = mkPackage(
  nixRaw`pkgs.haskellPackages.timing-convenience`,
  "Convenient functions for getting times",
);

/**
 * Tiny INI file and configuration library with a minimal dependency footprint
 */
export const tini = mkPackage(
  nixRaw`pkgs.haskellPackages.tini`,
  "Tiny INI file and configuration library with a minimal dependency footprint",
);

/**
 * gRPC based SDK for Tinkoff Invest API V2
 */
export const tinkoff_invest_sdk = mkPackage(
  nixRaw`pkgs.haskellPackages.tinkoff-invest-sdk`,
  "gRPC based SDK for Tinkoff Invest API V2",
);

/**
 * A softer alternative to Haddock
 */
export const tintin = mkPackage(
  nixRaw`pkgs.haskellPackages.tintin`,
  "A softer alternative to Haddock",
);

/**
 * TinyMesh - communicating with auto-meshing sensor network
 */
export const tinyMesh = mkPackage(
  nixRaw`pkgs.haskellPackages.tinyMesh`,
  "TinyMesh - communicating with auto-meshing sensor network",
);

/**
 * Wrapper around the 'tiny file dialogs' C library
 */
export const tinyfiledialogs = mkPackage(
  nixRaw`pkgs.haskellPackages.tinyfiledialogs`,
  "Wrapper around the 'tiny file dialogs' C library",
);

/**
 * tinytools is a mono-space unicode diagram editor
 */
export const tinytools = mkPackage(
  nixRaw`pkgs.haskellPackages.tinytools`,
  "tinytools is a mono-space unicode diagram editor",
);

/**
 * tinytools-vty is a terminal based monospace unicode diagram editing tool
 */
export const tinytools_vty = mkPackage(
  nixRaw`pkgs.haskellPackages.tinytools-vty`,
  "tinytools-vty is a terminal based monospace unicode diagram editing tool",
);

/**
 * Convert from Haskell to Tip
 */
export const tip_haskell_frontend = mkPackage(
  nixRaw`pkgs.haskellPackages.tip-haskell-frontend`,
  "Convert from Haskell to Tip",
);

/**
 * tons of inductive problems - support library and tools
 */
export const tip_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.tip-lib`,
  "tons of inductive problems - support library and tools",
);

/**
 * Testing Infrastructure for Temporal AbstractioNs - GUI to debug temporal programs
 */
export const titan = mkPackage(
  nixRaw`pkgs.haskellPackages.titan`,
  "Testing Infrastructure for Temporal AbstractioNs - GUI to debug temporal programs",
);

/**
 * Convert English Words to Title Case
 */
export const titlecase = mkPackage(
  nixRaw`pkgs.haskellPackages.titlecase`,
  "Convert English Words to Title Case",
);

/**
 * This project separates subdomains, domains, and top-level-domains from URLs
 */
export const tld = mkPackage(
  nixRaw`pkgs.haskellPackages.tld`,
  "This project separates subdomains, domains, and top-level-domains from URLs",
);

/**
 * Haskell tldr client
 */
export const tldr = mkPackage(
  nixRaw`pkgs.haskellPackages.tldr`,
  "Haskell tldr client",
);

/**
 * A lexer generator
 */
export const tlex = mkPackage(
  nixRaw`pkgs.haskellPackages.tlex`,
  "A lexer generator",
);

/**
 * A lexer generator
 */
export const tlex_core = mkPackage(
  nixRaw`pkgs.haskellPackages.tlex-core`,
  "A lexer generator",
);

/**
 * Debug utilities for Tlex
 */
export const tlex_debug = mkPackage(
  nixRaw`pkgs.haskellPackages.tlex-debug`,
  "Debug utilities for Tlex",
);

/**
 * Encoding plugin for Tlex
 */
export const tlex_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.tlex-encoding`,
  "Encoding plugin for Tlex",
);

/**
 * TemplateHaskell plugin for Tlex
 */
export const tlex_th = mkPackage(
  nixRaw`pkgs.haskellPackages.tlex-th`,
  "TemplateHaskell plugin for Tlex",
);

/**
 * TLS/SSL protocol native implementation (Server and Client)
 */
export const tls = mkPackage(
  nixRaw`pkgs.haskellPackages.tls`,
  "TLS/SSL protocol native implementation (Server and Client)",
);

/**
 * TLS/SSL protocol native implementation (Server and Client)
 */
export const tls_1_9_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.tls_1_9_0`,
  "TLS/SSL protocol native implementation (Server and Client)",
);

/**
 * TLS extra default values and helpers
 */
export const tls_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.tls-extra`,
  "TLS extra default values and helpers",
);

/**
 * In-memory TLS session manager
 */
export const tls_session_manager = mkPackage(
  nixRaw`pkgs.haskellPackages.tls-session-manager`,
  "In-memory TLS session manager",
);

/**
 * Handle phylogenetic trees
 */
export const tlynx = mkPackage(
  nixRaw`pkgs.haskellPackages.tlynx`,
  "Handle phylogenetic trees",
);

/**
 * An insert-ordered multimap (indexed FIFO) which consumes values as you lookup
 */
export const tmapchan = mkPackage(
  nixRaw`pkgs.haskellPackages.tmapchan`,
  "An insert-ordered multimap (indexed FIFO) which consumes values as you lookup",
);

/**
 * A single-entity stateful Map in STM, similar to tmapchan
 */
export const tmapmvar = mkPackage(
  nixRaw`pkgs.haskellPackages.tmapmvar`,
  "A single-entity stateful Map in STM, similar to tmapchan",
);

/**
 * Start and stop a temporary postgres
 */
export const tmp_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-postgres`,
  "Start and stop a temporary postgres",
);

/**
 * Run 'tmp' processes in integration tests
 */
export const tmp_proc = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc`,
  "Run 'tmp' processes in integration tests",
);

/**
 * Run 'tmp' processes in integration tests
 */
export const tmp_proc_0_5_3_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc_0_5_3_0`,
  "Run 'tmp' processes in integration tests",
);

/**
 * Shows how to run a PostgreSQL database as a tmp proc
 */
export const tmp_proc_postgres = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-postgres`,
  "Shows how to run a PostgreSQL database as a tmp proc",
);

/**
 * Launch a PostgreSQL database in docker using tmp-proc
 */
export const tmp_proc_postgres_0_5_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-postgres_0_5_3_1`,
  "Launch a PostgreSQL database in docker using tmp-proc",
);

/**
 * Shows how to run RabbitMQ as a tmp proc
 */
export const tmp_proc_rabbitmq = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-rabbitmq`,
  "Shows how to run RabbitMQ as a tmp proc",
);

/**
 * Launch RabbitMQ in docker using tmp-proc
 */
export const tmp_proc_rabbitmq_0_5_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-rabbitmq_0_5_3_1`,
  "Launch RabbitMQ in docker using tmp-proc",
);

/**
 * Shows how to run redis as a tmp proc
 */
export const tmp_proc_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-redis`,
  "Shows how to run redis as a tmp proc",
);

/**
 * Launch Redis in docker using tmp-proc
 */
export const tmp_proc_redis_0_5_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.tmp-proc-redis_0_5_3_1`,
  "Launch Redis in docker using tmp-proc",
);

/**
 * simple executable for templating
 */
export const tmpl = mkPackage(
  nixRaw`pkgs.haskellPackages.tmpl`,
  "simple executable for templating",
);

/**
 * A simple daily journal program
 */
export const tn = mkPackage(
  nixRaw`pkgs.haskellPackages.tn`,
  "A simple daily journal program",
);

/**
 * Library for encoding/decoding TNET strings for PGI
 */
export const tnet = mkPackage(
  nixRaw`pkgs.haskellPackages.tnet`,
  "Library for encoding/decoding TNET strings for PGI",
);

/**
 * Simple, safe, boring type conversions
 */
export const to = mkPackage(
  nixRaw`pkgs.haskellPackages.to`,
  "Simple, safe, boring type conversions",
);

/**
 * Instances for the ToString class
 */
export const to_string_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.to-string-instances`,
  "Instances for the ToString class",
);

/**
 * Twitter bot generator
 */
export const toboggan = mkPackage(
  nixRaw`pkgs.haskellPackages.toboggan`,
  "Twitter bot generator",
);

/**
 * A replacement for undefined that gives warnings
 */
export const todo = mkPackage(
  nixRaw`pkgs.haskellPackages.todo`,
  "A replacement for undefined that gives warnings",
);

/**
 * Easy-to-use TODOs manager
 */
export const todos = mkPackage(
  nixRaw`pkgs.haskellPackages.todos`,
  "Easy-to-use TODOs manager",
);

/**
 * Rate limiter using lazy bucket algorithm
 */
export const token_bucket = mkPackage(
  nixRaw`pkgs.haskellPackages.token-bucket`,
  "Rate limiter using lazy bucket algorithm",
);

/**
 * A thread-safe concurrent token-bucket rate limiter that guarantees fairness
 */
export const token_limiter_concurrent = mkPackage(
  nixRaw`pkgs.haskellPackages.token-limiter-concurrent`,
  "A thread-safe concurrent token-bucket rate limiter that guarantees fairness",
);

/**
 * Simple tokenizer for English text
 */
export const tokenize = mkPackage(
  nixRaw`pkgs.haskellPackages.tokenize`,
  "Simple tokenizer for English text",
);

/**
 * An efficient and easy-to-use tokenizer monad
 */
export const tokenizer_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.tokenizer-monad`,
  "An efficient and easy-to-use tokenizer monad",
);

/**
 * TokTok C code style checker
 */
export const tokstyle = mkPackage(
  nixRaw`pkgs.haskellPackages.tokstyle`,
  "TokTok C code style checker",
);

export const toktok = mkPackage(
  nixRaw`pkgs.haskellPackages.toktok`,
  "",
);

/**
 * Easy to use library for audio programming
 */
export const tomato_rubato_openal = mkPackage(
  nixRaw`pkgs.haskellPackages.tomato-rubato-openal`,
  "Easy to use library for audio programming",
);

/**
 * TOML 1.0.0 parser
 */
export const toml_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.toml-parser`,
  "TOML 1.0.0 parser",
);

/**
 * TOML format parser compliant with v1.0.0.
 */
export const toml_reader = mkPackage(
  nixRaw`pkgs.haskellPackages.toml-reader`,
  "TOML format parser compliant with v1.0.0.",
);

/**
 * Alternative parser for TOML values produced by the toml-reader package
 */
export const toml_reader_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.toml-reader-parse`,
  "Alternative parser for TOML values produced by the toml-reader package",
);

/**
 * Bidirectional TOML serialization
 */
export const tomland = mkPackage(
  nixRaw`pkgs.haskellPackages.tomland`,
  "Bidirectional TOML serialization",
);

/**
 * Command-line tool to check syntax of TOML files
 */
export const tomlcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.tomlcheck`,
  "Command-line tool to check syntax of TOML files",
);

/**
 * meta application framework
 */
export const tonatona = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona`,
  "meta application framework",
);

/**
 * tonatona plugin for google-server-api
 */
export const tonatona_google_server_api = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona-google-server-api`,
  "tonatona plugin for google-server-api",
);

/**
 * tonatona plugin for logging
 */
export const tonatona_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona-logger`,
  "tonatona plugin for logging",
);

/**
 * tonatona plugin for accessing PostgreSQL database
 */
export const tonatona_persistent_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona-persistent-postgresql`,
  "tonatona plugin for accessing PostgreSQL database",
);

/**
 * tonatona plugin for accessing Sqlite database
 */
export const tonatona_persistent_sqlite = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona-persistent-sqlite`,
  "tonatona plugin for accessing Sqlite database",
);

/**
 * tonatona plugin for servant
 */
export const tonatona_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.tonatona-servant`,
  "tonatona plugin for servant",
);

/**
 * Cluster single cells and analyze cell clade relationships
 */
export const too_many_cells = mkPackage(
  nixRaw`pkgs.haskellPackages.too-many-cells`,
  "Cluster single cells and analyze cell clade relationships",
);

/**
 * Ill-defined library
 */
export const toolshed = mkPackage(
  nixRaw`pkgs.haskellPackages.toolshed`,
  "Ill-defined library",
);

/**
 * Top (typed oriented protocol) API
 */
export const top = mkPackage(
  nixRaw`pkgs.haskellPackages.top`,
  "Top (typed oriented protocol) API",
);

/**
 * Extensible records library
 */
export const topaz = mkPackage(
  nixRaw`pkgs.haskellPackages.topaz`,
  "Extensible records library",
);

/**
 * Template-to-Haskell preprocessor, and templating language
 */
export const tophat = mkPackage(
  nixRaw`pkgs.haskellPackages.tophat`,
  "Template-to-Haskell preprocessor, and templating language",
);

/**
 * Directed acyclic graphs
 */
export const topograph = mkPackage(
  nixRaw`pkgs.haskellPackages.topograph`,
  "Directed acyclic graphs",
);

/**
 * BitTorrent file parser and generater
 */
export const torrent = mkPackage(
  nixRaw`pkgs.haskellPackages.torrent`,
  "BitTorrent file parser and generater",
);

/**
 * Torsor Typeclass
 */
export const torsor = mkPackage(
  nixRaw`pkgs.haskellPackages.torsor`,
  "Torsor Typeclass",
);

/**
 * The ToString class
 */
export const tostring = mkPackage(
  nixRaw`pkgs.haskellPackages.tostring`,
  "The ToString class",
);

/**
 * Exhaustive pattern matching using lenses, traversals, and prisms
 */
export const total = mkPackage(
  nixRaw`pkgs.haskellPackages.total`,
  "Exhaustive pattern matching using lenses, traversals, and prisms",
);

/**
 * Alternative interface for total versions of partial function on the Prelude
 */
export const total_alternative = mkPackage(
  nixRaw`pkgs.haskellPackages.total-alternative`,
  "Alternative interface for total versions of partial function on the Prelude",
);

/**
 * Finitely represented total maps
 */
export const total_map = mkPackage(
  nixRaw`pkgs.haskellPackages.total-map`,
  "Finitely represented total maps",
);

/**
 * A numeric tower
 */
export const tower = mkPackage(
  nixRaw`pkgs.haskellPackages.tower`,
  "A numeric tower",
);

/**
 * A Tox protocol implementation in Haskell
 */
export const toxcore = mkPackage(
  nixRaw`pkgs.haskellPackages.toxcore`,
  "A Tox protocol implementation in Haskell",
);

/**
 * Haskell bindings to the C reference implementation of Tox
 */
export const toxcore_c = mkPackage(
  nixRaw`pkgs.haskellPackages.toxcore-c`,
  "Haskell bindings to the C reference implementation of Tox",
);

/**
 * Assorted decision procedures for SAT, SMT, Max-SAT, PB, MIP, etc
 */
export const toysolver = mkPackage(
  nixRaw`pkgs.haskellPackages.toysolver`,
  "Assorted decision procedures for SAT, SMT, Max-SAT, PB, MIP, etc",
);

/**
 * simple, parallel job scheduling
 */
export const tpar = mkPackage(
  nixRaw`pkgs.haskellPackages.tpar`,
  "simple, parallel job scheduling",
);

/**
 * Applications for interacting with the Pushbullet API
 */
export const tpb = mkPackage(
  nixRaw`pkgs.haskellPackages.tpb`,
  "Applications for interacting with the Pushbullet API",
);

/**
 * Data Type for Rewriting Systems
 */
export const tpdb = mkPackage(
  nixRaw`pkgs.haskellPackages.tpdb`,
  "Data Type for Rewriting Systems",
);

/**
 * Tracing utilities for Functor/Applicative/Monad types
 */
export const tracer = mkPackage(
  nixRaw`pkgs.haskellPackages.tracer`,
  "Tracing utilities for Functor/Applicative/Monad types",
);

/**
 * Distributed tracing
 */
export const tracing = mkPackage(
  nixRaw`pkgs.haskellPackages.tracing`,
  "Distributed tracing",
);

/**
 * Distributed tracing
 */
export const tracing_control = mkPackage(
  nixRaw`pkgs.haskellPackages.tracing-control`,
  "Distributed tracing",
);

export const trade_journal = mkPackage(
  nixRaw`pkgs.haskellPackages.trade-journal`,
  "",
);

/**
 * Tools and a library for working with Trajectory
 */
export const trajectory = mkPackage(
  nixRaw`pkgs.haskellPackages.trajectory`,
  "Tools and a library for working with Trajectory",
);

/**
 * Monadic effect framework
 */
export const trans_fx_data = mkPackage(
  nixRaw`pkgs.haskellPackages.trans-fx-data`,
  "Monadic effect framework",
);

/**
 * Monadic effect framework
 */
export const trans_fx_io = mkPackage(
  nixRaw`pkgs.haskellPackages.trans-fx-io`,
  "Monadic effect framework",
);

/**
 * Monadic representation of transactions
 */
export const transaction = mkPackage(
  nixRaw`pkgs.haskellPackages.transaction`,
  "Monadic representation of transactions",
);

/**
 * ODBC database transfer
 */
export const transfer_db = mkPackage(
  nixRaw`pkgs.haskellPackages.transfer-db`,
  "ODBC database transfer",
);

/**
 * Generic representation of tree transformations
 */
export const transformations = mkPackage(
  nixRaw`pkgs.haskellPackages.transformations`,
  "Generic representation of tree transformations",
);

/**
 * Concrete functor and monad transformers
 */
export const transformers_0_6_1_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers_0_6_1_1`,
  "Concrete functor and monad transformers",
);

/**
 * Error and short-circuit monad transformers
 */
export const transformers_abort = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-abort`,
  "Error and short-circuit monad transformers",
);

/**
 * Lift computations from the bottom of a transformer stack
 */
export const transformers_base = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-base`,
  "Lift computations from the bottom of a transformer stack",
);

/**
 * A small compatibility shim for the transformers library
 */
export const transformers_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-compat`,
  "A small compatibility shim for the transformers library",
);

/**
 * Control flow data type and monad transformer
 */
export const transformers_continue = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-continue`,
  "Control flow data type and monad transformer",
);

/**
 * Sensible conversions between some of the monad transformers
 */
export const transformers_convert = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-convert`,
  "Sensible conversions between some of the monad transformers",
);

/**
 * An Either monad transformer
 */
export const transformers_either = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-either`,
  "An Either monad transformer",
);

/**
 * An Except monad transformer with
 */
export const transformers_except = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-except`,
  "An Except monad transformer with",
);

/**
 * Monad transformer for evaluating to a fixpoint
 */
export const transformers_fix = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-fix`,
  "Monad transformer for evaluating to a fixpoint",
);

/**
 * Free monad transformers
 */
export const transformers_free = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-free`,
  "Free monad transformers",
);

/**
 * Supply applicative, monad, applicative transformer and monad transformer
 */
export const transformers_supply = mkPackage(
  nixRaw`pkgs.haskellPackages.transformers-supply`,
  "Supply applicative, monad, applicative transformer and monad transformer",
);

/**
 * fully composable remote execution for the creation of distributed systems
 */
export const transient_universe = mkPackage(
  nixRaw`pkgs.haskellPackages.transient-universe`,
  "fully composable remote execution for the creation of distributed systems",
);

/**
 * transient with secure communications
 */
export const transient_universe_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.transient-universe-tls`,
  "transient with secure communications",
);

/**
 * Translation cli tool
 */
export const translate_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.translate-cli`,
  "Translation cli tool",
);

/**
 * Type Safe Web Routing
 */
export const trasa = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa`,
  "Type Safe Web Routing",
);

/**
 * Type safe http requests
 */
export const trasa_client = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-client`,
  "Type safe http requests",
);

/**
 * Extra functions for trasa
 */
export const trasa_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-extra`,
  "Extra functions for trasa",
);

/**
 * generate forms using lucid, ditto and trasa
 */
export const trasa_form = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-form`,
  "generate forms using lucid, ditto and trasa",
);

/**
 * Reactive Type Safe Routing
 */
export const trasa_reflex = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-reflex`,
  "Reactive Type Safe Routing",
);

/**
 * Type safe web server
 */
export const trasa_server = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-server`,
  "Type safe web server",
);

/**
 * Template Haskell to generate trasa routes
 */
export const trasa_th = mkPackage(
  nixRaw`pkgs.haskellPackages.trasa-th`,
  "Template Haskell to generate trasa routes",
);

/**
 * See README for more info
 */
export const traversal_template = mkPackage(
  nixRaw`pkgs.haskellPackages.traversal-template`,
  "See README for more info",
);

/**
 * Generic applicative traversals
 */
export const traverse_with_class = mkPackage(
  nixRaw`pkgs.haskellPackages.traverse-with-class`,
  "Generic applicative traversals",
);

/**
 * A better travis_wait
 */
export const travis_pogodi = mkPackage(
  nixRaw`pkgs.haskellPackages.travis-pogodi`,
  "A better travis_wait",
);

/**
 * Diffing of (expression) trees
 */
export const tree_diff = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-diff`,
  "Diffing of (expression) trees",
);

/**
 * Library for functions pertaining to tree exploration and manipulation
 */
export const tree_fun = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-fun`,
  "Library for functions pertaining to tree exploration and manipulation",
);

/**
 * Unstable bindings for the tree-sitter parsing library
 */
export const tree_sitter = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter`,
  "Unstable bindings for the tree-sitter parsing library",
);

/**
 * Tree-sitter grammar/parser for C#
 */
export const tree_sitter_c_sharp = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-c-sharp`,
  "Tree-sitter grammar/parser for C#",
);

/**
 * Tree-sitter grammar/parser for Go
 */
export const tree_sitter_go = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-go`,
  "Tree-sitter grammar/parser for Go",
);

/**
 * Tree-sitter grammar/parser for Haskell (with GHC extensions)
 */
export const tree_sitter_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-haskell`,
  "Tree-sitter grammar/parser for Haskell (with GHC extensions)",
);

/**
 * Tree-sitter grammar/parser for Java
 */
export const tree_sitter_java = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-java`,
  "Tree-sitter grammar/parser for Java",
);

/**
 * Tree-sitter grammar/parser for JSON
 */
export const tree_sitter_json = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-json`,
  "Tree-sitter grammar/parser for JSON",
);

/**
 * Tree-sitter grammar/parser for OCaml
 */
export const tree_sitter_ocaml = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-ocaml`,
  "Tree-sitter grammar/parser for OCaml",
);

/**
 * Tree-sitter grammar/parser for PHP
 */
export const tree_sitter_php = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-php`,
  "Tree-sitter grammar/parser for PHP",
);

/**
 * Tree-sitter grammar/parser for Python
 */
export const tree_sitter_python = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-python`,
  "Tree-sitter grammar/parser for Python",
);

/**
 * Tree-sitter grammar/parser for QL
 */
export const tree_sitter_ql = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-ql`,
  "Tree-sitter grammar/parser for QL",
);

/**
 * Tree-sitter grammar/parser for Ruby
 */
export const tree_sitter_ruby = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-ruby`,
  "Tree-sitter grammar/parser for Ruby",
);

/**
 * Tree-sitter grammar/parser for Rust
 */
export const tree_sitter_rust = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-rust`,
  "Tree-sitter grammar/parser for Rust",
);

/**
 * Tree-sitter grammar/parser for TSX
 */
export const tree_sitter_tsx = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-tsx`,
  "Tree-sitter grammar/parser for TSX",
);

/**
 * Tree-sitter grammar/parser for TypeScript
 */
export const tree_sitter_typescript = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-sitter-typescript`,
  "Tree-sitter grammar/parser for TypeScript",
);

/**
 * Render trees as foldable HTML and Unicode art
 */
export const tree_view = mkPackage(
  nixRaw`pkgs.haskellPackages.tree-view`,
  "Render trees as foldable HTML and Unicode art",
);

/**
 * Provides folds which try to combine elements in a balanced way
 */
export const treefold = mkPackage(
  nixRaw`pkgs.haskellPackages.treefold`,
  "Provides folds which try to combine elements in a balanced way",
);

/**
 * Treemap related commands for producing foldable TreeMap HTML
 */
export const treemap_html_tools = mkPackage(
  nixRaw`pkgs.haskellPackages.treemap-html-tools`,
  "Treemap related commands for producing foldable TreeMap HTML",
);

/**
 * Structure Editing Combinators
 */
export const treersec = mkPackage(
  nixRaw`pkgs.haskellPackages.treersec`,
  "Structure Editing Combinators",
);

/**
 * Library for a multi-way tree (rose tree), using Seq (finger tree) for forests
 */
export const treeseq = mkPackage(
  nixRaw`pkgs.haskellPackages.treeseq`,
  "Library for a multi-way tree (rose tree), using Seq (finger tree) for forests",
);

/**
 * Visualization of computation decomposition trees
 */
export const treeviz = mkPackage(
  nixRaw`pkgs.haskellPackages.treeviz`,
  "Visualization of computation decomposition trees",
);

export const trek = mkPackage(
  nixRaw`pkgs.haskellPackages.trek`,
  "",
);

/**
 * A PostgreSQL Database Migrator
 */
export const trek_app = mkPackage(
  nixRaw`pkgs.haskellPackages.trek-app`,
  "A PostgreSQL Database Migrator",
);

/**
 * A PostgreSQL Database Migrator
 */
export const trek_db = mkPackage(
  nixRaw`pkgs.haskellPackages.trek-db`,
  "A PostgreSQL Database Migrator",
);

export const trek_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.trek-lens`,
  "",
);

/**
 * Trial Data Structure
 */
export const trial = mkPackage(
  nixRaw`pkgs.haskellPackages.trial`,
  "Trial Data Structure",
);

/**
 * Trial helper functions for optparse-applicative
 */
export const trial_optparse_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.trial-optparse-applicative`,
  "Trial helper functions for optparse-applicative",
);

/**
 * Trial helper functions for tomland
 */
export const trial_tomland = mkPackage(
  nixRaw`pkgs.haskellPackages.trial-tomland`,
  "Trial helper functions for tomland",
);

/**
 * triangulation of polygons
 */
export const triangulation = mkPackage(
  nixRaw`pkgs.haskellPackages.triangulation`,
  "triangulation of polygons",
);

/**
 * Simple Map-based Trie
 */
export const trie_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.trie-simple`,
  "Simple Map-based Trie",
);

/**
 * Various trie implementations in Haskell
 */
export const tries = mkPackage(
  nixRaw`pkgs.haskellPackages.tries`,
  "Various trie implementations in Haskell",
);

/**
 * A modern parser combinator library with convenient diagnostics
 */
export const trifecta = mkPackage(
  nixRaw`pkgs.haskellPackages.trifecta`,
  "A modern parser combinator library with convenient diagnostics",
);

/**
 * Trigger is a cross platform file system watcher for super fast build-and-restart workflows
 */
export const trigger = mkPackage(
  nixRaw`pkgs.haskellPackages.trigger`,
  "Trigger is a cross platform file system watcher for super fast build-and-restart workflows",
);

/**
 * A utility for neat multiline string trimming
 */
export const trimdent = mkPackage(
  nixRaw`pkgs.haskellPackages.trimdent`,
  "A utility for neat multiline string trimming",
);

/**
 * Search for, annotate and trim poly-A tail
 */
export const trimpolya = mkPackage(
  nixRaw`pkgs.haskellPackages.trimpolya`,
  "Search for, annotate and trim poly-A tail",
);

/**
 * TripleSec is a simple, triple-paranoid, symmetric encryption library
 */
export const triplesec = mkPackage(
  nixRaw`pkgs.haskellPackages.triplesec`,
  "TripleSec is a simple, triple-paranoid, symmetric encryption library",
);

/**
 * Constraints that any type, resp. no type fulfills
 */
export const trivial_constraint = mkPackage(
  nixRaw`pkgs.haskellPackages.trivial-constraint`,
  "Constraints that any type, resp. no type fulfills",
);

/**
 * Template Haskell hack to violate module abstractions
 */
export const true_name = mkPackage(
  nixRaw`pkgs.haskellPackages.true-name`,
  "Template Haskell hack to violate module abstractions",
);

/**
 * Audio file compressor-limiter
 */
export const truelevel = mkPackage(
  nixRaw`pkgs.haskellPackages.truelevel`,
  "Audio file compressor-limiter",
);

/**
 * Haskell template code generator
 */
export const trurl = mkPackage(
  nixRaw`pkgs.haskellPackages.trurl`,
  "Haskell template code generator",
);

/**
 * Typeclass for truthfulness of values
 */
export const truthful = mkPackage(
  nixRaw`pkgs.haskellPackages.truthful`,
  "Typeclass for truthfulness of values",
);

/**
 * Generalized booleans and truthy values
 */
export const truthy = mkPackage(
  nixRaw`pkgs.haskellPackages.truthy`,
  "Generalized booleans and truthy values",
);

/**
 * A Transaction Framework for Happstack
 */
export const tsession_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.tsession-happstack`,
  "A Transaction Framework for Happstack",
);

/**
 * Hides duplicating channels when broadcasting
 */
export const tsetchan = mkPackage(
  nixRaw`pkgs.haskellPackages.tsetchan`,
  "Hides duplicating channels when broadcasting",
);

/**
 * A Skip List Implementation in Software Transactional Memory (STM)
 */
export const tskiplist = mkPackage(
  nixRaw`pkgs.haskellPackages.tskiplist`,
  "A Skip List Implementation in Software Transactional Memory (STM)",
);

/**
 * Thread-safe logging, with additional interleaving fuzz-testing
 */
export const tslogger = mkPackage(
  nixRaw`pkgs.haskellPackages.tslogger`,
  "Thread-safe logging, with additional interleaving fuzz-testing",
);

/**
 * t-SNE
 */
export const tsne = mkPackage(
  nixRaw`pkgs.haskellPackages.tsne`,
  "t-SNE",
);

/**
 * BK-tree implementation
 */
export const tst = mkPackage(
  nixRaw`pkgs.haskellPackages.tst`,
  "BK-tree implementation",
);

/**
 * Convert tsv to csv
 */
export const tsv2csv = mkPackage(
  nixRaw`pkgs.haskellPackages.tsv2csv`,
  "Convert tsv to csv",
);

/**
 * An API binding Web.Spock to Database.Beam
 */
export const tsweb = mkPackage(
  nixRaw`pkgs.haskellPackages.tsweb`,
  "An API binding Web.Spock to Database.Beam",
);

/**
 * Textual Type Classes
 */
export const ttc = mkPackage(
  nixRaw`pkgs.haskellPackages.ttc`,
  "Textual Type Classes",
);

/**
 * Textual Type Classes
 */
export const ttc_1_3_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.ttc_1_3_0_0`,
  "Textual Type Classes",
);

/**
 * Things Tracker Network JSON Types
 */
export const ttn = mkPackage(
  nixRaw`pkgs.haskellPackages.ttn`,
  "Things Tracker Network JSON Types",
);

/**
 * Contention-free STM hash map
 */
export const ttrie = mkPackage(
  nixRaw`pkgs.haskellPackages.ttrie`,
  "Contention-free STM hash map",
);

/**
 * A simple tun/tap library
 */
export const tuntap_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.tuntap-simple`,
  "A simple tun/tap library",
);

/**
 * Homogeneous tuples
 */
export const tup_functor = mkPackage(
  nixRaw`pkgs.haskellPackages.tup-functor`,
  "Homogeneous tuples",
);

/**
 * Various functions on tuples
 */
export const tuple = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple`,
  "Various functions on tuples",
);

/**
 * A package to append, sequence and fold items and tuples into new tuples
 */
export const tuple_append = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-append`,
  "A package to append, sequence and fold items and tuples into new tuples",
);

/**
 * Access tuple fields using record dot syntax
 */
export const tuple_fields = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-fields`,
  "Access tuple fields using record dot syntax",
);

/**
 * Enum instances for tuples where the digits increase with the same speed
 */
export const tuple_gen = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-gen`,
  "Enum instances for tuples where the digits increase with the same speed",
);

/**
 * Generic operations on tuples
 */
export const tuple_generic = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-generic`,
  "Generic operations on tuples",
);

/**
 * Functions to convert between tuples and HLists
 */
export const tuple_hlist = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-hlist`,
  "Functions to convert between tuples and HLists",
);

/**
 * Morph between tuples, or convert them from and to HLists
 */
export const tuple_morph = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-morph`,
  "Morph between tuples, or convert them from and to HLists",
);

/**
 * various operations on n-ary tuples via GHC.Generics
 */
export const tuple_ops = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-ops`,
  "various operations on n-ary tuples via GHC.Generics",
);

/**
 * functions on n-ary tuples using generics-sop
 */
export const tuple_sop = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-sop`,
  "functions on n-ary tuples using generics-sop",
);

/**
 * Generate (non-recursive) utility functions for tuples of statically known size
 */
export const tuple_th = mkPackage(
  nixRaw`pkgs.haskellPackages.tuple-th`,
  "Generate (non-recursive) utility functions for tuples of statically known size",
);

/**
 * Small monomorphic tuples
 */
export const tuples = mkPackage(
  nixRaw`pkgs.haskellPackages.tuples`,
  "Small monomorphic tuples",
);

/**
 * Wrappers for n-ary tuples with Traversable and Applicative/Monad instances
 */
export const tuples_homogenous_h98 = mkPackage(
  nixRaw`pkgs.haskellPackages.tuples-homogenous-h98`,
  "Wrappers for n-ary tuples with Traversable and Applicative/Monad instances",
);

/**
 * A simple simulator for Turing machines
 */
export const turing = mkPackage(
  nixRaw`pkgs.haskellPackages.turing`,
  "A simple simulator for Turing machines",
);

/**
 * An implementation of Turing Machine and Automaton
 */
export const turingMachine = mkPackage(
  nixRaw`pkgs.haskellPackages.turingMachine`,
  "An implementation of Turing Machine and Automaton",
);

/**
 * Haskell port of Deniz Yuret's Turkish deasciifier
 */
export const turkish_deasciifier = mkPackage(
  nixRaw`pkgs.haskellPackages.turkish-deasciifier`,
  "Haskell port of Deniz Yuret's Turkish deasciifier",
);

/**
 * Manage multiple turned-based sessions
 */
export const turn_loop = mkPackage(
  nixRaw`pkgs.haskellPackages.turn-loop`,
  "Manage multiple turned-based sessions",
);

/**
 * shifts scheduling tool
 */
export const turni = mkPackage(
  nixRaw`pkgs.haskellPackages.turni`,
  "shifts scheduling tool",
);

/**
 * Shell programming, Haskell-style
 */
export const turtle = mkPackage(
  nixRaw`pkgs.haskellPackages.turtle`,
  "Shell programming, Haskell-style",
);

/**
 * Trailing Whitespace
 */
export const tw = mkPackage(
  nixRaw`pkgs.haskellPackages.tw`,
  "Trailing Whitespace",
);

/**
 * Tiny web application framework for WAI
 */
export const twain = mkPackage(
  nixRaw`pkgs.haskellPackages.twain`,
  "Tiny web application framework for WAI",
);

/**
 * An equational theorem prover
 */
export const twee = mkPackage(
  nixRaw`pkgs.haskellPackages.twee`,
  "An equational theorem prover",
);

/**
 * An equational theorem prover
 */
export const twee_lib = mkPackage(
  nixRaw`pkgs.haskellPackages.twee-lib`,
  "An equational theorem prover",
);

/**
 * Command-line tool for twitter
 */
export const tweet_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.tweet-hs`,
  "Command-line tool for twitter",
);

/**
 * Lab Assignments Environment at Univeriteit Twente
 */
export const twentefp = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp`,
  "Lab Assignments Environment at Univeriteit Twente",
);

/**
 * Used as Lab Assignments Environment at the University of Twente
 */
export const twentefp_eventloop_graphics = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-eventloop-graphics`,
  "Used as Lab Assignments Environment at the University of Twente",
);

/**
 * Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree
 */
export const twentefp_eventloop_trees = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-eventloop-trees`,
  "Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree",
);

/**
 * Lab Assignments Environment at Univeriteit Twente
 */
export const twentefp_graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-graphs`,
  "Lab Assignments Environment at Univeriteit Twente",
);

/**
 * Lab Assignments Environment at Univeriteit Twente
 */
export const twentefp_number = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-number`,
  "Lab Assignments Environment at Univeriteit Twente",
);

/**
 * RoseTree type and show functions for lab assignment of University of Twente
 */
export const twentefp_rosetree = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-rosetree`,
  "RoseTree type and show functions for lab assignment of University of Twente",
);

/**
 * Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree
 */
export const twentefp_trees = mkPackage(
  nixRaw`pkgs.haskellPackages.twentefp-trees`,
  "Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree",
);

/**
 * Rubik's cube solver
 */
export const twentyseven = mkPackage(
  nixRaw`pkgs.haskellPackages.twentyseven`,
  "Rubik's cube solver",
);

/**
 * They Work For You API Client Library
 */
export const twfy_api_client = mkPackage(
  nixRaw`pkgs.haskellPackages.twfy-api-client`,
  "They Work For You API Client Library",
);

/**
 * Unix Command-Line Twitter and Identica Client
 */
export const twidge = mkPackage(
  nixRaw`pkgs.haskellPackages.twidge`,
  "Unix Command-Line Twitter and Identica Client",
);

/**
 * STM library with safe irrevocable I/O and inconsistency repair
 */
export const twilight_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.twilight-stm`,
  "STM library with safe irrevocable I/O and inconsistency repair",
);

/**
 * Twilio API interaction
 */
export const twill = mkPackage(
  nixRaw`pkgs.haskellPackages.twill`,
  "Twilio API interaction",
);

/**
 * Simple 2D Game Engine
 */
export const twirl = mkPackage(
  nixRaw`pkgs.haskellPackages.twirl`,
  "Simple 2D Game Engine",
);

/**
 * Haskell twirp foundations
 */
export const twirp = mkPackage(
  nixRaw`pkgs.haskellPackages.twirp`,
  "Haskell twirp foundations",
);

/**
 * Twitter API package with conduit interface and Streaming API support
 */
export const twitter_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.twitter-conduit`,
  "Twitter API package with conduit interface and Streaming API support",
);

/**
 * Twitter API package with enumerator interface and Streaming API support
 */
export const twitter_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.twitter-enumerator`,
  "Twitter API package with enumerator interface and Streaming API support",
);

/**
 * Twitter JSON parser and types
 */
export const twitter_types = mkPackage(
  nixRaw`pkgs.haskellPackages.twitter-types`,
  "Twitter JSON parser and types",
);

/**
 * Twitter JSON types (lens powered)
 */
export const twitter_types_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.twitter-types-lens`,
  "Twitter JSON types (lens powered)",
);

/**
 * Text
 */
export const txt = mkPackage(
  nixRaw`pkgs.haskellPackages.txt`,
  "Text",
);

/**
 * Filter to convert plain text files to RTF
 */
export const txt2rtf = mkPackage(
  nixRaw`pkgs.haskellPackages.txt2rtf`,
  "Filter to convert plain text files to RTF",
);

/**
 * The SQL link in your *NIX chain
 */
export const txt_sushi = mkPackage(
  nixRaw`pkgs.haskellPackages.txt-sushi`,
  "The SQL link in your *NIX chain",
);

/**
 * Typed type representations and equality proofs
 */
export const ty = mkPackage(
  nixRaw`pkgs.haskellPackages.ty`,
  "Typed type representations and equality proofs",
);

/**
 * Various type-aligned sequence data structures
 */
export const type_aligned = mkPackage(
  nixRaw`pkgs.haskellPackages.type-aligned`,
  "Various type-aligned sequence data structures",
);

/**
 * Runtime type assertions for testing
 */
export const type_assertions = mkPackage(
  nixRaw`pkgs.haskellPackages.type-assertions`,
  "Runtime type assertions for testing",
);

/**
 * Type-level booleans via type-families
 */
export const type_booleans = mkPackage(
  nixRaw`pkgs.haskellPackages.type-booleans`,
  "Type-level booleans via type-families",
);

/**
 * Utilities for caching type families results. Sometimes complex type families take long time to compile, so it is proficient to cache them and use the final result without the need of re-computation.
 */
export const type_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.type-cache`,
  "Utilities for caching type families results. Sometimes complex type families take long time to compile, so it is proficient to cache them and use the final result without the need of re-computation.",
);

/**
 * Type-level serialization of type constructors
 */
export const type_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.type-cereal`,
  "Type-level serialization of type constructors",
);

/**
 * Quasiquoters for the 'type-combinators' package
 */
export const type_combinators_quote = mkPackage(
  nixRaw`pkgs.haskellPackages.type-combinators-quote`,
  "Quasiquoters for the 'type-combinators' package",
);

/**
 * Interop between /type-combinators/ and /singletons/
 */
export const type_combinators_singletons = mkPackage(
  nixRaw`pkgs.haskellPackages.type-combinators-singletons`,
  "Interop between /type-combinators/ and /singletons/",
);

/**
 * Arbitrary-base type-level digits
 */
export const type_digits = mkPackage(
  nixRaw`pkgs.haskellPackages.type-digits`,
  "Arbitrary-base type-level digits",
);

/**
 * Data.Type.Equality compat package
 */
export const type_equality = mkPackage(
  nixRaw`pkgs.haskellPackages.type-equality`,
  "Data.Type.Equality compat package",
);

/**
 * Type equality check
 */
export const type_equality_check = mkPackage(
  nixRaw`pkgs.haskellPackages.type-equality-check`,
  "Type equality check",
);

/**
 * Tools for writing better type errors
 */
export const type_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.type-errors`,
  "Tools for writing better type errors",
);

/**
 * Collection of widely reimplemented type families
 */
export const type_fun = mkPackage(
  nixRaw`pkgs.haskellPackages.type-fun`,
  "Collection of widely reimplemented type families",
);

/**
 * Emulation of type-level functions
 */
export const type_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.type-functions`,
  "Emulation of type-level functions",
);

/**
 * Guide type inference with proxy values
 */
export const type_hint = mkPackage(
  nixRaw`pkgs.haskellPackages.type-hint`,
  "Guide type inference with proxy values",
);

/**
 * Typeclasses for injective relations and isomorphisms between types
 */
export const type_iso = mkPackage(
  nixRaw`pkgs.haskellPackages.type-iso`,
  "Typeclasses for injective relations and isomorphisms between types",
);

/**
 * Type-level programming library
 */
export const type_level = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level`,
  "Type-level programming library",
);

/**
 * Provides integers lifted to the type level
 */
export const type_level_integers = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-integers`,
  "Provides integers lifted to the type level",
);

/**
 * Type level Key-Value list
 */
export const type_level_kv_list = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-kv-list`,
  "Type level Key-Value list",
);

/**
 * Make Esqueleto handy with type-level-kv-list
 */
export const type_level_kv_list_esqueleto = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-kv-list-esqueleto`,
  "Make Esqueleto handy with type-level-kv-list",
);

/**
 * Make Persistent Raw SQL handy with type-level-kv-list
 */
export const type_level_kv_list_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-kv-list-persistent`,
  "Make Persistent Raw SQL handy with type-level-kv-list",
);

/**
 * Simple type level natural numbers
 */
export const type_level_natural_number = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-natural-number`,
  "Simple type level natural numbers",
);

/**
 * Type level numbers implemented using type families
 */
export const type_level_numbers = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-numbers`,
  "Type level numbers implemented using type families",
);

/**
 * Type-level programming library (type families)
 */
export const type_level_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.type-level-tf`,
  "Type-level programming library (type families)",
);

/**
 * Type-indexed maps
 */
export const type_map = mkPackage(
  nixRaw`pkgs.haskellPackages.type-map`,
  "Type-indexed maps",
);

/**
 * Type-level natural and proofs of their properties
 */
export const type_natural = mkPackage(
  nixRaw`pkgs.haskellPackages.type-natural`,
  "Type-level natural and proofs of their properties",
);

/**
 * High performance type driven html generation
 */
export const type_of_html = mkPackage(
  nixRaw`pkgs.haskellPackages.type-of-html`,
  "High performance type driven html generation",
);

/**
 * Type-level comparison operator
 */
export const type_ord = mkPackage(
  nixRaw`pkgs.haskellPackages.type-ord`,
  "Type-level comparison operator",
);

/**
 * Generic type-level comparison of types
 */
export const type_ord_spine_cereal = mkPackage(
  nixRaw`pkgs.haskellPackages.type-ord-spine-cereal`,
  "Generic type-level comparison of types",
);

/**
 * Support functions to work with type representations
 */
export const type_reflection = mkPackage(
  nixRaw`pkgs.haskellPackages.type-reflection`,
  "Support functions to work with type representations",
);

/**
 * Classes for the rig (sums and products) of types
 */
export const type_rig = mkPackage(
  nixRaw`pkgs.haskellPackages.type-rig`,
  "Classes for the rig (sums and products) of types",
);

/**
 * Type-level sets
 */
export const type_sets = mkPackage(
  nixRaw`pkgs.haskellPackages.type-sets`,
  "Type-level sets",
);

/**
 * Type Level Specification by Example
 */
export const type_spec = mkPackage(
  nixRaw`pkgs.haskellPackages.type-spec`,
  "Type Level Specification by Example",
);

/**
 * Type structure analysis
 */
export const type_structure = mkPackage(
  nixRaw`pkgs.haskellPackages.type-structure`,
  "Type structure analysis",
);

/**
 * Substitute types for other types with Template Haskell
 */
export const type_sub_th = mkPackage(
  nixRaw`pkgs.haskellPackages.type-sub-th`,
  "Substitute types for other types with Template Haskell",
);

/**
 * Mock functions and expressions anywhere
 */
export const typeable_mock = mkPackage(
  nixRaw`pkgs.haskellPackages.typeable-mock`,
  "Mock functions and expressions anywhere",
);

/**
 * Simple type check plugin which calculate addition, subtraction and less-or-equal-than
 */
export const typecheck_plugin_nat_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.typecheck-plugin-nat-simple`,
  "Simple type check plugin which calculate addition, subtraction and less-or-equal-than",
);

/**
 * Admin console framework
 */
export const typed_admin = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-admin`,
  "Admin console framework",
);

/**
 * Thread delay and timeout functions with typed arguments
 */
export const typed_duration = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-duration`,
  "Thread delay and timeout functions with typed arguments",
);

/**
 * Bridge between encoding and typed-encoding packages
 */
export const typed_encoding_encoding = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-encoding-encoding`,
  "Bridge between encoding and typed-encoding packages",
);

/**
 * Run external processes, with strong typing of streams
 */
export const typed_process = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-process`,
  "Run external processes, with strong typing of streams",
);

/**
 * A stream based replacement for lists
 */
export const typed_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-streams`,
  "A stream based replacement for lists",
);

/**
 * Phantom-Typed version of UUID
 */
export const typed_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-uuid`,
  "Phantom-Typed version of UUID",
);

/**
 * Haskell utility library required for code generated by typed-wire compiler
 */
export const typed_wire_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.typed-wire-utils`,
  "Haskell utility library required for code generated by typed-wire compiler",
);

/**
 * Typed frontend to TensorFlow and higher-order deep learning
 */
export const typedflow = mkPackage(
  nixRaw`pkgs.haskellPackages.typedflow`,
  "Typed frontend to TensorFlow and higher-order deep learning",
);

/**
 * Useful type level operations (type families and related operators)
 */
export const typelevel = mkPackage(
  nixRaw`pkgs.haskellPackages.typelevel`,
  "Useful type level operations (type families and related operators)",
);

/**
 * Type-safe printf from parsing GHC TypeLits Symbol
 */
export const typelits_printf = mkPackage(
  nixRaw`pkgs.haskellPackages.typelits-printf`,
  "Type-safe printf from parsing GHC TypeLits Symbol",
);

/**
 * Type level numbers using existing Nat functionality
 */
export const typenums = mkPackage(
  nixRaw`pkgs.haskellPackages.typenums`,
  "Type level numbers using existing Nat functionality",
);

/**
 * Small script for inferring types
 */
export const typeof_ = mkPackage(
  nixRaw`pkgs.haskellPackages.typeof`,
  "Small script for inferring types",
);

/**
 * Efficient implementation of a dependent map with types as keys
 */
export const typerep_map = mkPackage(
  nixRaw`pkgs.haskellPackages.typerep-map`,
  "Efficient implementation of a dependent map with types as keys",
);

/**
 * Enforce endianness with types
 */
export const typesafe_endian = mkPackage(
  nixRaw`pkgs.haskellPackages.typesafe-endian`,
  "Enforce endianness with types",
);

/**
 * Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)
 */
export const typesafe_precure = mkPackage(
  nixRaw`pkgs.haskellPackages.typesafe-precure`,
  "Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)",
);

/**
 * A documentation generator for TypeScript Definition files
 */
export const typescript_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.typescript-docs`,
  "A documentation generator for TypeScript Definition files",
);

/**
 * Type level numbers, vectors, list. This lib needs to be extended.
 */
export const typical = mkPackage(
  nixRaw`pkgs.haskellPackages.typical`,
  "Type level numbers, vectors, list. This lib needs to be extended.",
);

/**
 * Drawings for printed text documents
 */
export const typography_geometry = mkPackage(
  nixRaw`pkgs.haskellPackages.typography-geometry`,
  "Drawings for printed text documents",
);

/**
 * Typson Beam Integration
 */
export const typson_beam = mkPackage(
  nixRaw`pkgs.haskellPackages.typson-beam`,
  "Typson Beam Integration",
);

/**
 * Typson Esqueleto Integration
 */
export const typson_esqueleto = mkPackage(
  nixRaw`pkgs.haskellPackages.typson-esqueleto`,
  "Typson Esqueleto Integration",
);

/**
 * Typson Selda Integration
 */
export const typson_selda = mkPackage(
  nixRaw`pkgs.haskellPackages.typson-selda`,
  "Typson Selda Integration",
);

/**
 * Parsing and evaluating typst syntax
 */
export const typst = mkPackage(
  nixRaw`pkgs.haskellPackages.typst`,
  "Parsing and evaluating typst syntax",
);

/**
 * Symbol and emoji lookup for typst language
 */
export const typst_symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.typst-symbols`,
  "Symbol and emoji lookup for typst language",
);

/**
 * Efficient time zone handling
 */
export const tz = mkPackage(
  nixRaw`pkgs.haskellPackages.tz`,
  "Efficient time zone handling",
);

/**
 * Time zone database (as files and as a module)
 */
export const tzdata = mkPackage(
  nixRaw`pkgs.haskellPackages.tzdata`,
  "Time zone database (as files and as a module)",
);

/**
 * Safe timezone-aware handling of time
 */
export const tztime = mkPackage(
  nixRaw`pkgs.haskellPackages.tztime`,
  "Safe timezone-aware handling of time",
);

/**
 * Haskell Universal Two Factor helper toolbox library thing
 */
export const u2f = mkPackage(
  nixRaw`pkgs.haskellPackages.u2f`,
  "Haskell Universal Two Factor helper toolbox library thing",
);

/**
 * A library for parsing User-Agent strings, official Haskell port of ua-parser
 */
export const ua_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.ua-parser`,
  "A library for parsing User-Agent strings, official Haskell port of ua-parser",
);

/**
 * Userspace Advanced Configuration and Power Interface event daemon
 */
export const uacpid = mkPackage(
  nixRaw`pkgs.haskellPackages.uacpid`,
  "Userspace Advanced Configuration and Power Interface event daemon",
);

/**
 * Uber client for Haskell
 */
export const uber = mkPackage(
  nixRaw`pkgs.haskellPackages.uber`,
  "Uber client for Haskell",
);

/**
 * The Ucam-Webauth protocol, used by Raven
 */
export const ucam_webauth = mkPackage(
  nixRaw`pkgs.haskellPackages.ucam-webauth`,
  "The Ucam-Webauth protocol, used by Raven",
);

/**
 * Unicode Character Database  Predicates on characters specified by Unicode
 */
export const ucd = mkPackage(
  nixRaw`pkgs.haskellPackages.ucd`,
  "Unicode Character Database  Predicates on characters specified by Unicode",
);

/**
 * Model API for udbus introspection and definitions
 */
export const udbus_model = mkPackage(
  nixRaw`pkgs.haskellPackages.udbus-model`,
  "Model API for udbus introspection and definitions",
);

/**
 * Does a set of code words form a uniquely decodable code?
 */
export const udcode = mkPackage(
  nixRaw`pkgs.haskellPackages.udcode`,
  "Does a set of code words form a uniquely decodable code?",
);

/**
 * libudev bindings
 */
export const udev = mkPackage(
  nixRaw`pkgs.haskellPackages.udev`,
  "libudev bindings",
);

/**
 * A simple (but internally ugly) memoization function
 */
export const uglymemo = mkPackage(
  nixRaw`pkgs.haskellPackages.uglymemo`,
  "A simple (but internally ugly) memoization function",
);

/**
 * Part of UHC packaged as cabal/hackage installable library
 */
export const uhc_light = mkPackage(
  nixRaw`pkgs.haskellPackages.uhc-light`,
  "Part of UHC packaged as cabal/hackage installable library",
);

/**
 * UHC utilities
 */
export const uhc_util = mkPackage(
  nixRaw`pkgs.haskellPackages.uhc-util`,
  "UHC utilities",
);

/**
 * Simple unique identifier datatype, serializable and encodable as base32
 */
export const uid = mkPackage(
  nixRaw`pkgs.haskellPackages.uid`,
  "Simple unique identifier datatype, serializable and encodable as base32",
);

/**
 * A library to work with the basic Ukrainian phonetics and syllable segmentation
 */
export const ukrainian_phonetics_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.ukrainian-phonetics-basic`,
  "A library to work with the basic Ukrainian phonetics and syllable segmentation",
);

/**
 * A library to work with the basic Ukrainian phonetics and syllable segmentation
 */
export const ukrainian_phonetics_basic_array = mkPackage(
  nixRaw`pkgs.haskellPackages.ukrainian-phonetics-basic-array`,
  "A library to work with the basic Ukrainian phonetics and syllable segmentation",
);

/**
 * A library to work with the basic Ukrainian phonetics and syllable segmentation
 */
export const ukrainian_phonetics_common = mkPackage(
  nixRaw`pkgs.haskellPackages.ukrainian-phonetics-common`,
  "A library to work with the basic Ukrainian phonetics and syllable segmentation",
);

/**
 * Implementation of ULID - Universally Unique Lexicographically Sortable Identifier
 */
export const ulid = mkPackage(
  nixRaw`pkgs.haskellPackages.ulid`,
  "Implementation of ULID - Universally Unique Lexicographically Sortable Identifier",
);

/**
 * Universal un-archiver utility
 */
export const una = mkPackage(
  nixRaw`pkgs.haskellPackages.una`,
  "Universal un-archiver utility",
);

/**
 * A fast, cache-efficient, concurrent bloom filter
 */
export const unagi_bloomfilter = mkPackage(
  nixRaw`pkgs.haskellPackages.unagi-bloomfilter`,
  "A fast, cache-efficient, concurrent bloom filter",
);

/**
 * Fast concurrent queues with a Chan-like API, and more
 */
export const unagi_chan = mkPackage(
  nixRaw`pkgs.haskellPackages.unagi-chan`,
  "Fast concurrent queues with a Chan-like API, and more",
);

/**
 * Unagi Chan IO-Streams
 */
export const unagi_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.unagi-streams`,
  "Unagi Chan IO-Streams",
);

/**
 * Unambiguous choice
 */
export const unamb = mkPackage(
  nixRaw`pkgs.haskellPackages.unamb`,
  "Unambiguous choice",
);

/**
 * Generic support for programming with names and binders
 */
export const unbound = mkPackage(
  nixRaw`pkgs.haskellPackages.unbound`,
  "Generic support for programming with names and binders",
);

/**
 * Support for programming with names and binders using GHC Generics
 */
export const unbound_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.unbound-generics`,
  "Support for programming with names and binders using GHC Generics",
);

/**
 * Support for programming with names and binders using kind-generics
 */
export const unbound_kind_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.unbound-kind-generics`,
  "Support for programming with names and binders using kind-generics",
);

/**
 * Unbounded thread delays and timeouts
 */
export const unbounded_delays = mkPackage(
  nixRaw`pkgs.haskellPackages.unbounded-delays`,
  "Unbounded thread delays and timeouts",
);

/**
 * Fast unboxed references for ST and IO monad
 */
export const unboxed_ref = mkPackage(
  nixRaw`pkgs.haskellPackages.unboxed-ref`,
  "Fast unboxed references for ST and IO monad",
);

/**
 * A newtype-friendly variant of unboxed vectors
 */
export const unboxing_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.unboxing-vector`,
  "A newtype-friendly variant of unboxed vectors",
);

/**
 * Customize uncaught exception handling
 */
export const uncaught_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.uncaught-exception`,
  "Customize uncaught exception handling",
);

/**
 * Manipulating numbers with inherent experimental/measurement uncertainty
 */
export const uncertain = mkPackage(
  nixRaw`pkgs.haskellPackages.uncertain`,
  "Manipulating numbers with inherent experimental/measurement uncertainty",
);

/**
 * Null constraint
 */
export const unconstrained = mkPackage(
  nixRaw`pkgs.haskellPackages.unconstrained`,
  "Null constraint",
);

/**
 * Tiny package providing unescaping versions of show and print
 */
export const unescaping_print = mkPackage(
  nixRaw`pkgs.haskellPackages.unescaping-print`,
  "Tiny package providing unescaping versions of show and print",
);

/**
 * IO without any non-error, synchronous exceptions
 */
export const unexceptionalio = mkPackage(
  nixRaw`pkgs.haskellPackages.unexceptionalio`,
  "IO without any non-error, synchronous exceptions",
);

/**
 * A wrapper around UnexceptionalIO using monad transformers
 */
export const unexceptionalio_trans = mkPackage(
  nixRaw`pkgs.haskellPackages.unexceptionalio-trans`,
  "A wrapper around UnexceptionalIO using monad transformers",
);

/**
 * Class of data structures that can be unfolded
 */
export const unfoldable = mkPackage(
  nixRaw`pkgs.haskellPackages.unfoldable`,
  "Class of data structures that can be unfolded",
);

/**
 * An alternative to the Unfoldable typeclass
 */
export const unfoldable_restricted = mkPackage(
  nixRaw`pkgs.haskellPackages.unfoldable-restricted`,
  "An alternative to the Unfoldable typeclass",
);

/**
 * Make any action thread safe
 */
export const unfork = mkPackage(
  nixRaw`pkgs.haskellPackages.unfork`,
  "Make any action thread safe",
);

/**
 * Simplistic free monad with deriving through UndecidableInstances
 */
export const unfree = mkPackage(
  nixRaw`pkgs.haskellPackages.unfree`,
  "Simplistic free monad with deriving through UndecidableInstances",
);

/**
 * Abstract GADTs from typelevel tags
 */
export const ungadtagger = mkPackage(
  nixRaw`pkgs.haskellPackages.ungadtagger`,
  "Abstract GADTs from typelevel tags",
);

/**
 * uni events
 */
export const uni_events = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-events`,
  "uni events",
);

/**
 * Graphs
 */
export const uni_graphs = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-graphs`,
  "Graphs",
);

/**
 * Graphical User Interface for Haskell Programs
 */
export const uni_htk = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-htk`,
  "Graphical User Interface for Haskell Programs",
);

/**
 * Posix utilities for the uniform workbench
 */
export const uni_posixutil = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-posixutil`,
  "Posix utilities for the uniform workbench",
);

/**
 * Reactors for the uniform workbench
 */
export const uni_reactor = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-reactor`,
  "Reactors for the uniform workbench",
);

/**
 * Graphs binding
 */
export const uni_uDrawGraph = mkPackage(
  nixRaw`pkgs.haskellPackages.uni-uDrawGraph`,
  "Graphs binding",
);

/**
 * Construct and transform unicode characters
 */
export const unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode`,
  "Construct and transform unicode characters",
);

/**
 * Haskell implementation of the Unicode Collation Algorithm
 */
export const unicode_collation = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-collation`,
  "Haskell implementation of the Unicode Collation Algorithm",
);

/**
 * Access Unicode Character Database (UCD)
 */
export const unicode_data = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-data`,
  "Access Unicode Character Database (UCD)",
);

/**
 * Unicode characters names and aliases
 */
export const unicode_data_names = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-data-names`,
  "Unicode characters names and aliases",
);

/**
 * Unicode characters scripts
 */
export const unicode_data_scripts = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-data-scripts`,
  "Unicode characters scripts",
);

/**
 * Unicode security mechanisms database
 */
export const unicode_data_security = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-data-security`,
  "Unicode security mechanisms database",
);

/**
 * Unicode 3.2.0 character names
 */
export const unicode_names = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-names`,
  "Unicode 3.2.0 character names",
);

/**
 * Unicode normalization using the ICU library
 */
export const unicode_normalization = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-normalization`,
  "Unicode normalization using the ICU library",
);

/**
 * Unicode 3.2.0 character properties
 */
export const unicode_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-properties`,
  "Unicode 3.2.0 character properties",
);

/**
 * print and show in unicode
 */
export const unicode_show = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-show`,
  "print and show in unicode",
);

/**
 * Unicode normalization
 */
export const unicode_transforms = mkPackage(
  nixRaw`pkgs.haskellPackages.unicode-transforms`,
  "Unicode normalization",
);

/**
 * Make writing in unicode easy
 */
export const unicoder = mkPackage(
  nixRaw`pkgs.haskellPackages.unicoder`,
  "Make writing in unicode easy",
);

/**
 * Haskell binding of Unidecode
 */
export const unidecode = mkPackage(
  nixRaw`pkgs.haskellPackages.unidecode`,
  "Haskell binding of Unidecode",
);

/**
 * Simple generic unification algorithms
 */
export const unification_fd = mkPackage(
  nixRaw`pkgs.haskellPackages.unification-fd`,
  "Simple generic unification algorithms",
);

/**
 * A uniform base to build apps on
 */
export const uniformBase = mkPackage(
  nixRaw`pkgs.haskellPackages.uniformBase`,
  "A uniform base to build apps on",
);

/**
 * Pointless functions and a simplistic zero and monoid
 */
export const uniform_algebras = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-algebras`,
  "Pointless functions and a simplistic zero and monoid",
);

/**
 * a convenient handling of command line arguments
 */
export const uniform_cmdLineArgs = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-cmdLineArgs`,
  "a convenient handling of command line arguments",
);

/**
 * Handling errors in the uniform framework
 */
export const uniform_error = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-error`,
  "Handling errors in the uniform framework",
);

/**
 * Uniform file handling operations
 */
export const uniform_fileio = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-fileio`,
  "Uniform file handling operations",
);

/**
 * uniform text based operations to call http
 */
export const uniform_http = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-http`,
  "uniform text based operations to call http",
);

/**
 * Uniform IO over files, network, anything
 */
export const uniform_io = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-io`,
  "Uniform IO over files, network, anything",
);

/**
 * handling of JSON and YAML in an uniform way
 */
export const uniform_json = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-json`,
  "handling of JSON and YAML in an uniform way",
);

/**
 * convert a latex `tex` file to a pdf
 */
export const uniform_latex2pdf = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-latex2pdf`,
  "convert a latex `tex` file to a pdf",
);

/**
 * Uniform pairs with class instances
 */
export const uniform_pair = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-pair`,
  "Uniform pairs with class instances",
);

/**
 * handling of some pandoc stuff
 */
export const uniform_pandoc = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-pandoc`,
  "handling of some pandoc stuff",
);

/**
 * uniform wrapper for shake
 */
export const uniform_shake = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-shake`,
  "uniform wrapper for shake",
);

/**
 * Manipulate and convert strings of characters uniformly and consistently
 */
export const uniform_strings = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-strings`,
  "Manipulate and convert strings of characters uniformly and consistently",
);

/**
 * Time in the uniform framework
 */
export const uniform_time = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-time`,
  "Time in the uniform framework",
);

/**
 * uniform wrapper for watch
 */
export const uniform_watch = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-watch`,
  "uniform wrapper for watch",
);

/**
 * uniform text based operations to call http
 */
export const uniform_webserver = mkPackage(
  nixRaw`pkgs.haskellPackages.uniform-webserver`,
  "uniform text based operations to call http",
);

/**
 * Extensible type-safe unions
 */
export const union = mkPackage(
  nixRaw`pkgs.haskellPackages.union`,
  "Extensible type-safe unions",
);

/**
 * Union type that include radian angle and degree angle
 */
export const union_angle = mkPackage(
  nixRaw`pkgs.haskellPackages.union-angle`,
  "Union type that include radian angle and degree angle",
);

/**
 * Unify verious color formats
 */
export const union_color = mkPackage(
  nixRaw`pkgs.haskellPackages.union-color`,
  "Unify verious color formats",
);

/**
 * union find data structure
 */
export const union_find_array = mkPackage(
  nixRaw`pkgs.haskellPackages.union-find-array`,
  "union find data structure",
);

/**
 * Union mount filesystem paths into Haskell datastructures
 */
export const unionmount = mkPackage(
  nixRaw`pkgs.haskellPackages.unionmount`,
  "Union mount filesystem paths into Haskell datastructures",
);

/**
 * Helpers which allow safe partial pattern matching in lambdas
 */
export const unipatterns = mkPackage(
  nixRaw`pkgs.haskellPackages.unipatterns`,
  "Helpers which allow safe partial pattern matching in lambdas",
);

/**
 * Help writing simple, concise and fast generic operations
 */
export const uniplate = mkPackage(
  nixRaw`pkgs.haskellPackages.uniplate`,
  "Help writing simple, concise and fast generic operations",
);

/**
 * uniq-deep
 */
export const uniq_deep = mkPackage(
  nixRaw`pkgs.haskellPackages.uniq-deep`,
  "uniq-deep",
);

/**
 * Fully concurrent unique identifiers
 */
export const unique = mkPackage(
  nixRaw`pkgs.haskellPackages.unique`,
  "Fully concurrent unique identifiers",
);

/**
 * Esoteric programming language where each number can only appear once
 */
export const unique_lang = mkPackage(
  nixRaw`pkgs.haskellPackages.unique-lang`,
  "Esoteric programming language where each number can only appear once",
);

/**
 * Solve simple simultaneous equations
 */
export const unique_logic = mkPackage(
  nixRaw`pkgs.haskellPackages.unique-logic`,
  "Solve simple simultaneous equations",
);

/**
 * Solve simple simultaneous equations
 */
export const unique_logic_tf = mkPackage(
  nixRaw`pkgs.haskellPackages.unique-logic-tf`,
  "Solve simple simultaneous equations",
);

/**
 * Can be used to produce the 'uniquenessPeriods' function and related functionality
 */
export const uniqueness_periods = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods`,
  "Can be used to produce the 'uniquenessPeriods' function and related functionality",
);

/**
 * Usage examples for the uniqueness-periods-vector series of packages
 */
export const uniqueness_periods_vector_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods-vector-examples`,
  "Usage examples for the uniqueness-periods-vector series of packages",
);

/**
 * A library allows to change the structure of the 'RealFrac' function output
 */
export const uniqueness_periods_vector_filters = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods-vector-filters`,
  "A library allows to change the structure of the 'RealFrac' function output",
);

/**
 * Some kind of the optimization approach to data inner structure
 */
export const uniqueness_periods_vector_general = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods-vector-general`,
  "Some kind of the optimization approach to data inner structure",
);

/**
 * Metrices for the maximum element for the uniqueness-periods-vector packages family
 */
export const uniqueness_periods_vector_properties = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods-vector-properties`,
  "Metrices for the maximum element for the uniqueness-periods-vector packages family",
);

/**
 * A very basic descriptive statistics
 */
export const uniqueness_periods_vector_stats = mkPackage(
  nixRaw`pkgs.haskellPackages.uniqueness-periods-vector-stats`,
  "A very basic descriptive statistics",
);

/**
 * Aliases for `()`
 */
export const unit = mkPackage(
  nixRaw`pkgs.haskellPackages.unit`,
  "Aliases for `()`",
);

/**
 * Extremely simple typeclass
 */
export const unit_constraint = mkPackage(
  nixRaw`pkgs.haskellPackages.unit-constraint`,
  "Extremely simple typeclass",
);

/**
 * A domain-specific type system for dimensional analysis
 */
export const units = mkPackage(
  nixRaw`pkgs.haskellPackages.units`,
  "A domain-specific type system for dimensional analysis",
);

/**
 * Definitions for use with the units package
 */
export const units_defs = mkPackage(
  nixRaw`pkgs.haskellPackages.units-defs`,
  "Definitions for use with the units package",
);

/**
 * A parser for units of measure
 */
export const units_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.units-parser`,
  "A parser for units of measure",
);

export const unity_testresult_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.unity-testresult-parser`,
  "",
);

/**
 * Implementaation of unitym for Servant servers
 */
export const unitym_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.unitym-servant`,
  "Implementaation of unitym for Servant servers",
);

/**
 * Implementation of the unity monad for the Yesod framework
 */
export const unitym_yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.unitym-yesod`,
  "Implementation of the unity monad for the Yesod framework",
);

/**
 * Universal
 */
export const universal = mkPackage(
  nixRaw`pkgs.haskellPackages.universal`,
  "Universal",
);

/**
 * A class for finite and recursively enumerable types
 */
export const universe = mkPackage(
  nixRaw`pkgs.haskellPackages.universe`,
  "A class for finite and recursively enumerable types",
);

/**
 * A class for finite and recursively enumerable types
 */
export const universe_base = mkPackage(
  nixRaw`pkgs.haskellPackages.universe-base`,
  "A class for finite and recursively enumerable types",
);

/**
 * Universe instances for types from dependent-sum
 */
export const universe_dependent_sum = mkPackage(
  nixRaw`pkgs.haskellPackages.universe-dependent-sum`,
  "Universe instances for types from dependent-sum",
);

/**
 * Universe instances for types from selected extra packages
 */
export const universe_instances_extended = mkPackage(
  nixRaw`pkgs.haskellPackages.universe-instances-extended`,
  "Universe instances for types from selected extra packages",
);

/**
 * Instances of standard classes that are made possible by enumerations
 */
export const universe_reverse_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.universe-reverse-instances`,
  "Instances of standard classes that are made possible by enumerations",
);

/**
 * Construct a Dec's ancestor list
 */
export const universe_th = mkPackage(
  nixRaw`pkgs.haskellPackages.universe-th`,
  "Construct a Dec's ancestor list",
);

/**
 * Custom prelude used in Serokell
 */
export const universum = mkPackage(
  nixRaw`pkgs.haskellPackages.universum`,
  "Custom prelude used in Serokell",
);

/**
 * POSIX functionality
 */
export const unix_2_8_2_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.unix_2_8_2_1`,
  "POSIX functionality",
);

/**
 * Unix/Posix-specific functions for ByteStrings
 */
export const unix_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-bytestring`,
  "Unix/Posix-specific functions for ByteStrings",
);

/**
 * Portable POSIX-compatibility layer
 */
export const unix_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-compat`,
  "Portable POSIX-compatibility layer",
);

/**
 * Portable POSIX-compatibility layer
 */
export const unix_compat_0_6 = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-compat_0_6`,
  "Portable POSIX-compatibility layer",
);

/**
 * Comprehensive bindings to fcntl(2)
 */
export const unix_fcntl = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-fcntl`,
  "Comprehensive bindings to fcntl(2)",
);

/**
 * Support for writev, pwrite and pread
 */
export const unix_io_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-io-extra`,
  "Support for writev, pwrite and pread",
);

/**
 * Unix memory syscalls
 */
export const unix_memory = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-memory`,
  "Unix memory syscalls",
);

/**
 * POSIX pseudo-terminal support
 */
export const unix_pty_light = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-pty-light`,
  "POSIX pseudo-terminal support",
);

/**
 * Straightforward bindings to the posix API
 */
export const unix_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-simple`,
  "Straightforward bindings to the posix API",
);

/**
 * Unix time parser/formatter and utilities
 */
export const unix_time = mkPackage(
  nixRaw`pkgs.haskellPackages.unix-time`,
  "Unix time parser/formatter and utilities",
);

/**
 * Bidirectional JSON parsing and generation
 */
export const unjson = mkPackage(
  nixRaw`pkgs.haskellPackages.unjson`,
  "Bidirectional JSON parsing and generation",
);

/**
 * Unlambda interpreter
 */
export const unlambda = mkPackage(
  nixRaw`pkgs.haskellPackages.unlambda`,
  "Unlambda interpreter",
);

/**
 * Unlifted and levity-polymorphic types
 */
export const unlifted = mkPackage(
  nixRaw`pkgs.haskellPackages.unlifted`,
  "Unlifted and levity-polymorphic types",
);

/**
 * The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)
 */
export const unliftio = mkPackage(
  nixRaw`pkgs.haskellPackages.unliftio`,
  "The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)",
);

/**
 * The MonadUnliftIO typeclass for unlifting monads to IO
 */
export const unliftio_core = mkPackage(
  nixRaw`pkgs.haskellPackages.unliftio-core`,
  "The MonadUnliftIO typeclass for unlifting monads to IO",
);

/**
 * UnliftIO using well-typed Paths
 */
export const unliftio_path = mkPackage(
  nixRaw`pkgs.haskellPackages.unliftio-path`,
  "UnliftIO using well-typed Paths",
);

/**
 * Data.Pool generalized to MonadUnliftIO.
 */
export const unliftio_pool = mkPackage(
  nixRaw`pkgs.haskellPackages.unliftio-pool`,
  "Data.Pool generalized to MonadUnliftIO.",
);

/**
 * Generalization of io-streams to MonadUnliftIO
 */
export const unliftio_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.unliftio-streams`,
  "Generalization of io-streams to MonadUnliftIO",
);

/**
 * Tool to convert literate code between styles or to code
 */
export const unlit = mkPackage(
  nixRaw`pkgs.haskellPackages.unlit`,
  "Tool to convert literate code between styles or to code",
);

/**
 * Extract useful information from Amiga MED files
 */
export const unmed2 = mkPackage(
  nixRaw`pkgs.haskellPackages.unmed2`,
  "Extract useful information from Amiga MED files",
);

/**
 * Efficient hashing-based container types
 */
export const unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.unordered-containers`,
  "Efficient hashing-based container types",
);

/**
 * Unpacked containers via backpack
 */
export const unpacked_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.unpacked-containers`,
  "Unpacked containers via backpack",
);

/**
 * optional text that unpacks well
 */
export const unpacked_maybe_text = mkPackage(
  nixRaw`pkgs.haskellPackages.unpacked-maybe-text`,
  "optional text that unpacks well",
);

/**
 * An unpacked these data type
 */
export const unpacked_these = mkPackage(
  nixRaw`pkgs.haskellPackages.unpacked-these`,
  "An unpacked these data type",
);

/**
 * An unpacked validation data type
 */
export const unpacked_validation = mkPackage(
  nixRaw`pkgs.haskellPackages.unpacked-validation`,
  "An unpacked validation data type",
);

/**
 * An attoparsec roundtrip
 */
export const unparse_attoparsec = mkPackage(
  nixRaw`pkgs.haskellPackages.unparse-attoparsec`,
  "An attoparsec roundtrip",
);

/**
 * Unified interface to unsafe functions
 */
export const unsafe = mkPackage(
  nixRaw`pkgs.haskellPackages.unsafe`,
  "Unified interface to unsafe functions",
);

/**
 * Create pure futures using lazy IO
 */
export const unsafe_promises = mkPackage(
  nixRaw`pkgs.haskellPackages.unsafe-promises`,
  "Create pure futures using lazy IO",
);

/**
 * Like unsafeperformIO, but for the ST monad
 */
export const unsafeperformst = mkPackage(
  nixRaw`pkgs.haskellPackages.unsafeperformst`,
  "Like unsafeperformIO, but for the ST monad",
);

/**
 * Solve Boggle-like word games
 */
export const unscramble = mkPackage(
  nixRaw`pkgs.haskellPackages.unscramble`,
  "Solve Boggle-like word games",
);

/**
 * Utility construction of the graph depending unusable packages
 */
export const unusable_pkg = mkPackage(
  nixRaw`pkgs.haskellPackages.unusable-pkg`,
  "Utility construction of the graph depending unusable packages",
);

/**
 * Unwrapping sums/products lifted to functors
 */
export const unwrapped_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.unwrapped-functors`,
  "Unwrapping sums/products lifted to functors",
);

/**
 * Command-line tool to generate paths for moving upward in a file system
 */
export const up = mkPackage(
  nixRaw`pkgs.haskellPackages.up`,
  "Command-line tool to generate paths for moving upward in a file system",
);

/**
 * Software management tool
 */
export const up_grade = mkPackage(
  nixRaw`pkgs.haskellPackages.up-grade`,
  "Software management tool",
);

export const update_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.update-monad`,
  "",
);

/**
 * A program to update fetchgit values in Nix expressions
 */
export const update_nix_fetchgit = mkPackage(
  nixRaw`pkgs.haskellPackages.update-nix-fetchgit`,
  "A program to update fetchgit values in Nix expressions",
);

/**
 * Update all your git repositories with just one command
 */
export const update_repos = mkPackage(
  nixRaw`pkgs.haskellPackages.update-repos`,
  "Update all your git repositories with just one command",
);

/**
 * A style of maintaining and upgrading Haskell projects
 */
export const updo = mkPackage(
  nixRaw`pkgs.haskellPackages.updo`,
  "A style of maintaining and upgrading Haskell projects",
);

/**
 * Upload test
 */
export const uploadtest = mkPackage(
  nixRaw`pkgs.haskellPackages.uploadtest`,
  "Upload test",
);

/**
 * Talk to Urbit from Haskell
 */
export const urbit_airlock = mkPackage(
  nixRaw`pkgs.haskellPackages.urbit-airlock`,
  "Talk to Urbit from Haskell",
);

/**
 * Talk to Urbit from Haskell
 */
export const urbit_api = mkPackage(
  nixRaw`pkgs.haskellPackages.urbit-api`,
  "Talk to Urbit from Haskell",
);

/**
 * Minimalistic CLI RSS reader
 */
export const ureader = mkPackage(
  nixRaw`pkgs.haskellPackages.ureader`,
  "Minimalistic CLI RSS reader",
);

/**
 * Ur/Web static content generator
 */
export const urembed = mkPackage(
  nixRaw`pkgs.haskellPackages.urembed`,
  "Ur/Web static content generator",
);

/**
 * Haskell URI parsing as ByteStrings
 */
export const uri_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.uri-bytestring`,
  "Haskell URI parsing as ByteStrings",
);

/**
 * Aeson instances for URI Bytestring
 */
export const uri_bytestring_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.uri-bytestring-aeson`,
  "Aeson instances for URI Bytestring",
);

/**
 * Unicode aware uri-encoding
 */
export const uri_encode = mkPackage(
  nixRaw`pkgs.haskellPackages.uri-encode`,
  "Unicode aware uri-encoding",
);

/**
 * Read and write URIs (deprecated)
 */
export const uri_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.uri-enumerator`,
  "Read and write URIs (deprecated)",
);

/**
 * uri-enumerator backend for the file scheme (deprecated)
 */
export const uri_enumerator_file = mkPackage(
  nixRaw`pkgs.haskellPackages.uri-enumerator-file`,
  "uri-enumerator backend for the file scheme (deprecated)",
);

/**
 * A library for working with URLs
 */
export const url = mkPackage(
  nixRaw`pkgs.haskellPackages.url`,
  "A library for working with URLs",
);

/**
 * Encoding and decoding of URL slugs
 */
export const url_slug = mkPackage(
  nixRaw`pkgs.haskellPackages.url-slug`,
  "Encoding and decoding of URL slugs",
);

/**
 * Painfully simple URL deployment
 */
export const urlpath = mkPackage(
  nixRaw`pkgs.haskellPackages.urlpath`,
  "Painfully simple URL deployment",
);

export const usa_holidays = mkPackage(
  nixRaw`pkgs.haskellPackages.usa-holidays`,
  "",
);

/**
 * Communicate with USB devices
 */
export const usb = mkPackage(
  nixRaw`pkgs.haskellPackages.usb`,
  "Communicate with USB devices",
);

/**
 * Iteratee enumerators for the usb package
 */
export const usb_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.usb-enumerator`,
  "Iteratee enumerators for the usb package",
);

/**
 * Parser and request Library for USB HIDs
 */
export const usb_hid = mkPackage(
  nixRaw`pkgs.haskellPackages.usb-hid`,
  "Parser and request Library for USB HIDs",
);

/**
 * A database of USB identifiers
 */
export const usb_id_database = mkPackage(
  nixRaw`pkgs.haskellPackages.usb-id-database`,
  "A database of USB identifiers",
);

/**
 * Iteratee enumerators for the usb package
 */
export const usb_iteratee = mkPackage(
  nixRaw`pkgs.haskellPackages.usb-iteratee`,
  "Iteratee enumerators for the usb package",
);

/**
 * Type-safe communication with USB devices
 */
export const usb_safe = mkPackage(
  nixRaw`pkgs.haskellPackages.usb-safe`,
  "Type-safe communication with USB devices",
);

/**
 * A library simplifying user management for web applications
 */
export const users = mkPackage(
  nixRaw`pkgs.haskellPackages.users`,
  "A library simplifying user management for web applications",
);

/**
 * A mysql-haskell backend for the users library
 */
export const users_mysql_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.users-mysql-haskell`,
  "A mysql-haskell backend for the users library",
);

/**
 * A PostgreSQL backend for the users package
 */
export const users_postgresql_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.users-postgresql-simple`,
  "A PostgreSQL backend for the users package",
);

/**
 * Library to test backends for the users library
 */
export const users_test = mkPackage(
  nixRaw`pkgs.haskellPackages.users-test`,
  "Library to test backends for the users library",
);

/**
 * UTF-8
 */
export const utf = mkPackage(
  nixRaw`pkgs.haskellPackages.utf`,
  "UTF-8",
);

/**
 * UTF-8 aware substitutes for functions in System.Environment
 */
export const utf8_env = mkPackage(
  nixRaw`pkgs.haskellPackages.utf8-env`,
  "UTF-8 aware substitutes for functions in System.Environment",
);

/**
 * Unicode
 */
export const utf8_light = mkPackage(
  nixRaw`pkgs.haskellPackages.utf8-light`,
  "Unicode",
);

/**
 * Support for reading and writing UTF8 Strings
 */
export const utf8_string = mkPackage(
  nixRaw`pkgs.haskellPackages.utf8-string`,
  "Support for reading and writing UTF8 Strings",
);

/**
 * Exceptional utilities
 */
export const util_exception = mkPackage(
  nixRaw`pkgs.haskellPackages.util-exception`,
  "Exceptional utilities",
);

/**
 * Utilities for stateful primitive types and types based on them
 */
export const util_primitive_control = mkPackage(
  nixRaw`pkgs.haskellPackages.util-primitive-control`,
  "Utilities for stateful primitive types and types based on them",
);

/**
 * Utilities for universal types
 */
export const util_universe = mkPackage(
  nixRaw`pkgs.haskellPackages.util-universe`,
  "Utilities for universal types",
);

/**
 * Various small helper functions for Lists, Maybes, Tuples, Functions
 */
export const utility_ht = mkPackage(
  nixRaw`pkgs.haskellPackages.utility-ht`,
  "Various small helper functions for Lists, Maybes, Tuples, Functions",
);

/**
 * Utilities for compiler construction: example programs
 */
export const uu_cco_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-cco-examples`,
  "Utilities for compiler construction: example programs",
);

/**
 * Utilities for compiler construction: Feedback wrapper around parser in uulib
 */
export const uu_cco_hut_parsing = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-cco-hut-parsing`,
  "Utilities for compiler construction: Feedback wrapper around parser in uulib",
);

/**
 * Utilities for compiler construction: Feedback wrapper around parser in uu-parsinglib
 */
export const uu_cco_uu_parsinglib = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-cco-uu-parsinglib`,
  "Utilities for compiler construction: Feedback wrapper around parser in uu-parsinglib",
);

/**
 * An interleaving combinator for use with applicative style implementations
 */
export const uu_interleaved = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-interleaved`,
  "An interleaving combinator for use with applicative style implementations",
);

/**
 * Parse command line options using uu-interleave and uu-parsinglib
 */
export const uu_options = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-options`,
  "Parse command line options using uu-interleave and uu-parsinglib",
);

/**
 * Fast, online, error-correcting, monadic, applicative, merging, permuting, interleaving, idiomatic parser combinators
 */
export const uu_parsinglib = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-parsinglib`,
  "Fast, online, error-correcting, monadic, applicative, merging, permuting, interleaving, idiomatic parser combinators",
);

/**
 * Haskell 98 parser combinators for INFOB3TC at Utrecht University
 */
export const uu_tc = mkPackage(
  nixRaw`pkgs.haskellPackages.uu-tc`,
  "Haskell 98 parser combinators for INFOB3TC at Utrecht University",
);

/**
 * Attribute Grammar System of Universiteit Utrecht
 */
export const uuagc = mkPackage(
  nixRaw`pkgs.haskellPackages.uuagc`,
  "Attribute Grammar System of Universiteit Utrecht",
);

/**
 * Cabal plugin for UUAGC
 */
export const uuagc_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.uuagc-cabal`,
  "Cabal plugin for UUAGC",
);

/**
 * A debugger for the UUAG system
 */
export const uuagd = mkPackage(
  nixRaw`pkgs.haskellPackages.uuagd`,
  "A debugger for the UUAG system",
);

/**
 * For creating, comparing, parsing and printing Universally Unique Identifiers
 */
export const uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid`,
  "For creating, comparing, parsing and printing Universally Unique Identifiers",
);

/**
 * UUID parsing using byteverse packages
 */
export const uuid_bytes = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-bytes`,
  "UUID parsing using byteverse packages",
);

/**
 * Reversable and secure encoding of object ids as uuids
 */
export const uuid_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-crypto`,
  "Reversable and secure encoding of object ids as uuids",
);

/**
 * Universally Unique Identifiers with little-endian-ish encoding tools
 */
export const uuid_le = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-le`,
  "Universally Unique Identifiers with little-endian-ish encoding tools",
);

/**
 * Orphan instances for the UUID datatype
 */
export const uuid_orphans = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-orphans`,
  "Orphan instances for the UUID datatype",
);

/**
 * Supplemental package for 'uuid' allowing quasiquotation
 */
export const uuid_quasi = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-quasi`,
  "Supplemental package for 'uuid' allowing quasiquotation",
);

/**
 * Type definitions for Universally Unique Identifiers
 */
export const uuid_types = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-types`,
  "Type definitions for Universally Unique Identifiers",
);

/**
 * Type definitions for Universally Unique Identifiers
 */
export const uuid_types_1_0_5_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.uuid-types_1_0_5_1`,
  "Type definitions for Universally Unique Identifiers",
);

/**
 * Haskell Utrecht Tools Library
 */
export const uulib = mkPackage(
  nixRaw`pkgs.haskellPackages.uulib`,
  "Haskell Utrecht Tools Library",
);

/**
 * Efficient algorithms for uvector unboxed arrays
 */
export const uvector_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.uvector-algorithms`,
  "Efficient algorithms for uvector unboxed arrays",
);

/**
 * Utility function for reading a source of loaded uzbl pages
 */
export const uzbl_with_source = mkPackage(
  nixRaw`pkgs.haskellPackages.uzbl-with-source`,
  "Utility function for reading a source of loaded uzbl pages",
);

/**
 * interface to Video For Linux Two (V4L2)
 */
export const v4l2 = mkPackage(
  nixRaw`pkgs.haskellPackages.v4l2`,
  "interface to Video For Linux Two (V4L2)",
);

/**
 * video for linux two examples
 */
export const v4l2_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.v4l2-examples`,
  "video for linux two examples",
);

/**
 * the cabal companion
 */
export const vabal = mkPackage(
  nixRaw`pkgs.haskellPackages.vabal`,
  "the cabal companion",
);

/**
 * Visualize live Haskell data structures using vacuum, graphviz and cairo
 */
export const vacuum_cairo = mkPackage(
  nixRaw`pkgs.haskellPackages.vacuum-cairo`,
  "Visualize live Haskell data structures using vacuum, graphviz and cairo",
);

/**
 * A library for transforming vacuum graphs into GraphViz output
 */
export const vacuum_graphviz = mkPackage(
  nixRaw`pkgs.haskellPackages.vacuum-graphviz`,
  "A library for transforming vacuum graphs into GraphViz output",
);

/**
 * Visualize live Haskell data structures using vacuum, graphviz and OpenGL
 */
export const vacuum_opengl = mkPackage(
  nixRaw`pkgs.haskellPackages.vacuum-opengl`,
  "Visualize live Haskell data structures using vacuum, graphviz and OpenGL",
);

/**
 * Visualize Haskell data structures using vacuum and Ubigraph
 */
export const vacuum_ubigraph = mkPackage(
  nixRaw`pkgs.haskellPackages.vacuum-ubigraph`,
  "Visualize Haskell data structures using vacuum and Ubigraph",
);

/**
 * Type isomorphic to `Either` with `Applicative` instance which combines errors
 */
export const valid = mkPackage(
  nixRaw`pkgs.haskellPackages.valid`,
  "Type isomorphic to `Either` with `Applicative` instance which combines errors",
);

/**
 * Simple applicative validation for product types, batteries included!
 */
export const valida = mkPackage(
  nixRaw`pkgs.haskellPackages.valida`,
  "Simple applicative validation for product types, batteries included!",
);

/**
 * Simple applicative validation for product types, batteries included!
 */
export const valida_base = mkPackage(
  nixRaw`pkgs.haskellPackages.valida-base`,
  "Simple applicative validation for product types, batteries included!",
);

/**
 * None
 */
export const validate = mkPackage(
  nixRaw`pkgs.haskellPackages.validate`,
  "None",
);

/**
 * Input validation combinator library
 */
export const validate_input = mkPackage(
  nixRaw`pkgs.haskellPackages.validate-input`,
  "Input validation combinator library",
);

/**
 * Compile-time checking for partial smart-constructors
 */
export const validated_literals = mkPackage(
  nixRaw`pkgs.haskellPackages.validated-literals`,
  "Compile-time checking for partial smart-constructors",
);

/**
 * A data-type like Either but with an accumulating Applicative
 */
export const validation = mkPackage(
  nixRaw`pkgs.haskellPackages.validation`,
  "A data-type like Either but with an accumulating Applicative",
);

/**
 * Lighweight pure data validation based on Applicative
 */
export const validation_micro = mkPackage(
  nixRaw`pkgs.haskellPackages.validation-micro`,
  "Lighweight pure data validation based on Applicative",
);

/**
 * Lighweight pure data validation based on Applicative and Selective functors
 */
export const validation_selective = mkPackage(
  nixRaw`pkgs.haskellPackages.validation-selective`,
  "Lighweight pure data validation based on Applicative and Selective functors",
);

/**
 * Straightforward validation monad
 */
export const validationt = mkPackage(
  nixRaw`pkgs.haskellPackages.validationt`,
  "Straightforward validation monad",
);

/**
 * Validity typeclass
 */
export const validity = mkPackage(
  nixRaw`pkgs.haskellPackages.validity`,
  "Validity typeclass",
);

/**
 * Validity instances for aeson
 */
export const validity_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-aeson`,
  "Validity instances for aeson",
);

/**
 * Validity instances for bytestring
 */
export const validity_bytestring = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-bytestring`,
  "Validity instances for bytestring",
);

/**
 * Validity instances for case-insensitive
 */
export const validity_case_insensitive = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-case-insensitive`,
  "Validity instances for case-insensitive",
);

/**
 * Validity instances for containers
 */
export const validity_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-containers`,
  "Validity instances for containers",
);

/**
 * Validity instances for Path
 */
export const validity_path = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-path`,
  "Validity instances for Path",
);

/**
 * Validity instances for persistent-related types
 */
export const validity_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-persistent`,
  "Validity instances for persistent-related types",
);

/**
 * Validity instances for primitive
 */
export const validity_primitive = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-primitive`,
  "Validity instances for primitive",
);

/**
 * Validity instances for scientific
 */
export const validity_scientific = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-scientific`,
  "Validity instances for scientific",
);

/**
 * Validity instances for text
 */
export const validity_text = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-text`,
  "Validity instances for text",
);

/**
 * Validity instances for time
 */
export const validity_time = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-time`,
  "Validity instances for time",
);

/**
 * Validity instances for unordered-containers
 */
export const validity_unordered_containers = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-unordered-containers`,
  "Validity instances for unordered-containers",
);

/**
 * Validity instances for uuid
 */
export const validity_uuid = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-uuid`,
  "Validity instances for uuid",
);

/**
 * Validity instances for vector
 */
export const validity_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.validity-vector`,
  "Validity instances for vector",
);

/**
 * Simple and powerful data validation
 */
export const valor = mkPackage(
  nixRaw`pkgs.haskellPackages.valor`,
  "Simple and powerful data validation",
);

/**
 * The VarMonad typeclass, generalizing types of references
 */
export const var_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.var-monad`,
  "The VarMonad typeclass, generalizing types of references",
);

/**
 * Dhall instances for VF
 */
export const variable_media_field_dhall = mkPackage(
  nixRaw`pkgs.haskellPackages.variable-media-field-dhall`,
  "Dhall instances for VF",
);

/**
 * Optics for variable-media-field
 */
export const variable_media_field_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.variable-media-field-optics`,
  "Optics for variable-media-field",
);

/**
 * variable-precision floating point
 */
export const variable_precision = mkPackage(
  nixRaw`pkgs.haskellPackages.variable-precision`,
  "variable-precision floating point",
);

/**
 * Create and transform functions with variable arity
 */
export const variadic_function = mkPackage(
  nixRaw`pkgs.haskellPackages.variadic-function`,
  "Create and transform functions with variable arity",
);

/**
 * FRP through value streams and monadic splines
 */
export const varying = mkPackage(
  nixRaw`pkgs.haskellPackages.varying`,
  "FRP through value streams and monadic splines",
);

/**
 * a persistent store for values of arbitrary types
 */
export const vault = mkPackage(
  nixRaw`pkgs.haskellPackages.vault`,
  "a persistent store for values of arbitrary types",
);

/**
 * Utility library for spawning a HashiCorp Vault process
 */
export const vault_tool_server = mkPackage(
  nixRaw`pkgs.haskellPackages.vault-tool-server`,
  "Utility library for spawning a HashiCorp Vault process",
);

/**
 * A monad transformer for vault-tool
 */
export const vault_trans = mkPackage(
  nixRaw`pkgs.haskellPackages.vault-trans`,
  "A monad transformer for vault-tool",
);

/**
 * Common types and instances for Vaultaire
 */
export const vaultaire_common = mkPackage(
  nixRaw`pkgs.haskellPackages.vaultaire-common`,
  "Common types and instances for Vaultaire",
);

/**
 * Runs processes with secrets from HashiCorp Vault
 */
export const vaultenv = mkPackage(
  nixRaw`pkgs.haskellPackages.vaultenv`,
  "Runs processes with secrets from HashiCorp Vault",
);

/**
 * patricia tries modeled above VCache
 */
export const vcache_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.vcache-trie`,
  "patricia tries modeled above VCache",
);

/**
 * A library for parsing/printing vCards from/to various formats
 */
export const vcard = mkPackage(
  nixRaw`pkgs.haskellPackages.vcard`,
  "A library for parsing/printing vCards from/to various formats",
);

/**
 * Reading and writing VCD files
 */
export const vcd = mkPackage(
  nixRaw`pkgs.haskellPackages.vcd`,
  "Reading and writing VCD files",
);

/**
 * Library for handling files ignored by VCS systems
 */
export const vcs_ignore = mkPackage(
  nixRaw`pkgs.haskellPackages.vcs-ignore`,
  "Library for handling files ignored by VCS systems",
);

/**
 * Facilities for accessing the version control revision of the current directory
 */
export const vcs_revision = mkPackage(
  nixRaw`pkgs.haskellPackages.vcs-revision`,
  "Facilities for accessing the version control revision of the current directory",
);

/**
 * Parse development platform web hook messages
 */
export const vcs_web_hook_parse = mkPackage(
  nixRaw`pkgs.haskellPackages.vcs-web-hook-parse`,
  "Parse development platform web hook messages",
);

/**
 * GUI library for source code management systems
 */
export const vcsgui = mkPackage(
  nixRaw`pkgs.haskellPackages.vcsgui`,
  "GUI library for source code management systems",
);

/**
 * Vec: length-indexed (sized) list
 */
export const vec = mkPackage(
  nixRaw`pkgs.haskellPackages.vec`,
  "Vec: length-indexed (sized) list",
);

/**
 * Vec: length-indexed (sized) list: lens support
 */
export const vec_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.vec-lens`,
  "Vec: length-indexed (sized) list: lens support",
);

/**
 * Vec: length-indexed (sized) list: optics support
 */
export const vec_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.vec-optics`,
  "Vec: length-indexed (sized) list: optics support",
);

/**
 * A low-dimensional linear algebra library, tailored to computer graphics
 */
export const vect = mkPackage(
  nixRaw`pkgs.haskellPackages.vect`,
  "A low-dimensional linear algebra library, tailored to computer graphics",
);

/**
 * Accelerate instances for vect-floating types
 */
export const vect_floating_accelerate = mkPackage(
  nixRaw`pkgs.haskellPackages.vect-floating-accelerate`,
  "Accelerate instances for vect-floating types",
);

/**
 * Efficient Arrays
 */
export const vector = mkPackage(
  nixRaw`pkgs.haskellPackages.vector`,
  "Efficient Arrays",
);

/**
 * Efficient algorithms for vector arrays
 */
export const vector_algorithms = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-algorithms`,
  "Efficient algorithms for vector arrays",
);

/**
 * Binary instances for vector types (deprecated)
 */
export const vector_binary = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-binary`,
  "Binary instances for vector types (deprecated)",
);

/**
 * Instances of Data.Binary for vector
 */
export const vector_binary_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-binary-instances`,
  "Instances of Data.Binary for vector",
);

/**
 * A buffer compatible with Data.Vector.*
 */
export const vector_buffer = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-buffer`,
  "A buffer compatible with Data.Vector.*",
);

/**
 * Vector builder
 */
export const vector_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-builder`,
  "Vector builder",
);

/**
 * Serial (from the bytes package) for Vector (from the vector package)
 */
export const vector_bytes_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-bytes-instances`,
  "Serial (from the bytes package) for Vector (from the vector package)",
);

/**
 * Utilities for the "vector" library
 */
export const vector_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-extras`,
  "Utilities for the \"vector\" library",
);

/**
 * Native FFT and IFFT for vector
 */
export const vector_fft = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-fft`,
  "Native FFT and IFFT for vector",
);

/**
 * Efficient vector-based mutable hashtables implementation
 */
export const vector_hashtables = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-hashtables`,
  "Efficient vector-based mutable hashtables implementation",
);

/**
 * Orphan Instances for 'Data.Vector'
 */
export const vector_instances = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-instances`,
  "Orphan Instances for 'Data.Vector'",
);

/**
 * Instances of the Data.Collections classes for Data.Vector.*
 */
export const vector_instances_collections = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-instances-collections`,
  "Instances of the Data.Collections classes for Data.Vector.*",
);

/**
 * Memory map immutable and mutable vectors
 */
export const vector_mmap = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-mmap`,
  "Memory map immutable and mutable vectors",
);

/**
 * Fast and flexible quicksort implementation for mutable vectors
 */
export const vector_quicksort = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-quicksort`,
  "Fast and flexible quicksort implementation for mutable vectors",
);

/**
 * Vectors with O(1) reverse
 */
export const vector_rotcev = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-rotcev`,
  "Vectors with O(1) reverse",
);

/**
 * Size tagged vectors
 */
export const vector_sized = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-sized`,
  "Size tagged vectors",
);

/**
 * Vector & affine spaces, linear maps, and derivatives
 */
export const vector_space = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-space`,
  "Vector & affine spaces, linear maps, and derivatives",
);

/**
 * Combinator library for splitting vectors
 */
export const vector_split = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-split`,
  "Combinator library for splitting vectors",
);

/**
 * A parallel evaluation strategy for boxed vectors
 */
export const vector_strategies = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-strategies`,
  "A parallel evaluation strategy for boxed vectors",
);

/**
 * Efficient Streams
 */
export const vector_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-stream`,
  "Efficient Streams",
);

/**
 * Text implementation based on unboxed char vector
 */
export const vector_text = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-text`,
  "Text implementation based on unboxed char vector",
);

/**
 * Deriver for Data.Vector.Unboxed using Template Haskell
 */
export const vector_th_unbox = mkPackage(
  nixRaw`pkgs.haskellPackages.vector-th-unbox`,
  "Deriver for Data.Vector.Unboxed using Template Haskell",
);

/**
 * GIS Vector Tiles, as defined by Mapbox
 */
export const vectortiles = mkPackage(
  nixRaw`pkgs.haskellPackages.vectortiles`,
  "GIS Vector Tiles, as defined by Mapbox",
);

/**
 * ASCII platform-adventure game
 */
export const venzone = mkPackage(
  nixRaw`pkgs.haskellPackages.venzone`,
  "ASCII platform-adventure game",
);

/**
 * Simple enum that encodes application verbosity
 */
export const verbosity = mkPackage(
  nixRaw`pkgs.haskellPackages.verbosity`,
  "Simple enum that encodes application verbosity",
);

/**
 * JSON instances and JSON Schema for verdict
 */
export const verdict_json = mkPackage(
  nixRaw`pkgs.haskellPackages.verdict-json`,
  "JSON instances and JSON Schema for verdict",
);

/**
 * An intermediate language for Hoare logic style verification
 */
export const verifiable_expressions = mkPackage(
  nixRaw`pkgs.haskellPackages.verifiable-expressions`,
  "An intermediate language for Hoare logic style verification",
);

/**
 * Random verilog generation and simulator testing
 */
export const verismith = mkPackage(
  nixRaw`pkgs.haskellPackages.verismith`,
  "Random verilog generation and simulator testing",
);

/**
 * Small alternative prelude
 */
export const verset = mkPackage(
  nixRaw`pkgs.haskellPackages.verset`,
  "Small alternative prelude",
);

/**
 * A simple version type
 */
export const version_natural = mkPackage(
  nixRaw`pkgs.haskellPackages.version-natural`,
  "A simple version type",
);

/**
 * FromDhall and ToDhall instances for version-natural
 */
export const version_natural_dhall_instance = mkPackage(
  nixRaw`pkgs.haskellPackages.version-natural-dhall-instance`,
  "FromDhall and ToDhall instances for version-natural",
);

/**
 * Servant combinators for the versioning library
 */
export const versioning_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.versioning-servant`,
  "Servant combinators for the versioning library",
);

/**
 * Types and parsers for software version numbers
 */
export const versions = mkPackage(
  nixRaw`pkgs.haskellPackages.versions`,
  "Types and parsers for software version numbers",
);

/**
 * Functor-parametric containers
 */
export const vessel = mkPackage(
  nixRaw`pkgs.haskellPackages.vessel`,
  "Functor-parametric containers",
);

/**
 * types for ingesting vflow data with aeson
 */
export const vflow_types = mkPackage(
  nixRaw`pkgs.haskellPackages.vflow-types`,
  "types for ingesting vflow data with aeson",
);

/**
 * Extend vformat to Aeson datatypes
 */
export const vformat_aeson = mkPackage(
  nixRaw`pkgs.haskellPackages.vformat-aeson`,
  "Extend vformat to Aeson datatypes",
);

/**
 * Extend vformat to time datatypes
 */
export const vformat_time = mkPackage(
  nixRaw`pkgs.haskellPackages.vformat-time`,
  "Extend vformat to time datatypes",
);

/**
 * VFR waypoints, as published in the AIP (ERSA)
 */
export const vfr_waypoints = mkPackage(
  nixRaw`pkgs.haskellPackages.vfr-waypoints`,
  "VFR waypoints, as published in the AIP (ERSA)",
);

/**
 * An extensible dead-man's switch system
 */
export const vigilance = mkPackage(
  nixRaw`pkgs.haskellPackages.vigilance`,
  "An extensible dead-man's switch system",
);

/**
 * Frontend for video metadata tagging tools
 */
export const vimeta = mkPackage(
  nixRaw`pkgs.haskellPackages.vimeta`,
  "Frontend for video metadata tagging tools",
);

/**
 * An MPD client with vim-like key bindings
 */
export const vimus = mkPackage(
  nixRaw`pkgs.haskellPackages.vimus`,
  "An MPD client with vim-like key bindings",
);

/**
 * Extensible Records
 */
export const vinyl = mkPackage(
  nixRaw`pkgs.haskellPackages.vinyl`,
  "Extensible Records",
);

/**
 * Convert plain records to vinyl (and vice versa), generically
 */
export const vinyl_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.vinyl-generics`,
  "Convert plain records to vinyl (and vice versa), generically",
);

/**
 * Utilities for working with OpenGL's GLSL shading language and vinyl records
 */
export const vinyl_gl = mkPackage(
  nixRaw`pkgs.haskellPackages.vinyl-gl`,
  "Utilities for working with OpenGL's GLSL shading language and vinyl records",
);

/**
 * Loeb's theorem for extensible records
 */
export const vinyl_loeb = mkPackage(
  nixRaw`pkgs.haskellPackages.vinyl-loeb`,
  "Loeb's theorem for extensible records",
);

/**
 * Initial project template from stack
 */
export const vinyl_operational = mkPackage(
  nixRaw`pkgs.haskellPackages.vinyl-operational`,
  "Initial project template from stack",
);

/**
 * An XMMS2 client
 */
export const vision = mkPackage(
  nixRaw`pkgs.haskellPackages.vision`,
  "An XMMS2 client",
);

/**
 * Visualize the graph-rewrite steps of a Haskell program
 */
export const visual_graphrewrite = mkPackage(
  nixRaw`pkgs.haskellPackages.visual-graphrewrite`,
  "Visualize the graph-rewrite steps of a Haskell program",
);

/**
 * Visualize CBN reduction
 */
export const visualize_cbn = mkPackage(
  nixRaw`pkgs.haskellPackages.visualize-cbn`,
  "Visualize CBN reduction",
);

/**
 * Sound synthesis with SuperCollider
 */
export const vivid = mkPackage(
  nixRaw`pkgs.haskellPackages.vivid`,
  "Sound synthesis with SuperCollider",
);

/**
 * Open Sound Control encode/decode
 */
export const vivid_osc = mkPackage(
  nixRaw`pkgs.haskellPackages.vivid-osc`,
  "Open Sound Control encode/decode",
);

/**
 * Implementation of SuperCollider server specifications
 */
export const vivid_supercollider = mkPackage(
  nixRaw`pkgs.haskellPackages.vivid-supercollider`,
  "Implementation of SuperCollider server specifications",
);

/**
 * Pseudo terminal interaction with subprocesses
 */
export const vk_posix_pty = mkPackage(
  nixRaw`pkgs.haskellPackages.vk-posix-pty`,
  "Pseudo terminal interaction with subprocesses",
);

/**
 * Smaoin vocabulary definitions of the base framework
 */
export const vocabulary_kadma = mkPackage(
  nixRaw`pkgs.haskellPackages.vocabulary-kadma`,
  "Smaoin vocabulary definitions of the base framework",
);

/**
 * Phase vocoder
 */
export const vocoder = mkPackage(
  nixRaw`pkgs.haskellPackages.vocoder`,
  "Phase vocoder",
);

/**
 * Phase vocoder for conduit-audio
 */
export const vocoder_audio = mkPackage(
  nixRaw`pkgs.haskellPackages.vocoder-audio`,
  "Phase vocoder for conduit-audio",
);

/**
 * Phase vocoder for Conduit
 */
export const vocoder_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.vocoder-conduit`,
  "Phase vocoder for Conduit",
);

/**
 * Phase vocoder for Dunai and Rhine
 */
export const vocoder_dunai = mkPackage(
  nixRaw`pkgs.haskellPackages.vocoder-dunai`,
  "Phase vocoder for Dunai and Rhine",
);

/**
 * Upload audio files to voicebase to get a transcription
 */
export const voicebase = mkPackage(
  nixRaw`pkgs.haskellPackages.voicebase`,
  "Upload audio files to voicebase to get a transcription",
);

/**
 * A Haskell 98 logically uninhabited data type
 */
export const void_ = mkPackage(
  nixRaw`pkgs.haskellPackages.void`,
  "A Haskell 98 logically uninhabited data type",
);

/**
 * Reading of Vorbis comments from Ogg Vorbis files
 */
export const vorbiscomment = mkPackage(
  nixRaw`pkgs.haskellPackages.vorbiscomment`,
  "Reading of Vorbis comments from Ogg Vorbis files",
);

/**
 * Vantage Point Trees
 */
export const vp_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.vp-tree`,
  "Vantage Point Trees",
);

/**
 * Priority queue based on vector
 */
export const vpq = mkPackage(
  nixRaw`pkgs.haskellPackages.vpq`,
  "Priority queue based on vector",
);

/**
 * Bindings to VRPN
 */
export const vrpn = mkPackage(
  nixRaw`pkgs.haskellPackages.vrpn`,
  "Bindings to VRPN",
);

/**
 * A simple terminal UI library
 */
export const vty = mkPackage(
  nixRaw`pkgs.haskellPackages.vty`,
  "A simple terminal UI library",
);

/**
 * A simple terminal UI library
 */
export const vty_5_35_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.vty_5_35_1`,
  "A simple terminal UI library",
);

/**
 * Extra vty-ui functionality not included in the core library
 */
export const vty_ui_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.vty-ui-extras`,
  "Extra vty-ui functionality not included in the core library",
);

/**
 * Bindings to the Vulkan graphics API
 */
export const vulkan = mkPackage(
  nixRaw`pkgs.haskellPackages.vulkan`,
  "Bindings to the Vulkan graphics API",
);

/**
 * Low-level low-overhead vulkan api bindings
 */
export const vulkan_api = mkPackage(
  nixRaw`pkgs.haskellPackages.vulkan-api`,
  "Low-level low-overhead vulkan api bindings",
);

/**
 * Utils for the vulkan package
 */
export const vulkan_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.vulkan-utils`,
  "Utils for the vulkan package",
);

/**
 * JSON wrangling
 */
export const waargonaut = mkPackage(
  nixRaw`pkgs.haskellPackages.waargonaut`,
  "JSON wrangling",
);

/**
 * A haskell binding of the Web Audio API ala blank-canvas
 */
export const wahsp = mkPackage(
  nixRaw`pkgs.haskellPackages.wahsp`,
  "A haskell binding of the Web Audio API ala blank-canvas",
);

/**
 * Web Application Interface
 */
export const wai = mkPackage(
  nixRaw`pkgs.haskellPackages.wai`,
  "Web Application Interface",
);

/**
 * Rewrite based on Accept-Language header
 */
export const wai_accept_language = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-accept-language`,
  "Rewrite based on Accept-Language header",
);

/**
 * File/CGI/Rev Proxy App of WAI
 */
export const wai_app_file_cgi = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-app-file-cgi`,
  "File/CGI/Rev Proxy App of WAI",
);

/**
 * WAI application for static serving
 */
export const wai_app_static = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-app-static`,
  "WAI application for static serving",
);

/**
 * Command line runner for Wai apps (using Warp) with TLS, CGI, socket activation & graceful shutdown
 */
export const wai_cli = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-cli`,
  "Command line runner for Wai apps (using Warp) with TLS, CGI, socket activation & graceful shutdown",
);

/**
 * conduit wrappers for WAI
 */
export const wai_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-conduit`,
  "conduit wrappers for WAI",
);

/**
 * Run wai Applications in IO based monads
 */
export const wai_control = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-control`,
  "Run wai Applications in IO based monads",
);

/**
 * CORS for WAI
 */
export const wai_cors = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-cors`,
  "CORS for WAI",
);

/**
 * A web server for the development of WAI compliant web applications
 */
export const wai_devel = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-devel`,
  "A web server for the development of WAI compliant web applications",
);

/**
 * Helpers to bind digestive-functors onto wai requests
 */
export const wai_digestive_functors = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-digestive-functors`,
  "Helpers to bind digestive-functors onto wai requests",
);

/**
 * Nice wrapper around yesod-routes for use with WAI
 */
export const wai_dispatch = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-dispatch`,
  "Nice wrapper around yesod-routes for use with WAI",
);

/**
 * Enforce HTTPS in Wai server app safely
 */
export const wai_enforce_https = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-enforce-https`,
  "Enforce HTTPS in Wai server app safely",
);

/**
 * WAI middleware to parameterize requests with environment
 */
export const wai_env = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-env`,
  "WAI middleware to parameterize requests with environment",
);

/**
 * WAI support for server-sent events (deprecated)
 */
export const wai_eventsource = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-eventsource`,
  "WAI support for server-sent events (deprecated)",
);

/**
 * Provides some basic WAI handlers and middleware
 */
export const wai_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-extra`,
  "Provides some basic WAI handlers and middleware",
);

/**
 * Feature flag support for WAI applications
 */
export const wai_feature_flags = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-feature-flags`,
  "Feature flag support for WAI applications",
);

/**
 * Run CGI apps on WAI
 */
export const wai_frontend_monadcgi = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-frontend-monadcgi`,
  "Run CGI apps on WAI",
);

/**
 * Wrap WAI applications to run on AWS Lambda
 */
export const wai_handler_hal = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-handler-hal`,
  "Wrap WAI applications to run on AWS Lambda",
);

/**
 * Launch a web app in the default browser
 */
export const wai_handler_launch = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-handler-launch`,
  "Launch a web app in the default browser",
);

/**
 * Web Application Interface handler using snap-server. (deprecated)
 */
export const wai_handler_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-handler-snap`,
  "Web Application Interface handler using snap-server. (deprecated)",
);

/**
 * Nice wrapper around hastache for use with WAI
 */
export const wai_hastache = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-hastache`,
  "Nice wrapper around hastache for use with WAI",
);

/**
 * WAI utilities for HTTP/2
 */
export const wai_http2_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-http2-extra`,
  "WAI utilities for HTTP/2",
);

/**
 * Haskell Webapps on AWS Lambda
 */
export const wai_lambda = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-lambda`,
  "Haskell Webapps on AWS Lambda",
);

/**
 * A logging middleware for WAI applications
 */
export const wai_log = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-log`,
  "A logging middleware for WAI applications",
);

/**
 * A logging system for WAI
 */
export const wai_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-logger`,
  "A logging system for WAI",
);

/**
 * Compiling and serving assets
 */
export const wai_make_assets = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-make-assets`,
  "Compiling and serving assets",
);

/**
 * WAI Middleware for Bearer Token Authentication
 */
export const wai_middleware_bearer = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-bearer`,
  "WAI Middleware for Bearer Token Authentication",
);

/**
 * WAI middleware for brotli compression
 */
export const wai_middleware_brotli = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-brotli`,
  "WAI middleware for brotli compression",
);

/**
 * Caching middleware for WAI
 */
export const wai_middleware_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-cache`,
  "Caching middleware for WAI",
);

/**
 * Redis backend for wai-middleware-cache
 */
export const wai_middleware_cache_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-cache-redis`,
  "Redis backend for wai-middleware-cache",
);

/**
 * WAI Middleware to cache things
 */
export const wai_middleware_caching = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-caching`,
  "WAI Middleware to cache things",
);

/**
 * Initial project template from stack
 */
export const wai_middleware_caching_lru = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-caching-lru`,
  "Initial project template from stack",
);

/**
 * Cache Wai Middleware using Redis backend
 */
export const wai_middleware_caching_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-caching-redis`,
  "Cache Wai Middleware using Redis backend",
);

/**
 * GNU Terry Pratchett - Add the X-Clacks-Overhead Header to Wai Responses
 */
export const wai_middleware_clacks = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-clacks`,
  "GNU Terry Pratchett - Add the X-Clacks-Overhead Header to Wai Responses",
);

/**
 * Wai Middleware for Consul
 */
export const wai_middleware_consul = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-consul`,
  "Wai Middleware for Consul",
);

/**
 * Route to different middlewares based on the incoming Accept header
 */
export const wai_middleware_content_type = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-content-type`,
  "Route to different middlewares based on the incoming Accept header",
);

/**
 * WAI middleware to unzip request bodies
 */
export const wai_middleware_gunzip = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-gunzip`,
  "WAI middleware to unzip request bodies",
);

/**
 * HMAC Authentication Middleware for WAI
 */
export const wai_middleware_hmac = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-hmac`,
  "HMAC Authentication Middleware for WAI",
);

/**
 * Converts errors from plaintext to json
 */
export const wai_middleware_json_errors = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-json-errors`,
  "Converts errors from plaintext to json",
);

/**
 * A WAI middleware to collect EKG request metrics
 */
export const wai_middleware_metrics = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-metrics`,
  "A WAI middleware to collect EKG request metrics",
);

/**
 * WAI middlware for exposing http://prometheus.io metrics.
 */
export const wai_middleware_prometheus = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-prometheus`,
  "WAI middlware for exposing http://prometheus.io metrics.",
);

/**
 * Middleware that communicates to Rollbar
 */
export const wai_middleware_rollbar = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-rollbar`,
  "Middleware that communicates to Rollbar",
);

/**
 * Wai dispatch middleware
 */
export const wai_middleware_route = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-route`,
  "Wai dispatch middleware",
);

/**
 * WAI Slack request verification middleware
 */
export const wai_middleware_slack_verify = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-slack-verify`,
  "WAI Slack request verification middleware",
);

/**
 * WAI middleware that serves requests to static files
 */
export const wai_middleware_static = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-static`,
  "WAI middleware that serves requests to static files",
);

/**
 * Serve embedded static files as a Wai middleware
 */
export const wai_middleware_static_embedded = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-static-embedded`,
  "Serve embedded static files as a Wai middleware",
);

/**
 * WAI Middleware for Request Throttling
 */
export const wai_middleware_throttle = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-throttle`,
  "WAI Middleware for Request Throttling",
);

/**
 * WAI Middleware to validate the request and response bodies
 */
export const wai_middleware_validation = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-validation`,
  "WAI Middleware to validate the request and response bodies",
);

/**
 * Route Wai middlewares based on HTTP verbs
 */
export const wai_middleware_verbs = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-middleware-verbs`,
  "Route Wai middlewares based on HTTP verbs",
);

/**
 * WAI request predicates
 */
export const wai_predicates = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-predicates`,
  "WAI request predicates",
);

/**
 * Rate limiting as WAI middleware
 */
export const wai_rate_limit = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-rate-limit`,
  "Rate limiting as WAI middleware",
);

/**
 * WAI middleware for path-based request routing with captures
 */
export const wai_route = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-route`,
  "WAI middleware for path-based request routing with captures",
);

/**
 * Declarative routing for WAI
 */
export const wai_routing = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-routing`,
  "Declarative routing for WAI",
);

/**
 * Flexible session middleware for WAI
 */
export const wai_session = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-session`,
  "Flexible session middleware for WAI",
);

/**
 * An alternative session middleware for WAI
 */
export const wai_session_alt = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-session-alt`,
  "An alternative session middleware for WAI",
);

/**
 * Session store based on clientsession
 */
export const wai_session_clientsession = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-session-clientsession`,
  "Session store based on clientsession",
);

/**
 * Session store based on Tokyo Cabinet
 */
export const wai_session_tokyocabinet = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-session-tokyocabinet`,
  "Session store based on Tokyo Cabinet",
);

/**
 * A Slack middleware for WAI
 */
export const wai_slack_middleware = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-slack-middleware`,
  "A Slack middleware for WAI",
);

/**
 * generate static html pages from a WAI application
 */
export const wai_static_pages = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-static-pages`,
  "generate static html pages from a WAI application",
);

/**
 * Unit test framework (built on HUnit) for WAI applications. (deprecated)
 */
export const wai_test = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-test`,
  "Unit test framework (built on HUnit) for WAI applications. (deprecated)",
);

/**
 * Thrift transport layer for Wai
 */
export const wai_thrift = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-thrift`,
  "Thrift transport layer for Wai",
);

export const wai_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-transformers`,
  "",
);

/**
 * Collection of utility functions for use with WAI
 */
export const wai_util = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-util`,
  "Collection of utility functions for use with WAI",
);

/**
 * Provide a bridge between WAI and the websockets package
 */
export const wai_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.wai-websockets`,
  "Provide a bridge between WAI and the websockets package",
);

/**
 * Wait handles are MVars which can only be written to once, and from which values can never be removed
 */
export const wait_handle = mkPackage(
  nixRaw`pkgs.haskellPackages.wait-handle`,
  "Wait handles are MVars which can only be written to once, and from which values can never be removed",
);

/**
 * A generator of comics based on some ascertainable data about the requester
 */
export const waldo = mkPackage(
  nixRaw`pkgs.haskellPackages.waldo`,
  "A generator of comics based on some ascertainable data about the requester",
);

/**
 * A fast, light-weight web server for WAI applications
 */
export const warp = mkPackage(
  nixRaw`pkgs.haskellPackages.warp`,
  "A fast, light-weight web server for WAI applications",
);

/**
 * A fast, light-weight web server for WAI applications
 */
export const warp_3_3_29 = mkPackage(
  nixRaw`pkgs.haskellPackages.warp_3_3_29`,
  "A fast, light-weight web server for WAI applications",
);

/**
 * A minimal gRPC server on top of Warp
 */
export const warp_grpc = mkPackage(
  nixRaw`pkgs.haskellPackages.warp-grpc`,
  "A minimal gRPC server on top of Warp",
);

/**
 * Warp based on QUIC
 */
export const warp_quic = mkPackage(
  nixRaw`pkgs.haskellPackages.warp-quic`,
  "Warp based on QUIC",
);

/**
 * HTTP over TLS support for Warp via the TLS package
 */
export const warp_tls = mkPackage(
  nixRaw`pkgs.haskellPackages.warp-tls`,
  "HTTP over TLS support for Warp via the TLS package",
);

/**
 * HTTP over TLS support for Warp via the TLS package
 */
export const warp_tls_3_4_3 = mkPackage(
  nixRaw`pkgs.haskellPackages.warp-tls_3_4_3`,
  "HTTP over TLS support for Warp via the TLS package",
);

/**
 * set group and user id before running server
 */
export const warp_tls_uid = mkPackage(
  nixRaw`pkgs.haskellPackages.warp-tls-uid`,
  "set group and user id before running server",
);

/**
 * Warp and Wai Library
 */
export const warped = mkPackage(
  nixRaw`pkgs.haskellPackages.warped`,
  "Warp and Wai Library",
);

/**
 * Simple control structure to re-try an action with exponential backoff
 */
export const watchdog = mkPackage(
  nixRaw`pkgs.haskellPackages.watchdog`,
  "Simple control structure to re-try an action with exponential backoff",
);

/**
 * Command-line tool for converting audio files and filling in ID3 tags
 */
export const wavconvert = mkPackage(
  nixRaw`pkgs.haskellPackages.wavconvert`,
  "Command-line tool for converting audio files and filling in ID3 tags",
);

/**
 * Work with WAVE and RF64 files
 */
export const wave = mkPackage(
  nixRaw`pkgs.haskellPackages.wave`,
  "Work with WAVE and RF64 files",
);

/**
 * Parse WaveSurfer files
 */
export const wavesurfer = mkPackage(
  nixRaw`pkgs.haskellPackages.wavesurfer`,
  "Parse WaveSurfer files",
);

/**
 * Process WAVE files in Haskell
 */
export const wavy = mkPackage(
  nixRaw`pkgs.haskellPackages.wavy`,
  "Process WAVE files in Haskell",
);

/**
 * Native wcwidth
 */
export const wcwidth = mkPackage(
  nixRaw`pkgs.haskellPackages.wcwidth`,
  "Native wcwidth",
);

/**
 * Run a command on a specified directory
 */
export const wd = mkPackage(
  nixRaw`pkgs.haskellPackages.wd`,
  "Run a command on a specified directory",
);

/**
 * Weak pointer extas
 */
export const weak = mkPackage(
  nixRaw`pkgs.haskellPackages.weak`,
  "Weak pointer extas",
);

/**
 * Weather and related data info command-line tool
 */
export const weatherhs = mkPackage(
  nixRaw`pkgs.haskellPackages.weatherhs`,
  "Weather and related data info command-line tool",
);

/**
 * Haskell Web3 library
 */
export const web3 = mkPackage(
  nixRaw`pkgs.haskellPackages.web3`,
  "Haskell Web3 library",
);

/**
 * Fixed size big integers for Haskell Web3 library
 */
export const web3_bignum = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-bignum`,
  "Fixed size big integers for Haskell Web3 library",
);

/**
 * Cryptograhical primitives for Haskell Web3 library
 */
export const web3_crypto = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-crypto`,
  "Cryptograhical primitives for Haskell Web3 library",
);

/**
 * Ethereum support for Haskell Web3 library
 */
export const web3_ethereum = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-ethereum`,
  "Ethereum support for Haskell Web3 library",
);

/**
 * Polkadot support for Haskell Web3 library
 */
export const web3_polkadot = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-polkadot`,
  "Polkadot support for Haskell Web3 library",
);

/**
 * Node connection provider for Haskell Web3 library
 */
export const web3_provider = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-provider`,
  "Node connection provider for Haskell Web3 library",
);

/**
 * Solidity language for Haskell Web3 library
 */
export const web3_solidity = mkPackage(
  nixRaw`pkgs.haskellPackages.web3-solidity`,
  "Solidity language for Haskell Web3 library",
);

/**
 * Web Browser In Haskell
 */
export const web_browser_in_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.web-browser-in-haskell`,
  "Web Browser In Haskell",
);

/**
 * Wrappers for web frameworks to ease usage with the FP Complete environment
 */
export const web_fpco = mkPackage(
  nixRaw`pkgs.haskellPackages.web-fpco`,
  "Wrappers for web frameworks to ease usage with the FP Complete environment",
);

/**
 * Composable, reversible, efficient web routing using invertible invariants and bijections
 */
export const web_inv_route = mkPackage(
  nixRaw`pkgs.haskellPackages.web-inv-route`,
  "Composable, reversible, efficient web routing using invertible invariants and bijections",
);

/**
 * Bindings for the Mongrel2 web server
 */
export const web_mongrel2 = mkPackage(
  nixRaw`pkgs.haskellPackages.web-mongrel2`,
  "Bindings for the Mongrel2 web server",
);

/**
 * representations of a web page
 */
export const web_rep = mkPackage(
  nixRaw`pkgs.haskellPackages.web-rep`,
  "representations of a web page",
);

/**
 * portable, type-safe URL routing
 */
export const web_routes = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes`,
  "portable, type-safe URL routing",
);

/**
 * Use boomerang for type-safe URL parsers/printers
 */
export const web_routes_boomerang = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-boomerang`,
  "Use boomerang for type-safe URL parsers/printers",
);

/**
 * portable, type-safe URL routing
 */
export const web_routes_generics = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-generics`,
  "portable, type-safe URL routing",
);

/**
 * Adds support for using web-routes with Happstack
 */
export const web_routes_happstack = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-happstack`,
  "Adds support for using web-routes with Happstack",
);

/**
 * Adds XMLGenerator instance for RouteT monad
 */
export const web_routes_hsp = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-hsp`,
  "Adds XMLGenerator instance for RouteT monad",
);

/**
 * Extends web-routes with mtl-based MonadIO / MonadTrans RouteT instances
 */
export const web_routes_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-mtl`,
  "Extends web-routes with mtl-based MonadIO / MonadTrans RouteT instances",
);

/**
 * portable, type-safe URL routing
 */
export const web_routes_regular = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-regular`,
  "portable, type-safe URL routing",
);

/**
 * Support for deriving PathInfo using Template Haskell
 */
export const web_routes_th = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-th`,
  "Support for deriving PathInfo using Template Haskell",
);

/**
 * Library for maintaining correctness of URLs within an application
 */
export const web_routes_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routes-wai`,
  "Library for maintaining correctness of URLs within an application",
);

/**
 * simple routing library
 */
export const web_routing = mkPackage(
  nixRaw`pkgs.haskellPackages.web-routing`,
  "simple routing library",
);

/**
 * Build a WAI Application from Webcrank Resources
 */
export const webcrank_wai = mkPackage(
  nixRaw`pkgs.haskellPackages.webcrank-wai`,
  "Build a WAI Application from Webcrank Resources",
);

/**
 * a Haskell client for the Selenium WebDriver protocol
 */
export const webdriver = mkPackage(
  nixRaw`pkgs.haskellPackages.webdriver`,
  "a Haskell client for the Selenium WebDriver protocol",
);

/**
 * Bindings to the WebDriver API
 */
export const webdriver_w3c = mkPackage(
  nixRaw`pkgs.haskellPackages.webdriver-w3c`,
  "Bindings to the WebDriver API",
);

/**
 * A Haskell bindings for Webex Teams API
 */
export const webex_teams_api = mkPackage(
  nixRaw`pkgs.haskellPackages.webex-teams-api`,
  "A Haskell bindings for Webex Teams API",
);

/**
 * Conduit wrapper of Webex Teams List API
 */
export const webex_teams_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.webex-teams-conduit`,
  "Conduit wrapper of Webex Teams List API",
);

/**
 * Pipes wrapper of Webex Teams List API
 */
export const webex_teams_pipes = mkPackage(
  nixRaw`pkgs.haskellPackages.webex-teams-pipes`,
  "Pipes wrapper of Webex Teams List API",
);

/**
 * Composable, type-safe library to build HTTP APIs
 */
export const webgear_core = mkPackage(
  nixRaw`pkgs.haskellPackages.webgear-core`,
  "Composable, type-safe library to build HTTP APIs",
);

/**
 * Composable, type-safe library to build HTTP API servers
 */
export const webgear_openapi = mkPackage(
  nixRaw`pkgs.haskellPackages.webgear-openapi`,
  "Composable, type-safe library to build HTTP API servers",
);

/**
 * Composable, type-safe library to build HTTP API servers
 */
export const webgear_server = mkPackage(
  nixRaw`pkgs.haskellPackages.webgear-server`,
  "Composable, type-safe library to build HTTP API servers",
);

/**
 * webfont generator
 */
export const webify = mkPackage(
  nixRaw`pkgs.haskellPackages.webify`,
  "webfont generator",
);

/**
 * Binding to the Webkit library
 */
export const webkit = mkPackage(
  nixRaw`pkgs.haskellPackages.webkit`,
  "Binding to the Webkit library",
);

/**
 * JavaScriptCore FFI from webkitgtk
 */
export const webkit2gtk3_javascriptcore = mkPackage(
  nixRaw`pkgs.haskellPackages.webkit2gtk3-javascriptcore`,
  "JavaScriptCore FFI from webkitgtk",
);

/**
 * JavaScriptCore FFI from webkitgtk
 */
export const webkitgtk3_javascriptcore = mkPackage(
  nixRaw`pkgs.haskellPackages.webkitgtk3-javascriptcore`,
  "JavaScriptCore FFI from webkitgtk",
);

/**
 * JuicyPixels support for WebP format
 */
export const webp = mkPackage(
  nixRaw`pkgs.haskellPackages.webp`,
  "JuicyPixels support for WebP format",
);

/**
 * Organized and simple web page scaffold for blaze and lucid
 */
export const webpage = mkPackage(
  nixRaw`pkgs.haskellPackages.webpage`,
  "Organized and simple web page scaffold for blaze and lucid",
);

/**
 * Easy voice activity detection
 */
export const webrtc_vad = mkPackage(
  nixRaw`pkgs.haskellPackages.webrtc-vad`,
  "Easy voice activity detection",
);

/**
 * HTTP server library
 */
export const webserver = mkPackage(
  nixRaw`pkgs.haskellPackages.webserver`,
  "HTTP server library",
);

/**
 * Transforms URLs to PNGs
 */
export const websnap = mkPackage(
  nixRaw`pkgs.haskellPackages.websnap`,
  "Transforms URLs to PNGs",
);

/**
 * A sensible and clean way to write WebSocket-capable servers in Haskell
 */
export const websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets`,
  "A sensible and clean way to write WebSocket-capable servers in Haskell",
);

/**
 * Extras for working with websockets & JSON
 */
export const websockets_json = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets-json`,
  "Extras for working with websockets & JSON",
);

/**
 * Simple streaming RPC mechanism using WebSockets
 */
export const websockets_rpc = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets-rpc`,
  "Simple streaming RPC mechanism using WebSockets",
);

/**
 * Composable websockets clients
 */
export const websockets_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets-simple`,
  "Composable websockets clients",
);

export const websockets_simple_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets-simple-extra`,
  "",
);

/**
 * Snap integration for the websockets library
 */
export const websockets_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.websockets-snap`,
  "Snap integration for the websockets library",
);

/**
 * a wedding announcement
 */
export const wedding_announcement = mkPackage(
  nixRaw`pkgs.haskellPackages.wedding-announcement`,
  "a wedding announcement",
);

/**
 * Wedged postcard generator
 */
export const wedged = mkPackage(
  nixRaw`pkgs.haskellPackages.wedged`,
  "Wedged postcard generator",
);

/**
 * Detect dead code
 */
export const weeder = mkPackage(
  nixRaw`pkgs.haskellPackages.weeder`,
  "Detect dead code",
);

/**
 * Detect dead code
 */
export const weeder_2_2_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.weeder_2_2_0`,
  "Detect dead code",
);

/**
 * Detect dead code
 */
export const weeder_2_3_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.weeder_2_3_1`,
  "Detect dead code",
);

/**
 * Detect dead code
 */
export const weeder_2_4_1 = mkPackage(
  nixRaw`pkgs.haskellPackages.weeder_2_4_1`,
  "Detect dead code",
);

/**
 * A school-timetable problem-solver
 */
export const weekdaze = mkPackage(
  nixRaw`pkgs.haskellPackages.weekdaze`,
  "A school-timetable problem-solver",
);

/**
 * Weierstrass Elliptic Functions
 */
export const weierstrass_functions = mkPackage(
  nixRaw`pkgs.haskellPackages.weierstrass-functions`,
  "Weierstrass Elliptic Functions",
);

/**
 * Measure allocations of a Haskell functions/values
 */
export const weigh = mkPackage(
  nixRaw`pkgs.haskellPackages.weigh`,
  "Measure allocations of a Haskell functions/values",
);

/**
 * Measure allocations of a Haskell functions/values
 */
export const weigh_0_0_17 = mkPackage(
  nixRaw`pkgs.haskellPackages.weigh_0_0_17`,
  "Measure allocations of a Haskell functions/values",
);

/**
 * Writer monad which uses semiring constraint
 */
export const weighted = mkPackage(
  nixRaw`pkgs.haskellPackages.weighted`,
  "Writer monad which uses semiring constraint",
);

/**
 * A weighted nondeterministic search monad
 */
export const weighted_search = mkPackage(
  nixRaw`pkgs.haskellPackages.weighted-search`,
  "A weighted nondeterministic search monad",
);

/**
 * Online computation of mean and variance using the Welford algorithm
 */
export const welford_online_mean_variance = mkPackage(
  nixRaw`pkgs.haskellPackages.welford-online-mean-variance`,
  "Online computation of mean and variance using the Welford algorithm",
);

/**
 * Pretty-printing of codebases
 */
export const wembley = mkPackage(
  nixRaw`pkgs.haskellPackages.wembley`,
  "Pretty-printing of codebases",
);

/**
 * A chat interface for playing werewolf in Slack
 */
export const werewolf_slack = mkPackage(
  nixRaw`pkgs.haskellPackages.werewolf-slack`,
  "A chat interface for playing werewolf in Slack",
);

/**
 * WGPU
 */
export const wgpu_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.wgpu-hs`,
  "WGPU",
);

/**
 * Solver-agnostic symbolic values support for issuing queries
 */
export const what4 = mkPackage(
  nixRaw`pkgs.haskellPackages.what4`,
  "Solver-agnostic symbolic values support for issuing queries",
);

/**
 * MongoDB plugin for Wheb
 */
export const wheb_mongo = mkPackage(
  nixRaw`pkgs.haskellPackages.wheb-mongo`,
  "MongoDB plugin for Wheb",
);

/**
 * Redis connection for Wheb
 */
export const wheb_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.wheb-redis`,
  "Redis connection for Wheb",
);

/**
 * Strapped templates for Wheb
 */
export const wheb_strapped = mkPackage(
  nixRaw`pkgs.haskellPackages.wheb-strapped`,
  "Strapped templates for Wheb",
);

/**
 * Determine the full path to an executable
 */
export const which = mkPackage(
  nixRaw`pkgs.haskellPackages.which`,
  "Determine the full path to an executable",
);

/**
 * Whitespace, an esoteric programming language
 */
export const whitespace = mkPackage(
  nixRaw`pkgs.haskellPackages.whitespace`,
  "Whitespace, an esoteric programming language",
);

export const wholepixels = mkPackage(
  nixRaw`pkgs.haskellPackages.wholepixels`,
  "",
);

/**
 * Data types for large but fixed width signed and unsigned integers
 */
export const wide_word = mkPackage(
  nixRaw`pkgs.haskellPackages.wide-word`,
  "Data types for large but fixed width signed and unsigned integers",
);

/**
 * CG coefficients and Wigner symbols
 */
export const wigner_symbols = mkPackage(
  nixRaw`pkgs.haskellPackages.wigner-symbols`,
  "CG coefficients and Wigner symbols",
);

/**
 * Wikipedia EPUB E-Book construction from Firefox history
 */
export const wikipedia4epub = mkPackage(
  nixRaw`pkgs.haskellPackages.wikipedia4epub`,
  "Wikipedia EPUB E-Book construction from Firefox history",
);

/**
 * Graphical indicator for WildBind
 */
export const wild_bind_indicator = mkPackage(
  nixRaw`pkgs.haskellPackages.wild-bind-indicator`,
  "Graphical indicator for WildBind",
);

/**
 * Task to install and export everything you need to use WildBind in X11
 */
export const wild_bind_task_x11 = mkPackage(
  nixRaw`pkgs.haskellPackages.wild-bind-task-x11`,
  "Task to install and export everything you need to use WildBind in X11",
);

/**
 * X11-specific implementation for WildBind
 */
export const wild_bind_x11 = mkPackage(
  nixRaw`pkgs.haskellPackages.wild-bind-x11`,
  "X11-specific implementation for WildBind",
);

/**
 * Haskell modules support for Wilton JavaScript runtime
 */
export const wilton_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.wilton-ffi`,
  "Haskell modules support for Wilton JavaScript runtime",
);

/**
 * Work with multiple Haskell Platform versions on Windows
 */
export const win_hp_path = mkPackage(
  nixRaw`pkgs.haskellPackages.win-hp-path`,
  "Work with multiple Haskell Platform versions on Windows",
);

/**
 * Implements Windows Live Web Authentication and Delegated Authentication
 */
export const windowslive = mkPackage(
  nixRaw`pkgs.haskellPackages.windowslive`,
  "Implements Windows Live Web Authentication and Delegated Authentication",
);

/**
 * A compact, well-typed seralisation format for Haskell values
 */
export const winery = mkPackage(
  nixRaw`pkgs.haskellPackages.winery`,
  "A compact, well-typed seralisation format for Haskell values",
);

/**
 * I/O library for Windows
 */
export const winio = mkPackage(
  nixRaw`pkgs.haskellPackages.winio`,
  "I/O library for Windows",
);

/**
 * Fast binary io-streams adapter
 */
export const wire_streams = mkPackage(
  nixRaw`pkgs.haskellPackages.wire-streams`,
  "Fast binary io-streams adapter",
);

/**
 * Access GPIO pins on Raspberry Pi via wiringPi library
 */
export const wiringPi = mkPackage(
  nixRaw`pkgs.haskellPackages.wiringPi`,
  "Access GPIO pins on Raspberry Pi via wiringPi library",
);

/**
 * Convert values from one type into another
 */
export const witch = mkPackage(
  nixRaw`pkgs.haskellPackages.witch`,
  "Convert values from one type into another",
);

/**
 * A tiny library for composing indexed traversals
 */
export const with_index = mkPackage(
  nixRaw`pkgs.haskellPackages.with-index`,
  "A tiny library for composing indexed traversals",
);

/**
 * Use ImplicitParams-based source locations in a backward compatible way
 */
export const with_location = mkPackage(
  nixRaw`pkgs.haskellPackages.with-location`,
  "Use ImplicitParams-based source locations in a backward compatible way",
);

/**
 * Get your IO right on the first try
 */
export const with_utf8 = mkPackage(
  nixRaw`pkgs.haskellPackages.with-utf8`,
  "Get your IO right on the first try",
);

/**
 * Run computations that depend on one or more elements in a stream
 */
export const withdependencies = mkPackage(
  nixRaw`pkgs.haskellPackages.withdependencies`,
  "Run computations that depend on one or more elements in a stream",
);

/**
 * filterable traversable
 */
export const witherable = mkPackage(
  nixRaw`pkgs.haskellPackages.witherable`,
  "filterable traversable",
);

/**
 * Witherable = Traversable + Filterable
 */
export const witherable_class = mkPackage(
  nixRaw`pkgs.haskellPackages.witherable-class`,
  "Witherable = Traversable + Filterable",
);

/**
 * A value within another path
 */
export const within = mkPackage(
  nixRaw`pkgs.haskellPackages.within`,
  "A value within another path",
);

/**
 * values that witness types
 */
export const witness = mkPackage(
  nixRaw`pkgs.haskellPackages.witness`,
  "values that witness types",
);

/**
 * the fantastical wizard monoid
 */
export const wizard = mkPackage(
  nixRaw`pkgs.haskellPackages.wizard`,
  "the fantastical wizard monoid",
);

/**
 * High level, generic library for interrogative user interfaces
 */
export const wizards = mkPackage(
  nixRaw`pkgs.haskellPackages.wizards`,
  "High level, generic library for interrogative user interfaces",
);

/**
 * The Wadler/Leijen Pretty Printer
 */
export const wl_pprint = mkPackage(
  nixRaw`pkgs.haskellPackages.wl-pprint`,
  "The Wadler/Leijen Pretty Printer",
);

/**
 * Pretty printer with annotation support
 */
export const wl_pprint_annotated = mkPackage(
  nixRaw`pkgs.haskellPackages.wl-pprint-annotated`,
  "Pretty printer with annotation support",
);

/**
 * ANSI Terminal support with wl-pprint-extras
 */
export const wl_pprint_ansiterm = mkPackage(
  nixRaw`pkgs.haskellPackages.wl-pprint-ansiterm`,
  "ANSI Terminal support with wl-pprint-extras",
);

/**
 * A color pretty printer with terminfo support
 */
export const wl_pprint_terminfo = mkPackage(
  nixRaw`pkgs.haskellPackages.wl-pprint-terminfo`,
  "A color pretty printer with terminfo support",
);

/**
 * A Wadler/Leijen Pretty Printer for Text values
 */
export const wl_pprint_text = mkPackage(
  nixRaw`pkgs.haskellPackages.wl-pprint-text`,
  "A Wadler/Leijen Pretty Printer for Text values",
);

/**
 * Haskell bindings for the wlc library
 */
export const wlc_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.wlc-hs`,
  "Haskell bindings for the wlc library",
);

/**
 * A simple and highly performant HTTP file server
 */
export const wobsurv = mkPackage(
  nixRaw`pkgs.haskellPackages.wobsurv`,
  "A simple and highly performant HTTP file server",
);

/**
 * Amazon Simple Workflow Service Wrapper
 */
export const wolf = mkPackage(
  nixRaw`pkgs.haskellPackages.wolf`,
  "Amazon Simple Workflow Service Wrapper",
);

/**
 * Real time group editor without operational transform
 */
export const woot = mkPackage(
  nixRaw`pkgs.haskellPackages.woot`,
  "Real time group editor without operational transform",
);

/**
 * Words of arbitrary size
 */
export const word = mkPackage(
  nixRaw`pkgs.haskellPackages.word`,
  "Words of arbitrary size",
);

/**
 * Word16 library
 */
export const word16 = mkPackage(
  nixRaw`pkgs.haskellPackages.word16`,
  "Word16 library",
);

/**
 * Word8 library
 */
export const word8 = mkPackage(
  nixRaw`pkgs.haskellPackages.word8`,
  "Word8 library",
);

/**
 * treat integral types as arrays of smaller integral types
 */
export const word_array = mkPackage(
  nixRaw`pkgs.haskellPackages.word-array`,
  "treat integral types as arrays of smaller integral types",
);

/**
 * Compatibility shim for the Int/Word internal change in GHC 9.2
 */
export const word_compat = mkPackage(
  nixRaw`pkgs.haskellPackages.word-compat`,
  "Compatibility shim for the Int/Word internal change in GHC 9.2",
);

/**
 * Implementation of a finite trie over words
 */
export const word_trie = mkPackage(
  nixRaw`pkgs.haskellPackages.word-trie`,
  "Implementation of a finite trie over words",
);

/**
 * Initial project template from stack
 */
export const word_vector = mkPackage(
  nixRaw`pkgs.haskellPackages.word-vector`,
  "Initial project template from stack",
);

/**
 * A library for word-wrapping
 */
export const word_wrap = mkPackage(
  nixRaw`pkgs.haskellPackages.word-wrap`,
  "A library for word-wrapping",
);

/**
 * Get word counts and distributions
 */
export const wordchoice = mkPackage(
  nixRaw`pkgs.haskellPackages.wordchoice`,
  "Get word counts and distributions",
);

/**
 * None
 */
export const wordcloud = mkPackage(
  nixRaw`pkgs.haskellPackages.wordcloud`,
  "None",
);

/**
 * wordexp(3) wrappers
 */
export const wordexp = mkPackage(
  nixRaw`pkgs.haskellPackages.wordexp`,
  "wordexp(3) wrappers",
);

/**
 * Validate Wordpress Cookies & Nonces; Build Wordpress Hashes & Salts
 */
export const wordpress_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.wordpress-auth`,
  "Validate Wordpress Cookies & Nonces; Build Wordpress Hashes & Salts",
);

/**
 * Cross-platform access to a list of words
 */
export const words = mkPackage(
  nixRaw`pkgs.haskellPackages.words`,
  "Cross-platform access to a list of words",
);

/**
 * Compare two files as sets of N-tuples of words
 */
export const wordsetdiff = mkPackage(
  nixRaw`pkgs.haskellPackages.wordsetdiff`,
  "Compare two files as sets of N-tuples of words",
);

/**
 * Utilities (e.g. Googling the clipboard contents) for the `workflow` pacakge
 */
export const workflow_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.workflow-extra`,
  "Utilities (e.g. Googling the clipboard contents) for the `workflow` pacakge",
);

/**
 * manipulate `workflow-types:Workflow`'s
 */
export const workflow_pure = mkPackage(
  nixRaw`pkgs.haskellPackages.workflow-pure`,
  "manipulate `workflow-types:Workflow`'s",
);

/**
 * Automate keyboard\/mouse\/clipboard\/application interaction
 */
export const workflow_types = mkPackage(
  nixRaw`pkgs.haskellPackages.workflow-types`,
  "Automate keyboard\\/mouse\\/clipboard\\/application interaction",
);

/**
 * Open Union and Open Product Types
 */
export const world_peace = mkPackage(
  nixRaw`pkgs.haskellPackages.world-peace`,
  "Open Union and Open Product Types",
);

/**
 * Wrap a function's return value with another function
 */
export const wrap = mkPackage(
  nixRaw`pkgs.haskellPackages.wrap`,
  "Wrap a function's return value with another function",
);

/**
 * Convenient handling of points on a seamless 2-dimensional plane
 */
export const wraparound = mkPackage(
  nixRaw`pkgs.haskellPackages.wraparound`,
  "Convenient handling of points on a seamless 2-dimensional plane",
);

/**
 * Newtypes to carry DerivingVia instances
 */
export const wrapped = mkPackage(
  nixRaw`pkgs.haskellPackages.wrapped`,
  "Newtypes to carry DerivingVia instances",
);

/**
 * A Generic instance of Default
 */
export const wrapped_generic_default = mkPackage(
  nixRaw`pkgs.haskellPackages.wrapped-generic-default`,
  "A Generic instance of Default",
);

/**
 * Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure
 */
export const wraxml = mkPackage(
  nixRaw`pkgs.haskellPackages.wraxml`,
  "Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure",
);

/**
 * An HTTP Performance Benchmarker
 */
export const wrecker = mkPackage(
  nixRaw`pkgs.haskellPackages.wrecker`,
  "An HTTP Performance Benchmarker",
);

/**
 * A web interface for Wrecker, the HTTP Performance Benchmarker
 */
export const wrecker_ui = mkPackage(
  nixRaw`pkgs.haskellPackages.wrecker-ui`,
  "A web interface for Wrecker, the HTTP Performance Benchmarker",
);

/**
 * An easy-to-use HTTP client library
 */
export const wreq = mkPackage(
  nixRaw`pkgs.haskellPackages.wreq`,
  "An easy-to-use HTTP client library",
);

/**
 * Simple wrapper to use wreq without Strings
 */
export const wreq_stringless = mkPackage(
  nixRaw`pkgs.haskellPackages.wreq-stringless`,
  "Simple wrapper to use wreq without Strings",
);

/**
 * Colour space transformations and metrics
 */
export const wright = mkPackage(
  nixRaw`pkgs.haskellPackages.wright`,
  "Colour space transformations and metrics",
);

/**
 * Buffer your writes, transparently
 */
export const write_buffer_core = mkPackage(
  nixRaw`pkgs.haskellPackages.write-buffer-core`,
  "Buffer your writes, transparently",
);

/**
 * A write buffer for STM channels and queues
 */
export const write_buffer_stm = mkPackage(
  nixRaw`pkgs.haskellPackages.write-buffer-stm`,
  "A write buffer for STM channels and queues",
);

/**
 * Control.Monad.Catch instances for the stricter CPS WriterT and RWST
 */
export const writer_cps_exceptions = mkPackage(
  nixRaw`pkgs.haskellPackages.writer-cps-exceptions`,
  "Control.Monad.Catch instances for the stricter CPS WriterT and RWST",
);

/**
 * WriteT and RWST monad transformers (Reexport with all dependencies)
 */
export const writer_cps_full = mkPackage(
  nixRaw`pkgs.haskellPackages.writer-cps-full`,
  "WriteT and RWST monad transformers (Reexport with all dependencies)",
);

/**
 * MonadWriter orphan instances for writer-cps-transformers
 */
export const writer_cps_mtl = mkPackage(
  nixRaw`pkgs.haskellPackages.writer-cps-mtl`,
  "MonadWriter orphan instances for writer-cps-transformers",
);

/**
 * WriteT and RWST monad transformers
 */
export const writer_cps_transformers = mkPackage(
  nixRaw`pkgs.haskellPackages.writer-cps-transformers`,
  "WriteT and RWST monad transformers",
);

/**
 * Pretty output for source generators
 */
export const wryte = mkPackage(
  nixRaw`pkgs.haskellPackages.wryte`,
  "Pretty output for source generators",
);

/**
 * Unagi chan based websocket client
 */
export const ws_chans = mkPackage(
  nixRaw`pkgs.haskellPackages.ws-chans`,
  "Unagi chan based websocket client",
);

/**
 * Terminal emulator over websockets
 */
export const wshterm = mkPackage(
  nixRaw`pkgs.haskellPackages.wshterm`,
  "Terminal emulator over websockets",
);

/**
 * WSJT-X UDP protocol
 */
export const wsjtx_udp = mkPackage(
  nixRaw`pkgs.haskellPackages.wsjtx-udp`,
  "WSJT-X UDP protocol",
);

/**
 * A-little-higher-level WebSocket client
 */
export const wss_client = mkPackage(
  nixRaw`pkgs.haskellPackages.wss-client`,
  "A-little-higher-level WebSocket client",
);

/**
 * Tunneling program over websocket protocol
 */
export const wstunnel = mkPackage(
  nixRaw`pkgs.haskellPackages.wstunnel`,
  "Tunneling program over websocket protocol",
);

/**
 * GTK tools within Wojcik Tool Kit
 */
export const wtk_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.wtk-gtk`,
  "GTK tools within Wojcik Tool Kit",
);

/**
 * Unimportant Unix adminstration tool
 */
export const wu_wei = mkPackage(
  nixRaw`pkgs.haskellPackages.wu-wei`,
  "Unimportant Unix adminstration tool",
);

/**
 * Code for the dice chain problem
 */
export const wuerfelschlange = mkPackage(
  nixRaw`pkgs.haskellPackages.wuerfelschlange`,
  "Code for the dice chain problem",
);

/**
 * Basic objects and system code built on Wumpus-Core
 */
export const wumpus_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.wumpus-basic`,
  "Basic objects and system code built on Wumpus-Core",
);

/**
 * High-level drawing objects built on Wumpus-Basic
 */
export const wumpus_drawing = mkPackage(
  nixRaw`pkgs.haskellPackages.wumpus-drawing`,
  "High-level drawing objects built on Wumpus-Basic",
);

/**
 * Microprints - "greek-text" pictures
 */
export const wumpus_microprint = mkPackage(
  nixRaw`pkgs.haskellPackages.wumpus-microprint`,
  "Microprints - \"greek-text\" pictures",
);

/**
 * Drawing trees
 */
export const wumpus_tree = mkPackage(
  nixRaw`pkgs.haskellPackages.wumpus-tree`,
  "Drawing trees",
);

/**
 * Secure WebSocket (WSS) clients
 */
export const wuss = mkPackage(
  nixRaw`pkgs.haskellPackages.wuss`,
  "Secure WebSocket (WSS) clients",
);

/**
 * Secure WebSocket (WSS) clients
 */
export const wuss_2_0_1_4 = mkPackage(
  nixRaw`pkgs.haskellPackages.wuss_2_0_1_4`,
  "Secure WebSocket (WSS) clients",
);

/**
 * wxHaskell
 */
export const wx = mkPackage(
  nixRaw`pkgs.haskellPackages.wx`,
  "wxHaskell",
);

/**
 * Try to avoid the asteroids with your space ship
 */
export const wxAsteroids = mkPackage(
  nixRaw`pkgs.haskellPackages.wxAsteroids`,
  "Try to avoid the asteroids with your space ship",
);

/**
 * An implementation of Fruit using wxHaskell
 */
export const wxFruit = mkPackage(
  nixRaw`pkgs.haskellPackages.wxFruit`,
  "An implementation of Fruit using wxHaskell",
);

/**
 * Simple zoomable canvas for wxHaskell
 */
export const wxSimpleCanvas = mkPackage(
  nixRaw`pkgs.haskellPackages.wxSimpleCanvas`,
  "Simple zoomable canvas for wxHaskell",
);

/**
 * wxHaskell C++ wrapper
 */
export const wxc = mkPackage(
  nixRaw`pkgs.haskellPackages.wxc`,
  "wxHaskell C++ wrapper",
);

/**
 * wxHaskell core
 */
export const wxcore = mkPackage(
  nixRaw`pkgs.haskellPackages.wxcore`,
  "wxHaskell core",
);

/**
 * An example of how to implement a basic notepad with wxHaskell
 */
export const wxhnotepad = mkPackage(
  nixRaw`pkgs.haskellPackages.wxhnotepad`,
  "An example of how to implement a basic notepad with wxHaskell",
);

/**
 * turtle like LOGO with wxHaskell
 */
export const wxturtle = mkPackage(
  nixRaw`pkgs.haskellPackages.wxturtle`,
  "turtle like LOGO with wxHaskell",
);

/**
 * Console line fuzzy search
 */
export const wybor = mkPackage(
  nixRaw`pkgs.haskellPackages.wybor`,
  "Console line fuzzy search",
);

/**
 * An autoresponder for Dragon Go Server
 */
export const wyvern = mkPackage(
  nixRaw`pkgs.haskellPackages.wyvern`,
  "An autoresponder for Dragon Go Server",
);

/**
 * A binding to the xim of X11 graphics library
 */
export const x11_xim = mkPackage(
  nixRaw`pkgs.haskellPackages.x11-xim`,
  "A binding to the xim of X11 graphics library",
);

/**
 * Haskell FFI bindings for X11 XInput library (-lXi)
 */
export const x11_xinput = mkPackage(
  nixRaw`pkgs.haskellPackages.x11-xinput`,
  "Haskell FFI bindings for X11 XInput library (-lXi)",
);

/**
 * X509 reader and writer
 */
export const x509 = mkPackage(
  nixRaw`pkgs.haskellPackages.x509`,
  "X509 reader and writer",
);

/**
 * X.509 collection accessing and storing methods
 */
export const x509_store = mkPackage(
  nixRaw`pkgs.haskellPackages.x509-store`,
  "X.509 collection accessing and storing methods",
);

/**
 * Handle per-operating-system X.509 accessors and storage
 */
export const x509_system = mkPackage(
  nixRaw`pkgs.haskellPackages.x509-system`,
  "Handle per-operating-system X.509 accessors and storage",
);

/**
 * Utility for X509 certificate and chain
 */
export const x509_util = mkPackage(
  nixRaw`pkgs.haskellPackages.x509-util`,
  "Utility for X509 certificate and chain",
);

/**
 * X.509 Certificate and CRL validation
 */
export const x509_validation = mkPackage(
  nixRaw`pkgs.haskellPackages.x509-validation`,
  "X.509 Certificate and CRL validation",
);

/**
 * Runtime code generation for x86 64 bit machine code
 */
export const x86_64bit = mkPackage(
  nixRaw`pkgs.haskellPackages.x86-64bit`,
  "Runtime code generation for x86 64 bit machine code",
);

/**
 * Haskell extended file attributes interface
 */
export const xattr = mkPackage(
  nixRaw`pkgs.haskellPackages.xattr`,
  "Haskell extended file attributes interface",
);

/**
 * Simple battery indicator
 */
export const xbattbar = mkPackage(
  nixRaw`pkgs.haskellPackages.xbattbar`,
  "Simple battery indicator",
);

/**
 * Parses XML files used by the XCB project
 */
export const xcb_types = mkPackage(
  nixRaw`pkgs.haskellPackages.xcb-types`,
  "Parses XML files used by the XCB project",
);

/**
 * A cffi-based python binding for X
 */
export const xcffib = mkPackage(
  nixRaw`pkgs.haskellPackages.xcffib`,
  "A cffi-based python binding for X",
);

/**
 * A wget-like utility for retrieving files from XDCC bots on IRC
 */
export const xdcc = mkPackage(
  nixRaw`pkgs.haskellPackages.xdcc`,
  "A wget-like utility for retrieving files from XDCC bots on IRC",
);

/**
 * A basic implementation of the XDG Base Directory specification
 */
export const xdg_basedir = mkPackage(
  nixRaw`pkgs.haskellPackages.xdg-basedir`,
  "A basic implementation of the XDG Base Directory specification",
);

/**
 * XDG Basedir
 */
export const xdg_basedir_compliant = mkPackage(
  nixRaw`pkgs.haskellPackages.xdg-basedir-compliant`,
  "XDG Basedir",
);

/**
 * Parse files conforming to the xdg desktop entry spec
 */
export const xdg_desktop_entry = mkPackage(
  nixRaw`pkgs.haskellPackages.xdg-desktop-entry`,
  "Parse files conforming to the xdg desktop entry spec",
);

/**
 * Basic implementation of XDG user directories specification
 */
export const xdg_userdirs = mkPackage(
  nixRaw`pkgs.haskellPackages.xdg-userdirs`,
  "Basic implementation of XDG user directories specification",
);

/**
 * Parse Graphviz xdot files and interactively view them using GTK and Cairo
 */
export const xdot = mkPackage(
  nixRaw`pkgs.haskellPackages.xdot`,
  "Parse Graphviz xdot files and interactively view them using GTK and Cairo",
);

/**
 * A fast event-based XML parser in pure Haskell
 */
export const xeno = mkPackage(
  nixRaw`pkgs.haskellPackages.xeno`,
  "A fast event-based XML parser in pure Haskell",
);

/**
 * XGBoost library for Haskell
 */
export const xgboost_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.xgboost-haskell`,
  "XGBoost library for Haskell",
);

/**
 * Atom cache for XHB
 */
export const xhb_atom_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.xhb-atom-cache`,
  "Atom cache for XHB",
);

/**
 * EWMH utilities for XHB
 */
export const xhb_ewmh = mkPackage(
  nixRaw`pkgs.haskellPackages.xhb-ewmh`,
  "EWMH utilities for XHB",
);

/**
 * An XHTML combinator library
 */
export const xhtml_3000_3_0_0 = mkPackage(
  nixRaw`pkgs.haskellPackages.xhtml_3000_3_0_0`,
  "An XHTML combinator library",
);

/**
 * Fast and easy to use XHTML combinators
 */
export const xhtml_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.xhtml-combinators`,
  "Fast and easy to use XHTML combinators",
);

/**
 * Conduit of keys pressed by xinput
 */
export const xinput_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.xinput-conduit`,
  "Conduit of keys pressed by xinput",
);

/**
 * Simple and incomplete Excel file parser/writer
 */
export const xlsx = mkPackage(
  nixRaw`pkgs.haskellPackages.xlsx`,
  "Simple and incomplete Excel file parser/writer",
);

/**
 * A simple XML library
 */
export const xml = mkPackage(
  nixRaw`pkgs.haskellPackages.xml`,
  "A simple XML library",
);

/**
 * blaze-html instances for xml-conduit types (deprecated)
 */
export const xml2html = mkPackage(
  nixRaw`pkgs.haskellPackages.xml2html`,
  "blaze-html instances for xml-conduit types (deprecated)",
);

/**
 * Convert BLAST output in XML format to CSV or HTML
 */
export const xml2x = mkPackage(
  nixRaw`pkgs.haskellPackages.xml2x`,
  "Convert BLAST output in XML format to CSV or HTML",
);

/**
 * Basics for XML/HTML representation and processing
 */
export const xml_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-basic`,
  "Basics for XML/HTML representation and processing",
);

/**
 * Parse XML catalog files (deprecated)
 */
export const xml_catalog = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-catalog`,
  "Parse XML catalog files (deprecated)",
);

/**
 * Pure-Haskell utilities for dealing with XML with the conduit package
 */
export const xml_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-conduit`,
  "Pure-Haskell utilities for dealing with XML with the conduit package",
);

/**
 * Lenses and traversals for xml-conduit based on microlens
 */
export const xml_conduit_microlens = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-conduit-microlens`,
  "Lenses and traversals for xml-conduit based on microlens",
);

/**
 * Warm and fuzzy creation of XML documents
 */
export const xml_conduit_writer = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-conduit-writer`,
  "Warm and fuzzy creation of XML documents",
);

/**
 * Pure-Haskell utilities for dealing with XML with the enumerator package. (deprecated)
 */
export const xml_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-enumerator`,
  "Pure-Haskell utilities for dealing with XML with the enumerator package. (deprecated)",
);

/**
 * Parser combinators for xml-enumerator and compatible XML parsers
 */
export const xml_enumerator_combinators = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-enumerator-combinators`,
  "Parser combinators for xml-enumerator and compatible XML parsers",
);

/**
 * Extension to the xml package to extract data from parsed xml
 */
export const xml_extractors = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-extractors`,
  "Extension to the xml package to extract data from parsed xml",
);

/**
 * Hamlet-style quasiquoter for XML content
 */
export const xml_hamlet = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-hamlet`,
  "Hamlet-style quasiquoter for XML content",
);

/**
 * Some useful helper functions for the xml library
 */
export const xml_helpers = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-helpers`,
  "Some useful helper functions for the xml library",
);

/**
 * Quasi-quoters for XML and HTML Documents
 */
export const xml_html_qq = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-html-qq`,
  "Quasi-quoters for XML and HTML Documents",
);

/**
 * Indexed XML cursors similar to 'Text.XML.Cursor' from xml-conduit
 */
export const xml_indexed_cursor = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-indexed-cursor`,
  "Indexed XML cursors similar to 'Text.XML.Cursor' from xml-conduit",
);

/**
 * Generate XML-isomorphic types
 */
export const xml_isogen = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-isogen`,
  "Generate XML-isomorphic types",
);

/**
 * Lenses, traversals, and prisms for xml-conduit
 */
export const xml_lens = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-lens`,
  "Lenses, traversals, and prisms for xml-conduit",
);

/**
 * Monadic extensions to the xml package
 */
export const xml_monad = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-monad`,
  "Monadic extensions to the xml package",
);

/**
 * Optics for xml-conduit
 */
export const xml_optics = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-optics`,
  "Optics for xml-conduit",
);

/**
 * XML parser with informative error-reporting and simple API
 */
export const xml_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-parser`,
  "XML parser with informative error-reporting and simple API",
);

/**
 * XML picklers based on xml-types, ported from hexpat-pickle
 */
export const xml_picklers = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-picklers`,
  "XML picklers based on xml-types, ported from hexpat-pickle",
);

/**
 * XML parser which uses simple-pipe
 */
export const xml_pipe = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-pipe`,
  "XML parser which uses simple-pipe",
);

/**
 * Push XML from/to client to/from server over XMPP or HTTP
 */
export const xml_push = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-push`,
  "Push XML from/to client to/from server over XMPP or HTTP",
);

/**
 * A binding for the "xml-query" and "xml-conduit" libraries
 */
export const xml_query_xml_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-query-xml-conduit`,
  "A binding for the \"xml-query\" and \"xml-conduit\" libraries",
);

/**
 * An interpreter of "xml-query" queries for the "xml-types" documents
 */
export const xml_query_xml_types = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-query-xml-types`,
  "An interpreter of \"xml-query\" queries for the \"xml-types\" documents",
);

/**
 * Fast, light converter of xml to json capable of handling huge xml files
 */
export const xml_to_json_fast = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-to-json-fast`,
  "Fast, light converter of xml to json capable of handling huge xml files",
);

/**
 * Typed XML encoding for an xml-conduit backend
 */
export const xml_tydom_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-tydom-conduit`,
  "Typed XML encoding for an xml-conduit backend",
);

/**
 * Basic types for representing XML
 */
export const xml_types = mkPackage(
  nixRaw`pkgs.haskellPackages.xml-types`,
  "Basic types for representing XML",
);

/**
 * XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints
 */
export const xmlbf = mkPackage(
  nixRaw`pkgs.haskellPackages.xmlbf`,
  "XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints",
);

/**
 * xeno backend support for the xmlbf library
 */
export const xmlbf_xeno = mkPackage(
  nixRaw`pkgs.haskellPackages.xmlbf-xeno`,
  "xeno backend support for the xmlbf library",
);

/**
 * xmlhtml backend support for the xmlbf library
 */
export const xmlbf_xmlhtml = mkPackage(
  nixRaw`pkgs.haskellPackages.xmlbf-xmlhtml`,
  "xmlhtml backend support for the xmlbf library",
);

/**
 * Fast XML generation library
 */
export const xmlgen = mkPackage(
  nixRaw`pkgs.haskellPackages.xmlgen`,
  "Fast XML generation library",
);

/**
 * XML parser and renderer with HTML 5 quirks mode
 */
export const xmlhtml = mkPackage(
  nixRaw`pkgs.haskellPackages.xmlhtml`,
  "XML parser and renderer with HTML 5 quirks mode",
);

/**
 * Show tv channels in the terminal
 */
export const xmltv = mkPackage(
  nixRaw`pkgs.haskellPackages.xmltv`,
  "Show tv channels in the terminal",
);

/**
 * An XMMS2 client library
 */
export const xmms2_client = mkPackage(
  nixRaw`pkgs.haskellPackages.xmms2-client`,
  "An XMMS2 client library",
);

/**
 * An XMMS2 client library  GLib integration
 */
export const xmms2_client_glib = mkPackage(
  nixRaw`pkgs.haskellPackages.xmms2-client-glib`,
  "An XMMS2 client library  GLib integration",
);

/**
 * A Minimalistic Text Based Status Bar
 */
export const xmobar = mkPackage(
  nixRaw`pkgs.haskellPackages.xmobar`,
  "A Minimalistic Text Based Status Bar",
);

/**
 * A tiling window manager
 */
export const xmonad = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad`,
  "A tiling window manager",
);

/**
 * Community-maintained extensions for xmonad
 */
export const xmonad_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-contrib`,
  "Community-maintained extensions for xmonad",
);

/**
 * Third party extensions for xmonad
 */
export const xmonad_contrib_bluetilebranch = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-contrib-bluetilebranch`,
  "Third party extensions for xmonad",
);

export const xmonad_dbus = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-dbus`,
  "",
);

/**
 * Third party extensions for xmonad with wacky dependencies
 */
export const xmonad_extras = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-extras`,
  "Third party extensions for xmonad with wacky dependencies",
);

/**
 * Bind media keys to work with Spotify
 */
export const xmonad_spotify = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-spotify`,
  "Bind media keys to work with Spotify",
);

/**
 * A small collection of X utilities
 */
export const xmonad_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-utils`,
  "A small collection of X utilities",
);

/**
 * XMonad volume controls
 */
export const xmonad_volume = mkPackage(
  nixRaw`pkgs.haskellPackages.xmonad-volume`,
  "XMonad volume controls",
);

/**
 * XMPP implementation using simple-PIPE
 */
export const xmpipe = mkPackage(
  nixRaw`pkgs.haskellPackages.xmpipe`,
  "XMPP implementation using simple-PIPE",
);

/**
 * Efficient XOR masking
 */
export const xor = mkPackage(
  nixRaw`pkgs.haskellPackages.xor`,
  "Efficient XOR masking",
);

/**
 * Haskell implementation of the xorshift random generator
 */
export const xorshift = mkPackage(
  nixRaw`pkgs.haskellPackages.xorshift`,
  "Haskell implementation of the xorshift random generator",
);

/**
 * A binding to the X on-screen display
 */
export const xosd = mkPackage(
  nixRaw`pkgs.haskellPackages.xosd`,
  "A binding to the X on-screen display",
);

/**
 * text builder for xournal file format
 */
export const xournal_builder = mkPackage(
  nixRaw`pkgs.haskellPackages.xournal-builder`,
  "text builder for xournal file format",
);

/**
 * convert utility for xoj files
 */
export const xournal_convert = mkPackage(
  nixRaw`pkgs.haskellPackages.xournal-convert`,
  "convert utility for xoj files",
);

/**
 * Xournal file parser
 */
export const xournal_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.xournal-parser`,
  "Xournal file parser",
);

/**
 * Xournal file renderer
 */
export const xournal_render = mkPackage(
  nixRaw`pkgs.haskellPackages.xournal-render`,
  "Xournal file renderer",
);

/**
 * Data types for programs for xournal file format
 */
export const xournal_types = mkPackage(
  nixRaw`pkgs.haskellPackages.xournal-types`,
  "Data types for programs for xournal file format",
);

/**
 * Command line tool to extract DSV data from HTML and XML with XPATH expressions
 */
export const xpathdsv = mkPackage(
  nixRaw`pkgs.haskellPackages.xpathdsv`,
  "Command line tool to extract DSV data from HTML and XML with XPATH expressions",
);

export const xrefcheck = mkPackage(
  nixRaw`pkgs.haskellPackages.xrefcheck`,
  "",
);

/**
 * sanitize untrusted HTML to prevent XSS attacks
 */
export const xss_sanitize = mkPackage(
  nixRaw`pkgs.haskellPackages.xss-sanitize`,
  "sanitize untrusted HTML to prevent XSS attacks",
);

/**
 * Low-Fat static file packaging for Haskell projects
 */
export const xstatic = mkPackage(
  nixRaw`pkgs.haskellPackages.xstatic`,
  "Low-Fat static file packaging for Haskell projects",
);

/**
 * Automatic generation of XStaticFile
 */
export const xstatic_th = mkPackage(
  nixRaw`pkgs.haskellPackages.xstatic-th`,
  "Automatic generation of XStaticFile",
);

/**
 * eXtended & Typed Controls for wxHaskell
 */
export const xtc = mkPackage(
  nixRaw`pkgs.haskellPackages.xtc`,
  "eXtended & Typed Controls for wxHaskell",
);

/**
 * Thin FFI bindings to X11 XTest library
 */
export const xtest = mkPackage(
  nixRaw`pkgs.haskellPackages.xtest`,
  "Thin FFI bindings to X11 XTest library",
);

/**
 * turtle like LOGO
 */
export const xturtle = mkPackage(
  nixRaw`pkgs.haskellPackages.xturtle`,
  "turtle like LOGO",
);

/**
 * Bindings to the C implementation the xxHash algorithm
 */
export const xxhash_ffi = mkPackage(
  nixRaw`pkgs.haskellPackages.xxhash-ffi`,
  "Bindings to the C implementation the xxHash algorithm",
);

/**
 * Yet Another Brainfuck Interpreter
 */
export const yabi = mkPackage(
  nixRaw`pkgs.haskellPackages.yabi`,
  "Yet Another Brainfuck Interpreter",
);

/**
 * Enumerator-based interface to YAJL, an event-based JSON implementation
 */
export const yajl_enumerator = mkPackage(
  nixRaw`pkgs.haskellPackages.yajl-enumerator`,
  "Enumerator-based interface to YAJL, an event-based JSON implementation",
);

/**
 * A wrapper of servant
 */
export const yam = mkPackage(
  nixRaw`pkgs.haskellPackages.yam`,
  "A wrapper of servant",
);

/**
 * Yam DataSource Middleware
 */
export const yam_datasource = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-datasource`,
  "Yam DataSource Middleware",
);

export const yam_job = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-job`,
  "",
);

/**
 * Yam Logger
 */
export const yam_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-logger`,
  "Yam Logger",
);

/**
 * Yam Redis Middleware
 */
export const yam_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-redis`,
  "Yam Redis Middleware",
);

export const yam_servant = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-servant`,
  "",
);

/**
 * Yam transaction
 */
export const yam_transaction = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-transaction`,
  "Yam transaction",
);

export const yam_transaction_odbc = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-transaction-odbc`,
  "",
);

export const yam_transaction_postgresql = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-transaction-postgresql`,
  "",
);

/**
 * Yam Web
 */
export const yam_web = mkPackage(
  nixRaw`pkgs.haskellPackages.yam-web`,
  "Yam Web",
);

/**
 * Simple memoisation function
 */
export const yamemo = mkPackage(
  nixRaw`pkgs.haskellPackages.yamemo`,
  "Simple memoisation function",
);

/**
 * Support for parsing and rendering YAML documents
 */
export const yaml = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml`,
  "Support for parsing and rendering YAML documents",
);

/**
 * Generate OWL schema from YAML syntax, and an RDFa template
 */
export const yaml2owl = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml2owl`,
  "Generate OWL schema from YAML syntax, and an RDFa template",
);

/**
 * A light-weight wrapper with utility functions around HsSyck
 */
export const yaml_light = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml-light`,
  "A light-weight wrapper with utility functions around HsSyck",
);

/**
 * Scotty server backend for yaml-rpc
 */
export const yaml_rpc_scotty = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml-rpc-scotty`,
  "Scotty server backend for yaml-rpc",
);

/**
 * Snap server backend for yaml-rpc
 */
export const yaml_rpc_snap = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml-rpc-snap`,
  "Snap server backend for yaml-rpc",
);

/**
 * Support for parsing and rendering YAML documents
 */
export const yaml_streamly = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml-streamly`,
  "Support for parsing and rendering YAML documents",
);

/**
 * Flexible declarative YAML parsing toolkit
 */
export const yaml_unscrambler = mkPackage(
  nixRaw`pkgs.haskellPackages.yaml-unscrambler`,
  "Flexible declarative YAML parsing toolkit",
);

/**
 * Declaritive configuration parsing with free docs
 */
export const yamlparse_applicative = mkPackage(
  nixRaw`pkgs.haskellPackages.yamlparse-applicative`,
  "Declaritive configuration parsing with free docs",
);

/**
 * blank-canvas frontend for Yampa
 */
export const yampa_canvas = mkPackage(
  nixRaw`pkgs.haskellPackages.yampa-canvas`,
  "blank-canvas frontend for Yampa",
);

/**
 * A GLOSS backend for Yampa
 */
export const yampa_gloss = mkPackage(
  nixRaw`pkgs.haskellPackages.yampa-gloss`,
  "A GLOSS backend for Yampa",
);

/**
 * Testing library for Yampa
 */
export const yampa_test = mkPackage(
  nixRaw`pkgs.haskellPackages.yampa-test`,
  "Testing library for Yampa",
);

/**
 * yet another prelude - a simplistic refactoring with algebraic classes
 */
export const yap = mkPackage(
  nixRaw`pkgs.haskellPackages.yap`,
  "yet another prelude - a simplistic refactoring with algebraic classes",
);

/**
 * Yet another records libraries
 */
export const yarl = mkPackage(
  nixRaw`pkgs.haskellPackages.yarl`,
  "Yet another records libraries",
);

/**
 * Represent and parse yarn.lock files
 */
export const yarn_lock = mkPackage(
  nixRaw`pkgs.haskellPackages.yarn-lock`,
  "Represent and parse yarn.lock files",
);

/**
 * Image IO for Yarr library
 */
export const yarr_image_io = mkPackage(
  nixRaw`pkgs.haskellPackages.yarr-image-io`,
  "Image IO for Yarr library",
);

/**
 * Yet another string interpolator
 */
export const yasi = mkPackage(
  nixRaw`pkgs.haskellPackages.yasi`,
  "Yet another string interpolator",
);

/**
 * yet another visual editor
 */
export const yavie = mkPackage(
  nixRaw`pkgs.haskellPackages.yavie`,
  "yet another visual editor",
);

/**
 * Total recursion schemes
 */
export const yaya = mkPackage(
  nixRaw`pkgs.haskellPackages.yaya`,
  "Total recursion schemes",
);

/**
 * Hedgehog testing support for the Yaya recursion scheme library
 */
export const yaya_hedgehog = mkPackage(
  nixRaw`pkgs.haskellPackages.yaya-hedgehog`,
  "Hedgehog testing support for the Yaya recursion scheme library",
);

/**
 * Non-total extensions to the Yaya recursion scheme library
 */
export const yaya_unsafe = mkPackage(
  nixRaw`pkgs.haskellPackages.yaya-unsafe`,
  "Non-total extensions to the Yaya recursion scheme library",
);

/**
 * Additional utilities to work with Yhc Core
 */
export const ycextra = mkPackage(
  nixRaw`pkgs.haskellPackages.ycextra`,
  "Additional utilities to work with Yhc Core",
);

/**
 * Yesod-based server for interactive presentation slides
 */
export const yeamer = mkPackage(
  nixRaw`pkgs.haskellPackages.yeamer`,
  "Yesod-based server for interactive presentation slides",
);

/**
 * small dmenu wrapper
 */
export const yeganesh = mkPackage(
  nixRaw`pkgs.haskellPackages.yeganesh`,
  "small dmenu wrapper",
);

/**
 * Extended yes command to reproduce phrases in Yes! Precure 5
 */
export const yes_precure5_command = mkPackage(
  nixRaw`pkgs.haskellPackages.yes-precure5-command`,
  "Extended yes command to reproduce phrases in Yes! Precure 5",
);

/**
 * YesQL-style SQL database abstraction (legacy compatibility wrapper)
 */
export const yeshql = mkPackage(
  nixRaw`pkgs.haskellPackages.yeshql`,
  "YesQL-style SQL database abstraction (legacy compatibility wrapper)",
);

/**
 * YesQL-style SQL database abstraction (core)
 */
export const yeshql_core = mkPackage(
  nixRaw`pkgs.haskellPackages.yeshql-core`,
  "YesQL-style SQL database abstraction (core)",
);

/**
 * Creation of type-safe, RESTful web applications
 */
export const yesod = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod`,
  "Creation of type-safe, RESTful web applications",
);

/**
 * Alert messages for the Yesod framework
 */
export const yesod_alerts = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-alerts`,
  "Alert messages for the Yesod framework",
);

/**
 * Automatically generate article previews for a yesod site
 */
export const yesod_articles = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-articles`,
  "Automatically generate article previews for a yesod site",
);

/**
 * Authentication for Yesod
 */
export const yesod_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth`,
  "Authentication for Yesod",
);

/**
 * Yesod Middleware for HTTP Basic Authentication
 */
export const yesod_auth_basic = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-basic`,
  "Yesod Middleware for HTTP Basic Authentication",
);

/**
 * Authentication plugin for Yesod
 */
export const yesod_auth_hashdb = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-hashdb`,
  "Authentication plugin for Yesod",
);

/**
 * LDAP Authentication for Yesod
 */
export const yesod_auth_ldap = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-ldap`,
  "LDAP Authentication for Yesod",
);

/**
 * A yesod-auth plugin for LTI 1.3
 */
export const yesod_auth_lti13 = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-lti13`,
  "A yesod-auth plugin for LTI 1.3",
);

/**
 * OAuth Authentication for Yesod
 */
export const yesod_auth_oauth = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-oauth`,
  "OAuth Authentication for Yesod",
);

/**
 * OAuth 2.0 authentication plugins
 */
export const yesod_auth_oauth2 = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-oauth2`,
  "OAuth 2.0 authentication plugins",
);

/**
 * A yesod-auth plugin for multi-tenant SSO via OpenID Connect
 */
export const yesod_auth_oidc = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-oidc`,
  "A yesod-auth plugin for multi-tenant SSO via OpenID Connect",
);

/**
 * Traditional email/pass auth for Yesod
 */
export const yesod_auth_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-auth-simple`,
  "Traditional email/pass auth for Yesod",
);

/**
 * Auto-reload a yesod app during development
 */
export const yesod_autoreload = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-autoreload`,
  "Auto-reload a yesod app during development",
);

/**
 * The yesod helper executable
 */
export const yesod_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-bin`,
  "The yesod helper executable",
);

/**
 * Helper functions for using yesod with colonnade
 */
export const yesod_colonnade = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-colonnade`,
  "Helper functions for using yesod with colonnade",
);

/**
 * Continuations for Yesod
 */
export const yesod_continuations = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-continuations`,
  "Continuations for Yesod",
);

/**
 * Creation of type-safe, RESTful web applications
 */
export const yesod_core = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-core`,
  "Creation of type-safe, RESTful web applications",
);

/**
 * Default config and main functions for your yesod application (deprecated)
 */
export const yesod_default = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-default`,
  "Default config and main functions for your yesod application (deprecated)",
);

/**
 * Non template haskell markup building function in the spirit of lucid
 */
export const yesod_elements = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-elements`,
  "Non template haskell markup building function in the spirit of lucid",
);

/**
 * Server-sent events support for Yesod apps
 */
export const yesod_eventsource = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-eventsource`,
  "Server-sent events support for Yesod apps",
);

/**
 * Example programs using the Yesod Web Framework. (deprecated)
 */
export const yesod_examples = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-examples`,
  "Example programs using the Yesod Web Framework. (deprecated)",
);

/**
 * Utilities for using the Fay Haskell-to-JS compiler with Yesod
 */
export const yesod_fay = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-fay`,
  "Utilities for using the Fay Haskell-to-JS compiler with Yesod",
);

/**
 * Useful glue functions between the fb library and Yesod
 */
export const yesod_fb = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-fb`,
  "Useful glue functions between the fb library and Yesod",
);

/**
 * Form handling support for Yesod Web Framework
 */
export const yesod_form = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-form`,
  "Form handling support for Yesod Web Framework",
);

/**
 * renderBootstrap4
 */
export const yesod_form_bootstrap4 = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-form-bootstrap4`,
  "renderBootstrap4",
);

/**
 * support Bulma form for Yesod
 */
export const yesod_form_bulma = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-form-bulma`,
  "support Bulma form for Yesod",
);

/**
 * Multi-input form handling for Yesod Web Framework
 */
export const yesod_form_multi = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-form-multi`,
  "Multi-input form handling for Yesod Web Framework",
);

/**
 * Host content provided by a Git repo
 */
export const yesod_gitrepo = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-gitrepo`,
  "Host content provided by a Git repo",
);

/**
 * Generate content for Yesod using the aeson package. (deprecated)
 */
export const yesod_json = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-json`,
  "Generate content for Yesod using the aeson package. (deprecated)",
);

/**
 * Yesod library for MangoPay API access
 */
export const yesod_mangopay = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-mangopay`,
  "Yesod library for MangoPay API access",
);

/**
 * Tools for using markdown in a yesod application
 */
export const yesod_markdown = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-markdown`,
  "Tools for using markdown in a yesod application",
);

/**
 * Simple display of media types, served by yesod
 */
export const yesod_media_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-media-simple`,
  "Simple display of media types, served by yesod",
);

/**
 * A middleware for building CSP headers on the fly
 */
export const yesod_middleware_csp = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-middleware-csp`,
  "A middleware for building CSP headers on the fly",
);

/**
 * Helper functions and data types for producing News feeds
 */
export const yesod_newsfeed = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-newsfeed`,
  "Helper functions and data types for producing News feeds",
);

export const yesod_page_cursor = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-page-cursor`,
  "",
);

/**
 * A pagination approach for yesod
 */
export const yesod_paginator = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-paginator`,
  "A pagination approach for yesod",
);

/**
 * Yesod plugin to use PayPal with the paypal-rest-client library
 */
export const yesod_paypal_rest = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-paypal-rest`,
  "Yesod plugin to use PayPal with the paypal-rest-client library",
);

/**
 * Some helpers for using Persistent from Yesod
 */
export const yesod_persistent = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-persistent`,
  "Some helpers for using Persistent from Yesod",
);

/**
 * Meta package for Yesod (deprecated)
 */
export const yesod_platform = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-platform`,
  "Meta package for Yesod (deprecated)",
);

/**
 * PureScript integration for Yesod
 */
export const yesod_purescript = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-purescript`,
  "PureScript integration for Yesod",
);

/**
 * The raml helper executable
 */
export const yesod_raml_bin = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-raml-bin`,
  "The raml helper executable",
);

/**
 * A html documentation generator library for RAML
 */
export const yesod_raml_docs = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-raml-docs`,
  "A html documentation generator library for RAML",
);

/**
 * A mock-handler generator library from RAML
 */
export const yesod_raml_mock = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-raml-mock`,
  "A mock-handler generator library from RAML",
);

/**
 * yesod recaptcha2
 */
export const yesod_recaptcha2 = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-recaptcha2`,
  "yesod recaptcha2",
);

/**
 * Generate Flow routes for Yesod
 */
export const yesod_routes_flow = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-routes-flow`,
  "Generate Flow routes for Yesod",
);

/**
 * generate TypeScript routes for Yesod
 */
export const yesod_routes_typescript = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-routes-typescript`,
  "generate TypeScript routes for Yesod",
);

/**
 * Redis-Powered Sessions for Haskell
 */
export const yesod_session_redis = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-session-redis`,
  "Redis-Powered Sessions for Haskell",
);

/**
 * Generate XML sitemaps
 */
export const yesod_sitemap = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-sitemap`,
  "Generate XML sitemaps",
);

/**
 * Static file serving subsite for Yesod Web Framework
 */
export const yesod_static = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-static`,
  "Static file serving subsite for Yesod Web Framework",
);

/**
 * HTML tables for Yesod
 */
export const yesod_table = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-table`,
  "HTML tables for Yesod",
);

/**
 * Table view for Yesod applications
 */
export const yesod_tableview = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-tableview`,
  "Table view for Yesod applications",
);

/**
 * integration testing for WAI/Yesod Applications
 */
export const yesod_test = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-test`,
  "integration testing for WAI/Yesod Applications",
);

/**
 * WebSockets support for Yesod
 */
export const yesod_websockets = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-websockets`,
  "WebSockets support for Yesod",
);

/**
 * Extension to yesod-websockets
 */
export const yesod_websockets_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-websockets-extra`,
  "Extension to yesod-websockets",
);

/**
 * Initial project template from stack
 */
export const yesod_worker = mkPackage(
  nixRaw`pkgs.haskellPackages.yesod-worker`,
  "Initial project template from stack",
);

/**
 * Yet Another Logger
 */
export const yet_another_logger = mkPackage(
  nixRaw`pkgs.haskellPackages.yet-another-logger`,
  "Yet Another Logger",
);

/**
 * Yi editor
 */
export const yi = mkPackage(
  nixRaw`pkgs.haskellPackages.yi`,
  "Yi editor",
);

/**
 * Add-ons to Yi, the Haskell-Scriptable Editor
 */
export const yi_contrib = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-contrib`,
  "Add-ons to Yi, the Haskell-Scriptable Editor",
);

/**
 * Yi editor core library
 */
export const yi_core = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-core`,
  "Yi editor core library",
);

/**
 * Dynamic configuration support for Yi
 */
export const yi_dynamic_configuration = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-dynamic-configuration`,
  "Dynamic configuration support for Yi",
);

/**
 * Simple mapping from colour names used in emacs to Color
 */
export const yi_emacs_colours = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-emacs-colours`,
  "Simple mapping from colour names used in emacs to Color",
);

/**
 * Pango frontend for Yi editor
 */
export const yi_frontend_pango = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-frontend-pango`,
  "Pango frontend for Yi editor",
);

/**
 * Vty frontend for Yi editor
 */
export const yi_frontend_vty = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-frontend-vty`,
  "Vty frontend for Yi editor",
);

/**
 * Fuzzy open plugin for yi
 */
export const yi_fuzzy_open = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-fuzzy-open`,
  "Fuzzy open plugin for yi",
);

/**
 * The Haskell-Scriptable Editor, helper package
 */
export const yi_gtk = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-gtk`,
  "The Haskell-Scriptable Editor, helper package",
);

/**
 * Yi editor incremental reader
 */
export const yi_ireader = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-ireader`,
  "Yi editor incremental reader",
);

/**
 * Cua keymap for Yi editor
 */
export const yi_keymap_cua = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-keymap-cua`,
  "Cua keymap for Yi editor",
);

/**
 * Emacs keymap for Yi editor
 */
export const yi_keymap_emacs = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-keymap-emacs`,
  "Emacs keymap for Yi editor",
);

/**
 * Vim keymap for Yi editor
 */
export const yi_keymap_vim = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-keymap-vim`,
  "Vim keymap for Yi editor",
);

/**
 * Yi editor miscellaneous modes
 */
export const yi_misc_modes = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-misc-modes`,
  "Yi editor miscellaneous modes",
);

/**
 * Yi editor haskell mode
 */
export const yi_mode_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-mode-haskell`,
  "Yi editor haskell mode",
);

/**
 * Yi editor javascript mode
 */
export const yi_mode_javascript = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-mode-javascript`,
  "Yi editor javascript mode",
);

/**
 * Monokai colour theme for the Yi text editor
 */
export const yi_monokai = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-monokai`,
  "Monokai colour theme for the Yi text editor",
);

/**
 * A rope data structure used by Yi
 */
export const yi_rope = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-rope`,
  "A rope data structure used by Yi",
);

/**
 * Snippet support for yi
 */
export const yi_snippet = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-snippet`,
  "Snippet support for yi",
);

/**
 * Solarized colour theme for the Yi text editor
 */
export const yi_solarized = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-solarized`,
  "Solarized colour theme for the Yi text editor",
);

/**
 * Spolsky colour theme for the Yi text editor
 */
export const yi_spolsky = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-spolsky`,
  "Spolsky colour theme for the Yi text editor",
);

/**
 * The Haskell-Scriptable Editor, helper package
 */
export const yi_vty = mkPackage(
  nixRaw`pkgs.haskellPackages.yi-vty`,
  "The Haskell-Scriptable Editor, helper package",
);

/**
 * Simple interface to the Yices SMT (SAT modulo theories) solver
 */
export const yices_easy = mkPackage(
  nixRaw`pkgs.haskellPackages.yices-easy`,
  "Simple interface to the Yices SMT (SAT modulo theories) solver",
);

/**
 * An embedded language for programming the Yices SMT solver
 */
export const yices_painless = mkPackage(
  nixRaw`pkgs.haskellPackages.yices-painless`,
  "An embedded language for programming the Yices SMT solver",
);

export const yiyd = mkPackage(
  nixRaw`pkgs.haskellPackages.yiyd`,
  "",
);

/**
 * CUI FTP client like 'ftp', 'ncftp'
 */
export const yjftp = mkPackage(
  nixRaw`pkgs.haskellPackages.yjftp`,
  "CUI FTP client like 'ftp', 'ncftp'",
);

/**
 * CUI FTP client like 'ftp', 'ncftp'
 */
export const yjftp_libs = mkPackage(
  nixRaw`pkgs.haskellPackages.yjftp-libs`,
  "CUI FTP client like 'ftp', 'ncftp'",
);

/**
 * make SVG string from Haskell data
 */
export const yjsvg = mkPackage(
  nixRaw`pkgs.haskellPackages.yjsvg`,
  "make SVG string from Haskell data",
);

/**
 * some tools for Monad, List, Tuple and so on
 */
export const yjtools = mkPackage(
  nixRaw`pkgs.haskellPackages.yjtools`,
  "some tools for Monad, List, Tuple and so on",
);

/**
 * A Minimal JSON Parser & Printer for Haskell
 */
export const yocto = mkPackage(
  nixRaw`pkgs.haskellPackages.yocto`,
  "A Minimal JSON Parser & Printer for Haskell",
);

/**
 * Bindings to Facebook's Yoga layout library
 */
export const yoga = mkPackage(
  nixRaw`pkgs.haskellPackages.yoga`,
  "Bindings to Facebook's Yoga layout library",
);

/**
 * Generic Programming with Disbanded Data Types
 */
export const yoko = mkPackage(
  nixRaw`pkgs.haskellPackages.yoko`,
  "Generic Programming with Disbanded Data Types",
);

/**
 * A library for digital circuit description
 */
export const york_lava = mkPackage(
  nixRaw`pkgs.haskellPackages.york-lava`,
  "A library for digital circuit description",
);

/**
 * Upload video to YouTube via YouTube API
 */
export const youtube = mkPackage(
  nixRaw`pkgs.haskellPackages.youtube`,
  "Upload video to YouTube via YouTube API",
);

/**
 * A YQL engine to execute Open Data Tables
 */
export const yql = mkPackage(
  nixRaw`pkgs.haskellPackages.yql`,
  "A YQL engine to execute Open Data Tables",
);

/**
 * Builds a static website from templates and data in YAML or CSV files
 */
export const yst = mkPackage(
  nixRaw`pkgs.haskellPackages.yst`,
  "Builds a static website from templates and data in YAML or CSV files",
);

/**
 * mtl-style transformations for Yesod sites
 */
export const ytl = mkPackage(
  nixRaw`pkgs.haskellPackages.ytl`,
  "mtl-style transformations for Yesod sites",
);

/**
 * Auth module for Yu
 */
export const yu_auth = mkPackage(
  nixRaw`pkgs.haskellPackages.yu-auth`,
  "Auth module for Yu",
);

/**
 * The launcher for Yu
 */
export const yu_launch = mkPackage(
  nixRaw`pkgs.haskellPackages.yu-launch`,
  "The launcher for Yu",
);

/**
 * Utils for Yu
 */
export const yu_utils = mkPackage(
  nixRaw`pkgs.haskellPackages.yu-utils`,
  "Utils for Yu",
);

/**
 * A transcendental HTML parser gently wrapping the HXT library
 */
export const yuuko = mkPackage(
  nixRaw`pkgs.haskellPackages.yuuko`,
  "A transcendental HTML parser gently wrapping the HXT library",
);

/**
 * Row-major coordinates
 */
export const yx = mkPackage(
  nixRaw`pkgs.haskellPackages.yx`,
  "Row-major coordinates",
);

/**
 * Bindings for the Z3 Theorem Prover
 */
export const z3 = mkPackage(
  nixRaw`pkgs.haskellPackages.z3`,
  "Bindings for the Z3 Theorem Prover",
);

/**
 * Z-algorithm implemented on haskell's built-in cons-cell-based lists
 */
export const zalgo = mkPackage(
  nixRaw`pkgs.haskellPackages.zalgo`,
  "Z-algorithm implemented on haskell's built-in cons-cell-based lists",
);

/**
 * lojban parser (zasni gerna)
 */
export const zasni_gerna = mkPackage(
  nixRaw`pkgs.haskellPackages.zasni-gerna`,
  "lojban parser (zasni gerna)",
);

/**
 * Zobrist keys for game state tracking
 */
export const zcache = mkPackage(
  nixRaw`pkgs.haskellPackages.zcache`,
  "Zobrist keys for game state tracking",
);

/**
 * A standard compliant HTML parsing library
 */
export const zenacy_html = mkPackage(
  nixRaw`pkgs.haskellPackages.zenacy-html`,
  "A standard compliant HTML parsing library",
);

/**
 * Unicode utilities for Haskell
 */
export const zenacy_unicode = mkPackage(
  nixRaw`pkgs.haskellPackages.zenacy-unicode`,
  "Unicode utilities for Haskell",
);

/**
 * GHC style name Z-encoding and Z-decoding
 */
export const zenc = mkPackage(
  nixRaw`pkgs.haskellPackages.zenc`,
  "GHC style name Z-encoding and Z-decoding",
);

/**
 * @zenhack's personal custom prelude
 */
export const zenhack_prelude = mkPackage(
  nixRaw`pkgs.haskellPackages.zenhack-prelude`,
  "@zenhack's personal custom prelude",
);

/**
 * Zephyr, tree-shaking for the PureScript language
 */
export const zephyr = mkPackage(
  nixRaw`pkgs.haskellPackages.zephyr`,
  "Zephyr, tree-shaking for the PureScript language",
);

/**
 * Embedded programming in haskell using the Copilot stream DSL and Zephyr
 */
export const zephyr_copilot = mkPackage(
  nixRaw`pkgs.haskellPackages.zephyr-copilot`,
  "Embedded programming in haskell using the Copilot stream DSL and Zephyr",
);

/**
 * Post to 0bin services
 */
export const zerobin = mkPackage(
  nixRaw`pkgs.haskellPackages.zerobin`,
  "Post to 0bin services",
);

/**
 * Conduit bindings for zeromq3-haskell
 */
export const zeromq3_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.zeromq3-conduit`,
  "Conduit bindings for zeromq3-haskell",
);

/**
 * Haskell implementation of the ZeroMQ clone pattern
 */
export const zeromq4_clone_pattern = mkPackage(
  nixRaw`pkgs.haskellPackages.zeromq4-clone-pattern`,
  "Haskell implementation of the ZeroMQ clone pattern",
);

/**
 * Bindings to ZeroMQ 4.x
 */
export const zeromq4_haskell = mkPackage(
  nixRaw`pkgs.haskellPackages.zeromq4-haskell`,
  "Bindings to ZeroMQ 4.x",
);

/**
 * Haskell implementation of several ZeroMQ patterns
 */
export const zeromq4_patterns = mkPackage(
  nixRaw`pkgs.haskellPackages.zeromq4-patterns`,
  "Haskell implementation of several ZeroMQ patterns",
);

/**
 * More constrained extensions to zeromq4-haskell
 */
export const zeromq4_simple = mkPackage(
  nixRaw`pkgs.haskellPackages.zeromq4-simple`,
  "More constrained extensions to zeromq4-haskell",
);

/**
 * ZeroTH - remove unnecessary TH dependencies
 */
export const zeroth = mkPackage(
  nixRaw`pkgs.haskellPackages.zeroth`,
  "ZeroTH - remove unnecessary TH dependencies",
);

/**
 * Polysemy effects for testing
 */
export const zeugma = mkPackage(
  nixRaw`pkgs.haskellPackages.zeugma`,
  "Polysemy effects for testing",
);

/**
 * zifter-cabal
 */
export const zifter_cabal = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-cabal`,
  "zifter-cabal",
);

/**
 * zifter-git
 */
export const zifter_git = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-git`,
  "zifter-git",
);

/**
 * zifter-google-java-format
 */
export const zifter_google_java_format = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-google-java-format`,
  "zifter-google-java-format",
);

/**
 * zifter-hindent
 */
export const zifter_hindent = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-hindent`,
  "zifter-hindent",
);

/**
 * zifter-hlint
 */
export const zifter_hlint = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-hlint`,
  "zifter-hlint",
);

/**
 * zifter-stack
 */
export const zifter_stack = mkPackage(
  nixRaw`pkgs.haskellPackages.zifter-stack`,
  "zifter-stack",
);

/**
 * Zigzag encoding of integers into unsigned integers
 */
export const zigzag = mkPackage(
  nixRaw`pkgs.haskellPackages.zigzag`,
  "Zigzag encoding of integers into unsigned integers",
);

/**
 * Read and parse ZIM files
 */
export const zim_parser = mkPackage(
  nixRaw`pkgs.haskellPackages.zim-parser`,
  "Read and parse ZIM files",
);

/**
 * Typed templates with jinja like syntax
 */
export const zinza = mkPackage(
  nixRaw`pkgs.haskellPackages.zinza`,
  "Typed templates with jinja like syntax",
);

/**
 * App-centric Monad-transformer based on Scala ZIO (UIO + ReaderT + ExceptT)
 */
export const zio = mkPackage(
  nixRaw`pkgs.haskellPackages.zio`,
  "App-centric Monad-transformer based on Scala ZIO (UIO + ReaderT + ExceptT)",
);

/**
 * Operations on zip archives
 */
export const zip = mkPackage(
  nixRaw`pkgs.haskellPackages.zip`,
  "Operations on zip archives",
);

/**
 * Library for creating and modifying zip archives
 */
export const zip_archive = mkPackage(
  nixRaw`pkgs.haskellPackages.zip-archive`,
  "Library for creating and modifying zip archives",
);

/**
 * Simple CLI tool for the haskell zip library
 */
export const zip_cmd = mkPackage(
  nixRaw`pkgs.haskellPackages.zip-cmd`,
  "Simple CLI tool for the haskell zip library",
);

/**
 * ZIP archive streaming using conduits
 */
export const zip_stream = mkPackage(
  nixRaw`pkgs.haskellPackages.zip-stream`,
  "ZIP archive streaming using conduits",
);

/**
 * Generic zipper for families of recursive datatypes
 */
export const zipper = mkPackage(
  nixRaw`pkgs.haskellPackages.zipper`,
  "Generic zipper for families of recursive datatypes",
);

/**
 * Zipper utils that weren't in Control.Comonad.Store.Zipper
 */
export const zipper_extra = mkPackage(
  nixRaw`pkgs.haskellPackages.zipper-extra`,
  "Zipper utils that weren't in Control.Comonad.Store.Zipper",
);

/**
 * Traversal based zippers
 */
export const zippers = mkPackage(
  nixRaw`pkgs.haskellPackages.zippers`,
  "Traversal based zippers",
);

/**
 * A simple lens-based, generic, heterogenous, type-checked zipper library
 */
export const zippo = mkPackage(
  nixRaw`pkgs.haskellPackages.zippo`,
  "A simple lens-based, generic, heterogenous, type-checked zipper library",
);

/**
 * A type-safe client for the Ziptastic API for doing forward and reverse geocoding
 */
export const ziptastic_client = mkPackage(
  nixRaw`pkgs.haskellPackages.ziptastic-client`,
  "A type-safe client for the Ziptastic API for doing forward and reverse geocoding",
);

/**
 * Compression and decompression in the gzip and zlib formats
 */
export const zlib = mkPackage(
  nixRaw`pkgs.haskellPackages.zlib`,
  "Compression and decompression in the gzip and zlib formats",
);

/**
 * Low-level bindings to the zlib package
 */
export const zlib_bindings = mkPackage(
  nixRaw`pkgs.haskellPackages.zlib-bindings`,
  "Low-level bindings to the zlib package",
);

/**
 * Streaming compression/decompression via conduits. (deprecated)
 */
export const zlib_conduit = mkPackage(
  nixRaw`pkgs.haskellPackages.zlib-conduit`,
  "Streaming compression/decompression via conduits. (deprecated)",
);

/**
 * Enumerator interface for zlib compression
 */
export const zlib_enum = mkPackage(
  nixRaw`pkgs.haskellPackages.zlib-enum`,
  "Enumerator interface for zlib compression",
);

/**
 * Language independent, reproducible, absolute types
 */
export const zm = mkPackage(
  nixRaw`pkgs.haskellPackages.zm`,
  "Language independent, reproducible, absolute types",
);

/**
 * Command-line tool for ZeroMQ
 */
export const zmcat = mkPackage(
  nixRaw`pkgs.haskellPackages.zmcat`,
  "Command-line tool for ZeroMQ",
);

/**
 * Read and write MIDI files
 */
export const zmidi_core = mkPackage(
  nixRaw`pkgs.haskellPackages.zmidi-core`,
  "Read and write MIDI files",
);

/**
 * A streamable, seekable, zoomable cache file format
 */
export const zoom_cache = mkPackage(
  nixRaw`pkgs.haskellPackages.zoom-cache`,
  "A streamable, seekable, zoomable cache file format",
);

/**
 * Library for zoom-cache PCM audio codecs
 */
export const zoom_cache_pcm = mkPackage(
  nixRaw`pkgs.haskellPackages.zoom-cache-pcm`,
  "Library for zoom-cache PCM audio codecs",
);

/**
 * Tools for generating zoom-cache-pcm files
 */
export const zoom_cache_sndfile = mkPackage(
  nixRaw`pkgs.haskellPackages.zoom-cache-sndfile`,
  "Tools for generating zoom-cache-pcm files",
);

/**
 * A haskell binding to Apache Zookeeper C library(mt) using Haskell Z project
 */
export const zoovisitor = mkPackage(
  nixRaw`pkgs.haskellPackages.zoovisitor`,
  "A haskell binding to Apache Zookeeper C library(mt) using Haskell Z project",
);

/**
 * Zot language
 */
export const zot = mkPackage(
  nixRaw`pkgs.haskellPackages.zot`,
  "Zot language",
);

/**
 * ZRE protocol implementation
 */
export const zre = mkPackage(
  nixRaw`pkgs.haskellPackages.zre`,
  "ZRE protocol implementation",
);

/**
 * Haskell bindings to the Zstandard compression algorithm
 */
export const zstd = mkPackage(
  nixRaw`pkgs.haskellPackages.zstd`,
  "Haskell bindings to the Zstandard compression algorithm",
);

/**
 * Creating and extracting arbitrary archives
 */
export const ztar = mkPackage(
  nixRaw`pkgs.haskellPackages.ztar`,
  "Creating and extracting arbitrary archives",
);

/**
 * A lisp processor, An inline-lisp, in Haskell
 */
export const zuramaru = mkPackage(
  nixRaw`pkgs.haskellPackages.zuramaru`,
  "A lisp processor, An inline-lisp, in Haskell",
);

/**
 * Password strength estimation
 */
export const zxcvbn_c = mkPackage(
  nixRaw`pkgs.haskellPackages.zxcvbn-c`,
  "Password strength estimation",
);

/**
 * Password strength estimation based on zxcvbn
 */
export const zxcvbn_hs = mkPackage(
  nixRaw`pkgs.haskellPackages.zxcvbn-hs`,
  "Password strength estimation based on zxcvbn",
);
